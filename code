

================================================
FILE: ./tests/mocks/env.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
module.exports = {
  NEXT_PUBLIC_INFURA_GAS_API_KEY: 'dummy_key',
};


================================================
FILE: ./tests/integration/legacy-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { LegacyWallet, SegwitBech32Wallet, SegwitP2SHWallet } from '../../class';

jest.setTimeout(30 * 1000);

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

describe('LegacyWallet', function () {
  it('can serialize and unserialize correctly', () => {
    const a = new LegacyWallet();
    a.setLabel('my1');
    const key = JSON.stringify(a);

    const b = LegacyWallet.fromJson(key);
    assert.strictEqual(b.type, LegacyWallet.type);
    assert.strictEqual(key, JSON.stringify(b));
  });

  it('can fetch balance', async () => {
    const w = new LegacyWallet();
    w._address = '115fUy41sZkAG14CmdP1VbEKcNRZJWkUWG'; // hack internals
    assert.ok(w.weOwnAddress('115fUy41sZkAG14CmdP1VbEKcNRZJWkUWG'));
    assert.ok(!w.weOwnAddress('aaa'));
    // @ts-ignore wrong type on purpose
    assert.ok(!w.weOwnAddress(false));
    assert.ok(w.getBalance() === 0);
    assert.ok(w.getUnconfirmedBalance() === 0);
    assert.ok(w._lastBalanceFetch === 0);
    await w.fetchBalance();
    assert.ok(w.getBalance() === 18262000);
    assert.ok(w.getUnconfirmedBalance() === 0);
    assert.ok(w._lastBalanceFetch > 0);
  });

  it('can fetch TXs and derive UTXO from them', async () => {
    const w = new LegacyWallet();
    w._address = '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK';
    await w.fetchTransactions();
    assert.strictEqual(w.getTransactions().length, 1);

    for (const tx of w.getTransactions()) {
      assert.ok(tx.hash);
      assert.ok(tx.value);
      assert.ok(tx.timestamp);
      assert.ok(tx.confirmations! > 1);
    }

    assert.ok(w.weOwnTransaction('b2ac59bc282083498d1e87805d89bef9d3f3bc216c1d2c4dfaa2e2911b547100'));
    assert.ok(!w.weOwnTransaction('825c12f277d1f84911ac15ad1f41a3de28e9d906868a930b0a7bca61b17c8881'));

    assert.strictEqual(w.getUtxo().length, 1);

    for (const tx of w.getUtxo()) {
      assert.strictEqual(tx.txid, 'b2ac59bc282083498d1e87805d89bef9d3f3bc216c1d2c4dfaa2e2911b547100');
      assert.strictEqual(tx.vout, 0);
      assert.strictEqual(tx.address, '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK');
      assert.strictEqual(tx.value, 51432);
      assert.ok(tx.confirmations! > 0);
    }
  });

  // poor-mans tests with different params, since it works better with our DIY tests retrier
  const cases = [
    // Transaction with missing address output https://www.blockchain.com/btc/tx/d45818ae11a584357f7b74da26012d2becf4ef064db015a45bdfcd9cb438929d
    ['addresses for vout missing', '1PVfrmbn1vSMoFZB2Ga7nDuXLFDyJZHrHK'],
    // ['txdatas were coming back null from MalinElectrum because of high batchsize', '34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo'],
    // skipped because its slow and flaky if being run in pack with other electrum tests. uncomment and run single
    // if you need to debug huge electrum batches
  ];

  const caseRunner = async (address: string) => {
    const w = new LegacyWallet();
    w._address = address;
    await w.fetchTransactions();

    assert.ok(w.getTransactions().length > 0);
    for (const tx of w.getTransactions()) {
      assert.ok(tx.hash);
      assert.ok(tx.value);
      assert.ok(tx.timestamp);
      assert.ok(tx.confirmations! > 1);
    }
  };

  it('can fetch TXs when ' + cases[0][0], async () => await caseRunner(cases[0][1]), 240000);

  it('can fetch UTXO', async () => {
    const w = new LegacyWallet();
    w._address = '12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX';
    await w.fetchUtxo();
    assert.ok(w._utxo.length > 0, 'unexpected empty UTXO');
    assert.ok(w.getUtxo().length > 0, 'unexpected empty UTXO');

    assert.ok(w.getUtxo()[0].value);
    assert.ok(w.getUtxo()[0].vout === 1, JSON.stringify(w.getUtxo()[0]));
    assert.ok(w.getUtxo()[0].txid);
    assert.ok(w.getUtxo()[0].confirmations);
    assert.ok(w.getUtxo()[0].txhex);
  });
});

describe('SegwitP2SHWallet', function () {
  it('can generate segwit P2SH address from WIF', async () => {
    const l = new SegwitP2SHWallet();
    l.setSecret('Kxr9tQED9H44gCmp6HAdmemAzU3n84H3dGkuWTKvE23JgHMW8gct');
    assert.ok(l.getAddress() === '34AgLJhwXrvmkZS1o5TrcdeevMt22Nar53', 'expected ' + l.getAddress());
    assert.ok(l.getAddress() === (await l.getAddressAsync()));
    assert.ok(l.weOwnAddress('34AgLJhwXrvmkZS1o5TrcdeevMt22Nar53'));
    assert.ok(!l.weOwnAddress('garbage'));
    // @ts-ignore wrong type on purpose
    assert.ok(!l.weOwnAddress(false));
  });
});

describe('SegwitBech32Wallet', function () {
  it('can fetch balance', async () => {
    const w = new SegwitBech32Wallet();
    w._address = 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl';
    assert.ok(w.weOwnAddress('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl'));
    assert.ok(w.weOwnAddress('BC1Q063CTU6JHE5K4V8KA99QAC8RCM2TZJJNUKTYRL'));
    assert.ok(!w.weOwnAddress('garbage'));
    // @ts-ignore wrong type on purpose
    assert.ok(!w.weOwnAddress(false));
    await w.fetchBalance();
    assert.strictEqual(w.getBalance(), 69909);
  });

  it('can fetch UTXO', async () => {
    const w = new SegwitBech32Wallet();
    w._address = 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl';
    await w.fetchUtxo();
    const l1 = w.getUtxo().length;
    assert.ok(w.getUtxo().length > 0, 'unexpected empty UTXO');

    assert.ok(w.getUtxo()[0].value);
    assert.ok(w.getUtxo()[0].vout === 0);
    assert.ok(w.getUtxo()[0].txid);
    assert.ok(w.getUtxo()[0].confirmations, JSON.stringify(w.getUtxo()[0], null, 2));
    // double fetch shouldnt duplicate UTXOs:
    await w.fetchUtxo();
    const l2 = w.getUtxo().length;
    assert.strictEqual(l1, l2);
  });

  it('can fetch TXs LegacyWallet', async () => {
    const w = new LegacyWallet();
    w._address = 'bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv';
    await w.fetchTransactions();
    assert.strictEqual(w.getTransactions().length, 2);

    for (const tx of w.getTransactions()) {
      assert.ok(tx.hash);
      assert.ok(tx.value);
      assert.ok(tx.timestamp);
      assert.ok(tx.confirmations! > 1);
    }

    assert.strictEqual(w.getTransactions()[0].value, -892111);
    assert.strictEqual(w.getTransactions()[1].value, 892111);
  });

  it('can fetch TXs SegwitBech32Wallet', async () => {
    const w = new SegwitBech32Wallet();
    w._address = 'bc1qn887fmetaytw4vj68vsh529ft408q8j9x3dndc';
    assert.ok(w.weOwnAddress('bc1qn887fmetaytw4vj68vsh529ft408q8j9x3dndc'));
    assert.ok(w.weOwnAddress('BC1QN887FMETAYTW4VJ68VSH529FT408Q8J9X3DNDC'));
    assert.ok(!w.weOwnAddress('garbage'));
    // @ts-ignore wrong type on purpose
    assert.ok(!w.weOwnAddress(false));
    await w.fetchTransactions();
    assert.strictEqual(w.getTransactions().length, 2);
    const tx = w.getTransactions()[1];
    assert.ok(tx.hash);
    assert.strictEqual(tx.value, 100000);
    assert.ok(tx.timestamp);
    assert.ok(tx.confirmations! > 1);

    const tx0 = w.getTransactions()[0];
    assert.ok(tx0.inputs);
    assert.ok(tx0.inputs.length === 1);
    assert.ok(tx0.outputs);
    assert.ok(tx0.outputs.length === 2);

    assert.ok(w.weOwnTransaction('49944e90fe917952e36b1967cdbc1139e60c89b4800b91258bf2345a77a8b888'));
    assert.ok(!w.weOwnTransaction('825c12f277d1f84911ac15ad1f41a3de28e9d906868a930b0a7bca61b17c8881'));
  });
});


================================================
FILE: ./tests/integration/multisig-hd-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { MultisigHDWallet } from '../../class/';

jest.setTimeout(300 * 1000);

afterAll(() => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  try {
    await MalinElectrum.connectMain();
  } catch (Err) {
    console.log('failed to connect to Electrum:', Err);
    process.exit(2);
  }
});

describe('multisig-hd-wallet', () => {
  it('can fetch balance & transactions', async () => {
    const path = "m/48'/0'/0'/2'";
    const fp1 = 'D37EAD88';
    const fp2 = '168DD603';
    const Zpub1 = 'Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ';
    const Zpub2 = 'Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn';

    const w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1);
    w.addCosigner(Zpub2, fp2);
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.getDerivationPath(), path);
    assert.strictEqual(w.getCosigner(1), Zpub1);
    assert.strictEqual(w.getCosigner(2), Zpub2);
    assert.strictEqual(w.getCosignerForFingerprint(fp1), Zpub1);
    assert.strictEqual(w.getCosignerForFingerprint(fp2), Zpub2);

    await w.fetchBalance();
    await w.fetchTransactions();
    assert.ok(w.getTransactions().length >= 6);
  });
});


================================================
FILE: ./tests/integration/lightning-custodian-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { LightningCustodianWallet } from '../../class';
import { fetch } from '../../util/fetch';

jest.setTimeout(200 * 1000);
const baseUri = 'https://lndhub-staging.herokuapp.com';

// eslint-disable-next-line jest/no-disabled-tests
describe.skip('LightningCustodianWallet', () => {
  const l1 = new LightningCustodianWallet();
  l1.setBaseURI(baseUri);
  l1.init();

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('issue credentials', async () => {
    assert.ok(l1.refill_addressess.length === 0);
    assert.ok(l1._refresh_token_created_ts === 0);
    assert.ok(l1._access_token_created_ts === 0);
    l1.balance = 'FAKE';

    await l1.createAccount(false);
    await l1.authorize();

    assert.ok(l1.access_token);
    assert.ok(l1.refresh_token);
    assert.ok(l1._refresh_token_created_ts > 0);
    assert.ok(l1._access_token_created_ts > 0);
    console.log(l1.getSecret());
  });

  it('can create, auth and getbtc', async () => {
    assert.ok(l1.refill_addressess.length === 0);
    assert.ok(l1._refresh_token_created_ts === 0);
    assert.ok(l1._access_token_created_ts === 0);
    l1.balance = 'FAKE';

    await l1.createAccount(true);
    await l1.authorize();
    await l1.fetchBtcAddress();
    await l1.fetchBalance();
    await l1.fetchTransactions();
    await l1.fetchPendingTransactions();

    assert.ok(l1.access_token);
    assert.ok(l1.refresh_token);
    assert.ok(l1._refresh_token_created_ts > 0);
    assert.ok(l1._access_token_created_ts > 0);
    assert.ok(l1.refill_addressess.length > 0);
    assert.ok(l1.balance === 0);
    assert.ok(l1.pending_transactions_raw.length === 0);
    assert.ok(l1.transactions_raw.length === 0);
    assert.ok(l1.transactions_raw.length === l1.getTransactions().length);
  });

  it('can refresh token', async () => {
    const oldRefreshToken = l1.refresh_token;
    const oldAccessToken = l1.access_token;
    await l1.refreshAcessToken();
    assert.ok(oldRefreshToken !== l1.refresh_token);
    assert.ok(oldAccessToken !== l1.access_token);
    assert.ok(l1.access_token);
    assert.ok(l1.refresh_token);
  });

  it('can use existing login/pass', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }
    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    await l2.fetchPendingTransactions();
    await l2.fetchTransactions();

    assert.ok(l2.pending_transactions_raw.length === 0);
    assert.ok(l2.transactions_raw.length > 0);
    assert.ok(l2.transactions_raw.length === l2.getTransactions().length);
    for (const tx of l2.getTransactions()) {
      assert.ok(typeof tx.fee !== 'undefined');
      assert.ok(tx.value);
      assert.ok(tx.timestamp);
      assert.ok(tx.description || tx.memo, JSON.stringify(tx));
      assert.ok(!isNaN(tx.value));
      assert.ok(tx.type === 'bitcoind_tx' || tx.type === 'paid_invoice', 'unexpected tx type ' + tx.type);
    }
    await l2.fetchBalance();
    assert.ok(l2.getBalance() > 0);
  });

  it('can decode & check invoice', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }
    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();

    let invoice =
      'lnbc1u1pdcqpt3pp5ltuevvq2g69kdrzcegrs9gfqjer45rwjc0w736qjl92yvwtxhn6qdp8dp6kuerjv4j9xct5daeks6tnyp3xc6t50f582cscqp2zrkghzl535xjav52ns0rpskcn20takzdr2e02wn4xqretlgdemg596acq5qtfqhjk4jpr7jk8qfuuka2k0lfwjsk9mchwhxcgxzj3tsp09gfpy';
    const decoded = l2.decodeInvoice(invoice);

    assert.ok(decoded.payment_hash);
    assert.ok(decoded.description);
    assert.ok(decoded.num_satoshis);
    assert.strictEqual(parseInt(decoded.num_satoshis, 10) * 1000, parseInt(decoded.num_millisatoshis, 10));

    // checking that bad invoice cant be decoded
    invoice = 'gsom';
    let error = false;
    try {
      l2.decodeInvoice(invoice);
    } catch (Err) {
      error = true;
    }
    assert.ok(error);
  });

  it('decode can handle zero sats but present msats', async () => {
    const l = new LightningCustodianWallet();
    const decoded = l.decodeInvoice(
      'lnbc89n1p0zptvhpp5j3h5e80vdlzn32df8y80nl2t7hssn74lzdr96ve0u4kpaupflx2sdphgfkx7cmtwd68yetpd5s9xct5v4kxc6t5v5s9gunpdeek66tnwd5k7mscqp2sp57m89zv0lrgc9zzaxy5p3d5rr2cap2pm6zm4n0ew9vyp2d5zf2mfqrzjqfxj8p6qjf5l8du7yuytkwdcjhylfd4gxgs48t65awjg04ye80mq7z990yqq9jsqqqqqqqqqqqqq05qqrc9qy9qsq9mynpa9ucxg53hwnvw323r55xdd3l6lcadzs584zvm4wdw5pv3eksdlcek425pxaqrn9u5gpw0dtpyl9jw2pynjtqexxgh50akwszjgq4ht4dh',
    );
    assert.strictEqual(decoded.num_satoshis, '8.9');
  });

  it('can decode invoice locally & remotely', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }
    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    const invoice =
      'lnbc1u1pdcqpt3pp5ltuevvq2g69kdrzcegrs9gfqjer45rwjc0w736qjl92yvwtxhn6qdp8dp6kuerjv4j9xct5daeks6tnyp3xc6t50f582cscqp2zrkghzl535xjav52ns0rpskcn20takzdr2e02wn4xqretlgdemg596acq5qtfqhjk4jpr7jk8qfuuka2k0lfwjsk9mchwhxcgxzj3tsp09gfpy';
    const decodedLocally = l2.decodeInvoice(invoice);
    const decodedRemotely = await l2.decodeInvoiceRemote(invoice);
    assert.strictEqual(decodedLocally.destination, decodedRemotely.destination);
    assert.strictEqual(decodedLocally.num_satoshis, decodedRemotely.num_satoshis);
    assert.strictEqual(decodedLocally.timestamp, decodedRemotely.timestamp);
    assert.strictEqual(decodedLocally.expiry, decodedRemotely.expiry);
    assert.strictEqual(decodedLocally.payment_hash, decodedRemotely.payment_hash);
    assert.strictEqual(decodedLocally.description, decodedRemotely.description);
    assert.strictEqual(decodedLocally.cltv_expiry, decodedRemotely.cltv_expiry);
  });

  it('can pay invoice from opennode', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }
    if (!process.env.OPENNODE) {
      console.error('process.env.OPENNODE not set, skipped');
      return;
    }

    const response = await fetch('https://api.opennode.co/v1/charges', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: process.env.OPENNODE,
      },
      body: JSON.stringify({
        amount: '0.01',
        currency: 'USD',
      }),
    });

    const res = await response.json();
    if (!res.data || !res.data.lightning_invoice || !res.data.lightning_invoice.payreq) {
      throw new Error('Opennode problem');
    }

    const invoice = res.data.lightning_invoice.payreq;

    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    await l2.fetchTransactions();
    const txLen = l2.transactions_raw.length;

    const start = +new Date();
    await l2.payInvoice(invoice);
    const end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('payInvoice took', (end - start) / 1000, 'sec');
    }

    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen + 1);
    const lastTx = l2.transactions_raw[l2.transactions_raw.length - 1];
    assert.strictEqual(typeof lastTx.payment_preimage, 'string', 'preimage is present and is a string');
    assert.strictEqual(lastTx.payment_preimage.length, 64, 'preimage is present and is a string of 32 hex-encoded bytes');
    // transactions became more after paying an invoice
  });

  // turned off because acinq strike is shutting down
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can pay invoice (acinq)', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }
    if (!process.env.STRIKE) {
      console.error('process.env.STRIKE not set, skipped');
      return;
    }

    const response = await fetch('https://api.strike.acinq.co/api/v1/charges', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Basic ${btoa(process.env.STRIKE + ':')}`,
      },
      body: 'amount=1&currency=btc&description=acceptance+test',
    });

    const res = await response.json();

    if (!res.payment_request) {
      throw new Error('Strike problem: ' + JSON.stringify(res));
    }

    const invoice = res.payment_request;

    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    await l2.fetchTransactions();
    const txLen = l2.transactions_raw.length;

    const decoded = l2.decodeInvoice(invoice);
    assert.ok(decoded.payment_hash);
    assert.ok(decoded.description);

    let start = +new Date();
    await l2.payInvoice(invoice);
    let end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('payInvoice took', (end - start) / 1000, 'sec');
    }

    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen + 1);
    const lastTx = l2.transactions_raw[l2.transactions_raw.length - 1];
    assert.strictEqual(typeof lastTx.payment_preimage, 'string', 'preimage is present and is a string');
    assert.strictEqual(lastTx.payment_preimage.length, 64, 'preimage is present and is a string of 32 hex-encoded bytes');
    // transactions became more after paying an invoice

    // now, trying to pay duplicate invoice
    start = +new Date();
    let caughtError = false;
    try {
      await l2.payInvoice(invoice);
    } catch (Err) {
      caughtError = true;
    }
    assert.ok(caughtError);
    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen + 1);
    // havent changed since last time
    end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('duplicate payInvoice took', (end - start) / 1000, 'sec');
    }
  });

  it('can pay invoice (bitrefill)', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }
    if (!process.env.BITREFILL) {
      console.error('process.env.BITREFILL not set, skipped');
      return;
    }

    const response = await fetch(`https://api-bitrefill.com/v1/lnurl_pay/${process.env.BITREFILL}/callback?amount=1000`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    const res = await response.json();

    if (!res.pr) {
      throw new Error('Bitrefill problem: ' + JSON.stringify(res));
    }

    const invoice = res.pr;

    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    await l2.fetchTransactions();
    const txLen = l2.transactions_raw.length;

    const decoded = l2.decodeInvoice(invoice);
    assert.ok(decoded.payment_hash);

    let start = +new Date();
    await l2.payInvoice(invoice);
    let end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('payInvoice took', (end - start) / 1000, 'sec');
    }

    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen + 1);
    const lastTx = l2.transactions_raw[l2.transactions_raw.length - 1];
    assert.strictEqual(typeof lastTx.payment_preimage, 'string', 'preimage is present and is a string');
    assert.strictEqual(lastTx.payment_preimage.length, 64, 'preimage is present and is a string of 32 hex-encoded bytes');
    // transactions became more after paying an invoice

    // now, trying to pay duplicate invoice
    start = +new Date();
    let caughtError = false;
    try {
      await l2.payInvoice(invoice);
    } catch (Err) {
      caughtError = true;
    }
    assert.ok(caughtError);
    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen + 1);
    // havent changed since last time
    end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('duplicate payInvoice took', (end - start) / 1000, 'sec');
    }
  });

  it('can create invoice and pay other blitzhub invoice', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }

    const lOld = new LightningCustodianWallet();
    lOld.setSecret(process.env.BLITZHUB);
    lOld.setBaseURI(baseUri);
    lOld.init();
    await lOld.authorize();
    await lOld.fetchTransactions();
    let txLen = lOld.transactions_raw.length;

    // creating LND wallet
    const lNew = new LightningCustodianWallet();
    lNew.setBaseURI(baseUri);
    lNew.init();
    await lNew.createAccount(true);
    await lNew.authorize();
    await lNew.fetchBalance();
    assert.strictEqual(lNew.balance, 0);

    let invoices = await lNew.getUserInvoices();
    let invoice = await lNew.addInvoice(2, 'test memo');
    const decoded = lNew.decodeInvoice(invoice);
    let invoices2 = await lNew.getUserInvoices();
    assert.strictEqual(invoices2.length, invoices.length + 1);
    assert.ok(invoices2[0].ispaid === false);
    assert.ok(invoices2[0].description);
    assert.strictEqual(invoices2[0].description, 'test memo');
    assert.ok(invoices2[0].payment_request);
    assert.ok(invoices2[0].timestamp);
    assert.ok(invoices2[0].expire_time);
    assert.strictEqual(invoices2[0].amt, 2);
    for (const inv of invoices2) {
      assert.strictEqual(inv.type, 'user_invoice');
    }

    await lOld.fetchBalance();
    let oldBalance = lOld.balance;

    const start = +new Date();
    await lOld.payInvoice(invoice);
    const end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('payInvoice took', (end - start) / 1000, 'sec');
    }

    invoices2 = await lNew.getUserInvoices();
    assert.ok(invoices2[0].ispaid);

    assert.ok(lNew.weOwnTransaction(decoded.payment_hash));
    assert.ok(!lNew.weOwnTransaction('d45818ae11a584357f7b74da26012d2becf4ef064db015a45bdfcd9cb438929d'));

    await lOld.fetchBalance();
    await lNew.fetchBalance();
    assert.strictEqual(oldBalance - lOld.balance, 2);
    assert.strictEqual(lNew.balance, 2);

    await lOld.fetchTransactions();
    assert.strictEqual(lOld.transactions_raw.length, txLen + 1, 'internal invoice should also produce record in payer`s tx list');
    const newTx = lOld.transactions_raw.slice().pop();
    assert.ok(typeof newTx.fee !== 'undefined');
    assert.ok(newTx.value);
    assert.ok(newTx.description || newTx.memo, JSON.stringify(newTx));
    assert.ok(newTx.timestamp);
    assert.ok(!isNaN(newTx.value));
    assert.ok(newTx.type === 'paid_invoice', 'unexpected tx type ' + newTx.type);

    // now, paying back that amount
    oldBalance = lOld.balance;
    invoice = await lOld.addInvoice(1, 'test memo');
    await lNew.payInvoice(invoice);
    await lOld.fetchBalance();
    await lNew.fetchBalance();
    assert.strictEqual(lOld.balance - oldBalance, 1);
    assert.strictEqual(lNew.balance, 1); // ok, forfeit this 1, unrecoverable

    // now, paying same internal invoice. should fail:

    let caughtError = false;
    await lOld.fetchTransactions();
    txLen = lOld.transactions_raw.length;
    const invLen = (await lNew.getUserInvoices()).length;
    try {
      await lOld.payInvoice(invoice);
    } catch (Err) {
      caughtError = true;
    }
    assert.ok(caughtError);

    await lOld.fetchTransactions();
    assert.strictEqual(txLen, lOld.transactions_raw.length, 'tx count should not be changed');
    assert.strictEqual(invLen, (await lNew.getUserInvoices()).length, 'invoices count should not be changed');

    // testing how limiting works:
    assert.strictEqual(lNew.user_invoices_raw.length, 1);
    await lNew.addInvoice(666, 'test memo 2');
    invoices = await lNew.getUserInvoices(1);
    assert.strictEqual(invoices.length, 2);
    assert.strictEqual(invoices[0].amt, 2);
    assert.strictEqual(invoices[1].amt, 666);
  });

  it('can pay invoice with free amount (tippin.me)', async function () {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }

    // fetching invoice from tippin.me :

    const response = await fetch('https://tippin.me/lndreq/newinvoice.php', {
      method: 'POST',
      headers: {
        Origin: 'https://tippin.me',
        'Accept-Encoding': 'gzip, deflate, br',
        'Accept-Language': 'en-GB,en-US;q=0.9,en;q=0.8',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        Accept: 'application/json, text/javascript, */*; q=0.01',
      },
      body: 'userid=1188&username=overtorment&istaco=0&customAmnt=0&customMemo=',
    });

    const res = await response.json();
    if (!res || !res.message) {
      throw new Error('tippin.me problem: ' + JSON.stringify(res));
    }
    const invoice = res.message;

    // --> use to pay specific invoice
    // invoice =
    //   'lnbc1pwrp35spp5z62nvj8yw6luq7ns4a8utpwn2qkkdwdt0ludwm54wjeazk2xv5wsdpu235hqurfdcsx7an9wf6x7undv4h8ggpgw35hqurfdchx6eff9p6nzvfc8q5scqzysxqyz5vqj8xq6wz6dezmunw6qxleuw67ensjnt3fldltrmmkvzurge0dczpn94fkwwh7hkh5wqrhsvfegtvhswn252hn6uw5kx99dyumz4v5n9sp337py2';

    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    await l2.fetchTransactions();
    await l2.fetchBalance();
    const oldBalance = +l2.balance;
    const txLen = l2.transactions_raw.length;

    const decoded = l2.decodeInvoice(invoice);
    assert.ok(decoded.payment_hash);
    assert.ok(decoded.description);
    assert.strictEqual(+decoded.num_satoshis, 0);

    // first, tip invoice without amount should not work:
    let gotError = false;
    try {
      await l2.payInvoice(invoice);
    } catch (_) {
      gotError = true;
    }
    assert.ok(gotError);

    // then, pay:

    const start = +new Date();
    await l2.payInvoice(invoice, 3);
    const end = +new Date();
    if ((end - start) / 1000 > 9) {
      console.warn('payInvoice took', (end - start) / 1000, 'sec');
    }

    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen + 1);
    // transactions became more after paying an invoice

    await l2.fetchBalance();
    assert.ok(oldBalance - l2.balance >= 3);
    assert.ok(oldBalance - l2.balance < 10); // sanity check
  });

  it('cant create zero amt invoices yet', async () => {
    const l = new LightningCustodianWallet();
    l.setBaseURI(baseUri);
    l.init();
    assert.ok(l.refill_addressess.length === 0);
    assert.ok(l._refresh_token_created_ts === 0);
    assert.ok(l._access_token_created_ts === 0);
    l.balance = 'FAKE';

    await l.createAccount(true);
    await l.authorize();
    await l.fetchBalance();

    assert.ok(l.access_token);
    assert.ok(l.refresh_token);
    assert.ok(l._refresh_token_created_ts > 0);
    assert.ok(l._access_token_created_ts > 0);
    assert.ok(l.balance === 0);

    let err = false;
    try {
      await l.addInvoice(0, 'zero amt inv');
    } catch (_) {
      err = true;
    }
    assert.ok(err);

    err = false;
    try {
      await l.addInvoice(NaN, 'zero amt inv');
    } catch (_) {
      err = true;
    }
    assert.ok(err);
  });

  it('cant pay negative free amount', async () => {
    if (!process.env.BLITZHUB) {
      console.error('process.env.BLITZHUB not set, skipped');
      return;
    }

    // fetching invoice from tippin.me :

    const response = await fetch('https://tippin.me/lndreq/newinvoice.php', {
      method: 'POST',
      headers: {
        Origin: 'https://tippin.me',
        'Accept-Encoding': 'gzip, deflate, br',
        'Accept-Language': 'en-GB,en-US;q=0.9,en;q=0.8',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        Accept: 'application/json, text/javascript, */*; q=0.01',
      },
      body: 'userid=1188&username=overtorment&istaco=0&customAmnt=0&customMemo=',
    });

    const res = await response.json();
    if (!res || !res.message) {
      throw new Error('tippin.me problem: ' + JSON.stringify(res));
    }
    const invoice = res.message;
    const l2 = new LightningCustodianWallet();
    l2.setSecret(process.env.BLITZHUB);
    l2.setBaseURI(baseUri);
    l2.init();
    await l2.authorize();
    await l2.fetchTransactions();
    await l2.fetchBalance();
    const oldBalance = +l2.balance;
    const txLen = l2.transactions_raw.length;

    const decoded = l2.decodeInvoice(invoice);
    assert.ok(decoded.payment_hash);
    assert.ok(decoded.description);
    assert.strictEqual(+decoded.num_satoshis, 0);

    let error = false;
    try {
      await l2.payInvoice(invoice, -1);
    } catch (Err) {
      error = true;
    }
    assert.ok(error);
    await l2.fetchBalance();
    assert.strictEqual(l2.balance, oldBalance);
    await l2.fetchTransactions();
    assert.strictEqual(l2.transactions_raw.length, txLen);
  });
});


================================================
FILE: ./tests/integration/hd-segwit-bech32-transaction.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { HDSegwitBech32Transaction, HDSegwitBech32Wallet, SegwitBech32Wallet, SegwitP2SHWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

jest.setTimeout(150 * 1000);

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

let _cachedHdWallet = false;

/**
 * @returns {Promise<HDSegwitBech32Wallet>}
 * @private
 */
async function _getHdWallet() {
  if (_cachedHdWallet) return _cachedHdWallet;
  _cachedHdWallet = new HDSegwitBech32Wallet();
  _cachedHdWallet.setSecret(process.env.HD_MNEMONIC_BIP84);
  await _cachedHdWallet.fetchBalance();
  await _cachedHdWallet.fetchTransactions();
  return _cachedHdWallet;
}

describe('HDSegwitBech32Transaction', () => {
  it('can decode & check sequence', async function () {
    let T = new HDSegwitBech32Transaction(null, 'e9ef58baf4cff3ad55913a360c2fa1fd124309c59dcd720cdb172ce46582097b');
    assert.strictEqual(await T.getMaxUsedSequence(), 0xffffffff);
    assert.strictEqual(await T.isSequenceReplaceable(), false);

    // 881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e
    T = new HDSegwitBech32Transaction(
      '02000000000102f1155666b534f7cb476a0523a45dc8731d38d56b5b08e877c968812423fbd7f3010000000000000000d8a2882a692ee759b43e6af48ac152dd3410cc4b7d25031e83b3396c16ffbc8900000000000000000002400d03000000000017a914e286d58e53f9247a4710e51232cce0686f16873c870695010000000000160014d3e2ecbf4d91321794e0297e0284c47527cf878b02483045022100d18dc865fb4d087004d021d480b983b8afb177a1934ce4cd11cf97b03e17944f02206d7310687a84aab5d4696d535bca69c2db4449b48feb55fff028aa004f2d1744012103af4b208608c75f38e78f6e5abfbcad9c360fb60d3e035193b2cd0cdc8fc0155c0247304402207556e859845df41d897fe442f59b6106c8fa39c74ba5b7b8e3268ab0aebf186f0220048a9f3742339c44a1e5c78b491822b96070bcfda3f64db9dc6434f8e8068475012102456e5223ed3884dc6b0e152067fd836e3eb1485422eda45558bf83f59c6ad09f00000000',
    );
    assert.strictEqual(await T.getMaxUsedSequence(), 0);
    assert.strictEqual(await T.isSequenceReplaceable(), true);

    assert.ok((await T.getRemoteConfirmationsNum()) >= 292);
  });

  it('can tell if its our transaction', async function () {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const hd = await _getHdWallet();

    let tt = new HDSegwitBech32Transaction(null, '881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e', hd);

    assert.ok(await tt.isOurTransaction());

    tt = new HDSegwitBech32Transaction(null, '89bcff166c39b3831e03257d4bcc1034dd52c18af46a3eb459e72e692a88a2d8', hd);

    assert.ok(!(await tt.isOurTransaction()));
  });

  it('can tell tx info', async function () {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const hd = await _getHdWallet();

    const tt = new HDSegwitBech32Transaction(null, '881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e', hd);

    const { fee, feeRate, targets, changeAmount, utxos } = await tt.getInfo();
    assert.strictEqual(fee, 4464);
    assert.strictEqual(changeAmount, 103686);
    assert.strictEqual(feeRate, 21);
    assert.strictEqual(targets.length, 1);
    assert.strictEqual(targets[0].value, 200000);
    assert.strictEqual(targets[0].address, '3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC');
    assert.strictEqual(
      JSON.stringify(utxos),
      JSON.stringify([
        {
          vout: 1,
          value: 108150,
          txid: 'f3d7fb23248168c977e8085b6bd5381d73c85da423056a47cbf734b5665615f1',
          address: 'bc1qahhgjtxexjx9t0e5pjzqwtjnxexzl6f5an38hq',
        },
        {
          vout: 0,
          value: 200000,
          txid: '89bcff166c39b3831e03257d4bcc1034dd52c18af46a3eb459e72e692a88a2d8',
          address: 'bc1qvh44cwd2v7zld8ef9ld5rs5zafmejuslp6yd73',
        },
      ]),
    );
  });

  it('can do RBF - cancel tx', async function () {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const hd = await _getHdWallet();

    const tt = new HDSegwitBech32Transaction(null, '881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e', hd);

    assert.strictEqual(await tt.canCancelTx(), true);

    const { tx } = await tt.createRBFcancelTx(25);

    const createdTx = bitcoin.Transaction.fromHex(tx.toHex());
    assert.strictEqual(createdTx.ins.length, 2);
    assert.strictEqual(createdTx.outs.length, 1);
    const addr = SegwitBech32Wallet.scriptPubKeyToAddress(uint8ArrayToHex(createdTx.outs[0].script));
    assert.ok(hd.weOwnAddress(addr));

    const actualFeerate = (108150 + 200000 - Number(createdTx.outs[0].value)) / tx.virtualSize();
    assert.strictEqual(Math.round(actualFeerate), 25);

    const tt2 = new HDSegwitBech32Transaction(tx.toHex(), null, hd);
    assert.strictEqual(await tt2.canCancelTx(), false); // newly created cancel tx is not cancellable anymore
  });

  it('can do RBF - bumpfees tx', async function () {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const hd = await _getHdWallet();

    const tt = new HDSegwitBech32Transaction(null, '881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e', hd);

    assert.strictEqual(await tt.canCancelTx(), true);
    assert.strictEqual(await tt.canBumpTx(), true);

    const { tx } = await tt.createRBFbumpFee(27);

    const createdTx = bitcoin.Transaction.fromHex(tx.toHex());
    assert.strictEqual(createdTx.ins.length, 2);
    assert.strictEqual(createdTx.outs.length, 2);
    const addr0 = SegwitP2SHWallet.scriptPubKeyToAddress(uint8ArrayToHex(createdTx.outs[0].script));
    assert.ok(!hd.weOwnAddress(addr0));
    assert.strictEqual(addr0, '3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC'); // dest address
    const addr1 = SegwitBech32Wallet.scriptPubKeyToAddress(uint8ArrayToHex(createdTx.outs[1].script));
    assert.ok(hd.weOwnAddress(addr1));

    const actualFeerate = (108150 + 200000 - Number(createdTx.outs[0].value + createdTx.outs[1].value)) / tx.virtualSize();
    assert.strictEqual(Math.round(actualFeerate), 28);

    const tt2 = new HDSegwitBech32Transaction(tx.toHex(), null, hd);
    assert.strictEqual(await tt2.canCancelTx(), true); // new tx is still cancellable since we only bumped fees
  });

  it('can do CPFP - bump fees', async function () {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const hd = await _getHdWallet();

    const tt = new HDSegwitBech32Transaction(null, '2ec8a1d0686dcccffc102ba5453a28d99c8a1e5061c27b41f5c0a23b0b27e75f', hd);
    assert.ok(await tt.isToUsTransaction());
    const { unconfirmedUtxos, fee: oldFee } = await tt.getInfo();

    assert.strictEqual(
      JSON.stringify(unconfirmedUtxos),
      JSON.stringify([
        {
          vout: 0,
          value: 200000,
          txid: '2ec8a1d0686dcccffc102ba5453a28d99c8a1e5061c27b41f5c0a23b0b27e75f',
          address: 'bc1qvlmgrq0gtatanmas0tswrsknllvupq2g844ss2',
        },
      ]),
    );

    const { tx, fee } = await tt.createCPFPbumpFee(20);
    const avgFeeRate = (oldFee + fee) / (tt._txDecoded.virtualSize() + tx.virtualSize());
    assert.ok(Math.round(avgFeeRate) >= 20);
  });
});


================================================
FILE: ./tests/integration/Currency.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import DefaultPreference from 'react-native-default-preference';
import assert from 'assert';

import {
  EXCHANGE_RATES_STORAGE_KEY,
  getPreferredCurrency,
  initCurrencyDaemon,
  LAST_UPDATED,
  PREFERRED_CURRENCY_STORAGE_KEY,
  setPreferredCurrency,
  GROUP_IO_MALINWALLET,
} from '../../malin_modules/currency';
import { FiatUnit } from '../../models/fiatUnit';

jest.setTimeout(90 * 1000);

describe('currency', () => {
  beforeAll(async () => {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
  });

  afterEach(async () => {
    await DefaultPreference.clearAll();
  });

  it('fetches exchange rate and saves to DefaultPreference', async () => {
    await initCurrencyDaemon();
    let curString = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    let cur = JSON.parse(curString || '{}');
    assert.ok(Number.isInteger(cur[LAST_UPDATED]));
    assert.ok(cur[LAST_UPDATED] > 0);
    assert.ok(cur.BTC_USD > 0);

    // now, setting other currency as default
    await DefaultPreference.set(PREFERRED_CURRENCY_STORAGE_KEY, FiatUnit.JPY.endPointKey);
    await initCurrencyDaemon(true);
    curString = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    cur = JSON.parse(curString || '{}');
    assert.ok(cur.BTC_JPY > 0);

    // now setting with a proper setter
    await setPreferredCurrency(FiatUnit.EUR);
    await initCurrencyDaemon(true);
    const preferred = await getPreferredCurrency();
    assert.strictEqual(preferred.endPointKey, 'EUR');
    curString = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    cur = JSON.parse(curString || '{}');
    assert.ok(cur.BTC_EUR > 0);

    // test Yadio rate source
    await setPreferredCurrency(FiatUnit.ARS);
    await initCurrencyDaemon(true);
    curString = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    cur = JSON.parse(curString || '{}');
    assert.ok(cur.BTC_ARS > 0);

    // test YadioConvert rate source
    await setPreferredCurrency(FiatUnit.LBP);
    await initCurrencyDaemon(true);
    curString = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    cur = JSON.parse(curString || '{}');
    assert.ok(cur.BTC_LBP > 0);

    // test Exir rate source
    await setPreferredCurrency(FiatUnit.IRT);
    await initCurrencyDaemon(true);
    curString = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    cur = JSON.parse(curString || '{}');
    assert.ok(cur.BTC_IRT > 0);
  });
});


================================================
FILE: ./tests/integration/hd-legacy-breadwallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { HDLegacyBreadwalletWallet } from '../../class';
import { AbstractHDElectrumWallet } from '../../class/wallets/abstract-hd-electrum-wallet';

jest.setTimeout(300 * 1000);
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
  await sleep(20);
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

it('Legacy HD Breadwallet can fetch utxo, balance, and create transaction', async () => {
  if (!process.env.HD_MNEMONIC_BREAD) {
    console.error('process.env.HD_MNEMONIC_BREAD not set, skipped');
    return;
  }
  const wallet = new HDLegacyBreadwalletWallet();
  wallet.setSecret(process.env.HD_MNEMONIC_BREAD);

  await wallet.fetchBalance();

  // m/0'/0/1 1K9ofAnenRn1aR9TMMTreiin9ddjKWbS7z x 0.0001
  // m/0'/0/2 bc1qh0vtrnjn7zs99j4n6xaadde95ctnnvegh9l2jn x 0.00032084
  // m/0'/1/0 1A9Sc4opR6c7Ui6NazECiGmsmnUPh2WeHJ x 0.00016378 BTC
  // m/0'/1/1 bc1qksn08tz44fvnnrpgrrexvs9526t6jg3xnj9tpc x 0.00012422
  // 0.0001 + 0.00016378 + 0.00012422 + 0.00032084 = 0.00070884
  assert.strictEqual(wallet.getBalance(), 70884);

  // try to create a tx
  await wallet.fetchUtxo();

  for (const utxo of wallet.getUtxo()) {
    assert.ok(utxo.txhex);
    assert.ok(typeof utxo.vout !== 'undefined');
    assert.ok(utxo.txid);
    assert.ok(utxo.confirmations);
    assert.ok(utxo.value);
  }

  const { tx } = wallet.createTransaction(
    wallet.getUtxo(),
    [{ address: 'bc1q47efz9aav8g4mnnz9r6ql4pf48phy3g509p7gx' }],
    1,
    'bc1qk9hvkxqsqmps6ex3qawr79rvtg8es4ecjfu5v0',
    AbstractHDElectrumWallet.defaultRBFSequence,
    false,
    0,
  );

  assert.ok(tx);
  const transaction = bitcoin.Transaction.fromHex(tx.toHex());
  assert.ok(transaction.ins.length === 4);
  assert.strictEqual(transaction.outs.length, 1);
});


================================================
FILE: ./tests/integration/MalinElectrum.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';

jest.setTimeout(150 * 1000);

afterAll(() => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
})

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  try {
    await MalinElectrum.connectMain();
  } catch (err) {
    console.log('failed to connect to Electrum:', err);
    process.exit(1);
  }
});

describe('MalinElectrum', () => {
  it('ElectrumClient can estimate fees from histogram', async () => {
    assert.strictEqual(
      MalinElectrum.calcEstimateFeeFromFeeHistorgam(1, [
        [96, 105086],
        [83, 124591],
        [64, 108207],
        [50, 131141],
        [22, 148800],
        [17, 156916],
        [11, 413222],
        [10, 361384],
        [9, 294146],
        [8, 121778],
        [7, 1153727],
        [6, 283925],
        [5, 880946],
        [4, 825703],
        [3, 2179023],
        [2, 590559],
        [1, 1648473],
      ]),
      22,
    )
    assert.strictEqual(
      MalinElectrum.calcEstimateFeeFromFeeHistorgam(18, [
        [96, 105086],
        [83, 124591],
        [64, 108207],
        [50, 131141],
        [22, 148800],
        [17, 156916],
        [11, 413222],
        [10, 361384],
        [9, 294146],
        [8, 121778],
        [7, 1153727],
        [6, 283925],
        [5, 880946],
        [4, 825703],
        [3, 2179023],
        [2, 590559],
        [1, 1648473],
      ]),
      4,
    )
    assert.strictEqual(
      MalinElectrum.calcEstimateFeeFromFeeHistorgam(144, [
        [96, 105086],
        [83, 124591],
        [64, 108207],
        [50, 131141],
        [22, 148800],
        [17, 156916],
        [11, 413222],
        [10, 361384],
        [9, 294146],
        [8, 121778],
        [7, 1153727],
        [6, 283925],
        [5, 880946],
        [4, 825703],
        [3, 2179023],
        [2, 590559],
        [1, 1648473],
      ]),
      4,
    )
  });

  it('ElectrumClient can test connection', async () => {
    assert.ok(
      !(await MalinElectrum.testConnection(
        'electrum1.malinwallet.io',
        444,
        false
      )),
    )
    assert.ok(
      !(await MalinElectrum.testConnection(
        'electrum1.malinwallet.io',
        false,
        444
      )),
    )
    assert.ok(!(await MalinElectrum.testConnection('ya.ru', 444, false)));
    assert.ok(!(await MalinElectrum.testConnection('google.com', false, 80)));
    assert.ok(!(await MalinElectrum.testConnection('google.com', 80, false)));
    assert.ok(!(await MalinElectrum.testConnection('google.com', false, 443)));
    assert.ok(!(await MalinElectrum.testConnection('google.com', 443, false)));
    assert.ok(
      !(await MalinElectrum.testConnection('joyreactor.cc', false, 443))
    );
    assert.ok(
      !(await MalinElectrum.testConnection('joyreactor.cc', 443, false))
    );
    assert.ok(!(await MalinElectrum.testConnection('joyreactor.cc', 80, false)));
    assert.ok(!(await MalinElectrum.testConnection('joyreactor.cc', false, 80)));

    assert.ok(
      await MalinElectrum.testConnection('electrum1.malinwallet.io', '50001'),
    )
    assert.ok(
      await MalinElectrum.testConnection('electrum1.malinwallet.io', false, 443)
    );
  })

  it('ElectrumClient can estimate fees', async () => {
    assert.ok((await MalinElectrum.estimateFee(1)) >= 1);
    const fees = await MalinElectrum.estimateFees();
    assert.ok(fees.fast > 0);
    assert.ok(fees.medium > 0);
    assert.ok(fees.slow > 0);
  })

  it('ElectrumClient can request server features', async () => {
    const features = await MalinElectrum.serverFeatures();
    // console.warn({features});
    assert.ok(features.server_version);
    assert.ok(features.protocol_min);
    assert.ok(features.protocol_max);
  })

  it('MalinElectrum can do getBalanceByAddress()', async function () {
    const address = '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK';
    const balance = await MalinElectrum.getBalanceByAddress(address);
    assert.strictEqual(balance.confirmed, 51432);
    assert.strictEqual(balance.unconfirmed, 0);
    assert.strictEqual(balance.addr, address);
  })

  it('MalinElectrum can do getTransactionsByAddress()', async function () {
    const txs = await MalinElectrum.getTransactionsByAddress(
      'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
    )
    assert.strictEqual(txs.length, 1);
    assert.strictEqual(
      txs[0].tx_hash,
      'ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d',
    )
    assert.strictEqual(txs[0].height, 563077);
  })

  // skipped because requires fresh address with pending txs every time
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('MalinElectrum can do getMempoolTransactionsByAddress()', async function () {
    const txs = await MalinElectrum.getMempoolTransactionsByAddress(
      'bc1qp33en9mnw277c9vz5fz9vcu666cvervdnk02327wwph97hdjurqqxtl03c',
    )
    assert.ok(txs.length > 0);
    assert.ok(txs[0].tx_hash);
    assert.ok(txs[0].fee);

    const rez = await MalinElectrum.multiGetTransactionByTxid(
      [txs[0].tx_hash],
      10,
      true
    );
    assert.ok(rez[txs[0].tx_hash]);
  })

  it('MalinElectrum can do getTransactionsFullByAddress()', async function () {
    const txs = await MalinElectrum.getTransactionsFullByAddress(
      'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
    )
    for (const tx of txs) {
      assert.ok(tx.address === 'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh');
      assert.ok(tx.txid);
      assert.ok(tx.confirmations);
      assert.ok(!tx.vin);
      assert.ok(!tx.vout);
      assert.ok(tx.inputs);
      assert.strictEqual(
        tx.inputs[0]?.addresses[0],
        'bc1q7td49wcxfad9v42kmvg5refn9wcnvnru4395qw',
      )
      assert.ok(tx.inputs[0].addresses.length > 0);
      assert.ok(tx.inputs[0].value > 0);
      assert.ok(tx.outputs);
      assert.ok(tx.outputs[0].value > 0);
      assert.ok(tx.outputs[0].scriptPubKey);
      assert.ok(tx.outputs[0].addresses.length > 0);
    }
  });

  it('MalinElectrum can do txhexToElectrumTransaction()', () => {
    const tx =
      '0200000000010137d07edbc9db9a072a79c6f03e7274e52642d64d760143adc64832501087f37b00000000000000008002102700000000000022512040ef293a8a0ebaf8b351a27d89ff4b5b3822a635e4afdca77a30170c363bafa3e4ad0b00000000001600147dfe2249fa56a2f2b4b7ed3b16ee55e7c565198002483045022100e5b9f1c12e133ef659a0e5cc417b1f8625ba9e951bc7083408de2a33d6fb1a84022035ebb1e2d4ab620ee178dc6cd0b58c54123d1526d9a1b3efba612ea80e48edd101210295b56fc62cdd09c200ce19f873d5ddb3074f7141b2533448829385f48f093a1600000000';
    const decoded = MalinElectrum.txhexToElectrumTransaction(tx);
    assert.strictEqual(
      decoded.vout[0].scriptPubKey.addresses[0],
      'bc1pgrhjjw52p6a03v635f7cnl6ttvuz9f34ujhaefm6xqtscd3m473szkl92g',
    )
  });

  it.each([false, true])(
    'MalinElectrum can do multiGetBalanceByAddress(), disableBatching=%p',
    async function (diableBatching) {
      if (diableBatching) MalinElectrum.setBatchingDisabled();
      const balances = await MalinElectrum.multiGetBalanceByAddress([
        'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
        'bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p',
        'bc1qwp58x4c9e5cplsnw5096qzdkae036ug7a34x3r',
        '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK',
        'bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy',
      ]);

      assert.strictEqual(balances.balance, 200000 + 51432)
      assert.strictEqual(balances.unconfirmed_balance, 0)
      assert.strictEqual(
        balances.addresses.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh.confirmed,
        50000
      )
      assert.strictEqual(
        balances.addresses.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh
          .unconfirmed,
        0
      )
      assert.strictEqual(
        balances.addresses.bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p.confirmed,
        50000
      )
      assert.strictEqual(
        balances.addresses.bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p
          .unconfirmed,
        0
      )
      assert.strictEqual(
        balances.addresses.bc1qwp58x4c9e5cplsnw5096qzdkae036ug7a34x3r.confirmed,
        50000
      )
      assert.strictEqual(
        balances.addresses.bc1qwp58x4c9e5cplsnw5096qzdkae036ug7a34x3r
          .unconfirmed,
        0
      )
      assert.strictEqual(
        balances.addresses.bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy.confirmed,
        50000
      )
      assert.strictEqual(
        balances.addresses.bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy
          .unconfirmed,
        0
      )
      assert.strictEqual(
        balances.addresses['3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK'].confirmed,
        51432
      )
      assert.strictEqual(
        balances.addresses['3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK'].unconfirmed,
        0
      )
      if (diableBatching) MalinElectrum.setBatchingEnabled()
    }
  )

  it('MalinElectrum can do multiGetUtxoByAddress()', async () => {
    const utxos = await MalinElectrum.multiGetUtxoByAddress(
      [
        'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
        'bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p',
        'bc1qwp58x4c9e5cplsnw5096qzdkae036ug7a34x3r',
        'bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy',
      ],
      3,
    )

    assert.strictEqual(Object.keys(utxos).length, 4);
    assert.strictEqual(
      utxos.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh[0].txid,
      'ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d',
    );
    assert.strictEqual(
      utxos.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh[0].vout,
      1
    );
    assert.strictEqual(
      utxos.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh[0].value,
      50000
    );
    assert.strictEqual(
      utxos.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh[0].address,
      'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
    )
  });

  it.each([false, true])(
    'ElectrumClient can do multiGetHistoryByAddress(), disableBatching=%p',
    async (disableBatching) => {
      if (disableBatching) MalinElectrum.setBatchingDisabled();
      const histories = await MalinElectrum.multiGetHistoryByAddress(
        [
          'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
          'bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p',
          'bc1qwp58x4c9e5cplsnw5096qzdkae036ug7a34x3r',
          'bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy',
          'bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy', // duplicate intended
        ],
        3
      )

      assert.ok(
        histories.bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh[0].tx_hash ===
          'ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d',
      )
      assert.ok(
        histories.bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy[0].tx_hash ===
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df',
      )
      assert.ok(Object.keys(histories).length === 4);
      if (disableBatching) MalinElectrum.setBatchingEnabled()
    }
  )

  it.each([false, true])(
    'ElectrumClient can do multiGetTransactionByTxid(), disableBatching=%p',
    async (disableBatching) => {
      if (disableBatching) MalinElectrum.setBatchingDisabled();
      const txdatas = await MalinElectrum.multiGetTransactionByTxid(
        [
          'ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d',
          '042c9e276c2d06b0b84899771a7f218af90dd60436947c49a844a05d7c104b26',
          '2cf439be65e7cc7c6e4db721b1c8fcb1cd95ff07cde79a52a73b3d15a12b2eb6',
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df',
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df', // duplicate intended
        ],
        true,
        3
      )

      assert.ok(
        txdatas.ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d
          .txid ===
          'ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d',
      )
      assert.ok(
        txdatas[
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'
        ].txid ===
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df',
      );
      assert.ok(
        txdatas[
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'
        ].size
      )
      assert.ok(
        txdatas[
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'
        ].vin
      )
      assert.ok(
        txdatas[
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'
        ].vout
      )
      assert.ok(
        txdatas[
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'
        ].blocktime
      )
      assert.strictEqual(
        txdatas[
          '5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'
        ]?.vout[0]?.scriptPubKey?.addresses[0],
        'bc1qp09gdem9xepasp4zxa2fxyvr8wazhms0wvtds9',
      );

      assert.ok(Object.keys(txdatas).length === 4)
      if (disableBatching) MalinElectrum.setBatchingEnabled()
    }
  )

  it('multiGetTransactionByTxid() can work with big batches', async () => {
    // eslint-disable-next-line prettier/prettier
    const vinTxids = ['fb083ca5fb98451314836bbf31d08bf658deddcc8947d76eefe44b5aa49f3a48', '5f0f4ac816af5717f6e049454ef698c5d46b2303b1622a17b42eed0d914ea412', '8f58af45a9375ed2516237e6910186f4c9c5655a873396e71721057bdd68b3f2', 'e3cca3df55a880adbe639955c68772d2c491b36e28368380241ac096d9967095', '5aef653da43618151ea24ed13b26e67415a397212a60dbb3609a67ba1c01373b', 'b67c9ce40020584b82085f4093d066c2759542d9aa612bd1cc2e561548e2f9bb', '28f29df4660afa58dd6e0f9c31d3e3c204b575029c4b429dbab7da834748f097', '147aa266b25fb24bfd7f2e66a1d8eeaa5086c35922c59a36a7a7c4e6a7805d5d', '40f00b01d2173c46fc1b4f462132f183beb368bd43df7b88869a8bb7a8bb3b5f', 'b67c9ce40020584b82085f4093d066c2759542d9aa612bd1cc2e561548e2f9bb', '147aa266b25fb24bfd7f2e66a1d8eeaa5086c35922c59a36a7a7c4e6a7805d5d', 'ba4a6c71c3b3d738609526693bdf87ed5b441f3546d70a2a83128cf6645c10dd', 'b1b7410fb84def2a3fa0ba54e587e3ce373c4f6e1972b5a7044c804e53101131', 'a4a0790f7d00ad7da97e349062cff61da12bc2b1ee06223a41d4960621ad6781', 'b1b7410fb84def2a3fa0ba54e587e3ce373c4f6e1972b5a7044c804e53101131', '15e499177b871ac205bf509e1abd81c29a72475661957ea82db69f4afde6cc3f', '6702bf9dc679c9086d0cb3f43c10d48bb200e1b29d73b4b4a399bd3eae31f4d0', '51c07c5c882b49931d18adf2f62afed25db53ef4264b1f3144152b6c4dfeda1c', '38eba464479c79a230e0256b7e9cc9b9cc8539b9a7297bc9961046df29d63b4a', '5d29eef47330797e9b37cf0d57e48a871a6e249a0102e4744ec9d30613b054b8', '3af7c1fa064a2c74e0d34972895daba4b78f32eae596774bb4bb35d44cf069c1', 'cc5485827920ea5de1375c9806a1b6f7db1f87f2e4074481778d1e44183b3cf6', '38eba464479c79a230e0256b7e9cc9b9cc8539b9a7297bc9961046df29d63b4a', '217b99f47c1a05076b68e98cf65b08df8aa485c28c74e43a0ab5a4aa98a89fa0', 'fb2b8dcb2997c331bd8d9f4d611293874bde116184ef38dfd5a0d5745f9d475d', '2ef35d16748d56d4ec19fb458bc0147e85dd1d78e25f71f0ddd71ba22f0f49ec', '05b4009d2ec7c6472a10d652efdbd7e4fa72a2e2448287e386c4d68864ba75af', 'cd801bc012c361fd6be0bc5b440c71d656d2fa14af90af1f469fc91ca3be0967', '24807d3563342275bee7cc4b98dc2fadb9e39d074534e79c7921b46596988344', '2b29aaa43d344393769f38e1d3dc0ba1d89b2f9868311ff9ec9eb44183d21250', 'b07747a598d4f1f0beae08332568292104f4360929057396c5637c1900e4f3ff', 'f13a237529bfd21edad34678f1da8ebd4606422a85b5f92ee270f3808c286e44', '20264987b20aa1d6975cf9bad62855c3f8c1492e38ea7a73963eb355bd18b77f', '65e0a29033eb3cea6b4c9eaa7448754e468585cf1877e0b228281138421f30cb', '133874b546cdc715439d1d1dba865419a9640ee740f8a72191d1221ac29d066b', 'b056e86b160b08d3e944f1d61368d3523e9c0820ebc8f755b98ac38eb3e307d1', '4bb01e9b0388441442a04bb36fe932c3e3da525c4c09413c90f0a6a74c57d280', '2fc80afde86a45f5f113067f44433d44da28d6e17dd8dbe19f511bc371863a1c', 'e7650f7fa769c2b1aee41477278633a342017c81009feff8b6566b3f3664b6dc', '01315e63a7b852f1dfd83bc7a405351492c076d88f2ae4adc3c32d3431fd5a35', '7cb1e59903fb72e4f618ba7ab078765e9117d8aca2421268fe24b41986df37ba', '7fd27c38816b461eba58b547a524747b28eec2b58e2c8fd29fa9858de96265f5', '38b95ee03adf62feb5188c1a8c5ac6334e95e0e21bba6b30e667b54f6ad7b728', '8927bc71680f4a9f25af6f2c0c4e1956e0e703124ac725d842c64bba5e92a6e5', '48d0b1d45f8e228d41f01f71e56618d0f2ce8263bbd9b59352760640eb2df66c', '8f41920019edb0924b861daa6feaf2922d0ce0a9c45b777ba88f6e026cb9a6ea', '7a4dad8678a23b608ce8acacd9a2f4c24929bc68037fb2991a43cc022e977b60', '684daad794ebc87661f8250eb42621db03f6b3f31185e0f760ee3db73286e6c9', '69080677f9b643e100e62a2edf12e2dbd529b047d584ff922e5458381761a05d', 'ccc4c5111cc02d243b67fc20fd93026d88add65c6fd2055602152227903c703c', '242fc7936d4480e5fba4b9515aca0b97de121a9effcc1be26d4e455c7adef9f1', '833db41cd8b9c20470bc3b5e70249d243aacfcf6b69593ac460a0029467689b9', '5fd098cace35e4c0d08f10059d520bae1b2b074ac1059d2980a1be82a8f77f31', 'e445ff4d77e50cd5d04d2dd3c482677c5531c2198494768dacb624d4f7f7bfc5', 'c4e521e8f00cc3979bdd0e0c99970374fa1f92ff742a3e9fdf52c1e4bbcfd78d', 'a1d6296a9801ee538e0d27feb10f8be41b00b0fccc6c83fcb49e98f23c42dcd3', 'aa368285e0e05d9bc3f957b89b95260349684cc872b167f36a61982bf63c2201', 'f4fa04c284d1f3eb907f9e7f8adf6e1e832a21ed763d6d23857e45926f9ce10a', 'fb9e869cf8465c71c8f4a1756a6dbd8dcd1eca4246d8645b037ad0cc65e800f0', 'e059ad921e8a07dacd01727774bd17821768e61d3f7062f77131f517a9197e50', '8736be2b2a646ce5a471e16baf9d11aadd818a71dfe790395b0b2809e115c1e6', '4fe6b558e435fdad3843b2db5d14915501c147148dbeb4985e3e596feda17d99', 'e8318e5e612c6d48b4711e5414abc396ab3d7633a2529eaabe3a82d7c851ccb4', '804b049e776174f3eded63d18185d769841f7abc5b0751109a5942862c939fdf', '3d263a914bb8e82f1566490d2e8d20ab66542f223089cc4cce9b034930e775f1', '1daf03c9dabfd10483a637b59f18d44b8e5fc8a4b2d44e72ffa610824f71879b', '3bd025508217aeba5c4a616ea6c30969f252f58231087ce11714db7110b2005c', '1a66088cb7d460aeb56c00dd069156adc5cef549648e5481ee5c5e589879b731', '4ff1cc8b15a09062bed7a53124c3af351ceda82d439aa3606fe3ca277a20bc2a', 'ca2095f1eced85cb8e07f785b4e1b8c3f7d9e8ee60f87458c40bdfe731d09c30', 'd7f31a681b35a7012ced38f106f3b478e9a31f8d58fbf244c721ca1ba89cb394', '4bd47e0c626359950fc09888e1a505dfe7286800d0ec0a21b49c66d8de32c901', '1a66088cb7d460aeb56c00dd069156adc5cef549648e5481ee5c5e589879b731', '3bd025508217aeba5c4a616ea6c30969f252f58231087ce11714db7110b2005c', '19ebfbba4c51e79099c031e91a36621312a50c46d0f87d83183a71a0834afe3f', 'e8ebe53a94ee73fa803f0f144c8ac31d5075de45e2f798b383a6d88164d6113a', '944569d8a887d238cf2d7c104ea3fe558bdea38e961b73a0378bfd7969e13157', 'a08897fe730d7de1f2d5376e1d6e9e500c6e20dce4bd9225c5694667464bf8eb', '472a92ca21fe52d676dca31266943a87745bec8b04450b83e5ea29559253e902', '3c86ca512b36c13218249dede37b9ed2813b368115926931c08df7dfb049822b', 'b49c0fce3665545d887872e927e76d7df0927e4baec27c7106181651611424ab', '8881027cfa2be033b7a9724b5547b710f5ba8aef1becb3ed53d34d614a54e3bc', 'bb5ee6ed47f61fc2cc33c29540f1e778a9c9583083e2441c9b23439c5e46820f', 'cbd9c2e1782d72fae42254f615caba2cc28de5f222ba142ff2020c5499990cc4', '52b39e96c6672ecc70554cea0a10c57ad4636526a8f51477d2108bdda78d30e8', 'c2c4cb3164f6576cf559ab0e7180ad3d1f5ba27156727085ddf3ec36b4fccf33', 'af940582b1416ab699abc542994f2f8da43c0af0c5518e57c2087eb33dc0503d', 'd7eace81b9bb79318113d2f30f9d18d90d78f0dffaee7f3bacbcc343ee0101cd', 'aaf156826bb506f93fc4aaee3bed00172819f02a06ecd5a446afce5321f93ba3', 'ca2e3b7dde57407212bc4017621f6433908dc2f8b725d365fc7109c7b8067097', 'd6fdbf77be6e2979543798f41b6cf36fca557c17d0a9d367cc52701770eb2d46', '1af6c454434e19d802f83f600982e083de6b4f925c90938783c55236174640b2', '66a5abcb3210724cc93b9e4eb537ef9f28e987f2915f00620eb887a419521125', '91df6caa3a703fbaebaf35a3ed61d7b80eae59e0daf3f4443c41e2ed69d8cadf', 'cf62992c60c36cd327652e93bfb0fb7fa14d1f80195616907128ca7fd2b8b24c', '1cf9269f1c03276f21bd0f939ee83f9319df7516f9efb06cdbc8ad4f2e985d15', '39e051909a54e187a21500c3ab48966058414320a881dbb90517ef770e18b553', '696d6bab49f36a42c10486bb4db41f6c7ab89e1f615c221a3c8115b9813246d6', 'ce01648dfa0c14f86836404e745a9d071c992675d8899b837233a1ccf6e8d9d1', '6e60a751d87946c28cbbd6d19115a036edc083b61d981efe513327bbe4e035cf', 'c73a7a623ffe18351b51942f10371950a5afc5b967ad8e831fc1b4339078b004', '2ababd951785b88b19c609338df9bf5f3b25f33d85196410533dc02f6e3d2e60', '4edfa2ade6895b198d53dfe5070148c920cc55e810ab4b7c109192d045289669', 'be8e83fa02962e432fea91f9d49fade6a781c8e85d277ac4f90ab73d7ec1c75e', '297256d3db749c28489984d33e3a44118068c71dee801f6c8f7e61dec30e7103', '7df23870105909c9c390e97527ea9a37f5fc4dab7a2d11b5bce48ac97e81fcb5', '5fcef9d6d418f7a47bbbff082d97b4cf789403df2a0eb75f1ae18b873362f8fb', 'b3ca2274cc0a5bd844df396ee075344a210fa95b50738d6f8938a76b865fe874', 'fd2606fc511fa58038c9e9511f3db2d0163ee4615b1c58af53ad1c419b85a7b7', '75386c3230b6eab0dd67207ade52679d6fb3c8f9003bca870e0bde8980971146', '35c7d91dfcecac4ea844a26f4650e0c7455722359d2299f265ab609da6a7e885', '7d67395f69c72c319b991b8c0a8c550cdc7124aa73b86edb5dc78125c8cb2b06', '45c7b3879a07324548d034d5698166f8e0fcfcfdf596c18640fe3f7636913bdb', 'a069791dbb92acabe3ade5dcc6f88f4310abcd6e77927764c71db4c850190542', '60c8f1368add0de87f0849d0e93a92d707fecd6f476a850f242dd2c283e05fcc', '8d32423d43a5a22332c312975ed03e1e8131dc35c846a16a7cfc3abc255b8eb5', '9717ce2d17c080a6bbc635ec15295d0b6567442f8f6e247e56d61a35fed8f574', '618d565513599b0cfcee5ab01f6ef86aabaf11615eafd56f66eaba29df6073ca', 'e53cde1fccab2a904f542a9cad704843a71964be0223113d8c229a706b1d3120', 'ced6089c414f9deceb70228e42ad0281ec8b13ef4f3a8b3952b6417f9f69346e', 'b1cb1f5a8b04e3cd5d4e736ed3c703dac8db6376bfa74f4ca5ed0264ffcb6992', '326b5964ab27e31c3952520bae0e06c66daf576e3a70faca2a891228831cc3ee', '40a0b058213a2e3540c9fc3a5dcbd1eb5bd876c9748f81bb12dc89a944e45a29', '12bc66fa8c86611d2785bec80faad4b880cd48bc4ff30f337022d9e8675e30c4', '3a7ef749c28ab552daa4fb7e54c3980e86aefa92506caded4feedb4bb70a03c9', '4ed789a4d9adc6777c585653267b1d22292d992adfb5224faa1115a1c2b3734c', 'dc0de14bc6290725ef57d2a54a4044dbb83b425af4a94d609ed7ef516d4d03b1', 'bc83071647ec91f147f83635bcf99faf8f3431b0af41094ad9a574f117618adc', 'adce7a0971cd0a515e31e761f4f76113347548d792e0d14cedd683c9221a006a', '8fbc8775ab4a90aabc860679fa9ec02be810d1076b607f0f0573baa37ca759fe', 'ad24ecdfbacb2e8f49425aec400f028e3cc26fb2f0bb7e1dda3ca9ccd98b2c65', '01864c0c6901c8e0214987703d75b6f7248bde19964d1c3460dcb8b447296c52', '91bcfb9559bb4ea9890c403cc8d0420b4312b4f1f233838636b1f1cf0d03cca1', '74ea7961e345714f014bea53111b23952f5309f318af4c373388308971c481ab', '1a0df705f0bdf61d9474d949395fbed08f9ffa73668b1201ff6eb4be6ecc94a8', 'd65d0447197ac25105c8b6fed1675be1940e595eed94aa552140d0027c3a14ae', '52d1fcdb4899521daf0b36fd46e0daf8a0e3d1fcd80246f8ac6bd9b92e1bf814', 'fc26e159b9ba609a0c3abb098f800ddfdc124f0150f6bcd6ef28a73edcfc46b1', 'fa04269ada73e905ae9b70e0b348c04e980ce0c9a5f92813642691c90fff9b4c', '6f67910e966aed715c97a3f34123895e5f12cc3eac821b35519f14410ed84217', '2e3f3493cacf15681f4587b2ddccf16bf24c93025cb62b5c9c7c725303c18e42', 'ff5aaeb07738cecc1ec9c5959254005fa20ca2fd331dd2f15dc80ad6dd8810d2', 'de1e6715cd6c6ab48a4fed996c168d40cbaa8a47356deb9729ae3df1430e6ccd', 'b005828433393021f9db66d6e8ad6928f0a9d5c3dc2cf4dbfa0e264b6d4f9e3f', '8e67b23999d09515a11fcb142bd1c843580eba1e07df1a89e97bfc61db430739', '9a69f53c94388a60f1b16f7d2861bd554fcd7f6aceef6b1c1e3f48ca9030fbff', '65ead8101d45973f10664e840193ae01ff8179a81e0a143e6a4cb90a4f0a78f8', 'ffa35cc1ab3169651692b80f3c91a16ff5136d7c15fba57f43101fc31b9c45f7', 'c3f038db69e3d5f661f109b711ad04e7f596b68b2d555a081ea422a18109016b', '2a07e0970916588dc3d1cf8274c0e54672232a55cc01437deea383fbc9fd8903', '6ef42127f51e88ba7505c920e77897d5b983bc86955439492094f1966bb17dd0', 'd22a5dfe87c858a69e1470dcc8d2fb14dc7b1c30002ca6c2ab85ee8d11f26c01', '088131dc57db44873dca6ecc79ac8fbef7d37dccb1618ce9373526512956dde6', '4ef88767cc4a4234fd487165ca4d733eac96f5d0f69d0da3668509ad8322a6e7', '0b9171dd1de9b00df7c5ca401acf9d715cc5a1c4a77082996beb166e661197a8', 'dab64e620f07903bd218338db299f48cd21a578e18b54d21d75d9f887d4cdee5', '0f357a93a11c2921ac7d078ba2fc01ed6142141ad27170a70d6ca1e7bcd216da', '935d138f548875f2700aad732286be9f9b7a27950e49b8a9d9a26d4a04984849', '97049b7cc03e75ca4d88e5fc499d028e0efd36426f983e7cc62e79ac25bacd74', '29ce849f696e358d3d191165dd0b5a0fe877551d8076a13545bb42e4c1f2628a', 'd612e39e947aaa4ead5ba2b9f117f9f0f66eaa7b6f8e9ce3fad27840d048c4bb', '2f9e1b6669b51121d81ee2f8e7ff070d55501e478b27d9bcd5b517037dbb907a', '09fb6c5cf76713fc1aa2cba8cff23a15706ebc69a0ace264ab97b1d27f87b25b', 'dfe8efc67c47bc2a09806ef1a7b795223b7d200fce0a41173382c8d5d15f4e1d', '25c9af80002c3cafcf9a71a115d5cf1fb52ee5e2bbb92e7fe5af2ac498bdade1', 'dfe8efc67c47bc2a09806ef1a7b795223b7d200fce0a41173382c8d5d15f4e1d', 'd3f431413d390d24af4f8bfa5f72768f4e1dfd2d84ae1235a27961405c6b8660', 'd3f431413d390d24af4f8bfa5f72768f4e1dfd2d84ae1235a27961405c6b8660', '4bbbbc9591fe8270da47b29df25e14322e6560ac547382ae2a42ee35ecaa44bf', 'd56c5203a816443e1823372533b711434c45e25a09e5cedad076c9d8038065e9', '44c9d492e1374aafb3f6d71f8f408eb74394550ad8e4665c0169bb7dd930ffea', '11610aae481891ec2a0fc552d7f3c569d6ebcd8150c322c1d58b94f3a0f1c3df', '3dac2a5afb3d345b6276c42ed4a69aee7b9600e0562ad6d3a9828fcbdba78267', '67c759d4395f8b91e82a43a13be121e6924def3f3ce88c6a62bd45ec04e2a0a8', 'd6a7a8d9fe420579dd5351ac769cbd5c1d2454ef8f1b142a71cef10ecc70ec56', '7f34eecdda77971fc96007d90eebd2f7addc85c214e0442f40990a28b840a032', '153b939a629f12f0802d21bc0b335bb49daef00c6b9c4535c6144883a02a05a3', '2f61964ca74a3b0f3c845426395a2d4cefa51ff5b0716bf1d9933274c40cefe9', '83cb85c0863bc46fbac3879b4c67a60629008c02eaa88ddd1d51cf8d6013eadc', '1e7c81072f87b7d817c8583a78a4d4056178b21f9ecf3d237b19bcc8cee1d391', '736af4be184ea560f3010dd6bd796846e773e223f14ba13c1b9cec272788126a', '0addef1e4c530c74fbaa56d65b00e9a0929bf64375fa6bf848d8afc8e1da3c3d', '77bfab96a52e4fbf3b9afac9447ca6be2c64564f2c58fc560f7104611e646128', 'af32a73e481f2825f2dd83e5aa06fea0ee2d064a997a203af95d5e33ccf91ad5', '37974afcd645a15237810a6785d78cfb51d791d6cd074b96770781248675a838', 'e0374bccc25125fb6b18555d7ec9761df443bd5801185359534ecdbae8c34a05', 'e26c3a19188fc8e9fee4962df6d30cf57d238463e79e92c7c65e77dcbd317d8f', '17a4fafbf186721a4088d5f3d4373c74bd00af9a86e09bf5f056ba72c36748a4', '41a0d9e099ee0c58affff9765cb0536174b98eda38bf403eaeb4d7f014180a48', 'b032980d1dfdf8f6692c1eac85f7d24134c075e6071e1cc1453a340ce04c94c2', 'a2fa19621c26c64773920e21c5ddd2758bdd992759a5124e1b4ae761d31d81b6', '2a97222ee8383b85a17cdf9e868d1a04eedc5a7bd2b9813f1333fda730fd8149', '7e278244c39cea3270f540d7add70595cb73204951030e9a6062ab9f3528a20a', 'f7be68d1757c477d837c754a5aebb96d44e7668d74204a6e471101acc2e3c331', '0de6045abf24a55ffbe03db5517e1b619239e76d9308681899e6c115f10936bb', 'dfb894c450cef578aa27499be753b8945b759a6006f498e8a808da9362e60420', '99727700bf127721388f7ebbe23188da7e87beaee64f775b0d6dff3e6ee9f499', '09bbfdb57c117eb7b11b386d388923f8e6caf2a3c6b29fff81041c5ce427f6f3', '3d3a1c0602c0e00c01efd86425ae6cdf9abc81fff15679bdcdaccea56cf992ac', '4bf67246834d6fa98ec500cb519f39afd2159b4f932f7438c3f8afca62781215', '8d2c3da3e0514f5f4dc88c4157bd320f89101c392be1a323b6eb42e94a47c415', 'fcf5d4d250a4967064b3c571f7e63decf50802e2ca6ac841cefe66aee6b6f1a9', 'fc44a49a0431b10c27c130da37ee6dcd1b0dc695d0b65ca6f57b89ca32030d69', 'ac58809688940109655913fea3cd3f4c37dc3192124d4b3bd6597cff4a9a6fc4', '034243891e1c94fdf12a7008ed3db1e162c39a6b722e2226615e9d28ab233a38', 'acc6c6cd91d8cc9b37bcccd7385d98a95708b79ebd3a048b84499e33a988329c', '90fb75c59748fd82c8052bb7ead9623d5a8cd1f8d0d75b743678b750a61d5647', '071c3b31cca18e2c879dff4a8202cd2fdcb25045b64b6f1a035c5a712ba6f4e7', '327e9f1a1b1d630314b5fe11e3cd5b2b2288e1044d3b98cc553523cdb765c5c8', '6fe963af6a8576cc6190979a7fa46f71100d7468f01ae6fd3a1f60d293d95fec', 'd6adfc9ada50609dbfd6f598a9402a235f270aeb895cbd3433bfa1611301313a', '0dd9f649e2f2afa45cd17181f55a01c76cb3f631770ea75952c4ad48fbd57d72', '89622477e7d7cf0ff4ad038876b2231878a4f21976f6949af7b6876e0a0ccaf0', 'ddee132dd2a5b78962d0e6195a4990646e8d4567df5df058eb8280c2854b1b8d', 'd030c924c80a977415ba752a59eb8c359fc255608a72d137e5a3995e4f3dd09a', '55e93a772bb8fd4851dfb79014d40f11d9dd714eff39acef6045776d6ee7abb7', '79f0fe9adab2a9c45054ca0665649f702284d435fcecf6963f426494c4685177', '9350f517362ea8d2e2a14ad23e77820b7f811a57b740ac145aa9607aebfbbcc1', 'f20bd6e5f63e3751b65cc0f69f800d1386b71f7bcf831df63a3e0a1980940f3a', 'e58d90563ede6de8f27a04736ae935f918c840b8c4d3ba2e9fd37197bd6dd776', 'a26368de811b9f9b4982bf58d3dcf926929b1768c9140cf52e6628f75699c92c', '70b58e0eedf00c7424eee4693ed777f70cce8d9db6a3d41e7e7f911e1f3b7f94', 'eb5768d60f8b0323f07f7e89c0879617fedc960c37c85cf7c25c50e0165f0597', 'a90e6b3648ef7e2cd8951ee712a1b186c1092a11a149a1ddd96b97e01ce7d4f0', 'd2641c4410d3add40bf7a4dbdbc80c3f056c2a5b15fff09282eb06022c951ed7', '8732005fd6e34080693fa81e4227187c05e70cefa43726fe459ae1b80a041437', '124e5d8278708bd1a32a51c452508e15dfd06e7191c3994933cadb8f072fec4f', '27f82563dc1dfcf0172267da16a4adae713cd2980e02577450530f36fd9aceba', 'e5dd6efb0064688f3857440b97e231045c4a1b3f708a00cd18ee721b4ac71db0', '1aa08a948bc8b6bd3285973f97a14e4ad4a04b8c1cd696dbc4654f2689b3b4a4', '20acd54cc349c30313c76e850d2d9a381540514d6330722fbb4d17c1d94fffcc', 'd934c22a6d997a8a1ecbc6c085587a52ec21a29d56803eb6e40d0c5f7bf79761', '02ab03784d559a467cb4b720a8ce8f203f6968c2ecff93a79114fa13f7f8a3b6', '01fc012c78c3f28beaa494e3b3cc45aaeea52923e24c1ea0bf5aaf6715fbddb8', 'e737cc7650ebe1801bbd87523a015431a9a2b44d090af8d84ff780e2fc0a7570', 'd8ee63e1d52dc44c682966ff8fc53b0d00646400a92df4adf02cfa0418c2823e', 'b6dfc2022e2a716dcf0e5c8057126c03fa75844e893bcd9461d2c24172ca0e0f', '231cc8f40e3456165c8667715a40b9538bfb73d48668aca51db481b0b485bccd', 'f289532af57cb7e80c0f670205b64d27d2b9c6cdb6f78df475b585cbbc2d1a69', '0a766fd0048fd37119a4bdad28dc2c952369a3e8fcc04892dd39adbd3700f818', 'd1cd8572518e8bbd33be0c841ced2e9bbe9d67471f27e4b9374c26b8e62473d9', '5fcef9d6d418f7a47bbbff082d97b4cf789403df2a0eb75f1ae18b873362f8fb', '42362a794b85db5592eaab0e21c9b6894a932653d59a97f3e081a7f9760ece61', '70631829bbf1208cb277a988224efeedff692a6a44bb0d33b99a5750652cc2e3', '269c8261cc14dd76365a9ed49f71332c0ce95198a51746c4343e6a8c99842bc7', '7219f03e489efd3648c5182bc96a3f7bd9d39c1d656d25ae57314ab281eadb79', '09fb6c5cf76713fc1aa2cba8cff23a15706ebc69a0ace264ab97b1d27f87b25b', '2f9e1b6669b51121d81ee2f8e7ff070d55501e478b27d9bcd5b517037dbb907a', '3879367de390469ac48196f22e461e58e03545f79e4ec5f6c4f935db5f26c7a8', '4e65324ae5d788ba5e8982eb9af30ef9db63d454576aee979b183bdbf822bd10', '18f46b4609876d1d108434c8207317f0f11a602aba8f899e3371f91887442bd9', '23fd40eaa32f83a635fdba9ee1dbcb2308a3f6f651428c339dbe083bc10b1379', '4785d461d01c6c9ad6fb294478df3ff76f677bb239b1434eea096f18e82508e1', 'f402bac0eae54e6d72b832962e2224eeddd330ae8df85bc1e02c4e47c831fd9a', 'd2da86368f860bd524a9bc9a6a3fc68fd822e18d921e20a68843e41946aaea20', '07377d1ffb0e5f4582c311e11e5d5598ffd9d4b40d6b431a783d89d34e9597ff', 'a06e59909846a40b8ff6936ccb25279ae7152f0d1213cbcc52bc702601b1af1b', '3632eb0ec85c5d95efeafca8a6237cb594d83f98779bdd763edf2e79b4e9e19a', '387eb7e0dad26484d9f00d39e40658e4271d1c82b9f0c0365a211a12a536353a', '090ce294c0ba760c0338591af254b03ed4310defe2fa6c4ff8096de17d3ee856', 'e0b84355712e3f0c4cc076a40e96c5991667ee17b746db73f52e67f5b1d59b1c', '5444a9606d8aacf4b8f4779a00df1fb9f28b6d275f519011b6c511ff2419b745', 'f59ea6fd64694fdb9d7e94577a33a95725967b72bc01069a285e52caf78704ab']
    const vintxdatas = await MalinElectrum.multiGetTransactionByTxid(
      vinTxids,
      true
    );
    assert.ok(
      vintxdatas[
        '8881027cfa2be033b7a9724b5547b710f5ba8aef1becb3ed53d34d614a54e3bc'
      ]
    );
  })

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('multiGetTransactionByTxid() can work with huge tx', async () => {
    // electrum cant return verbose output because of "response too large (over 1,000,000 bytes"
    // for example:
    // echo '[{"jsonrpc":"2.0","method":"blockchain.transaction.get","params":["484a11c5e086a281413b9192b4f60c06abf745f08c2c28c4b4daefe6df3b9e5c", true],"id":1}]' | nc bitkoins.nl  50001 -i 1
    // @see https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-transaction-get
    //
    // possible solution: fetch it without verbose and decode locally. unfortunatelly it omits such info as confirmations, time etc
    // so whoever uses it should be prepared for this.
    // tbh consumer wallets dont usually work with such big txs, so probably we dont need it
    const txdatas = await MalinElectrum.multiGetTransactionByTxid(
      ['484a11c5e086a281413b9192b4f60c06abf745f08c2c28c4b4daefe6df3b9e5c'],
      true,
    )
    assert.ok(
      txdatas[
        '484a11c5e086a281413b9192b4f60c06abf745f08c2c28c4b4daefe6df3b9e5c'
      ]
    );
  })

  it.each([false, true])(
    'ElectrumClient can do multiGetHistoryByAddress() to obtain txhex, disableBatching=%p',
    async (disableBatching) => {
      if (disableBatching) MalinElectrum.setBatchingDisabled();
      const txdatas = await MalinElectrum.multiGetTransactionByTxid(
        ['881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e'],
        false,
        3,
      )

      assert.strictEqual(
        txdatas[
          '881c54edd95cbdd1583d6b9148eb35128a47b64a2e67a5368a649d6be960f08e'
        ],
        '02000000000102f1155666b534f7cb476a0523a45dc8731d38d56b5b08e877c968812423fbd7f3010000000000000000d8a2882a692ee759b43e6af48ac152dd3410cc4b7d25031e83b3396c16ffbc8900000000000000000002400d03000000000017a914e286d58e53f9247a4710e51232cce0686f16873c870695010000000000160014d3e2ecbf4d91321794e0297e0284c47527cf878b02483045022100d18dc865fb4d087004d021d480b983b8afb177a1934ce4cd11cf97b03e17944f02206d7310687a84aab5d4696d535bca69c2db4449b48feb55fff028aa004f2d1744012103af4b208608c75f38e78f6e5abfbcad9c360fb60d3e035193b2cd0cdc8fc0155c0247304402207556e859845df41d897fe442f59b6106c8fa39c74ba5b7b8e3268ab0aebf186f0220048a9f3742339c44a1e5c78b491822b96070bcfda3f64db9dc6434f8e8068475012102456e5223ed3884dc6b0e152067fd836e3eb1485422eda45558bf83f59c6ad09f00000000',
      );
      if (disableBatching) MalinElectrum.setBatchingEnabled()
    }
  )
});


================================================
FILE: ./tests/integration/hd-segwit-p2sh-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { HDSegwitP2SHWallet } from '../../class';

jest.setTimeout(300 * 1000);

afterAll(() => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  try {
    await MalinElectrum.connectMain();
  } catch (Err) {
    console.log('failed to connect to Electrum:', Err);
    process.exit(2);
  }
});

it('HD (BIP49) can work with a gap', async function () {
  const hd = new HDSegwitP2SHWallet();
  hd._xpub = 'ypub6XRzrn3HB1tjhhvrHbk1vnXCecZEdXohGzCk3GXwwbDoJ3VBzZ34jNGWbC6WrS7idXrYjjXEzcPDX5VqnHEnuNf5VAXgLfSaytMkJ2rwVqy'; // has gap
  await hd.fetchBalance();

  // for (let c = 0; c < 5; c++) {
  //   console.log('internal', c, hd._getInternalAddressByIndex(c));
  // }

  // for (let c = 0; c < 5; c++) {
  //   console.log('external', c, hd._getExternalAddressByIndex(c));
  // }
  await hd.fetchTransactions();
  assert.ok(hd.getTransactions().length >= 3);
});

it('Segwit HD (BIP49) can fetch more data if pointers to last_used_addr are lagging behind', async function () {
  const hd = new HDSegwitP2SHWallet();
  hd._xpub = 'ypub6WZ2c7YJ1SQ1rBYftwMqwV9bBmybXzETFxWmkzMz25bCf6FkDdXjNgR7zRW8JGSnoddNdUH7ZQS7JeQAddxdGpwgPskcsXFcvSn1JdGVcPQ';
  hd.next_free_change_address_index = 40;
  hd.next_free_address_index = 50;
  await hd.fetchBalance();
  await hd.fetchTransactions();
  assert.strictEqual(hd.getTransactions().length, 153);
});

it('HD (BIP49) can create TX', async () => {
  if (!process.env.HD_MNEMONIC_BIP49) {
    console.error('process.env.HD_MNEMONIC_BIP49 not set, skipped');
    return;
  }
  const hd = new HDSegwitP2SHWallet();
  hd.setSecret(process.env.HD_MNEMONIC_BIP49);
  assert.ok(hd.validateMnemonic());

  await hd.fetchBalance();
  await hd.fetchUtxo();
  assert.ok(typeof hd._utxo[0].confirmations === 'number');
  assert.ok(hd._utxo[0].txid);
  assert.ok(hd._utxo[0].vout !== undefined);
  assert.ok(hd._utxo[0].value);
  assert.ok(hd._utxo[0].address);
  assert.ok(hd._utxo[0].wif);

  let txNew = hd.createTransaction(
    hd.getUtxo(),
    [{ address: '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', value: 500 }],
    1,
    hd._getInternalAddressByIndex(hd.next_free_change_address_index),
  );
  let tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
  assert.strictEqual(
    txNew.tx.toHex(),
    '0200000000010187c9acd9d5714845343b18abaa26cb83299be2487c22da9c0e270f241b4d9cfe0000000017160014a239b6a0cbc7aadc2e77643de36306a6167fad150000008002f40100000000000017a914a3a65daca3064280ae072b9d6773c027b30abace87f36200000000000017a9140acff2c37ed45110baece4bb9d4dcc0c6309dbbd8702483045022100fdddfc8f2f85181b0eb95d9f2ebd506b611318b85419889f9b7e4648cb9912e002206c963079673dfcfeea53120592d995dfab5f0e12f4c0054cace0cda90c481d2001210202ac3bd159e54dc31e65842ad5f9a10b4eb024e83864a319b27de65ee08b2a3900000000',
  );
  assert.strictEqual(tx.ins.length, 1);
  assert.strictEqual(tx.outs.length, 2);
  assert.strictEqual(tx.outs[0].value, 500n);
  assert.strictEqual(tx.outs[1].value, 25331n);
  let toAddress = bitcoin.address.fromOutputScript(tx.outs[0].script);
  const changeAddress = bitcoin.address.fromOutputScript(tx.outs[1].script);
  assert.strictEqual('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', toAddress);
  assert.strictEqual(hd._getInternalAddressByIndex(hd.next_free_change_address_index), changeAddress);

  //

  txNew = hd.createTransaction(
    hd.getUtxo(),
    [{ address: '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', value: 25000 }],
    5,
    hd._getInternalAddressByIndex(hd.next_free_change_address_index),
  );
  const satPerVbyte = txNew.fee / tx.virtualSize();

  assert.strictEqual(Math.round(satPerVbyte), 6); // so_close.jpg
  tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
  assert.strictEqual(tx.ins.length, 1);
  assert.strictEqual(tx.outs.length, 1);
  toAddress = bitcoin.address.fromOutputScript(tx.outs[0].script);
  assert.strictEqual('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', toAddress);

  // testing sendMAX
  const utxo = [
    {
      height: 591862,
      value: 26000,
      address: '3C5iv2Hp6nfuhkfTZibb7GJPkXj367eurD',
      vout: 0,
      txid: '2000000000000000000000000000000000000000000000000000000000000000',
      amount: 26000,
      wif: 'L3fg5Jb6tJDVMvoG2boP4u3CxjX1Er3e7Z4zDALQdGgVLLE8zVUr',
      confirmations: 1,
    },
    {
      height: 591862,
      value: 26000,
      address: '3C5iv2Hp6nfuhkfTZibb7GJPkXj367eurD',
      vout: 0,
      txid: '1000000000000000000000000000000000000000000000000000000000000000',
      amount: 26000,
      wif: 'L3fg5Jb6tJDVMvoG2boP4u3CxjX1Er3e7Z4zDALQdGgVLLE8zVUr',
      confirmations: 1,
    },
    {
      height: 591862,
      value: 26000,
      address: '3C5iv2Hp6nfuhkfTZibb7GJPkXj367eurD',
      vout: 0,
      txid: '0000000000000000000000000000000000000000000000000000000000000000',
      amount: 26000,
      wif: 'L3fg5Jb6tJDVMvoG2boP4u3CxjX1Er3e7Z4zDALQdGgVLLE8zVUr',
      confirmations: 1,
    },
  ];

  // one MAX output
  txNew = hd.createTransaction(
    utxo,
    [{ address: '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK' }],
    1,
    hd._getInternalAddressByIndex(hd.next_free_change_address_index),
  );
  tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
  assert.strictEqual(tx.outs.length, 1);
  assert.ok(tx.outs[0].value > 77000);

  // MAX with regular output
  txNew = hd.createTransaction(
    utxo,
    [{ address: '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK' }, { address: 'bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p', value: 25000 }],
    1,
    hd._getInternalAddressByIndex(hd.next_free_change_address_index),
  );
  tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
  assert.strictEqual(tx.outs.length, 2);
  assert.ok(Number(tx.outs[0].value) > 50000);
  assert.strictEqual(tx.outs[1].value, 25000n);
});

// skpped because its slow
// unskip and test manually
// eslint-disable-next-line jest/no-disabled-tests
it.skip('Segwit HD (BIP49) can fetch balance with many used addresses in hierarchy', async function () {
  if (!process.env.HD_MNEMONIC_BIP49_MANY_TX) {
    console.error('process.env.HD_MNEMONIC_BIP49_MANY_TX not set, skipped');
    return;
  }

  const hd = new HDSegwitP2SHWallet();
  hd.setSecret(process.env.HD_MNEMONIC_BIP49_MANY_TX);
  assert.ok(hd.validateMnemonic());
  const start = +new Date();
  await hd.fetchBalance();
  const end = +new Date();
  const took = (end - start) / 1000;
  took > 15 && console.warn('took', took, "sec to fetch huge HD wallet's balance");
  assert.strictEqual(hd.getBalance(), 51432);

  await hd.fetchUtxo();
  assert.ok(hd._utxo.length > 0);
  assert.ok(hd._utxo[0].txid);
  assert.ok(hd._utxo[0].vout === 0);
  assert.ok(hd._utxo[0].value);

  await hd.fetchTransactions();
  assert.strictEqual(hd.getTransactions().length, 107);
});


================================================
FILE: ./tests/integration/ElectrumClient.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';
import ElectrumClient from 'electrum-client';
import { sha256 as _sha256 } from '@noble/hashes/sha256';

const net = require('net');
const tls = require('tls');

jest.setTimeout(150 * 1000);

const hardcodedPeers = [
  { host: 'electrum1.malinwallet.io', ssl: '443' },
  { host: 'electrum2.malinwallet.io', ssl: '443' },
  { host: 'electrum3.malinwallet.io', ssl: '443' },
  { host: 'electrum1.malinwallet.io', tcp: '50001' },
  { host: 'electrum2.malinwallet.io', tcp: '50001' },
  { host: 'electrum3.malinwallet.io', tcp: '50001' },
]

function bitcoinjs_crypto_sha256(buffer /*: Buffer */) /*: Buffer */ {
  return Buffer.from(_sha256(Uint8Array.from(buffer)));
}

describe('ElectrumClient', () => {
  it('can connect and query', async () => {
    for (const peer of hardcodedPeers) {
      const mainClient = new ElectrumClient(
        net,
        tls,
        peer.ssl || peer.tcp,
        peer.host,
        peer.ssl ? 'tls' : 'tcp',
      )

      try {
        await mainClient.connect();
        await mainClient.server_version('2.7.11', '1.4');
      } catch (e) {
        mainClient.reconnect = mainClient.keepAlive = () => {}; // dirty hack to make it stop reconnecting
        mainClient.close();
        throw new Error(
          'bad connection: ' + JSON.stringify(peer) + ' ' + e.message
        );
      }

      let addr4elect =
        'bc1qwqdg6squsna38e46795at95yu9atm8azzmyvckulcc7kytlcckxswvvzej';
      let script = bitcoin.address.toOutputScript(addr4elect);
      let hash = bitcoinjs_crypto_sha256(script);
      let reversedHash = Buffer.from(hash.reverse());
      const start = +new Date();
      let balance = await mainClient.blockchainScripthash_getBalance(
        reversedHash.toString('hex'),
      )
      const end = +new Date();
      end - start > 1000 &&
        console.warn(
          peer.host,
          'took',
          (end - start) / 1000,
          'seconds to fetch balance',
        )
      assert.ok(balance.confirmed > 0);

      addr4elect = '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK';
      script = bitcoin.address.toOutputScript(addr4elect);
      hash = bitcoinjs_crypto_sha256(script);
      reversedHash = Buffer.from(hash.reverse());
      balance = await mainClient.blockchainScripthash_getBalance(
        reversedHash.toString('hex'),
      )

      // let peers = await mainClient.serverPeers_subscribe();
      // console.log(peers);
      mainClient.close();
    }
  });
})


================================================
FILE: ./tests/integration/lightning-ark-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import { HDSegwitBech32Wallet } from '../../class';
import { LightningArkWallet } from '../../class/wallets/lightning-ark-wallet.ts';

// Mock AsyncStorage using fs in tests/integration/fixtures/ark/
jest.mock('@react-native-async-storage/async-storage', () => {
  const STORAGE_DIR = path.join(__dirname, 'fixtures', 'ark');

  // Ensure storage directory exists
  if (!fs.existsSync(STORAGE_DIR)) {
    fs.mkdirSync(STORAGE_DIR, { recursive: true });
  }

  const getFilePath = (key: string) => {
    const sanitizedKey = key.replace(/[^a-zA-Z0-9]/g, '_');
    return path.join(STORAGE_DIR, sanitizedKey);
  };

  async function _multiSet(keyValuePairs: [string, string][], callback?: any) {
    keyValuePairs.forEach(keyValue => {
      const key = keyValue[0];
      const value = keyValue[1];
      const filePath = getFilePath(key);
      fs.writeFileSync(filePath, value, 'utf8');
    });
    callback && callback(null);
    return null;
  }

  async function _multiGet(keys: string[], callback?: any) {
    const values = keys.map(key => {
      const filePath = getFilePath(key);
      let value = null;
      try {
        if (fs.existsSync(filePath)) {
          value = fs.readFileSync(filePath, 'utf8');
        }
      } catch (error) {
        // ignore
      }
      return [key, value];
    });
    callback && callback(null, values);
    return values;
  }

  async function _multiRemove(keys: string[], callback?: any) {
    keys.forEach(key => {
      const filePath = getFilePath(key);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    });
    callback && callback(null);
    return null;
  }

  async function _clear(callback?: any) {
    if (fs.existsSync(STORAGE_DIR)) {
      const files = fs.readdirSync(STORAGE_DIR);
      for (const file of files) {
        fs.unlinkSync(path.join(STORAGE_DIR, file));
      }
    }
    callback && callback(null);
    return null;
  }

  async function _getAllKeys() {
    if (!fs.existsSync(STORAGE_DIR)) {
      return [];
    }
    return fs.readdirSync(STORAGE_DIR);
  }

  const asMock: any = {
    setItem: jest.fn(async (key: string, value: string, callback?: any) => {
      const setResult = await asMock.multiSet([[key, value]], undefined);
      callback && callback(setResult);
      return setResult;
    }),

    getItem: jest.fn(async (key: string, callback?: any) => {
      const getResult = await asMock.multiGet([key], undefined);
      const result = getResult[0] ? getResult[0][1] : null;
      callback && callback(null, result);
      return result;
    }),

    removeItem: jest.fn((key: string, callback?: any) => asMock.multiRemove([key], callback)),

    clear: jest.fn(_clear),
    getAllKeys: jest.fn(_getAllKeys),
    flushGetRequests: jest.fn(),

    multiGet: jest.fn(_multiGet),
    multiSet: jest.fn(_multiSet),
    multiRemove: jest.fn(_multiRemove),
  };

  return asMock;
});

jest.setTimeout(30_000);

const w = new LightningArkWallet();

beforeAll(async () => {
  if (!process.env.HD_MNEMONIC) {
    console.error('process.env.HD_MNEMONIC not set, skipped');
    return;
  }
  w.setSecret('arkade://' + process.env.HD_MNEMONIC);
  await w.init();
});

afterAll(async () => {
  await new Promise(resolve => setTimeout(resolve, 3_000)); // sleep
});

describe('LightningArkWallet', () => {
  it('can generate', async () => {
    const wGenerated = new LightningArkWallet();
    await wGenerated.generate();

    assert.ok(wGenerated.getSecret().startsWith('arkade://'));

    const mnemonics = wGenerated.getSecret().replace('arkade://', '');
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(mnemonics);
    assert.ok(hd.validateMnemonic());
  });

  it('can fetch balance', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }

    await w.fetchBalance();
    const balance = w.getBalance();

    assert.ok(balance > 0);
  });

  it('can decode invoice', async () => {
    const invoice =
      'lnbc20n1p59n9nkpp58s49flel3cz5u3lrve8qeqzxljxmu0gja06elfcgwrx2e9nq959ssp5z7ytwq0rm6yq8evn2kteduj6a0rs4svn3sfwvg92a29f8l022jjqxq9z0rgqnp4qvyndeaqzman7h898jxm98dzkm0mlrsx36s93smrur7h0azyyuxc5rzjq25carzepgd4vqsyn44jrk85ezrpju92xyrk9apw4cdjh6yrwt5jgqqqqrt49lmtcqqqqqqqqqqq86qq9qrzjqwghf7zxvfkxq5a6sr65g0gdkv768p83mhsnt0msszapamzx2qvuxqqqqrt49lmtcqqqqqqqqqqq86qq9qcqzpgdq023mk7gryv9uhxgq9qyyssqy4mv8te3l6mrc7qf4pksh4m4z76jz7s2qrwxd7q2s22ghnanqt33e9p0nahz9fr32g00vn2vhc9rrhpvtr54s40tle25tyyvp59sdpsqty30rp';

    const decoded = w.decodeInvoice(invoice);

    assert.strictEqual(decoded.num_satoshis, 2);
    assert.strictEqual(decoded.num_millisatoshis, 2000);
    assert.strictEqual(decoded.timestamp, 1750701686);
    assert.strictEqual(decoded.expiry, 2592000);
    assert.strictEqual(decoded.description, 'Two days ');
    assert.strictEqual(decoded.payment_hash, '3c2a54ff3f8e054e47e3664e0c8046fc8dbe3d12ebf59fa70870ccac96602d0b');
    assert.strictEqual(decoded.destination, '030936e7a016fb3f5ce53c8db29da2b6dfbf8e068ea058c363e0fd77f444270d8a');
    assert.strictEqual(decoded.fallback_addr, '');
    assert.strictEqual(decoded.description_hash, '');
    assert.strictEqual(decoded.cltv_expiry, '40');
    assert.strictEqual(decoded.route_hints.length, 0); // decode function does not decode this yet cause we dont need it for now
  });

  it('can tell if invoice expired', async () => {
    const invoice =
      'lnbc6670n1p5jp0p9pp5jmyumdwfejjxzwhxh7wnckeugcwcpkqtf5t6dh2fzykjjh4hkatqdq6235x2grhdaexggrs09exzmtfvscqz3txqyyzzssp5ae74xvmlk5q6vxsxe3sqm90w2x4x0ekejt7qp9ca5zzhu83ru8hq9qxpqysgql4dexpmwacw98va6v6smww69a3w6hs5ng0573v8skyhlj7lylt8r65jm5zqaa7hzx3vlrs2fr3h0rtqjw7x94xprdwqy6rr9ff5pnxsppnpr5q';
    assert.strictEqual(w.isInvoiceExpired(invoice), true);
    assert.strictEqual(w.isInvoiceExpired(invoice, 1763752997), false);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can create invoice', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }

    const invoice = await w.addInvoice(1000, 'test invoice');
    console.log(invoice);
  });

  it('can fetch txs', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }

    await w.fetchTransactions();
    await w.fetchUserInvoices();

    const txs = w.getTransactions();
    assert.ok(txs.length > 0);

    // Find the reverse swap (incoming) transaction
    const receiveTx = txs.find(t => t.value! > 0);
    assert.ok(receiveTx, 'Should have at least one receive transaction');
    assert.strictEqual(receiveTx.memo, 'test invoice');
    assert.strictEqual(receiveTx.value, 10000);
    assert.strictEqual(receiveTx.timestamp, 1761224952);
    assert.strictEqual(receiveTx.ispaid, true);
    assert.ok(receiveTx.payment_hash);
    assert.ok(receiveTx.payment_request);
    assert.strictEqual(receiveTx.payment_preimage, '7244f7e956a91171038ea935d56cdb758cc36c345f0aa92764bfed6fe6fc9b17');

    // Find the submarine swap (outgoing) transaction
    const sendTx = txs.find(t => t.value! < 0);
    assert.ok(sendTx, 'Should have at least one send transaction');
    assert.strictEqual(sendTx.value, -8001);
    assert.strictEqual(sendTx.timestamp, 1761225645);
    assert.strictEqual(sendTx.ispaid, true);
    assert.ok(sendTx.payment_hash);
    assert.ok(sendTx.payment_request);
    assert.strictEqual(sendTx.payment_preimage, '182fb8f273bda01b22c0e91991e093e18b2970f389fc7f7a2121870324eb2de5');

    const invoices = await w.getUserInvoices();
    assert.ok(invoices.length > 0);
    assert(invoices[0].value! > 0);
    assert(invoices[0].ispaid);

    assert.ok(
      w.isInvoiceGeneratedByWallet(
        'lnbc100u1p50528cpp5rhy4fgs0ff23asecxtxt9zvc3apn0p8h7fxsj0d5k7j3x92zwhlqdq5w3jhxapqd9h8vmmfvdjscqrp80xqyf8ucsp5vcsrzye432n9wh0zwuv5z8y5n9zvkwpctr685e80utzc2yueccms9qxpqysgqd87swq3hput9k6llp0wxg098hc7ge3e5nrtnvak6zreywzaf4k9s8d3u4hrmt3m22kf0jt7ruqj0caknk5ykzdenjdphz50t7xrstnqqn6aw0m',
      ),
    );
    assert.ok(
      !w.isInvoiceGeneratedByWallet(
        'lnbc80u1p5052hwpp5z4ln6hyq4wcck809pt7f0q54ag5he6ce797flm7gl9vuccm9lx2sdqqcqzysxqyz5vqsp5nh9fl4g36606tvxswtnfxzy55yze2656cw2fya7dhl8r6u0czyds9qxpqysgq83sw25g9d9ltr05nkfzejnvvunzkrk4qeuxhszuvvsguk5m6vmg3a7n5nd67l9frru3kjzpt8x6jfusjyc7ezh49jeeh900kt3v30qsqzq7fst',
      ),
    );
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can pay invoice', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }

    await w.payInvoice(
      'lnbc80u1p5052hwpp5z4ln6hyq4wcck809pt7f0q54ag5he6ce797flm7gl9vuccm9lx2sdqqcqzysxqyz5vqsp5nh9fl4g36606tvxswtnfxzy55yze2656cw2fya7dhl8r6u0czyds9qxpqysgq83sw25g9d9ltr05nkfzejnvvunzkrk4qeuxhszuvvsguk5m6vmg3a7n5nd67l9frru3kjzpt8x6jfusjyc7ezh49jeeh900kt3v30qsqzq7fst',
    );
  });
});


================================================
FILE: ./tests/integration/import.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import fs from 'fs';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import {
  HDAezeedWallet,
  HDLegacyBreadwalletWallet,
  HDLegacyElectrumSeedP2PKHWallet,
  HDLegacyP2PKHWallet,
  HDSegwitBech32Wallet,
  HDSegwitElectrumSeedP2WPKHWallet,
  HDSegwitP2SHWallet,
  HDTaprootWallet,
  LegacyWallet,
  LightningArkWallet,
  SegwitBech32Wallet,
  SegwitP2SHWallet,
  SLIP39SegwitBech32Wallet,
  SLIP39SegwitP2SHWallet,
  WatchOnlyWallet,
} from '../../class';
import startImport from '../../class/wallet-import';
import { TWallet } from '../../class/wallets/types';

jest.setTimeout(90 * 1000);

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

type THistoryItem = { action: 'progress'; data: string } | { action: 'wallet'; data: TWallet } | { action: 'password'; data: string };
type TState = { wallets: TWallet[]; progress?: string; password?: string };
type TOnProgress = (name: string) => void;
type TOnWallet = (wallet: TWallet) => void;
type TOnPassword = (title: string, text: string) => Promise<string>;

const createStore = (password?: string) => {
  const state: TState = { wallets: [] };
  const history: THistoryItem[] = [];

  const onProgress: TOnProgress = data => {
    history.push({ action: 'progress', data });
    state.progress = data;
  };

  const onWallet: TOnWallet = data => {
    history.push({ action: 'wallet', data });
    state.wallets.push(data);
  };

  const onPassword: TOnPassword = async () => {
    history.push({ action: 'password', data: password! });
    state.password = password;
    return password!;
  };

  return {
    state,
    history,
    callbacks: [onProgress, onWallet, onPassword],
  } as const;
};

describe('import procedure', () => {
  it('can be cancelled', async () => {
    // returns undefined on first call, throws cancel exception on second
    let flag = false;
    const onPassword = async () => {
      if (flag) throw new Error('Cancel Pressed');
      flag = true;
      return undefined;
    };
    const store = createStore();
    // @ts-ignore: oopsie
    store.callbacks[2] = onPassword;
    const { promise } = startImport('6PnU5voARjBBykwSddwCdcn6Eu9EcsK24Gs5zWxbJbPZYW7eiYQP8XgKbN', false, false, false, ...store.callbacks);
    const imprt = await promise;
    assert.strictEqual(store.state.wallets.length, 0);
    assert.strictEqual(imprt.cancelled, true);
  });

  it('can be stopped', async () => {
    const store = createStore();
    const { promise, stop } = startImport('KztVRmc2EJJBHi599mCdXrxMTsNsGy3NUjc3Fb3FFDSMYyMDRjnv', false, false, false, ...store.callbacks);
    stop();
    await assert.doesNotReject(async () => await promise);
    const imprt = await promise;
    assert.strictEqual(imprt.stopped, true);
  });

  it('can import multiple wallets', async () => {
    const store = createStore();
    const { promise } = startImport(
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
      false,
      true,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets.length > 3, true);
  });

  it('can import multiple wallets in offline mode', async () => {
    const store = createStore();
    const { promise } = startImport(
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
      false,
      true,
      true,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets.length > 120, true);
  });

  it('can import BIP84', async () => {
    const store = createStore();
    const { promise } = startImport(
      'always direct find escape liar turn differ shy tool gap elder galaxy lawn wild movie fog moon spread casual inner box diagram outdoor tell',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDSegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1qth9qxvwvdthqmkl6x586ukkq8zvumd38nxr08l');
  });

  it('can import BIP86', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const store = createStore();
    const { promise } = startImport(process.env.HD_MNEMONIC_BIP84, false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[1].type, HDTaprootWallet.type);
    assert.strictEqual(
      store.state.wallets[1]._getExternalAddressByIndex(0),
      'bc1p84mlccwgz7vz2y7xp0yy98zz5h8myyjd7zdncw6dzw9cm5yglu9qm4qrjg',
    );
  });

  it('can import BIP84 with passphrase', async () => {
    const store = createStore('MalinWallet');
    const { promise } = startImport(
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
      true,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDSegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1qe8q660wfj6uvqg7zyn86jcsux36natklqnfdrc');
  });

  it('can import Legacy', async () => {
    const store = createStore();
    const { promise } = startImport('KztVRmc2EJJBHi599mCdXrxMTsNsGy3NUjc3Fb3FFDSMYyMDRjnv', false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), '1AhcdMCzby4VXgqrexuMfh7eiSprRFtN78');
  });

  it('can import P2SH Segwit', async () => {
    const store = createStore();
    const { promise } = startImport('L3NxFnYoBGjJ5PhxrxV6jorvjnc8cerYJx71vXU6ta8BXQxHVZya', false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].type, SegwitP2SHWallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), '3KM9VfdsDf9uT7uwZagoKgVn8z35m9CtSM');
    assert.strictEqual(store.state.wallets[1].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[1].getAddress(), '1L7AmTTKbAAefBe93gJcFRTH9fdfhkMdHt');
  });

  it('can import Bech32 Segwit', async () => {
    const store = createStore();
    const { promise } = startImport('L1T6FfKpKHi8JE6eBKrsXkenw34d5FfFzJUZ6dLs2utxkSvsDfxZ', false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].type, SegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), 'bc1q763rf54hzuncmf8dtlz558uqe4f247mq39rjvr');
    assert.strictEqual(store.state.wallets[1].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[1].getAddress(), '1PV5YV6UWWL6rJuKsNH5uY75E9377hFFWn');
  });

  it('can import Legacy/P2SH/Bech32 from an empty wallet', async () => {
    const store = createStore();
    const { promise } = startImport('L36mabzoQyMZoHHsBFVNB7PUBXgXTynwY6yR7kYZ82EkS7oejVp2', false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].type, SegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), 'bc1q8dkdgpaq9sd2xwptsjhe7krwp0k595w0hdtkfr');
    assert.strictEqual(store.state.wallets[1].type, SegwitP2SHWallet.type);
    assert.strictEqual(store.state.wallets[1].getAddress(), '3QNykAevvcnyw8S85wn4U8tsH2nksRMEKr');
    assert.strictEqual(store.state.wallets[2].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[2].getAddress(), '16RDEqXtDmZjm8f4s6Uf3EHgjCpsSqB2zM');
  });

  it('can import BIP44', async () => {
    const store = createStore();
    const { promise } = startImport(
      'sting museum endless duty nice riot because swallow brother depth weapon merge woman wish hold finish venture gauge stomach bomb device bracket agent parent',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDLegacyP2PKHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), '1EgDbwf5nXp9knoaWW6nV6N91EK3EFQ5vC');
  });

  it('can import BIP44 with mnemonic in french', async () => {
    const store = createStore();
    const { promise } = startImport(
      'abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abeille',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDLegacyP2PKHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), '1JFdzwd8SqFn5LeeiDKcbYUfXxvButqXgX');
  });

  it('can import BIP49', async () => {
    const store = createStore();
    const { promise } = startImport(
      'believe torch sport lizard absurd retreat scale layer song pen clump combine window staff dream filter latin bicycle vapor anchor put clean gain slush',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDSegwitP2SHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), '3EoqYYp7hQSHn5nHqRtWzkgqmK3caQ2SUu');
  });

  it('can import HD Legacy Electrum (BIP32 P2PKH)', async () => {
    const store = createStore();
    const { promise } = startImport(
      'eight derive blast guide smoke piece coral burden lottery flower tomato flame',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDLegacyElectrumSeedP2PKHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), '1FgVfJ5D3HyKWKC4xk36Cio7MUaxxnXaVd');
  });

  it('can import HD Legacy Electrum (BIP32 P2PKH) with passphrase', async () => {
    const store = createStore('super secret passphrase');
    const { promise } = startImport(
      'receive happy wash prosper update pet neck acid try profit proud hungry',
      true,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDLegacyElectrumSeedP2PKHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), '13sPvsrgRN8XibZNHtZXNqVDJPnNZLjTap');
  });

  it('can import BreadWallet', async () => {
    const store = createStore();
    const { promise } = startImport(
      'become salmon motor battle sweet merit romance ecology age squirrel oblige awesome',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDLegacyBreadwalletWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), '1G5tkEuWWirz8AFyzrafSgFxvKsRwcBqwY');
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(1), 'bc1q5gslp44fkfdkq6r255utxpq85c9n02m3hsla68');
  });

  it('can import HD Electrum (BIP32 P2WPKH)', async () => {
    const store = createStore();
    const { promise } = startImport(
      'noble mimic pipe merry knife screen enter dune crop bonus slice card',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDSegwitElectrumSeedP2WPKHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1qzzanxnr3xv9a5ha264kpzpfq260qvuameslddu');
  });

  it('can import HD Electrum (BIP32 P2WPKH) with passphrase', async () => {
    const UNICODE_HORROR = '          who knws wat horrors le in the dark heart f uncode?';
    const store = createStore(UNICODE_HORROR);
    const { promise } = startImport(
      'bitter grass shiver impose acquire brush forget axis eager alone wine silver',
      true,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDSegwitElectrumSeedP2WPKHWallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1qx94dutas7ysn2my645cyttujrms5d9p57f6aam');
  });

  it('can import AEZEED', async () => {
    const store = createStore();
    const { promise } = startImport(
      'abstract rhythm weird food attract treat mosquito sight royal actor surround ride strike remove guilt catch filter summer mushroom protect poverty cruel chaos pattern',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDAezeedWallet.type);
  });

  it('can import AEZEED with password', async () => {
    const store = createStore('strongPassword');
    const { promise } = startImport(
      'able mix price funny host express lawsuit congress antique float pig exchange vapor drip wide cup style apple tumble verb fix blush tongue market',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDAezeedWallet.type);
  });

  it('importing empty BIP39 should yield BIP84', async () => {
    const store = createStore();
    const tempWallet = new HDSegwitBech32Wallet();
    await tempWallet.generate();
    const { promise } = startImport(tempWallet.getSecret(), false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDSegwitBech32Wallet.type);
  });

  it('can import Legacy with uncompressed pubkey', async () => {
    const store = createStore();
    const { promise } = startImport('5KE6tf9vhYkzYSbgEL6M7xvkY69GMFHF3WxzYaCFMvwMxn3QgRS', false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].getSecret(), '5KE6tf9vhYkzYSbgEL6M7xvkY69GMFHF3WxzYaCFMvwMxn3QgRS');
    assert.strictEqual(store.state.wallets[0].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), '1GsJDeD6fqS912egpjhdjrUTiCh1hhwBgQ');
  });

  it('can import minikey Legacy with uncompressed pubkey', async () => {
    // Example from https://en.bitcoin.it/wiki/Mini_private_key_format#Example_with_SHA256
    // "Search on page" won't work unless this stuff they added to prevent copy pasting is included in the search.
    const minikey = 'S6c56bnXQiBjk9_SAMPLE_PRIVATE_KEY_DO_NOT_IMPORT_mqSYE7ykVQ7NzrRy'.replace(/_.+_/, '');
    const wif = '5JPy8Zg7z4P7RSLsiqcqyeAF1_SAMPLE_PRIVATE_KEY_DO_NOT_IMPORT_935zjNUdMxcDeVrtU1oarrgnB7'.replace(/_.+_/, '');
    const addr = '1CciesT23BNionJe_SAMPLE_ADDRESS_DO_NOT_SEND_Xrbxmjc7ywfiyM4oLW'.replace(/_.+_/, '');
    // Verifying the replace regex removes it.
    assert.strictEqual(minikey, 'S6c56bnXQiBjk9mqSYE7ykVQ7NzrRy');
    assert.strictEqual(wif, '5JPy8Zg7z4P7RSLsiqcqyeAF1935zjNUdMxcDeVrtU1oarrgnB7');
    assert.strictEqual(addr, '1CciesT23BNionJeXrbxmjc7ywfiyM4oLW');

    // Now actually generate the wallet for the test.
    const store = createStore();
    const { promise } = startImport(minikey, false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].getSecret(), wif);
    assert.strictEqual(store.state.wallets[0].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), addr);
  });

  it('can import BIP38 encrypted backup', async () => {
    const store = createStore('qwerty');
    const { promise } = startImport('6PnU5voARjBBykwSddwCdcn6Eu9EcsK24Gs5zWxbJbPZYW7eiYQP8XgKbN', false, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].getSecret(), 'KxqRtpd9vFju297ACPKHrGkgXuberTveZPXbRDiQ3MXZycSQYtjc');
    assert.strictEqual(store.state.wallets[0].type, SegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets[0].getAddress(), 'bc1qxaqgapg7sugyvq3zh0re8plqkgrvrxzr6snmqr');
    assert.strictEqual(store.state.wallets[1].getSecret(), 'KxqRtpd9vFju297ACPKHrGkgXuberTveZPXbRDiQ3MXZycSQYtjc');
    assert.strictEqual(store.state.wallets[1].type, SegwitP2SHWallet.type);
    assert.strictEqual(store.state.wallets[1].getAddress(), '3ANCYnBvFPJyc4sxNFWnLkVBfDrKBZCVSp');
    assert.strictEqual(store.state.wallets[2].getSecret(), 'KxqRtpd9vFju297ACPKHrGkgXuberTveZPXbRDiQ3MXZycSQYtjc');
    assert.strictEqual(store.state.wallets[2].type, LegacyWallet.type);
    assert.strictEqual(store.state.wallets[2].getAddress(), '1639W2kM6UY9PdavMQeLqG4SuUEae9NZfq');
  });

  it('can import watch-only address', async () => {
    const store1 = createStore();
    const { promise: promise1 } = startImport('1AhcdMCzby4VXgqrexuMfh7eiSprRFtN78', false, false, false, ...store1.callbacks);
    await promise1;
    assert.strictEqual(store1.state.wallets[0].type, WatchOnlyWallet.type);

    const store2 = createStore();
    const { promise: promise2 } = startImport('3EoqYYp7hQSHn5nHqRtWzkgqmK3caQ2SUu', false, false, false, ...store2.callbacks);
    await promise2;
    assert.strictEqual(store2.state.wallets[0].type, WatchOnlyWallet.type);

    const store3 = createStore();
    const { promise: promise3 } = startImport('bc1q8j4lk4qlhun0n7h5ahfslfldc8zhlxgynfpdj2', false, false, false, ...store3.callbacks);
    await promise3;
    assert.strictEqual(store3.state.wallets[0].type, WatchOnlyWallet.type);

    const store4 = createStore();
    const { promise: promise4 } = startImport(
      'zpub6r7jhKKm7BAVx3b3nSnuadY1WnshZYkhK8gKFoRLwK9rF3Mzv28BrGcCGA3ugGtawi1WLb2vyjQAX9ZTDGU5gNk2bLdTc3iEXr6tzR1ipNP',
      false,
      false,
      false,
      ...store4.callbacks,
    );
    await promise4;
    assert.strictEqual(store4.state.wallets[0].type, WatchOnlyWallet.type);
  });

  it('can import slip39 wallet', async () => {
    const store = createStore();
    // 2-of-3 slip39 wallet
    // crystal lungs academic acid corner infant satisfy spider alcohol laser golden equation fiscal epidemic infant scholar space findings tadpole belong
    // crystal lungs academic agency class payment actress avoid rebound ordinary exchange petition tendency mild mobile spine robin fancy shelter increase
    // crystal lungs academic always earth satoshi elbow satoshi that pants formal leaf rival texture romantic filter expand regular soul desert
    const { promise } = startImport(
      'crystal lungs academic acid corner infant satisfy spider alcohol laser golden equation fiscal epidemic infant scholar space findings tadpole belong\n' +
        'crystal lungs academic agency class payment actress avoid rebound ordinary exchange petition tendency mild mobile spine robin fancy shelter increase',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, SLIP39SegwitP2SHWallet.type);
  });

  it('can import slip39 wallet with password', async () => {
    const store = createStore('MalinWallet');
    // 2-of-3 slip39 wallet
    // crystal lungs academic acid corner infant satisfy spider alcohol laser golden equation fiscal epidemic infant scholar space findings tadpole belong
    // crystal lungs academic agency class payment actress avoid rebound ordinary exchange petition tendency mild mobile spine robin fancy shelter increase
    // crystal lungs academic always earth satoshi elbow satoshi that pants formal leaf rival texture romantic filter expand regular soul desert
    const { promise } = startImport(
      'crystal lungs academic acid corner infant satisfy spider alcohol laser golden equation fiscal epidemic infant scholar space findings tadpole belong\n' +
        'crystal lungs academic agency class payment actress avoid rebound ordinary exchange petition tendency mild mobile spine robin fancy shelter increase',
      true,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, SLIP39SegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1q5k23fle53w8a3982m82e9f6hqlnrh3mv5s9s6z');
  });

  it('can import watch-only Cobo vault export', async () => {
    const store = createStore();
    const { promise } = startImport(
      '{"ExtPubKey":"zpub6riZchHnrWzhhZ3Z4dhCJmesGyafMmZBRC9txhnidR313XJbcv4KiDubderKHhL7rMsqacYd82FQ38e4whgs8Dg7CpsxX3dSGWayXsEerF4","MasterFingerprint":"7D2F0272","AccountKeyPath":"84\'\\/0\'\\/0\'","CoboVaultFirmwareVersion":"2.6.1(BTC-Only)"}',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
    assert.strictEqual(store.state.wallets[0].getMasterFingerprintHex(), '7d2f0272');
  });

  it('can import watch-only Cobo vault export 2', async () => {
    const store = createStore();
    const { promise } = startImport(
      `[{"ExtPubKey":"zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs","MasterFingerprint":"73C5DA0A","AccountKeyPath":"m/84'/0'/0'"},{"ExtPubKey":"ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP","MasterFingerprint":"73C5DA0A","AccountKeyPath":"m/49'/0'/0'"},{"ExtPubKey":"xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj","MasterFingerprint":"73C5DA0A","AccountKeyPath":"m/44'/0'/0'"}]`,
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
    assert.strictEqual(store.state.wallets[0].getMasterFingerprintHex(), '73c5da0a');
    assert.strictEqual(
      store.state.wallets[0].getSecret(),
      'zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs',
    );

    assert.strictEqual(store.state.wallets[1].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[1].getDerivationPath(), "m/49'/0'/0'");
    assert.strictEqual(store.state.wallets[1].getMasterFingerprintHex(), '73c5da0a');
    assert.strictEqual(
      store.state.wallets[1].getSecret(),
      'ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP',
    );

    assert.strictEqual(store.state.wallets[2].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[2].getDerivationPath(), "m/44'/0'/0'");
    assert.strictEqual(store.state.wallets[2].getMasterFingerprintHex(), '73c5da0a');
    assert.strictEqual(
      store.state.wallets[2].getSecret(),
      'xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj',
    );
  });

  it('can import watch-only Keystone vault export', async () => {
    const store = createStore();
    const { promise } = startImport(
      '{"ExtPubKey":"zpub6qT7amLcp2exr4mU4AhXZMjD9CFkopECVhUxc9LHW8pNsJG2B9ogs5sFbGZpxEeT5TBjLmc7EFYgZA9EeWEM1xkJMFLefzZc8eigRFhKB8Q","MasterFingerprint":"01EBDA7D","AccountKeyPath":"m/84\'/0\'/0\'"}',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
  });

  it('can import watch-only xpub as a zpub if it has been used', async () => {
    const store = createStore();
    const { promise } = startImport(
      'xpub6C8z87Nj7vuUqntJdNfkY4LJBSih9BkA3kUVjmTbSmA4Fk88vrBJwcjCt2q8yb2Pt8axgDkonSfdGiACPYNH7yoyQnX3iETHLneSYvPcnRy',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
    assert.strictEqual(
      store.state.wallets[0].getSecret(),
      'zpub6qoWjSiZRHzSYPGYJ6EzxEXJXP1b2Rj9syWwJZFNCmupMwkbSAWSBk3UvSkJyQLEhQpaBAwvhmNj3HPKpwCJiTBB9Tutt46FtEmjL2DoU3J',
    );
  });

  it('can import BIP39 wallets with truncated words', async () => {
    // 12 words
    const store1 = createStore();
    const { promise: promise1 } = startImport(
      'trip ener cloc puls hams ghos inha crow inju vibr seve chro',
      false,
      false,
      false,
      ...store1.callbacks,
    );
    await promise1;
    assert.strictEqual(
      store1.state.wallets[0].getSecret(),
      'trip energy clock pulse hamster ghost inhale crowd injury vibrant seven chronic',
    );

    // 16 words
    const store2 = createStore();
    const { promise: promise2 } = startImport(
      'docu gosp razo chao nort ches nomi fati swam firs deca boy icon virt gap prep seri anch',
      false,
      false,
      false,
      ...store2.callbacks,
    );
    await promise2;
    assert.strictEqual(
      store2.state.wallets[0].getSecret(),
      'document gospel razor chaos north chest nominee fatigue swamp first decade boy icon virtual gap prepare series anchor',
    );

    // 24 words
    const store3 = createStore();
    const { promise: promise3 } = startImport(
      'rece own flig sent tide hood sile bunk deri mana wink belt loud apol mons pill raw gate hurd matc nigh wish todd achi',
      false,
      false,
      false,
      ...store3.callbacks,
    );
    await promise3;
    assert.strictEqual(
      store3.state.wallets[0].getSecret(),
      'receive own flight sentence tide hood silent bunker derive manage wink belt loud apology monster pill raw gate hurdle match night wish toddler achieve',
    );
  });

  it('can import BIP47 wallet that only has notification transaction', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const store = createStore('1');
    const { promise } = startImport(process.env.BIP47_HD_MNEMONIC.split(':')[0], true, false, false, ...store.callbacks);
    await promise;
    assert.strictEqual(store.state.wallets[0].type, HDLegacyP2PKHWallet.type);
    assert.strictEqual(store.state.wallets[1].type, HDSegwitBech32Wallet.type);
    assert.strictEqual(store.state.wallets.length, 2);
  });

  it('can import coldcard mk4 descriptor.txt', async () => {
    const store = createStore();
    const { promise } = startImport(
      fs.readFileSync('tests/unit/fixtures/coldcardmk4/descriptor.txt').toString('utf8'),
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;

    assert.strictEqual(store.state.wallets.length, 1);
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getMasterFingerprintHex(), '086ee178');
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1q5y4r767v5fzx74ez4nw36hjqrhr4ayeyut5px6');
  });

  it('can import coldcard mk4 new-wasabi.json', async () => {
    const store = createStore();
    const { promise } = startImport(
      fs.readFileSync('tests/unit/fixtures/coldcardmk4/new-wasabi.json').toString('utf8'),
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;

    assert.strictEqual(store.state.wallets.length, 1);
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getMasterFingerprintHex(), '086ee178');
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1q5y4r767v5fzx74ez4nw36hjqrhr4ayeyut5px6');
  });

  it('can import coldcard mk4 sparrow-export.json', async () => {
    const store = createStore();
    const { promise } = startImport(
      fs.readFileSync('tests/unit/fixtures/coldcardmk4/sparrow-export.json').toString('utf8'),
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;

    assert.strictEqual(store.state.wallets.length, 1);
    assert.strictEqual(store.state.wallets[0].type, WatchOnlyWallet.type);
    assert.strictEqual(store.state.wallets[0].getMasterFingerprintHex(), '086ee178');
    assert.strictEqual(store.state.wallets[0].getDerivationPath(), "m/84'/0'/0'");
    assert.strictEqual(store.state.wallets[0]._getExternalAddressByIndex(0), 'bc1q5y4r767v5fzx74ez4nw36hjqrhr4ayeyut5px6');
  });

  it('can import lightning ark wallet', async () => {
    const store = createStore();
    const { promise } = startImport(
      'arkade://abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
      false,
      false,
      false,
      ...store.callbacks,
    );
    await promise;

    assert.strictEqual(store.state.wallets.length, 1);
    assert.strictEqual(store.state.wallets[0].type, LightningArkWallet.type);
    assert.strictEqual(
      store.state.wallets[0].getSecret(),
      'arkade://abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
    );
  });
});


================================================
FILE: ./tests/integration/watch-only-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { WatchOnlyWallet } from '../../class';

jest.setTimeout(500 * 1000);

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

describe('Watch only wallet', () => {
  it('can fetch balance', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa');
    await w.fetchBalance();
    assert.ok(w.getBalance() > 16);
  });

  it('can fetch tx', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('1BiJW1jyUaxcJp2JWwbPLPzB1toPNWTFJV');
    await w.fetchTransactions();
    assert.strictEqual(w.getTransactions().length, 2);

    // fetch again and make sure no duplicates
    await w.fetchTransactions();
    assert.strictEqual(w.getTransactions().length, 2);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can fetch tx from huge wallet', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s'); // binance wallet
    await w.fetchTransactions();
    assert.ok(w.getTransactions().length === 0, w.getTransactions().length); // not yet kek but at least we dont crash
  });

  it('can fetch TXs with values', async () => {
    const w = new WatchOnlyWallet();
    for (const sec of [
      'bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv',
      'BC1QUHNVE8Q4TK3UNHMJTS7YMXV8CD6W9XV8WY29UV',
      'bitcoin:bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv',
      'BITCOIN:BC1QUHNVE8Q4TK3UNHMJTS7YMXV8CD6W9XV8WY29UV',
      'bitcoin:BC1QUHNVE8Q4TK3UNHMJTS7YMXV8CD6W9XV8WY29UV',
      'BITCOIN:bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv',
    ]) {
      w.setSecret(sec);
      assert.strictEqual(w.getAddress(), 'bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv');
      assert.strictEqual(await w.getAddressAsync(), 'bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv');
      assert.ok(w.weOwnAddress('bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv'));
      assert.ok(w.weOwnAddress('BC1QUHNVE8Q4TK3UNHMJTS7YMXV8CD6W9XV8WY29UV'));
      assert.ok(!w.weOwnAddress('garbage'));
      assert.ok(!w.weOwnAddress(false));
      await w.fetchTransactions();

      for (const tx of w.getTransactions()) {
        assert.ok(tx.hash);
        assert.ok(tx.value);
        assert.ok(tx.timestamp);
        assert.ok(tx.confirmations > 1);
      }

      assert.strictEqual(w.getTransactions()[0].value, -892111);
      assert.strictEqual(w.getTransactions()[1].value, 892111);
    }
  });

  it('can fetch complex TXs', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC');
    await w.fetchTransactions();
    for (const tx of w.getTransactions()) {
      assert.ok(tx.value, 'incorrect tx.value');
    }
  });

  it('can fetch balance & transactions from zpub HD', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('zpub6r7jhKKm7BAVx3b3nSnuadY1WnshZYkhK8gKFoRLwK9rF3Mzv28BrGcCGA3ugGtawi1WLb2vyjQAX9ZTDGU5gNk2bLdTc3iEXr6tzR1ipNP');
    await w.fetchBalance();
    assert.strictEqual(w.getBalance(), 200000);
    await w.fetchTransactions();
    assert.strictEqual(w.getTransactions().length, 4);
    const nextAddress = await w.getAddressAsync();

    assert.strictEqual(w.getNextFreeAddressIndex(), 2);
    assert.strictEqual(nextAddress, 'bc1q6442dedpwvqldldnsyux3cuz27paqks0pf2kvf');
    assert.strictEqual(nextAddress, w._getExternalAddressByIndex(w.getNextFreeAddressIndex()));

    const nextChangeAddress = await w.getChangeAddressAsync();
    assert.strictEqual(nextChangeAddress, 'bc1qgltdyjnertcyvdn9hlkfpgr6hc260rjrss49uy');
  });

  // skipped because its generally rare case
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can fetch txs for address funded by genesis txs', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('37jKPSmbEGwgfacCr2nayn1wTaqMAbA94Z');
    await w.fetchBalance();
    await w.fetchTransactions();
    assert.ok(w.getTransactions().length >= 138);
  });
});


================================================
FILE: ./tests/integration/App.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/* eslint react/prop-types: "off" */
import React from 'react';
import { render } from '@testing-library/react-native';
import { NavigationContainer } from '@react-navigation/native';
import { Header } from '../../components/Header';
import SelfTest from '../../screen/settings/SelfTest';
import Settings from '../../screen/settings/Settings';
import { MalinDefaultTheme } from '../../components/themes';

jest.mock('../../malin_modules/MalinElectrum', () => {
  return {
    connectMain: jest.fn(),
  }
});

const Wrapper = ({ children }) => (
  <NavigationContainer theme={MalinDefaultTheme}>{children}</NavigationContainer>
)

it('Header works', () => {
  const { toJSON } = render(
    <Wrapper>
      <Header />
    </Wrapper>,
  )
  expect(toJSON()).toBeTruthy();
})

// eslint-disable-next-line jest/no-disabled-tests
it.skip('Settings work', () => {
  const { toJSON } = render(
    <Wrapper>
      <Settings />
    </Wrapper>,
  )
  expect(toJSON()).toBeTruthy();
})

it('SelfTest work', () => {
  const { toJSON, getByText } = render(
    <Wrapper>
      <SelfTest />
    </Wrapper>,
  )
  expect(toJSON()).toBeTruthy();
  expect(getByText('OK')).toBeTruthy();
})


================================================
FILE: ./tests/integration/notifications.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import { isGroundControlUriValid } from '../../malin_modules/notifications';

// Notifications.default = new Notifications();

describe('notifications', () => {
  // yeah, lets rely less on external services...
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can check groundcontrol server uri validity', async () => {
    assert.ok(
      await isGroundControlUriValid(
        'https://groundcontrol-malinwallet.herokuapp.com',
      )
    );
    assert.ok(!(await isGroundControlUriValid('https://www.google.com')));
    await new Promise((resolve) => setTimeout(resolve, 2000));
  })

  // muted because it causes jest to hang waiting indefinitely
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can check non-responding url', async () => {
    assert.ok(!(await isGroundControlUriValid('https://localhost.com')));
  })
});


================================================
FILE: ./tests/integration/hd-segwit-bech32-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { HDSegwitBech32Wallet } from '../../class';

jest.setTimeout(90 * 1000);

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

describe('Bech32 Segwit HD (BIP84)', () => {
  it.each([false, true])('can fetch balance, transactions & utxo, disableBatching=%p', async function (disableBatching) {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }
    if (disableBatching) MalinElectrum.setBatchingDisabled();

    let hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC);
    assert.ok(hd.validateMnemonic());

    assert.strictEqual(
      'zpub6r7jhKKm7BAVx3b3nSnuadY1WnshZYkhK8gKFoRLwK9rF3Mzv28BrGcCGA3ugGtawi1WLb2vyjQAX9ZTDGU5gNk2bLdTc3iEXr6tzR1ipNP',
      hd.getXpub(),
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p');
    assert.strictEqual(hd._getExternalAddressByIndex(1), 'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1qcg6e26vtzja0h8up5w2m7utex0fsu4v0e0e7uy');
    assert.strictEqual(hd._getInternalAddressByIndex(1), 'bc1qwp58x4c9e5cplsnw5096qzdkae036ug7a34x3r');

    assert.ok(hd.weOwnAddress('bc1qvd6w54sydc08z3802svkxr7297ez7cusd6266p'));
    assert.ok(hd.weOwnAddress('BC1QVD6W54SYDC08Z3802SVKXR7297EZ7CUSD6266P'));
    assert.ok(hd.weOwnAddress('bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh'));
    assert.ok(!hd.weOwnAddress('1HjsSTnrwWzzEV2oi4r5MsAYENkTkrCtwL'));
    assert.ok(!hd.weOwnAddress('garbage'));
    assert.ok(!hd.weOwnAddress(false));

    assert.strictEqual(hd.timeToRefreshBalance(), true);
    assert.ok(hd._lastTxFetch === 0);
    assert.ok(hd._lastBalanceFetch === 0);

    await hd.fetchBalance();
    assert.strictEqual(hd.getBalance(), 200000);
    assert.strictEqual(await hd.getAddressAsync(), hd._getExternalAddressByIndex(2));
    assert.strictEqual(await hd.getChangeAddressAsync(), hd._getInternalAddressByIndex(2));
    assert.strictEqual(hd.next_free_address_index, 2);
    assert.strictEqual(hd.getNextFreeAddressIndex(), 2);
    assert.strictEqual(hd.next_free_change_address_index, 2);

    // now fetch txs
    await hd.fetchTransactions();
    assert.ok(hd._lastTxFetch > 0);
    assert.ok(hd._lastBalanceFetch > 0);
    assert.strictEqual(hd.timeToRefreshBalance(), false);
    assert.strictEqual(hd.getTransactions().length, 4);

    for (const tx of hd.getTransactions()) {
      assert.ok(tx.hash);
      assert.strictEqual(tx.value, 50000);
      assert.ok(tx.timestamp);
      assert.ok(tx.confirmations > 1);
    }

    assert.ok(hd.weOwnTransaction('5e2fa84148a7389537434b3ad12fcae71ed43ce5fb0f016a7f154a9b99a973df'));
    assert.ok(hd.weOwnTransaction('ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d'));
    assert.ok(!hd.weOwnTransaction('825c12f277d1f84911ac15ad1f41a3de28e9d906868a930b0a7bca61b17c8881'));

    // now fetch UTXO
    await hd.fetchUtxo();
    const utxo = hd.getUtxo();
    assert.strictEqual(utxo.length, 4);
    assert.ok(utxo[0].txid);
    assert.ok(utxo[0].vout === 0 || utxo[0].vout === 1);
    assert.ok(utxo[0].value);
    assert.ok(utxo[0].address);

    // now, reset HD wallet, and find free addresses from scratch:
    hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC);

    assert.strictEqual(await hd.getAddressAsync(), hd._getExternalAddressByIndex(2));
    assert.strictEqual(await hd.getChangeAddressAsync(), hd._getInternalAddressByIndex(2));
    assert.strictEqual(hd.next_free_address_index, 2);
    assert.strictEqual(hd.getNextFreeAddressIndex(), 2);
    assert.strictEqual(hd.next_free_change_address_index, 2);
    if (disableBatching) MalinElectrum.setBatchingEnabled();
  });

  // skpped because its a very specific testcase, and slow
  // unskip and test manually
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can catch up with externally modified wallet', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);
    assert.ok(hd.validateMnemonic());

    await hd.fetchBalance();
    const oldBalance = hd.getBalance();

    await hd.fetchTransactions();
    const oldTransactions = hd.getTransactions();

    // now, mess with internal state, make it 'obsolete'

    hd._txs_by_external_index['2'].pop();
    hd._txs_by_internal_index['16'].pop();
    hd._txs_by_internal_index['17'] = [];

    for (let c = 17; c < 100; c++) hd._balances_by_internal_index[c] = { c: 0, u: 0 };
    hd._balances_by_external_index['2'].c = 1000000;

    assert.ok(hd.getBalance() !== oldBalance);
    assert.ok(hd.getTransactions().length !== oldTransactions.length);

    // now, refetch! should get back to normal

    await hd.fetchBalance();
    assert.strictEqual(hd.getBalance(), oldBalance);
    await hd.fetchTransactions();
    assert.strictEqual(hd.getTransactions().length, oldTransactions.length);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('can work with faulty zpub', async () => {
    // takes too much time, skipped
    if (!process.env.FAULTY_ZPUB) {
      console.error('process.env.FAULTY_ZPUB not set, skipped');
      return;
    }
    const hd = new HDSegwitBech32Wallet();
    hd._xpub = process.env.FAULTY_ZPUB;

    await hd.fetchBalance();
    await hd.fetchTransactions();

    assert.ok(hd.getTransactions().length >= 76);
  });

  it('can fetchBalance, fetchTransactions, fetchUtxo and create transactions', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);
    assert.ok(hd.validateMnemonic());
    assert.strictEqual(
      hd.getXpub(),
      'zpub6qoWjSiZRHzSYPGYJ6EzxEXJXP1b2Rj9syWwJZFNCmupMwkbSAWSBk3UvSkJyQLEhQpaBAwvhmNj3HPKpwCJiTBB9Tutt46FtEmjL2DoU3J',
    );

    let start = +new Date();
    await hd.fetchBalance();
    let end = +new Date();
    end - start > 5000 && console.warn('fetchBalance took', (end - start) / 1000, 'sec');

    assert.ok(hd.next_free_change_address_index > 0);
    assert.ok(hd.next_free_address_index > 0);
    assert.ok(hd.getNextFreeAddressIndex() > 0);

    start = +new Date();
    await hd.fetchTransactions();
    end = +new Date();
    end - start > 15000 && console.warn('fetchTransactions took', (end - start) / 1000, 'sec');

    start = +new Date();
    await hd.fetchBalance();
    end = +new Date();
    end - start > 2000 && console.warn('warm fetchBalance took', (end - start) / 1000, 'sec');

    global.debug = true;
    start = +new Date();
    await hd.fetchTransactions();
    end = +new Date();
    end - start > 2000 && console.warn('warm fetchTransactions took', (end - start) / 1000, 'sec');

    let txFound = 0;
    for (const tx of hd.getTransactions()) {
      if (tx.hash === 'e9ef58baf4cff3ad55913a360c2fa1fd124309c59dcd720cdb172ce46582097b') {
        assert.strictEqual(tx.value, -129545);
        assert.strictEqual(tx.inputs[0].addresses[0], 'bc1qffcl35r05wyf06meu3dalfevawx559n0ufrxcw');
        assert.strictEqual(tx.inputs[1].addresses[0], 'bc1qtvh8mjcfdg9224nx4wu3sw7fmmtmy2k3jhdeul');
        assert.strictEqual(tx.inputs[2].addresses[0], 'bc1qhe03zgvq4fmfw8l2qq2zu4dxyhgyukcz6k2a5w');
        txFound++;
      }
      if (tx.hash === 'e112771fd43962abfe4e4623bf788d6d95ff1bd0f9b56a6a41fb9ed4dacc75f1') {
        assert.strictEqual(tx.value, 1000000);
        assert.strictEqual(tx.inputs[0].addresses[0], '3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC');
        assert.strictEqual(tx.inputs[1].addresses[0], '3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC');
        txFound++;
      }
      if (tx.hash === 'c94bdec21c72d3441245caa164b00315b131f6b72513369f4be1b00b9fb99cc5') {
        assert.strictEqual(tx.inputs[0].addresses[0], '16Nf5X77RbFz9Mb6t2GFqxs3twQN1joBkD');
        txFound++;
      }
      if (tx.hash === '51fc225ddf24f7e124f034637f46442645ca7ea2c442b28124d4bcdd04e30195') {
        assert.strictEqual(tx.inputs[0].addresses[0], '3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC');
        txFound++;
      }
    }
    assert.strictEqual(txFound, 4);

    await hd.fetchUtxo();
    assert.strictEqual(hd.getUtxo().length, 4);
    assert.strictEqual(hd.getDerivedUtxoFromOurTransaction().length, 4);
    const u1 = hd.getUtxo().find(utxo => utxo.txid === '8b0ab2c7196312e021e0d3dc73f801693826428782970763df6134457bd2ec20');
    const u2 = hd
      .getDerivedUtxoFromOurTransaction()
      .find(utxo => utxo.txid === '8b0ab2c7196312e021e0d3dc73f801693826428782970763df6134457bd2ec20');
    delete u1.confirmations;
    delete u2.confirmations;
    delete u1.height;
    delete u2.height;
    assert.deepStrictEqual(u1, u2);
    const changeAddress = await hd.getChangeAddressAsync();
    assert.ok(changeAddress && changeAddress.startsWith('bc1'));

    const { tx, inputs, outputs, fee } = hd.createTransaction(
      hd.getUtxo(),
      [{ address: 'bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu', value: 51000 }],
      13,
      changeAddress,
    );

    assert.strictEqual(Math.round(fee / tx.virtualSize()), 13);

    let totalInput = 0;
    for (const inp of inputs) {
      totalInput += inp.value;
    }

    assert.strictEqual(outputs.length, 2);
    let totalOutput = 0;
    for (const outp of outputs) {
      totalOutput += outp.value;
    }

    assert.strictEqual(totalInput - totalOutput, fee);
    assert.strictEqual(outputs[outputs.length - 1].address, changeAddress);
  });

  it('wasEverUsed() works', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }

    let hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC);
    assert.ok(await hd.wasEverUsed());

    hd = new HDSegwitBech32Wallet();
    await hd.generate();
    assert.ok(!(await hd.wasEverUsed()), hd.getSecret());
  });
});


================================================
FILE: ./tests/integration/bip47.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// import assert from 'assert';
import BIP47Factory from '@spsina/bip47';
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';
import { ECPairFactory } from 'ecpair';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import ecc from '../../malin_modules/noble_ecc';
import { HDLegacyP2PKHWallet, HDSegwitBech32Wallet } from '../../class';

const ECPair = ECPairFactory(ecc);

jest.setTimeout(90 * 1000);

afterAll(async () => {
  // after all tests we close socket so the test suite can actually terminate
  MalinElectrum.forceDisconnect();
});

beforeAll(async () => {
  // awaiting for Electrum to be connected. For RN Electrum would naturally connect
  // while app starts up, but for tests we need to wait for it
  await MalinElectrum.connectMain();
});

describe('Bech32 Segwit HD (BIP84) with BIP47', () => {
  it('should work', async () => {
    const hd = new HDLegacyP2PKHWallet();
    // @see https://gist.github.com/SamouraiDev/6aad669604c5930864bd
    hd.setSecret('reward upper indicate eight swift arch injury crystal super wrestle already dentist');

    expect(hd.getBIP47PaymentCode()).toEqual(
      'PM8TJS2JxQ5ztXUpBBRnpTbcUXbUHy2T1abfrb3KkAAtMEGNbey4oumH7Hc578WgQJhPjBxteQ5GHHToTYHE3A1w6p7tU6KSoFmWBVbFGjKPisZDbP97',
    );

    expect(hd.allowBIP47()).toEqual(true);

    await hd.fetchBIP47SenderPaymentCodes();
    expect(hd.getBIP47SenderPaymentCodes().length).toBeGreaterThanOrEqual(3);
    expect(hd.getBIP47SenderPaymentCodes()).toContain(
      'PM8TJTLJbPRGxSbc8EJi42Wrr6QbNSaSSVJ5Y3E4pbCYiTHUskHg13935Ubb7q8tx9GVbh2UuRnBc3WSyJHhUrw8KhprKnn9eDznYGieTzFcwQRya4GA',
    );
    expect(hd.getBIP47SenderPaymentCodes()).toContain(
      'PM8TJgndZSWCBPG5zCsqdXmCKLi7sP13jXuRp6b5X7G9geA3vRXQKAoXDf4Eym2RJB3vvcBdpDQT4vbo5QX7UfeV2ddjM8s79ERUTFS2ScKggSrciUsU',
    );
    expect(hd.getBIP47SenderPaymentCodes()).toContain(
      'PM8TJNiWKcyiA2MsWCfuAr9jvhA5qMEdEkjNypEnUbxMRa1D5ttQWdggQ7ib9VNFbRBSuw7i6RkqPSkCMR1XGPSikJHaCSfqWtsb1fn4WNAXjp5JVL5z',
    );

    await hd.fetchBalance();
    await hd.fetchTransactions();
    expect(hd.getTransactions().length).toBeGreaterThanOrEqual(4);
  });

  it('should work (samurai)', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[0]);
    w.setPassphrase('1');

    expect(w.getBIP47PaymentCode()).toEqual(
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    );

    expect(w._getExternalAddressByIndex(0)).toEqual('bc1q07l355j4yd5kyut36vjxn2u60d3dknnpt39t6y');

    const bip47 = BIP47Factory(ecc).fromBip39Seed(w.getSecret(), undefined, w.getPassphrase());
    const ourNotificationAddress = bip47.getNotificationAddress();

    const publicBip47 = BIP47Factory(ecc).fromPaymentCode(w.getBIP47PaymentCode());
    expect(ourNotificationAddress).toEqual(publicBip47.getNotificationAddress());

    expect(ourNotificationAddress).toEqual('1EiP2kSqxNqRhn8MPMkrtSEqaWiCWLYyTS'); // our notif address

    await w.fetchBIP47SenderPaymentCodes();
    assert.ok(
      w
        .getBIP47SenderPaymentCodes()
        .includes('PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo'),
    ); // sparrow payment code

    assert.ok(w.weOwnAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe')); // this is an address that was derived (and paid) from counterparty payment code

    const keyPair2 = ECPair.fromWIF(w._getWIFbyAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe') || '');
    const address = bitcoin.payments.p2wpkh({
      pubkey: keyPair2.publicKey,
    }).address;
    assert.strictEqual(address, 'bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe');

    await w.fetchTransactions();

    assert.ok(w.getTransactions().length >= 3);

    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f')?.value,
      100000,
    ); // initial deposit from sparrow after sparrow made a notification tx

    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '06b4c14587182fd0474f265a77b156519b4778769a99c21623863a8194d0fa4f')?.value,
      -22692,
    ); // notification tx to sparrow so we can pay sparrow

    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d')?.value,
      -77308,
    ); // paying to sparrow

    // now, constructing OP_RETURN data to notify sparrow about us

    const aliceBip47 = bip47;
    const keyPair = ECPair.fromWIF(w._getWIFbyAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe') || '');
    const bobBip47 = BIP47Factory(ecc).fromPaymentCode(
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    );
    const blindedPaymentCode = aliceBip47.getBlindedPaymentCode(
      bobBip47,
      keyPair.privateKey as Buffer,
      // txid is reversed, as well as output number ()
      Buffer.from('64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f', 'hex').reverse().toString('hex') + '01000000',
    );

    assert.strictEqual(
      blindedPaymentCode,
      '0100039da7642943ec5d16c9bce09b71f240fe246d891fa3b52a7d236fece98318e1ae972f3747672f7e79a23fc88c4dc91a8d014233e14a9e4417e132405b6a6c166d00000000000000000000000000',
    );

    // checking that this is exactly a data payload we have in an actual notification transaction we have sent:
    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '06b4c14587182fd0474f265a77b156519b4778769a99c21623863a8194d0fa4f')?.outputs?.[0]
        ?.scriptPubKey.hex,
      '6a4c50' + blindedPaymentCode,
    );

    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '06b4c14587182fd0474f265a77b156519b4778769a99c21623863a8194d0fa4f')?.outputs?.[1]
        .scriptPubKey.addresses[0],
      bobBip47.getNotificationAddress(),
    ); // transaction is to Bob's notification address
  });

  it('can tell whom to notify and whom dont', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    // whom we are going to notify:
    const bip47instanceReceiver = BIP47Factory(ecc).fromBip39Seed(process.env.BIP47_HD_MNEMONIC.split(':')[0], undefined, '1');

    // notifier:
    const walletSender = new HDSegwitBech32Wallet();
    walletSender.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[1]);
    walletSender.switchBIP47(true);
    await walletSender.fetchBIP47SenderPaymentCodes();
    await walletSender.fetchBalance();
    await walletSender.fetchTransactions();

    assert.ok(walletSender.getTransactions().length >= 3);
    assert.ok(walletSender._receive_payment_codes.length >= 2);

    assert.ok(walletSender.getBIP47NotificationTransaction(bip47instanceReceiver.getSerializedPaymentCode())); // already notified in the past
    assert.ok(
      !walletSender.getBIP47NotificationTransaction(
        'PM8TJdfXvRasx4WNpxky25ZKxhvfEiGYW9mka92tfiqDRSL7LQdxnC8uAk9k3okXctZowVwY2PUndjCQR6DHyuVVwqmy2aodmZNHgfFZcJRNTuBAXJCp',
      ),
    ); // random PC from interwebz. never interacted with him, so need to notify
  });

  it('can tell with which counterparty PC transaction is', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[0]);
    w.setPassphrase('1');

    w.switchBIP47(true);

    await w.fetchBIP47SenderPaymentCodes();
    await w.fetchBalance();
    await w.fetchTransactions();

    assert.ok(
      w
        .getBIP47SenderPaymentCodes()
        .includes('PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo'),
    ); // sparrow payment code

    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f')?.value,
      100000,
    ); // sparrow paid us after sparrow made a notification tx

    assert.ok(
      w.getBIP47NotificationTransaction(
        'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
      ),
    );

    assert.strictEqual(
      w.getBip47CounterpartyByTxid('64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f'),
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    ); // we got paid

    // pretending that user added this PC as a counterparty (sent a notif tx) to pay to:
    w.addBIP47Receiver(
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    );
    assert.ok(
      w.getBIP47NotificationTransaction(
        'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
      ),
    ); // dont need to notify

    // prior to sync, we have no info on which joint address shall be available
    assert.strictEqual(
      w._next_free_payment_code_address_index_send
        .PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo,
      undefined, // basically zero
    );

    await w.syncBip47ReceiversAddresses(
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    );

    // after sync, we know that index 0 was used so index 1 is next free:
    assert.strictEqual(
      w._next_free_payment_code_address_index_send
        .PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo,
      1,
    );

    assert.strictEqual(
      w.getBip47CounterpartyByTxid('73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d'),
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    ); // we paid sparrow

    let txWithCounterparty = w.getTransactions().find(tx => tx.txid === '73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d');
    assert(txWithCounterparty);
    assert.strictEqual(
      txWithCounterparty.counterparty,
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    );

    txWithCounterparty = w.getTransactions().find(tx => tx.txid === '64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f');
    assert(txWithCounterparty);
    assert.strictEqual(
      txWithCounterparty.counterparty,
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    );
  });

  it('can tell with which counterparty PC transaction is (sparrow)', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[1]);
    w.switchBIP47(true);

    await w.fetchBIP47SenderPaymentCodes();
    await w.fetchBalance();
    await w.fetchTransactions();

    assert.strictEqual(
      w.getTransactions().find(tx => tx.txid === '64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f')?.value,
      -102308,
    ); // we paid samurai

    assert.ok(
      w
        .getBIP47SenderPaymentCodes()
        .includes('PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF'),
    ); // samurai can pay us

    assert.deepStrictEqual(w.getBIP47ReceiverPaymentCodes(), []); // we can pay no-one

    assert.ok(!w.getBip47CounterpartyByTxid('64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f')); // dont know whom we paid

    w.addBIP47Receiver(
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    );
    assert.deepStrictEqual(w.getBIP47ReceiverPaymentCodes(), [
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    ]); // we can now  pay samurai

    // await w.fetchBIP47SenderPaymentCodes();
    // await w.fetchBalance();
    // await w.fetchTransactions();
    await w.syncBip47ReceiversAddresses(
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    );

    assert.strictEqual(
      w.getBip47CounterpartyByTxid('64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f'),
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    ); // we paid samurai, and now we can seethat
  });
});


================================================
FILE: ./tests/unit/taproot-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { TaprootWallet } from '../../class';

describe('Taproot wallet', () => {
  it('can convert scriptPubKey to address', () => {
    let address = TaprootWallet.scriptPubKeyToAddress('512040ef293a8a0ebaf8b351a27d89ff4b5b3822a635e4afdca77a30170c363bafa3');
    assert.strictEqual(address, 'bc1pgrhjjw52p6a03v635f7cnl6ttvuz9f34ujhaefm6xqtscd3m473szkl92g');
    address = TaprootWallet.scriptPubKeyToAddress('');
    assert.strictEqual(address, false);
    address = TaprootWallet.scriptPubKeyToAddress('trololo');
    assert.strictEqual(address, false);
  });

  it('can derive address from WIF', () => {
    const w = new TaprootWallet();
    w.setSecret('L4PKRVk1Peaar5WuH5LiKfkTygWtFfGrFeH2g2t3YVVqiwpJjMoF');
    assert.strictEqual(w.getAddress(), 'bc1pm6lqlel3qxefsx0v39nshtghasvvp6ghn3e5hd5q280j5m9h7csqrkzssu');
    assert.ok(w.weOwnAddress('bc1pm6lqlel3qxefsx0v39nshtghasvvp6ghn3e5hd5q280j5m9h7csqrkzssu'));
  });

  it('can derive address from WIF 2', () => {
    const w = new TaprootWallet();
    w.setSecret('L2an3aQwN2RX5YLkeXuFHUTVHuj1UKqRf38nESJRf6R9NmJrsftB');
    assert.strictEqual(w.getAddress(), 'bc1ptestlpef53v6vyku3f9rk0ve2mek2fdwnd9k6q3mnyn6vs9nqlsqqnejxf');
    assert.ok(w.weOwnAddress('bc1ptestlpef53v6vyku3f9rk0ve2mek2fdwnd9k6q3mnyn6vs9nqlsqqnejxf'));
  });

  it('can create transaction', () => {
    const w = new TaprootWallet();
    w.setSecret('L4PKRVk1Peaar5WuH5LiKfkTygWtFfGrFeH2g2t3YVVqiwpJjMoF');

    const utxos = [
      {
        height: 0,
        value: 10000,
        address: 'bc1pm6lqlel3qxefsx0v39nshtghasvvp6ghn3e5hd5q280j5m9h7csqrkzssu',
        txid: '4dc4c9a03dd7005310a313c5ef1754e5e53888d587073f01a5a662501c12ac3b',
        vout: 0,
      },
    ];

    // sendMax
    const txNew = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }],
      4,
      String(w.getAddress()),
      0xffffffff,
      false,
      0,
    );
    assert.ok(txNew.tx);

    assert.strictEqual(
      txNew.tx.toHex(),
      '020000000001013bac121c5062a6a5013f0787d58838e5e55417efc513a3105300d73da0c9c44d0000000000ffffffff0150250000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588ac0140fe709c8bc93582e749761438f76b4bc7d9820c4c321aa1849805f20bbeaba790bf0bb088031af50a75c0d7637c102d68322cfd77ce17342fdb22b19fef36e0b800000000',
    );

    // verifying:
    const tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 1);
    assert.strictEqual('13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
  });
});


================================================
FILE: ./tests/unit/hd-legacy-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { HDLegacyP2PKHWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('Legacy HD (BIP44)', () => {
  it('works', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }
    const hd = new HDLegacyP2PKHWallet();
    hd.setSecret(process.env.HD_MNEMONIC);
    assert.ok(hd.validateMnemonic());

    assert.strictEqual(
      hd.getXpub(),
      'xpub6ByZUAv558PPheJgcPYHpxPLwz8M7TtueYMAik84NADeQcvbzS8W3WxxJ3C9NzfYkMoChiMAumWbeEvMWhTVpH75NqGv5c9wF3wKDbfQShb',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), '186FBQmCV5W1xY7ywaWtTZPAQNciVN8Por');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '1J9zoJz5LsAJ361SQHYnLTWg46Tc2AXUCj');

    assert.strictEqual(hd._getInternalWIFByIndex(0), 'L4ojevRtK81A8Kof3qyLS2M7HvsVDbUDENNhJqU4vf79w9yGnQLb');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'Kz6kLhdyDfSbKuVH25XVqBRztjmFe8X22Xe1hnFzEv79gJNMkTAH');

    assert.ok(hd.getAllExternalAddresses().includes('186FBQmCV5W1xY7ywaWtTZPAQNciVN8Por'));
    assert.ok(!hd.getAllExternalAddresses().includes('1J9zoJz5LsAJ361SQHYnLTWg46Tc2AXUCj')); // not internal

    assert.strictEqual(
      uint8ArrayToHex(hd._getPubkeyByAddress(hd._getExternalAddressByIndex(0))),
      '0316e84a2556f30a199541633f5dda6787710ccab26771b7084f4c9e1104f47667',
    );
    assert.strictEqual(
      uint8ArrayToHex(hd._getPubkeyByAddress(hd._getInternalAddressByIndex(0))),
      '02ad7b2216f3a2b38d56db8a7ee5c540fd12c4bbb7013106eff78cc2ace65aa002',
    );

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/44'/0'/0'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/44'/0'/0'/1/0");
  });

  it('can create TX', async () => {
    if (!process.env.HD_MNEMONIC) {
      console.error('process.env.HD_MNEMONIC not set, skipped');
      return;
    }
    const hd = new HDLegacyP2PKHWallet();
    hd.setSecret(process.env.HD_MNEMONIC);
    assert.ok(hd.validateMnemonic());

    const utxo = [
      {
        height: 554830,
        value: 10000,
        address: '186FBQmCV5W1xY7ywaWtTZPAQNciVN8Por',
        vout: 0,
        txid: '4f65c8cb159585c00d4deba9c5b36a2bcdfb1399a561114dcf6f2d0c1174bc5f',
        wif: 'Kz6kLhdyDfSbKuVH25XVqBRztjmFe8X22Xe1hnFzEv79gJNMkTAH',
        confirmations: 1,
        txhex:
          '01000000000101e8d98effbb4fba4f0a89bcf217eb5a7e2f8efcae44f32ecacbc5d8cc3ce683c301000000171600148ba6d02e74c0a6e000e8b174eb2ed44e5ea211a6ffffffff0510270000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac204e0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac30750000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac409c0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac204716000000000017a914e286d58e53f9247a4710e51232cce0686f16873c8702483045022100af3800cd8171f154785cf13f46c092f61c1668f97db432bb4e7ed7bc812a8c6d022051bddca1eaf1ad8b5f3bd0ccde7447e56fd3c8709e5906f02ec6326e9a5b2ff30121039a421d5eb7c9de6590ae2a471cb556b60de8c6b056beb907dbdc1f5e6092f58800000000',
      },
      {
        height: 554830,
        value: 20000,
        address: '1J9zoJz5LsAJ361SQHYnLTWg46Tc2AXUCj',
        vout: 1,
        txid: '4f65c8cb159585c00d4deba9c5b36a2bcdfb1399a561114dcf6f2d0c1174bc5f',
        wif: 'L4ojevRtK81A8Kof3qyLS2M7HvsVDbUDENNhJqU4vf79w9yGnQLb',
        confirmations: 1,
        txhex:
          '01000000000101e8d98effbb4fba4f0a89bcf217eb5a7e2f8efcae44f32ecacbc5d8cc3ce683c301000000171600148ba6d02e74c0a6e000e8b174eb2ed44e5ea211a6ffffffff0510270000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac204e0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac30750000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac409c0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac204716000000000017a914e286d58e53f9247a4710e51232cce0686f16873c8702483045022100af3800cd8171f154785cf13f46c092f61c1668f97db432bb4e7ed7bc812a8c6d022051bddca1eaf1ad8b5f3bd0ccde7447e56fd3c8709e5906f02ec6326e9a5b2ff30121039a421d5eb7c9de6590ae2a471cb556b60de8c6b056beb907dbdc1f5e6092f58800000000',
      },
      {
        height: 554830,
        value: 30000,
        address: '186FBQmCV5W1xY7ywaWtTZPAQNciVN8Por',
        vout: 2,
        txid: '4f65c8cb159585c00d4deba9c5b36a2bcdfb1399a561114dcf6f2d0c1174bc5f',
        wif: 'Kz6kLhdyDfSbKuVH25XVqBRztjmFe8X22Xe1hnFzEv79gJNMkTAH',
        confirmations: 1,
        txhex:
          '01000000000101e8d98effbb4fba4f0a89bcf217eb5a7e2f8efcae44f32ecacbc5d8cc3ce683c301000000171600148ba6d02e74c0a6e000e8b174eb2ed44e5ea211a6ffffffff0510270000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac204e0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac30750000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac409c0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac204716000000000017a914e286d58e53f9247a4710e51232cce0686f16873c8702483045022100af3800cd8171f154785cf13f46c092f61c1668f97db432bb4e7ed7bc812a8c6d022051bddca1eaf1ad8b5f3bd0ccde7447e56fd3c8709e5906f02ec6326e9a5b2ff30121039a421d5eb7c9de6590ae2a471cb556b60de8c6b056beb907dbdc1f5e6092f58800000000',
      },
      {
        height: 554830,
        value: 40000,
        address: '1J9zoJz5LsAJ361SQHYnLTWg46Tc2AXUCj',
        vout: 3,
        txid: '4f65c8cb159585c00d4deba9c5b36a2bcdfb1399a561114dcf6f2d0c1174bc5f',
        wif: 'L4ojevRtK81A8Kof3qyLS2M7HvsVDbUDENNhJqU4vf79w9yGnQLb',
        confirmations: 1,
        txhex:
          '01000000000101e8d98effbb4fba4f0a89bcf217eb5a7e2f8efcae44f32ecacbc5d8cc3ce683c301000000171600148ba6d02e74c0a6e000e8b174eb2ed44e5ea211a6ffffffff0510270000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac204e0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac30750000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac409c0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac204716000000000017a914e286d58e53f9247a4710e51232cce0686f16873c8702483045022100af3800cd8171f154785cf13f46c092f61c1668f97db432bb4e7ed7bc812a8c6d022051bddca1eaf1ad8b5f3bd0ccde7447e56fd3c8709e5906f02ec6326e9a5b2ff30121039a421d5eb7c9de6590ae2a471cb556b60de8c6b056beb907dbdc1f5e6092f58800000000',
      },
    ];

    let txNew = hd.createTransaction(
      utxo,
      [{ address: '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', value: 80000 }],
      1,
      hd._getInternalAddressByIndex(hd.next_free_change_address_index),
    );
    let tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(tx.ins.length, 3);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual(tx.outs[0].value, 80000n); // payee
    assert.strictEqual(tx.outs[1].value, 9478n); // change
    let toAddress = bitcoin.address.fromOutputScript(tx.outs[0].script);
    const changeAddress = bitcoin.address.fromOutputScript(tx.outs[1].script);
    assert.strictEqual('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', toAddress);
    assert.strictEqual(hd._getInternalAddressByIndex(hd.next_free_change_address_index), changeAddress);

    // testing sendMax
    txNew = hd.createTransaction(
      utxo,
      [{ address: '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK' }],
      1,
      hd._getInternalAddressByIndex(hd.next_free_change_address_index),
    );
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(tx.ins.length, 4);
    assert.strictEqual(tx.outs.length, 1);
    toAddress = bitcoin.address.fromOutputScript(tx.outs[0].script);
    assert.strictEqual('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', toAddress);
  });

  it('can sign and verify messages', async () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDLegacyP2PKHWallet();
    hd.setSecret(mnemonic);
    let signature;

    // external address
    signature = hd.signMessage('vires is numeris', hd._getExternalAddressByIndex(0));
    assert.strictEqual(signature, 'H5J8DbqvuBy8lqRW7+LTVrrtrsaqLSwRDyj+5XtCrZpdCgPlxKM4EKRD6qvdKeyEh1fiSfIVB/edPAum3gKcJZo=');
    assert.strictEqual(hd.verifyMessage('vires is numeris', hd._getExternalAddressByIndex(0), signature), true);

    // internal address
    signature = hd.signMessage('vires is numeris', hd._getInternalAddressByIndex(0));
    assert.strictEqual(signature, 'H98hmvtyPFUbR6E5Tcsqmc+eSjlYhP2vy41Y6IyHS9DVKEI5n8VEMpIEDtvlMARVce96nOqbRHXo9nD05WXH/Eo=');
    assert.strictEqual(hd.verifyMessage('vires is numeris', hd._getInternalAddressByIndex(0), signature), true);
  });

  it('can show fingerprint', async () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDLegacyP2PKHWallet();
    hd.setSecret(mnemonic);
    assert.strictEqual(hd.getMasterFingerprintHex(), '73C5DA0A');
  });

  // from electrum tests https://github.com/spesmilo/electrum/blob/9c1a51547a301e765b9b0f9935c6d940bb9d658e/electrum/tests/test_wallet_vertical.py#L292
  it('can use mnemonic with passphrase', () => {
    const mnemonic = 'treat dwarf wealth gasp brass outside high rent blood crowd make initial';
    const UNICODE_HORROR = '          who knws wat horrors le in the dark heart f uncode?';
    const hd = new HDLegacyP2PKHWallet();
    hd.setSecret(mnemonic);
    hd.setPassphrase(UNICODE_HORROR);

    assert.strictEqual(
      hd.getXpub(),
      'xpub6D85QDBajeLe2JXJrZeGyQCaw47PWKi3J9DPuHakjTkVBWCxVQQkmMVMSSfnw39tj9FntbozpRtb1AJ8ubjeVSBhyK4M5mzdvsXZzKPwodT',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), '1F88g2naBMhDB7pYFttPWGQgryba3hPevM');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '1H4QD1rg2zQJ4UjuAVJr5eW1fEM8WMqyxh');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'L3HLzdVcwo4711gFiZG4fiLzLVNJpR6nejfo6J85wuYn9YF2G5zk');
  });

  it('can create with custom derivation path', async () => {
    const hd = new HDLegacyP2PKHWallet();
    hd.setSecret('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');
    hd.setDerivationPath("m/44'/0'/1'");

    assert.strictEqual(
      hd.getXpub(),
      'xpub6BosfCnifzxcJJ1wYuntGJfF2zPJkDeG9ELNHcKNjezuea4tumswN9sH1psMdSVqCMoJC21Bv8usSeqSP4Sp1tLzW7aY59fGn9GCYzx5UTo',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), '15qucUWKf95Fo58FdCBhUTSAtsm22HHE2Q');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '1DgjtFUiXvqxGic9A9fiDPrHNyKC4cGtTH');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'KzReLDRfwGJ7bBH6WjLQ36e2WxjHob3d61EKnZQT86nutd5tpkvC');

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/44'/0'/1'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/44'/0'/1'/1/0");
  });
});


================================================
FILE: ./tests/unit/hd-aezeed.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { HDAezeedWallet, WatchOnlyWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('HDAezeedWallet', () => {
  it('can import mnemonics and generate addresses and WIFs', async function () {
    const aezeed = new HDAezeedWallet();

    aezeed.setSecret('bs');
    assert.ok(!(await aezeed.validateMnemonicAsync()));
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));

    // correct pass:
    aezeed.setSecret(
      'able mix price funny host express lawsuit congress antique float pig exchange vapor drip wide cup style apple tumble verb fix blush tongue market',
    );
    aezeed.setPassphrase('strongPassword');
    assert.ok(await aezeed.validateMnemonicAsync());
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));

    // no pass but its required:
    aezeed.setSecret(
      'able mix price funny host express lawsuit congress antique float pig exchange vapor drip wide cup style apple tumble verb fix blush tongue market',
    );
    aezeed.setPassphrase();
    assert.ok(!(await aezeed.validateMnemonicAsync()));
    assert.ok(await aezeed.mnemonicInvalidPassword());

    // wrong pass:
    aezeed.setSecret(
      'able mix price funny host express lawsuit congress antique float pig exchange vapor drip wide cup style apple tumble verb fix blush tongue market',
    );
    aezeed.setPassphrase('badpassword');
    assert.ok(!(await aezeed.validateMnemonicAsync()));
    assert.ok(await aezeed.mnemonicInvalidPassword());

    aezeed.setSecret(
      'able concert slush lend olive cost wagon dawn board robot park snap dignity churn fiction quote shrimp hammer wing jump immune skill sunset west',
    );
    aezeed.setPassphrase();
    assert.ok(await aezeed.validateMnemonicAsync());
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));

    aezeed.setSecret(
      'able concert slush lend olive cost wagon dawn board robot park snap dignity churn fiction quote shrimp hammer wing jump immune skill sunset west',
    );
    aezeed.setPassphrase('aezeed');
    assert.ok(await aezeed.validateMnemonicAsync());
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));

    aezeed.setSecret(
      'abstract rhythm weird food attract treat mosquito sight royal actor surround ride strike remove guilt catch filter summer mushroom protect poverty cruel chaos pattern',
    );
    aezeed.setPassphrase();
    assert.ok(await aezeed.validateMnemonicAsync());
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));

    assert.strictEqual(
      aezeed.getXpub(),
      'zpub6rkAmx9z6PmK7tBpGQatqpRweZvRw7uqiEMRS9KuZA9VFKUSoz3GQeJFtRQsQwduWugh5mGHro1tGnt78ci9AiB8qEH4hCRBWxdMaxadGVy',
    );

    let address = aezeed._getExternalAddressByIndex(0);
    assert.strictEqual(address, 'bc1qdjj7lhj9lnjye7xq3dzv3r4z0cta294xy78txn');
    assert.ok(aezeed.getAllExternalAddresses().includes('bc1qdjj7lhj9lnjye7xq3dzv3r4z0cta294xy78txn'));

    address = aezeed._getExternalAddressByIndex(1);
    assert.strictEqual(address, 'bc1qswr3s4fylskqn9vemef8l28qukshuagsjz3wpe');
    assert.ok(aezeed.getAllExternalAddresses().includes('bc1qswr3s4fylskqn9vemef8l28qukshuagsjz3wpe'));

    address = aezeed._getInternalAddressByIndex(0);
    assert.strictEqual(address, 'bc1qzyjq8sjj56n8v9fgw5klsc8sq8yuy0jx03hzzp');

    let wif = aezeed._getExternalWIFByIndex(0);
    assert.strictEqual(wif, 'KxtkgprHVXCcgzRetDt3JnNuRApgzQyRrvAuwiE1yFPjmYnWh6rH');

    wif = aezeed._getInternalWIFByIndex(0);
    assert.strictEqual(wif, 'L1dewhNXkVMB3JdoXYRikbz6g4CbaMGfSqSXSrmTkk5PvzmEgpdT');

    assert.strictEqual(aezeed.getIdentityPubkey(), '0384b9a7158320e828280075224af324931ca9d6de4334f724dbb553ffee447164');

    // we should not really test private methods, but oh well
    assert.strictEqual(
      uint8ArrayToHex(aezeed._getNodePubkeyByIndex(0, 0)),
      '03ed28668d446c6e2ac11e4848f7afd894761ad26569baa8a16adff723699f2c07',
    );
    assert.strictEqual(
      uint8ArrayToHex(aezeed._getNodePubkeyByIndex(1, 0)),
      '0210791263114fe72ab5a2131ca1986b84c62a93e30ee9d509266f1eadf4febaf2',
    );
    assert.strictEqual(
      uint8ArrayToHex(aezeed._getPubkeyByAddress(aezeed._getExternalAddressByIndex(1))),
      uint8ArrayToHex(aezeed._getNodePubkeyByIndex(0, 1)),
    );
    assert.strictEqual(
      uint8ArrayToHex(aezeed._getPubkeyByAddress(aezeed._getInternalAddressByIndex(1))),
      uint8ArrayToHex(aezeed._getNodePubkeyByIndex(1, 1)),
    );
  });

  it('watch-only from zpub produces correct addresses', async () => {
    const aezeed = new HDAezeedWallet();
    aezeed.setSecret(
      'abstract rhythm weird food attract treat mosquito sight royal actor surround ride strike remove guilt catch filter summer mushroom protect poverty cruel chaos pattern',
    );
    assert.ok(await aezeed.validateMnemonicAsync());
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));

    assert.strictEqual(
      aezeed.getXpub(),
      'zpub6rkAmx9z6PmK7tBpGQatqpRweZvRw7uqiEMRS9KuZA9VFKUSoz3GQeJFtRQsQwduWugh5mGHro1tGnt78ci9AiB8qEH4hCRBWxdMaxadGVy',
    );

    const address = aezeed._getExternalAddressByIndex(0);
    assert.strictEqual(address, 'bc1qdjj7lhj9lnjye7xq3dzv3r4z0cta294xy78txn');
    assert.ok(aezeed.getAllExternalAddresses().includes('bc1qdjj7lhj9lnjye7xq3dzv3r4z0cta294xy78txn'));

    const watchOnly = new WatchOnlyWallet();
    watchOnly.setSecret(aezeed.getXpub());
    watchOnly.init();
    assert.strictEqual(watchOnly._getExternalAddressByIndex(0), aezeed._getExternalAddressByIndex(0));
    assert.ok(watchOnly.weOwnAddress('bc1qdjj7lhj9lnjye7xq3dzv3r4z0cta294xy78txn'));
    assert.ok(!watchOnly.weOwnAddress('garbage'));
    assert.ok(!watchOnly.weOwnAddress(false));
  });

  it('can sign and verify messages', async () => {
    const aezeed = new HDAezeedWallet();
    aezeed.setSecret(
      'abstract rhythm weird food attract treat mosquito sight royal actor surround ride strike remove guilt catch filter summer mushroom protect poverty cruel chaos pattern',
    );
    assert.ok(await aezeed.validateMnemonicAsync());
    assert.ok(!(await aezeed.mnemonicInvalidPassword()));
    let signature;

    // external address
    signature = aezeed.signMessage('vires is numeris', aezeed._getExternalAddressByIndex(0));
    assert.strictEqual(signature, 'J9zF7mdGGdc/9HMlvor6Zl7ap1qseQpiBDJ4oaSpkzbQGGhdfkM6LHo6m9BV8o/BlqiQI1vuODaNlBFyeyIWgfE=');
    assert.strictEqual(aezeed.verifyMessage('vires is numeris', aezeed._getExternalAddressByIndex(0), signature), true);

    // internal address
    signature = aezeed.signMessage('vires is numeris', aezeed._getInternalAddressByIndex(0));
    assert.strictEqual(signature, 'KIda06aSswmo9NiAYNUBRADA9q1v39raSmHHVg56+thtah5xL7hVw/x+cZgydFNyel2bXfyGluJRaP1uRQfJtzo=');
    assert.strictEqual(aezeed.verifyMessage('vires is numeris', aezeed._getInternalAddressByIndex(0), signature), true);
  });
});


================================================
FILE: ./tests/unit/segwit-p2sh-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { SegwitP2SHWallet } from '../../class';

describe('Segwit P2SH wallet', () => {
  it('can create transaction', async () => {
    const wallet = new SegwitP2SHWallet();
    wallet.setSecret('Ky1vhqYGCiCbPd8nmbUeGfwLdXB1h5aGwxHwpXrzYRfY5cTZPDo4');
    assert.strictEqual(wallet.getAddress(), '3CKN8HTCews4rYJYsyub5hjAVm5g5VFdQJ');
    assert.deepStrictEqual(wallet.getAllExternalAddresses(), ['3CKN8HTCews4rYJYsyub5hjAVm5g5VFdQJ']);
    assert.strictEqual(await wallet.getChangeAddressAsync(), wallet.getAddress());
    assert.strictEqual(await wallet.getAddressAsync(), wallet.getAddress());

    const utxos = [
      {
        txid: 'a56b44080cb606c0bd90e77fcd4fb34c863e68e5562e75b4386e611390eb860c',
        vout: 0,
        value: 300000,
      },
    ];

    let txNew = wallet.createTransaction(utxos, [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], 1, wallet.getAddress());
    let tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    const satPerVbyte = txNew.fee / tx.virtualSize();
    assert.strictEqual(Math.round(satPerVbyte), 1);
    assert.strictEqual(
      txNew.tx.toHex(),
      '020000000001010c86eb9013616e38b4752e56e5683e864cb34fcd7fe790bdc006b60c08446ba50000000017160014139dc70d73097f9d775f8a3280ba3e3435515641ffffffff02905f0100000000001976a914aa381cd428a4e91327fd4434aa0a08ff131f1a5a88aca73303000000000017a914749118baa93fb4b88c28909c8bf0a8202a0484f4870248304502210080545d30e3d30dff272ab11c91fd6150170b603239b48c3d56a3fa66bf240085022003762404e1b45975adc89f61ec1569fa19d6d4a8d405e060897754c489ebeade012103a5de146762f84055db3202c1316cd9008f16047f4f408c1482fdb108217eda0800000000',
    );
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual(bitcoin.address.fromOutputScript(tx.outs[1].script), wallet.getAddress()); // change address

    // sendMax
    txNew = wallet.createTransaction(utxos, [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], 1, wallet.getAddress());
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 1);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
  });

  it('can sign and verify messages', async () => {
    const l = new SegwitP2SHWallet();
    l.setSecret('L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1'); // from bitcoinjs-message examples

    const signature = l.signMessage('This is an example of a signed message.', l.getAddress());
    assert.strictEqual(signature, 'I9L5yLFjti0QTHhPyFrZCT1V/MMnBtXKmoiKDZ78NDBjERki6ZTQZdSMCtkgoNmp17By9ItJr8o7ChX0XxY91nk=');
    assert.strictEqual(l.verifyMessage('This is an example of a signed message.', l.getAddress(), signature), true);
  });
});


================================================
FILE: ./tests/unit/multisig-hd-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import Base43 from '../../malin_modules/base43';
import { MalinURDecoder, decodeUR, encodeUR } from '../../malin_modules/ur';
import { MultisigHDWallet } from '../../class/';
import { MultisigCosigner } from '../../class/multisig-cosigner';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

const fp1cobo = 'D37EAD88';
const Zpub1 = 'Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ';

const fp2coldcard = '168DD603';
const Zpub2 = 'Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn';

const txtFileFormatMultisigLegacy =
  'UR:BYTES/TYQHZGEQGDHKYM6KV96KCAPQF46KCARFWD5KWGRNV4682UPQVE5KCEFQ9P3HYETPW3JKGGR0DCSYGVEHG4Q5GWPC9Y9ZXZJWV9KK2W3QGDT97DPNGVER2VEJGF0NYTFJPFGX7MRFVDUN5GPJYPHKVGPJPFZX2UNFWESHG6T0DCAZQMF0XS6JWZJXDAEX6CT58GS9QVJNFQ9Q53PNXAZ5Z3PC8QAZQ7RSW43RVW2NVERXS3E4V4QNJCM30PYYKNFKVGC5S6ZCF4CYG7NFWP24Q3ZZFEX5YUN2FEN4W4MZVFAYKUTWW9MHSVNDWEXHJS34VFFXWM2VG95NWC6ZVAERSET4W4ARGNRK0GEK6C2H0PCXV4TDV3XNWVTY09GH2AN3XCUX64ZPGU6YXUQ2XYMRS3ZYXCCRXW3Q0PC82C3K8Q6RW4EKVDV42UT3X35HSCMDGE3RSVMFW9G8GJJ6VEHY65Z5DDC9J62RWD6427TZ0FR8QUZ2WQE8Z7NGXD95X4JGWDXYW5TEX3TKSCTCGACKKJEEV9ZYGKNW2DNXSS3EXFGXKJZYFD5KSCJGXET5C7N50FK5UD6H2UU5WKTS2G9QHU0U3D';
const txtFileFormatMultisigWrappedSegwit =
  'UR:BYTES/TYQCQGEQGDHKYM6KV96KCAPQF46KCARFWD5KWGRNV4682UPQVE5KCEFQ9P3HYETPW3JKGGR0DCSYGVEHG4Q5GWPC9Y9ZXZJWV9KK2W3QGDT97S6PXU6YV32ZGE0NYTFJPFGX7MRFVDUN5GPJYPHKVGPJPFZX2UNFWESHG6T0DCAZQMF0XSUZWTESYUHNQFE0XYNS53N0WFKKZAP6YPGRY46NFQK4QVJNFQ9Q53PNXAZ5Z3PC8QAZQKTSW43RV6N524VRZVJTGA3HZ3N0WDD9W5P5T935SCEEW93YK5J5WEN5YURZ8PS52DFCDPE4JUTZ0YE4X52K23ER2J68VEXK6EZDVUENSETTD4GNJ62VDPPKGEMZG93X56TGXAQ4W5MTGYMHQE6JDP55CENPDQEH54PKW5C4Q3NK2EZKYCC2XYMRS3ZYXCCRXW3QT9C82C3KDDM8GAJ5TFC8Z3M42A69ZEN8893YCDTCV568V3ZHW3MHX6TJ2GUYC7JYWEE4JVMKVAV8V7TWVDTNZNJ8TPP42J3E2PENWSMFD9A9X56V2CMYUMNWTPF4J72KG3H8SSM4XGM9ZSMG2AA9WNR8X4V5XS2GV9KNVC6EDFRHG7JJ0G9QPZ2FEZ';
const txtFileFormatMultisigNativeSegwit =
  'UR:BYTES/TYQHKGEQGDHKYM6KV96KCAPQF46KCARFWD5KWGRNV4682UPQVE5KCEFQ9P3HYETPW3JKGGR0DCSYGVEHG4Q5GWPC9Y9ZXZJWV9KK2W3QGDT97VENGG65YWF3G90NYTFJPFGX7MRFVDUN5GPJYPHKVGPJPFZX2UNFWESHG6T0DCAZQMF0XSUZWTESYUHNQFE0XGNS53N0WFKKZAP6YPGRY46NFQ9Q53PNXAZ5Z3PC8QAZQKNSW43RWDRFDFCXV6Z92F9YU6NGGD94S5NNWP2XGNZ22C6K2M69D4F4YKNYFPC5GANS8944VARY2EZHJ62CDVMHQKRC2F3XVKN629M8X3ZXWPNYGJZ9FPT8G4NS0Q6YG73EG3R42468DCE9S6E40FRN2AF5X4G4GNTNT9FNYAN2DA5YU5G2XYMRS3ZYXCCRXW3QTFC82C3HX4K5Z3FCG448J7ZN0FHHJ5RDGAHXGD29XEXHJ3PHG9XYWNNWV3E824MKX5E8SUR6D9K4552TW44HWAJ9VEV9GJR3D4YRSMNZVF3NVCMR2Q6HGVNPF5EK6AMNXDCYKK2NDE9HQJ6DF4UHGERZFEZ453J40P9H57N5T9RY6WZSDC9QWZ5LU2';
const coldcardExport =
  '{"p2sh_deriv":"m/45\'","p2sh":"xpub6847W6cYUqq4ixcmFb83iqPtJZfnMPTkpYiCsuUybzFppJp2qzh3KCVHsLGQy4WhaxGqkK9aDDZnSfhB92PkHDKihbH6WLztzmN7WW9GYpR","p2wsh_p2sh_deriv":"m/48\'/0\'/0\'/1\'","p2wsh_p2sh":"Ypub6kvtvTZpqGuWtQfg9bL5xe4vDWtwsirR8LzDvsY3vgXvyncW1NGXCUJ9Ps7CiizSSLV6NnnXSYyVDnxCu26QChWzWLg5YCAHam6cYjGtzRz","p2wsh_deriv":"m/48\'/0\'/0\'/2\'","p2wsh":"Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn","xfp":"168DD603"}';
const electumJson =
  '{"x2/": {"xpub": "Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn", "hw_type": "coldcard", "ckcc_xfp": 64392470, "label": "Coldcard", "derivation": "m/48\'/1\'/0\'/1\'", "type": "hardware"}, "x1/": {"xpub": "Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ", "hw_type": "coldcard", "ckcc_xfp": 2293071571, "label": "Coldcard", "derivation": "m/48\'/1\'/0\'/1\'", "type": "hardware"}, "wallet_type": "2of2", "use_encryption": false, "seed_version": 17}';

describe('multisig-wallet (p2sh)', () => {
  if (!process.env.MNEMONICS_COBO) {
    console.error('process.env.MNEMONICS_COBO not set, skipped');
    return;
  }
  if (!process.env.MNEMONICS_COLDCARD) {
    console.error('process.env.MNEMONICS_COLDCARD not set, skipped');
    return;
  }

  it('basic operations work', async () => {
    const w = new MultisigHDWallet();
    w.setSecret(txtFileFormatMultisigLegacy);

    assert.strictEqual(w.getDerivationPath(), "m/45'");
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
    assert.strictEqual(
      w.getCosigner(1),
      'xpub69SfFhG5eA9cqxHKM6b1HhXMpDzipUPDBNMBrjNgWWbbzKqnqwx2mvMyB5bRgmLAi7cBgr8euuz4Lvz3maWxpfUmdM71dyQuvq68mTAG4Cp',
    );
    assert.strictEqual(
      w.getCosigner(2),
      'xpub6847W6cYUqq4ixcmFb83iqPtJZfnMPTkpYiCsuUybzFppJp2qzh3KCVHsLGQy4WhaxGqkK9aDDZnSfhB92PkHDKihbH6WLztzmN7WW9GYpR',
    );
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w.getCosigner(1));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w.getCosigner(2));
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFormat(), MultisigHDWallet.FORMAT_P2SH);

    assert.strictEqual(w._getExternalAddressByIndex(0), '3J5xQcgBqoykSHhmDJLYp87SgVSNhYrvnz');
    assert.strictEqual(w._getExternalAddressByIndex(1), '3GkEXFYUifSmQ9SgzJDWL37pjMj4LT6vbq');
    assert.strictEqual(w._getInternalAddressByIndex(0), '365MagKko4t7L9XPXSYGkFj23dknTCx4UW');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36j8Qx6vxUknTxGFa5yYuxifEK9PGPEKso');
    assert.ok(!w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(w.isLegacy());
  });

  it('can coordinate tx creation', async () => {
    const utxos = [
      {
        height: 666,
        value: 100000,
        address: '3J5xQcgBqoykSHhmDJLYp87SgVSNhYrvnz',
        vout: 0,
        txid: '630a227c0b4ca30bc98689d40d31e0407fcc5d61730ce1fa548b26630efddeec',
        wif: false,
        confirmations: 666,
        script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
        txhex:
          '0200000000010211f8cdc7b1255b8d3eb951db2fc6964766aaf6e6d1b42e777c90a52977b3e8e50000000000ffffffff00696f18c09d884c100254825f3ca4f41ca35fbb5e988d3526cbdcfcb30c335b0000000000ffffffff02a08601000000000017a914b3d8a5081a9477dd5d354d4c8a7efc0e64689d1087e8340f0000000000160014eef1091149ba3658a5dfe9c8a8924b3a4f0e1baa02473044022068548d4369730e90f33d4243420b40d4c7ef240bbac1db33354c0e108d503f24022062adcc1d19756bcb3ecae9fe988af7c3147ba7df5ff6b26f4a135037669fcef001210211edf8b518a1ac28d1f9a956a5ddeddaea0df435f2386e7fb86f0e9fde818dda0247304402203140f8ee8311562f15eb1f062f3be98fbe41615262491ad5625d8541ce2e4386022077343891d341112a2b75647d5a1faec0f0a79dac8052249e22eb39591a4bb70c0121023f05c145e61311eb725fdea9834fe20c4e7bbb639def8e47137a2696001f9e9d00000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.setSecret(txtFileFormatMultisigLegacy);

    assert.strictEqual(w.getDerivationPath(), "m/45'");
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
    assert.strictEqual(
      w.getCosigner(1),
      'xpub69SfFhG5eA9cqxHKM6b1HhXMpDzipUPDBNMBrjNgWWbbzKqnqwx2mvMyB5bRgmLAi7cBgr8euuz4Lvz3maWxpfUmdM71dyQuvq68mTAG4Cp',
    );
    assert.strictEqual(
      w.getCosigner(2),
      'xpub6847W6cYUqq4ixcmFb83iqPtJZfnMPTkpYiCsuUybzFppJp2qzh3KCVHsLGQy4WhaxGqkK9aDDZnSfhB92PkHDKihbH6WLztzmN7WW9GYpR',
    );
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w.getCosigner(1));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w.getCosigner(2));
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);

    assert.strictEqual(w._getExternalAddressByIndex(0), '3J5xQcgBqoykSHhmDJLYp87SgVSNhYrvnz');
    assert.strictEqual(w._getExternalAddressByIndex(1), '3GkEXFYUifSmQ9SgzJDWL37pjMj4LT6vbq');
    assert.strictEqual(w._getInternalAddressByIndex(0), '365MagKko4t7L9XPXSYGkFj23dknTCx4UW');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36j8Qx6vxUknTxGFa5yYuxifEK9PGPEKso');
    assert.ok(!w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(w.isLegacy());

    // transaction is gona be UNsigned because we have no keys
    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 10000 }],
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(!tx, 'tx should not be provided when PSBT is only partially signed');
    assert.throws(() => psbt.finalizeAllInputs().extractTransaction());

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 0);
    assert.ok(w.calculateFeeFromPsbt(psbt) < 3000);
    assert.ok(w.calculateFeeFromPsbt(psbt) > 0);

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHUCAAAAAeze/Q5jJotU+uEMc2FdzH9A4DEN1ImGyQujTAt8IgpjAAAAAAAAAACAAhAnAAAAAAAAGXapFBkSnVPmMZuvGdugWb6tFm35Crj1iKy8VgEAAAAAABepFPI8FESPOvVVeCas7ULqnnFYnc5JhwAAAAAAAQD9cwECAAAAAAECEfjNx7ElW40+uVHbL8aWR2aq9ubRtC53fJClKXez6OUAAAAAAP////8AaW8YwJ2ITBACVIJfPKT0HKNfu16YjTUmy9z8swwzWwAAAAAA/////wKghgEAAAAAABepFLPYpQgalHfdXTVNTIp+/A5kaJ0Qh+g0DwAAAAAAFgAU7vEJEUm6Nlil3+nIqJJLOk8OG6oCRzBEAiBoVI1DaXMOkPM9QkNCC0DUx+8kC7rB2zM1TA4QjVA/JAIgYq3MHRl1a8s+yun+mIr3wxR7p99f9rJvShNQN2afzvABIQIR7fi1GKGsKNH5qVal3e3a6g30NfI4bn+4bw6f3oGN2gJHMEQCIDFA+O6DEVYvFesfBi876Y++QWFSYkka1WJdhUHOLkOGAiB3NDiR00ERKit1ZH1aH67A8KedrIBSJJ4i6zlZGku3DAEhAj8FwUXmExHrcl/eqYNP4gxOe7tjne+ORxN6JpYAH56dAAAAAAEER1IhAuKpQFZsreTHbjczMj+gmPaW2MpWjN/NE9t30TCFV6boIQMM4zcNTGSH1VK788aPJgBwsMhTJ20S4lg/3JkC8mJIjVKuIgYC4qlAVmyt5MduNzMyP6CY9pbYylaM380T23fRMIVXpugQFo3WAy0AAIAAAAAAAAAAACIGAwzjNw1MZIfVUrvzxo8mAHCwyFMnbRLiWD/cmQLyYkiNENN+rYgtAACAAAAAAAAAAAAAAAEAR1IhAoJkVao8TQcPGdH2rhAUNLNEoDTaWVlIZXZEEk77O3NoIQOJYtHCrnVaHKX4kVFrtjn9dVGJENMKTTOYLAY/aCS3rFKuIgICgmRVqjxNBw8Z0fauEBQ0s0SgNNpZWUhldkQSTvs7c2gQ036tiC0AAIABAAAAAwAAACICA4li0cKudVocpfiRUWu2Of11UYkQ0wpNM5gsBj9oJLesEBaN1gMtAACAAQAAAAMAAAAA',
    );

    // signed it on real coldcard device:
    const partSignedFromColdcard =
      'cHNidP8BAHUCAAAAAeze/Q5jJotU+uEMc2FdzH9A4DEN1ImGyQujTAt8IgpjAAAAAAAAAACAAhAnAAAAAAAAGXapFBkSnVPmMZuvGdugWb6tFm35Crj1iKy8VgEAAAAAABepFPI8FESPOvVVeCas7ULqnnFYnc5JhwAAAAAAAQD9cwECAAAAAAECEfjNx7ElW40+uVHbL8aWR2aq9ubRtC53fJClKXez6OUAAAAAAP////8AaW8YwJ2ITBACVIJfPKT0HKNfu16YjTUmy9z8swwzWwAAAAAA/////wKghgEAAAAAABepFLPYpQgalHfdXTVNTIp+/A5kaJ0Qh+g0DwAAAAAAFgAU7vEJEUm6Nlil3+nIqJJLOk8OG6oCRzBEAiBoVI1DaXMOkPM9QkNCC0DUx+8kC7rB2zM1TA4QjVA/JAIgYq3MHRl1a8s+yun+mIr3wxR7p99f9rJvShNQN2afzvABIQIR7fi1GKGsKNH5qVal3e3a6g30NfI4bn+4bw6f3oGN2gJHMEQCIDFA+O6DEVYvFesfBi876Y++QWFSYkka1WJdhUHOLkOGAiB3NDiR00ERKit1ZH1aH67A8KedrIBSJJ4i6zlZGku3DAEhAj8FwUXmExHrcl/eqYNP4gxOe7tjne+ORxN6JpYAH56dAAAAACICAuKpQFZsreTHbjczMj+gmPaW2MpWjN/NE9t30TCFV6boRzBEAiA7xMszlRAzEJDo++ZfweUQ1qQS+N7hCHnuZe9ifT11swIgFzcqL0y6iTN9OqIIfLLYA7aydcK3EgtCIpjPl+u//kQBAQMEAQAAACIGAwzjNw1MZIfVUrvzxo8mAHCwyFMnbRLiWD/cmQLyYkiNENN+rYgtAACAAAAAAAAAAAAiBgLiqUBWbK3kx243MzI/oJj2ltjKVozfzRPbd9EwhVem6BAWjdYDLQAAgAAAAAAAAAAAAQRHUiEC4qlAVmyt5MduNzMyP6CY9pbYylaM380T23fRMIVXpughAwzjNw1MZIfVUrvzxo8mAHCwyFMnbRLiWD/cmQLyYkiNUq4AACICAoJkVao8TQcPGdH2rhAUNLNEoDTaWVlIZXZEEk77O3NoENN+rYgtAACAAQAAAAMAAAAiAgOJYtHCrnVaHKX4kVFrtjn9dVGJENMKTTOYLAY/aCS3rBAWjdYDLQAAgAEAAAADAAAAAQBHUiECgmRVqjxNBw8Z0fauEBQ0s0SgNNpZWUhldkQSTvs7c2ghA4li0cKudVocpfiRUWu2Of11UYkQ0wpNM5gsBj9oJLesUq4A\n';
    const psbtFromColdcard = bitcoin.Psbt.fromBase64(partSignedFromColdcard);

    assert.throws(() => psbt.finalizeAllInputs().extractTransaction());
    psbt.combine(psbtFromColdcard); // should not throw an exception

    // signed on real Cobo device:
    const psbtFromCobo = bitcoin.Psbt.fromHex(
      decodeUR([
        'UR:BYTES/2OF2/HLCR0ERXVY0S4LY2V6EQUVEXL5XHRNEYC09GZVDX3T7H2KKLX5ASZWFVZJ/Q80ZVKVU4ZQE3PY8GL0N9LS09ZRT2GYHCMMSSS70WVHHKYLFAWKESYGQHXU4Z7N963YEH6W4ZPP7T9KQRK6E8TS4HZG95YG5CE7T7H0L7GSQJYQSRPN3NWR2VVJRA254M70RG7FSQWZCVS5E8D5FWYKPLMJVS9UNZFZX5WVZYQGSZ43YDGF3RAXYWQWRZWYF4JN3KC0QWN3QXJ7FW7WZH8YG9E7ZRE8GZYPEZ7VKKF4HERFVNYHGUF9XVF5X03TJSDSXTYHZXGSKM589KTC2K6QGPQVZQZQQQQQQSG36JYYPW922Q2EK2MEX8DCMNXV3L5ZV0D9KCEFTGEH7DZ0DH05FSS4T6D6PPQVXWXDCDF3JG042JH0EUDREXQPCTPJZNYAK39CJC8LWFJQHJVFYG654WYGRQ9C4FGPTXET0YCAHRWVEJ87SF3A5KMR99DRXLE5FAKA73XZZ40FHGZQTGM4SR95QQPQQQQQQQQQQQQQQZYPSRPN3NWR2VVJRA254M70RG7FSQWZCVS5E8D5FWYKPLMJVS9UNZFZX3P5M74KYZ6QQQSQQQQQQQQQQQQQQQQQQSQ36JYYPGYEZ44G7Y6PC0R8GLDTSSZS6TX39QXND9JK2GV4MYGYJWLVAHX6PPQWYK95WZ4E645899LZG4Z6AK887H25VFZRFS5NFNNQKQV0MGYJM6C54WYGPQ9QNY2K4RCNG8PUVARA4WZQ2RFV6Y5Q6D5K2EFPJHV3QJFMANKUMGZRFHATVG95QQPQQPQQQQQQCQQQQZYQSR393DRS4WW4DPEF0CJ9GKHD3EL464RZGS6V9Y6VUC9SRR76PYK7KPQ95D6CPJ6QQQSQQSQQQQQVQQQQQQ7C43S3',
        'UR:BYTES/1OF2/HLCR0ERXVY0S4LY2V6EQUVEXL5XHRNEYC09GZVDX3T7H2KKLX5ASZWFVZJ/TYZR5URNVF607QGQW5PQQQQQQ8KDALGWVVNGK486UYX8XC2AE3L5PCP3PH2GNPKFPW35CZMUYG9XXQQQQQQQQQQQQZQQYYP8QQQQQQQQQQVHD2G5RYFF65LXXXD67XWM5PVMATGKDHUS4W843ZKTC4SPQQQQQQQQZ753FU3UZ3ZG7WH424UZDT8DGT4FUU2CNH8YNPCQQQQQQQQPQR7HXQGZQQQQQQQPQGGL3NW8KYJ4HRF7H9GAKT7XJERKD2HKUMGMGTNH0JG222THK05W2QQQQQQQPLLLLLLSQ6T0RRQFMZZVZQP9FQJL8JJ0G89RT7A4AXYDX5NVHH8UKVXRXKCQQQQQQQ8LLLLL7Q4QSCQSQQQQQQQP02G5K0V22ZQ6J3MA6HF4F4XG5LHUPEJX38GSSL5RGRCQQQQQQQQKQQ2WAUGFZ9YM5DJC5H07NJ9GJF9N5NCWRW4QY3ESGSPZQ6Z534PKJUCWJREN6SJRGG95P4X8AUJQHWKPMVEN2NQWZZX4Q0EYQGSX9TWVR5VH267T8M9WNL5C3TMUX9RM5L04LA4JDA9PX5PHV60UAUQPYYPPRM0CK5V2RTPG68U6J449MHKA46SD7S6LYWRW07UX7R5LM6QCMKSZGUCYGQ3QX9Q03M5RZ9TZ790TRURZ7WLF37LYZC2JVFY344TZTKZ5RN3WGWRQYGRHXSUFR56PZY4ZKATY04DPLTKQ7ZNEMTYQ2GJFUGHT89V35JAHPSQJZQ3LQHQ5TESNZ84HYH774XP5LCSVFEAMKCUAA78YWYM6Y6TQQ8U7N5QQQQQQYGPQ9C4FGPTXET0YCAHRWVEJ87SF3A5KMR99DRXLE5FAKA73XZZ40FHGGUCYGQ3',
      ]),
    );

    psbt.combine(psbtFromCobo);
    const txhex = psbt.finalizeAllInputs().extractTransaction().toHex();
    assert.strictEqual(
      txhex,
      '0200000001ecdefd0e63268b54fae10c73615dcc7f40e0310dd48986c90ba34c0b7c220a6300000000d90047304402203bc4cb339510331090e8fbe65fc1e510d6a412f8dee10879ee65ef627d3d75b3022017372a2f4cba89337d3aa2087cb2d803b6b275c2b7120b422298cf97ebbffe440147304402202ac48d42623e988e038627113594e36c3c0e9c4069792ef385739105cf843c9d0220722f32d64d6f91a59325d1c494cc4d0cf8ae506c0cb25c46442dba1cb65e156d0147522102e2a940566cade4c76e3733323fa098f696d8ca568cdfcd13db77d1308557a6e821030ce3370d4c6487d552bbf3c68f260070b0c853276d12e2583fdc9902f262488d52ae000000800210270000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588acbc5601000000000017a914f23c14448f3af5557826aced42ea9e71589dce498700000000',
    );
  });

  it('can coordinate tx creation and sign 1 of 2', async () => {
    const path = "m/45'";

    const utxos = [
      {
        height: 666,
        value: 100000,
        address: '3J5xQcgBqoykSHhmDJLYp87SgVSNhYrvnz',
        vout: 0,
        txid: '630a227c0b4ca30bc98689d40d31e0407fcc5d61730ce1fa548b26630efddeec',
        wif: false,
        confirmations: 666,
        script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
        txhex:
          '0200000000010211f8cdc7b1255b8d3eb951db2fc6964766aaf6e6d1b42e777c90a52977b3e8e50000000000ffffffff00696f18c09d884c100254825f3ca4f41ca35fbb5e988d3526cbdcfcb30c335b0000000000ffffffff02a08601000000000017a914b3d8a5081a9477dd5d354d4c8a7efc0e64689d1087e8340f0000000000160014eef1091149ba3658a5dfe9c8a8924b3a4f0e1baa02473044022068548d4369730e90f33d4243420b40d4c7ef240bbac1db33354c0e108d503f24022062adcc1d19756bcb3ecae9fe988af7c3147ba7df5ff6b26f4a135037669fcef001210211edf8b518a1ac28d1f9a956a5ddeddaea0df435f2386e7fb86f0e9fde818dda0247304402203140f8ee8311562f15eb1f062f3be98fbe41615262491ad5625d8541ce2e4386022077343891d341112a2b75647d5a1faec0f0a79dac8052249e22eb39591a4bb70c0121023f05c145e61311eb725fdea9834fe20c4e7bbb639def8e47137a2696001f9e9d00000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(
      'xpub69SfFhG5eA9cqxHKM6b1HhXMpDzipUPDBNMBrjNgWWbbzKqnqwx2mvMyB5bRgmLAi7cBgr8euuz4Lvz3maWxpfUmdM71dyQuvq68mTAG4Cp',
      fp1cobo,
    );
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(w.getDerivationPath(), "m/45'");
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 1);
    assert.strictEqual(
      w.getCosigner(1),
      'xpub69SfFhG5eA9cqxHKM6b1HhXMpDzipUPDBNMBrjNgWWbbzKqnqwx2mvMyB5bRgmLAi7cBgr8euuz4Lvz3maWxpfUmdM71dyQuvq68mTAG4Cp',
    );
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);

    assert.strictEqual(w._getExternalAddressByIndex(0), '3J5xQcgBqoykSHhmDJLYp87SgVSNhYrvnz');
    assert.strictEqual(w._getExternalAddressByIndex(1), '3GkEXFYUifSmQ9SgzJDWL37pjMj4LT6vbq');
    assert.strictEqual(w._getInternalAddressByIndex(0), '365MagKko4t7L9XPXSYGkFj23dknTCx4UW');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36j8Qx6vxUknTxGFa5yYuxifEK9PGPEKso');
    assert.ok(!w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(w.isLegacy());

    // transaction is gona be signed with one key
    const { tx, psbt } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 10000 }],
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(!tx, 'tx should not be provided when PSBT is only partially signed');

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);
    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHUCAAAAAeze/Q5jJotU+uEMc2FdzH9A4DEN1ImGyQujTAt8IgpjAAAAAAAAAACAAhAnAAAAAAAAGXapFBkSnVPmMZuvGdugWb6tFm35Crj1iKy8VgEAAAAAABepFPI8FESPOvVVeCas7ULqnnFYnc5JhwAAAAAAAQD9cwECAAAAAAECEfjNx7ElW40+uVHbL8aWR2aq9ubRtC53fJClKXez6OUAAAAAAP////8AaW8YwJ2ITBACVIJfPKT0HKNfu16YjTUmy9z8swwzWwAAAAAA/////wKghgEAAAAAABepFLPYpQgalHfdXTVNTIp+/A5kaJ0Qh+g0DwAAAAAAFgAU7vEJEUm6Nlil3+nIqJJLOk8OG6oCRzBEAiBoVI1DaXMOkPM9QkNCC0DUx+8kC7rB2zM1TA4QjVA/JAIgYq3MHRl1a8s+yun+mIr3wxR7p99f9rJvShNQN2afzvABIQIR7fi1GKGsKNH5qVal3e3a6g30NfI4bn+4bw6f3oGN2gJHMEQCIDFA+O6DEVYvFesfBi876Y++QWFSYkka1WJdhUHOLkOGAiB3NDiR00ERKit1ZH1aH67A8KedrIBSJJ4i6zlZGku3DAEhAj8FwUXmExHrcl/eqYNP4gxOe7tjne+ORxN6JpYAH56dAAAAACICAuKpQFZsreTHbjczMj+gmPaW2MpWjN/NE9t30TCFV6boRzBEAiA7xMszlRAzEJDo++ZfweUQ1qQS+N7hCHnuZe9ifT11swIgFzcqL0y6iTN9OqIIfLLYA7aydcK3EgtCIpjPl+u//kQBAQRHUiEC4qlAVmyt5MduNzMyP6CY9pbYylaM380T23fRMIVXpughAwzjNw1MZIfVUrvzxo8mAHCwyFMnbRLiWD/cmQLyYkiNUq4iBgLiqUBWbK3kx243MzI/oJj2ltjKVozfzRPbd9EwhVem6BAWjdYDLQAAgAAAAAAAAAAAIgYDDOM3DUxkh9VSu/PGjyYAcLDIUydtEuJYP9yZAvJiSI0Q036tiC0AAIAAAAAAAAAAAAAAAQBHUiECgmRVqjxNBw8Z0fauEBQ0s0SgNNpZWUhldkQSTvs7c2ghA4li0cKudVocpfiRUWu2Of11UYkQ0wpNM5gsBj9oJLesUq4iAgKCZFWqPE0HDxnR9q4QFDSzRKA02llZSGV2RBJO+ztzaBDTfq2ILQAAgAEAAAADAAAAIgIDiWLRwq51Whyl+JFRa7Y5/XVRiRDTCk0zmCwGP2gkt6wQFo3WAy0AAIABAAAAAwAAAAA=',
    );

    const psbtSignedOnCobo = bitcoin.Psbt.fromHex(
      decodeUR([
        'UR:BYTES/2OF2/HKFUJ0HDC2GXTAJDW99S7D7KJF9HREVM33DN756FEJJ04MEN2WZSZX97JS/CYGQ3Q80ZVKVU4ZQE3PY8GL0N9LS09ZRT2GYHCMMSSS70WVHHKYLFAWKESYGQHXU4Z7N963YEH6W4ZPP7T9KQRK6E8TS4HZG95YG5CE7T7H0L7GSQJYQSRPN3NWR2VVJRA254M70RG7FSQWZCVS5E8D5FWYKPLMJVS9UNZFZX5WVZYQGSXMGM4P97RM7D5JFLH2EGCKQD74NUGDJMH42JYYXN8TQFPWNSLF6QZYPHVKP7SK456TVRPKALFGDDYHJW7UTVRWELCVTUWJW5GJ8H8E8G57QGPQ3R4YGGZU255Q4NV4HJVWM3HXVERLGYC76TD3JJK3N0U6Y7MWLGNPP2H5M5ZZQCVUVMS6NRYSL249WLNC68JVQRSKRY9XFMDZT39S07UNYP0YCJG34F2UGSXQT32JSZKDJK7F3MWXUENY0AQNRMFDKX226XDLNGNMDMAZVY927NWSYQK3HTQXTGQQZQQQQQQQQQQQQQQYGRQXR8RXUX5CEY864FTHU7X3UNQQU9SEPFJWMGJUFVRLHYEQTEXYJYDZRFHATVG95QQPQQQQQQQQQQQQQQQQQQPQPR4YGGZSFJ9T23UF5RS7XW376HPQ9P5KDZ2QDX6T9V5SETKGSFYA7EMWD5ZZQUFVTGU9TN4TGW2T7Y3294MVW0AW4GCJYXNPFXN8XPVQCLKSF9H43F2UGSZQ2PXG4D283XSWRCE68M2UYQ5XJE5FGP5MFV4JJR9WEZPYNHM8DEKSYXN06KCSTGQQZQQZQQQQQPSQQQQYGPQ8ZTZ68P2UA26RJJL3Y23DWMRNLT42XY3P5C2F5EESTQX8A5ZFDAVZQTGM4SR95QQPQQPQQQQQQCQQQQQQ55FRG0',
        'UR:BYTES/1OF2/HKFUJ0HDC2GXTAJDW99S7D7KJF9HREVM33DN756FEJJ04MEN2WZSZX97JS/TYZRXURNVF607QGQW5PQQQQQQ8KDALGWVVNGK486UYX8XC2AE3L5PCP3PH2GNPKFPW35CZMUYG9XXQQQQQQQQQQQQZQQYYP8QQQQQQQQQQVHD2G5RYFF65LXXXD67XWM5PVMATGKDHUS4W843ZKTC4SPQQQQQQQQZ753FU3UZ3ZG7WH424UZDT8DGT4FUU2CNH8YNPCQQQQQQQQPQR7HXQGZQQQQQQQPQGGL3NW8KYJ4HRF7H9GAKT7XJERKD2HKUMGMGTNH0JG222THK05W2QQQQQQQPLLLLLLSQ6T0RRQFMZZVZQP9FQJL8JJ0G89RT7A4AXYDX5NVHH8UKVXRXKCQQQQQQQ8LLLLL7Q4QSCQSQQQQQQQP02G5K0V22ZQ6J3MA6HF4F4XG5LHUPEJX38GSSL5RGRCQQQQQQQQKQQ2WAUGFZ9YM5DJC5H07NJ9GJF9N5NCWRW4QY3ESGSPZQ6Z534PKJUCWJREN6SJRGG95P4X8AUJQHWKPMVEN2NQWZZX4Q0EYQGSX9TWVR5VH267T8M9WNL5C3TMUX9RM5L04LA4JDA9PX5PHV60UAUQPYYPPRM0CK5V2RTPG68U6J449MHKA46SD7S6LYWRW07UX7R5LM6QCMKSZGUCYGQ3QX9Q03M5RZ9TZ790TRURZ7WLF37LYZC2JVFY344TZTKZ5RN3WGWRQYGRHXSUFR56PZY4ZKATY04DPLTKQ7ZNEMTYQ2GJFUGHT89V35JAHPSQJZQ3LQHQ5TESNZ84HYH774XP5LCSVFEAMKCUAA78YWYM6Y6TQQ8U7N5QQQQQQYGPQ9C4FGPTXET0YCAHRWVEJ87SF3A5KMR99DRXLE5FAKA73XZZ40FHGGU',
      ]),
    );

    psbt.combine(psbtSignedOnCobo);

    const hex = psbt.finalizeAllInputs().extractTransaction().toHex();
    assert.strictEqual(
      hex,
      '0200000001ecdefd0e63268b54fae10c73615dcc7f40e0310dd48986c90ba34c0b7c220a6300000000d90047304402203bc4cb339510331090e8fbe65fc1e510d6a412f8dee10879ee65ef627d3d75b3022017372a2f4cba89337d3aa2087cb2d803b6b275c2b7120b422298cf97ebbffe440147304402206da375097c3df9b4927f756518b01beacf886cb77aaa4421a675812174e1f4e802206ecb07d0b569a5b061b77e9435a4bc9dee2d83767f862f8e93a8891ee7c9d14f0147522102e2a940566cade4c76e3733323fa098f696d8ca568cdfcd13db77d1308557a6e821030ce3370d4c6487d552bbf3c68f260070b0c853276d12e2583fdc9902f262488d52ae000000800210270000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588acbc5601000000000017a914f23c14448f3af5557826aced42ea9e71589dce498700000000',
    );
  });

  it('can do both signatures', () => {
    const path = "m/45'";

    const utxos = [
      {
        height: 666,
        value: 87740,
        address: '3PmqRLiPnBXhdYGN6mAHChXLPvw8wb3Yt8',
        vout: 1,
        txid: '33eaa5193c71519deb968852c9938824d14504a785479a051ea07cc68400ee23',
        wif: false,
        confirmations: 666,
        txhex:
          '0200000001ecdefd0e63268b54fae10c73615dcc7f40e0310dd48986c90ba34c0b7c220a6300000000d90047304402203bc4cb339510331090e8fbe65fc1e510d6a412f8dee10879ee65ef627d3d75b3022017372a2f4cba89337d3aa2087cb2d803b6b275c2b7120b422298cf97ebbffe440147304402202ac48d42623e988e038627113594e36c3c0e9c4069792ef385739105cf843c9d0220722f32d64d6f91a59325d1c494cc4d0cf8ae506c0cb25c46442dba1cb65e156d0147522102e2a940566cade4c76e3733323fa098f696d8ca568cdfcd13db77d1308557a6e821030ce3370d4c6487d552bbf3c68f260070b0c853276d12e2583fdc9902f262488d52ae000000800210270000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588acbc5601000000000017a914f23c14448f3af5557826aced42ea9e71589dce498700000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(process.env.MNEMONICS_COBO);
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(w.getDerivationPath(), "m/45'");
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 2);
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);

    assert.strictEqual(w._getExternalAddressByIndex(0), '3J5xQcgBqoykSHhmDJLYp87SgVSNhYrvnz');
    assert.strictEqual(w._getExternalAddressByIndex(1), '3GkEXFYUifSmQ9SgzJDWL37pjMj4LT6vbq');
    assert.strictEqual(w._getInternalAddressByIndex(0), '365MagKko4t7L9XPXSYGkFj23dknTCx4UW');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36j8Qx6vxUknTxGFa5yYuxifEK9PGPEKso');
    assert.strictEqual(w._getInternalAddressByIndex(3), '3PmqRLiPnBXhdYGN6mAHChXLPvw8wb3Yt8');
    assert.ok(!w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(w.isLegacy());

    // transaction is gona be signed with both keys
    const { tx, psbt, fee } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }], // no change
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(tx);
    assert.ok(psbt);

    assert.throws(() => psbt.finalizeAllInputs()); // throws as it is already finalized
    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);

    // checking feerate:
    assert.strictEqual(10, Math.floor(fee / tx.virtualSize()));
  });

  it('can do both signatures, and create correct feerate tx', () => {
    const path = "m/45'";

    const utxos = [
      {
        height: 666,
        value: 87740,
        address: '3PmqRLiPnBXhdYGN6mAHChXLPvw8wb3Yt8',
        vout: 1,
        txid: '33eaa5193c71519deb968852c9938824d14504a785479a051ea07cc68400ee23',
        wif: false,
        confirmations: 666,
        txhex:
          '0200000001ecdefd0e63268b54fae10c73615dcc7f40e0310dd48986c90ba34c0b7c220a6300000000d90047304402203bc4cb339510331090e8fbe65fc1e510d6a412f8dee10879ee65ef627d3d75b3022017372a2f4cba89337d3aa2087cb2d803b6b275c2b7120b422298cf97ebbffe440147304402202ac48d42623e988e038627113594e36c3c0e9c4069792ef385739105cf843c9d0220722f32d64d6f91a59325d1c494cc4d0cf8ae506c0cb25c46442dba1cb65e156d0147522102e2a940566cade4c76e3733323fa098f696d8ca568cdfcd13db77d1308557a6e821030ce3370d4c6487d552bbf3c68f260070b0c853276d12e2583fdc9902f262488d52ae000000800210270000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588acbc5601000000000017a914f23c14448f3af5557826aced42ea9e71589dce498700000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(process.env.MNEMONICS_COBO);
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);

    // transaction is gona be signed with both keys
    const { tx, psbt } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }], // no change
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(tx);
    assert.ok(psbt);

    assert.throws(() => psbt.finalizeAllInputs()); // throws as it is already finalized
    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);
    assert.ok(psbt.extractTransaction().toHex());
    assert.strictEqual(Math.round(psbt.getFeeRate()), 10);
  });
});

describe('multisig-wallet (wrapped segwit)', () => {
  if (!process.env.MNEMONICS_COBO) {
    console.error('process.env.MNEMONICS_COBO not set, skipped');
    return;
  }
  if (!process.env.MNEMONICS_COLDCARD) {
    console.error('process.env.MNEMONICS_COLDCARD not set, skipped');
    return;
  }

  it('basic operations work', async () => {
    const w = new MultisigHDWallet();
    w.setSecret(txtFileFormatMultisigWrappedSegwit);
    assert.strictEqual(w.getDerivationPath(), "m/48'/0'/0'/1'");
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
    assert.strictEqual(
      w.getCosigner(1),
      'Ypub6jtUX12KGcqFosZWP4YcHc9qbKRTvgBpb8aE58hsYqby3SQVTr5KGfMmdMg38ekmQ9iLhCdgbAbjih7AWSkA7pgRhiLfah3zT6u1PFvVEbc',
    );
    assert.strictEqual(
      w.getCosigner(2),
      'Ypub6kvtvTZpqGuWtQfg9bL5xe4vDWtwsirR8LzDvsY3vgXvyncW1NGXCUJ9Ps7CiizSSLV6NnnXSYyVDnxCu26QChWzWLg5YCAHam6cYjGtzRz',
    );
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w.getCosigner(1));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w.getCosigner(2));
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);
    assert.strictEqual(w.getFormat(), MultisigHDWallet.FORMAT_P2SH_P2WSH);

    assert.strictEqual(w._getExternalAddressByIndex(0), '38xA38nfy649CC2JjjZj1CYAhtrcRc67dk');
    assert.strictEqual(w._getExternalAddressByIndex(1), '35ixkuzbrLb7Pr3j89uVYvYPe3jKSrbeB3');
    assert.strictEqual(w._getInternalAddressByIndex(0), '35yBZiSz9aBCz7HcobJzYpsuKhcgJ1Vrnd');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36uoZnudzSSUryHmWyNy3xfChmzvK35AL9');
    assert.ok(w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(!w.isLegacy());
  });

  it('can coordinate tx creation', async () => {
    const utxos = [
      {
        height: 666,
        value: 100000,
        address: '38xA38nfy649CC2JjjZj1CYAhtrcRc67dk',
        vout: 0,
        txid: 'e36f630517f5b094a9287e73bdb443792088255c50d74414c7f25bd7fbdcf18e',
        wif: false,
        confirmations: 666,
        script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
        txhex:
          '0200000000010196d35e9f8f176e83895a3fe9595a6245dfbab28d6ab67b3792fd5de22e1f6b6601000000000000008002a08601000000000017a9144fa5e491491e9ff7a4a1acfad13b1f40394a807587cc1e040000000000160014266425288c8b2b0ff90f2cffb630f174b1e1915602473044022027a467bd3d4aeb3d7e37d9e1218016e06ad0d5d55ce36f2852dc685e4261d5fb022006acb3e4ecb6c8b887ad94893a8b447a7003a34c0422864d2403493d8ab07fd60121022974397dca958232181a717400dc31629b4daad87e1e314e3b02dd059e88141000000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.setSecret(txtFileFormatMultisigWrappedSegwit);

    // transaction is gona be UNsigned because we have no keys
    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: 'bc1qlhpaukt44ru7044uqdf0hp2qs0ut0p93g66k8h', value: 10000 }],
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(!tx, 'tx should not be provided when PSBT is only partially signed');

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 0);
    assert.ok(w.calculateFeeFromPsbt(psbt) < 3000);
    assert.ok(w.calculateFeeFromPsbt(psbt) > 0);

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHICAAAAAY7x3PvXW/LHFETXUFwliCB5Q7S9c34oqZSw9RcFY2/jAAAAAAAAAACAAhAnAAAAAAAAFgAU/cPeWXWo+efWvANS+4VAg/i3hLG8VgEAAAAAABepFO7ireZCjVtHj35I/Nl7BehvwLUehwAAAAAAAQDfAgAAAAABAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAQAAAAAAAACAAqCGAQAAAAAAF6kUT6XkkUken/ekoaz60TsfQDlKgHWHzB4EAAAAAAAWABQmZCUojIsrD/kPLP+2MPF0seGRVgJHMEQCICekZ709Sus9fjfZ4SGAFuBq0NXVXONvKFLcaF5CYdX7AiAGrLPk7LbIuIetlIk6i0R6cAOjTAQihk0kA0k9irB/1gEhAil0OX3KlYIyGBpxdADcMWKbTarYfh4xTjsC3QWeiBQQAAAAAAEBIKCGAQAAAAAAF6kUT6XkkUken/ekoaz60TsfQDlKgHWHAQQiACDPTtxNIhrXXpN96Ge4RqNg6G5S2ekVWeRIxC6lrW7xpgEFR1IhAs4nrGikNjRB6wBod7xyiPlsajHLe784+TGSBSn1La1FIQNdxFn6ZgrWx54rXwjY8th8oxuC1GGaYJuwUCPwiHLvMlKuIgYCziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUUcFo3WAzAAAIAAAACAAAAAgAEAAIAAAAAAAAAAACIGA13EWfpmCtbHnitfCNjy2HyjG4LUYZpgm7BQI/CIcu8yHNN+rYgwAACAAAAAgAAAAIABAACAAAAAAAAAAAAAAAEAIgAgmEK/lrkZU6YPI0E7hA3gl4FCIJrzjUCO1HWnberBUHMBAUdSIQJiYhkhelPzRR4CoVURPwwFCiw4bloiKfu5PeiBcpsoBiEDu+RSG3dUJUlQnENUxiTZbrK1Nfe7LV+YDo2tmbD+GOBSriICAmJiGSF6U/NFHgKhVRE/DAUKLDhuWiIp+7k96IFymygGHNN+rYgwAACAAAAAgAAAAIABAACAAQAAAAMAAAAiAgO75FIbd1QlSVCcQ1TGJNlusrU197stX5gOja2ZsP4Y4BwWjdYDMAAAgAAAAIAAAACAAQAAgAEAAAADAAAAAA==',
    );

    // now, signing it on coldcard.

    const signedOnColdcard =
      'cHNidP8BAHICAAAAAY7x3PvXW/LHFETXUFwliCB5Q7S9c34oqZSw9RcFY2/jAAAAAAAAAACAAhAnAAAAAAAAFgAU/cPeWXWo+efWvANS+4VAg/i3hLG8VgEAAAAAABepFO7ireZCjVtHj35I/Nl7BehvwLUehwAAAAAAAQDfAgAAAAABAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAQAAAAAAAACAAqCGAQAAAAAAF6kUT6XkkUken/ekoaz60TsfQDlKgHWHzB4EAAAAAAAWABQmZCUojIsrD/kPLP+2MPF0seGRVgJHMEQCICekZ709Sus9fjfZ4SGAFuBq0NXVXONvKFLcaF5CYdX7AiAGrLPk7LbIuIetlIk6i0R6cAOjTAQihk0kA0k9irB/1gEhAil0OX3KlYIyGBpxdADcMWKbTarYfh4xTjsC3QWeiBQQAAAAAAEBIKCGAQAAAAAAF6kUT6XkkUken/ekoaz60TsfQDlKgHWHIgICziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUVHMEQCIGpbamFnic4XMuNHOC8AulQmuUzVdE+67aWOZC0lwwQJAiB1LID+LeJC87bL7U0wGtAfzLah8iScywpIhzVrVIrofwEBAwQBAAAAIgYCziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUUcFo3WAzAAAIAAAACAAAAAgAEAAIAAAAAAAAAAACIGA13EWfpmCtbHnitfCNjy2HyjG4LUYZpgm7BQI/CIcu8yHNN+rYgwAACAAAAAgAAAAIABAACAAAAAAAAAAAABBCIAIM9O3E0iGtdek33oZ7hGo2DoblLZ6RVZ5EjELqWtbvGmAQVHUiECziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUUhA13EWfpmCtbHnitfCNjy2HyjG4LUYZpgm7BQI/CIcu8yUq4AACICA7vkUht3VCVJUJxDVMYk2W6ytTX3uy1fmA6NrZmw/hjgHBaN1gMwAACAAAAAgAAAAIABAACAAQAAAAMAAAAiAgJiYhkhelPzRR4CoVURPwwFCiw4bloiKfu5PeiBcpsoBhzTfq2IMAAAgAAAAIAAAACAAQAAgAEAAAADAAAAAQAiACCYQr+WuRlTpg8jQTuEDeCXgUIgmvONQI7Udadt6sFQcwEBR1IhAmJiGSF6U/NFHgKhVRE/DAUKLDhuWiIp+7k96IFymygGIQO75FIbd1QlSVCcQ1TGJNlusrU197stX5gOja2ZsP4Y4FKuAA==';
    const psbtSignedOnColdcard = bitcoin.Psbt.fromBase64(signedOnColdcard);

    psbt.combine(psbtSignedOnColdcard); // should not throw

    // signed on real Cobo device:
    const psbtFromCobo = bitcoin.Psbt.fromHex(
      decodeUR([
        'UR:BYTES/1OF2/C3YV8V6ZLYC0XV3KCL3TLTYVJAMVAV2EGUKEA5XRPHHSTRFWR67QD0422H/TYZPJURNVF607QGQWGPQQQQQQX80RH8M6ADL93C5GNT4QHP93QS8JSA5H4EHU29FJJC029C9VDH7XQQQQQQQQQQQQZQQYYP8QQQQQQQQQQTQQ98AC009JADGL8NAD0QR2TAC2SYRLZMCFVDU2CQSQQQQQQQP02G5AM32MEJZ34D50RM7FR7DJ7C9APHUPDG7SUQQQQQQQQQSPHCZQQQQQQQPQXTDXH5L3UTKAQUFTGL7JK26VFZALW4J344TV7EHJT74MC3WRA4KVQGQQQQQQQQQQZQQ9GYXQYQQQQQQQQT6J9Z05HJFZJG7NLM6FGDVLTGNK86Q899GQAV8ES0QGQQQQQQQQ9SQZSNXGFFG3J9JKRLEPUK0LD3S796TRCV32CPYWVZYQGSZ0FR8H57546EA0CMANCFPSQTWQ6KS6H24ECM09PFDC6Z7GFSAT7CZYQR2EVLYAJMV3WY84K2GJW5TG3A8QQARFSZZ9PJDYSP5J0V2KPLAVQFPQG5HGWTAE22CYVSCRFCHGQXUX93FKND2MPLPUV2W8VPD6PV73Q2PQQQQQQQQZQFQ5ZRQZQQQQQQQQ9AFZ386TEY3FY0FLAAY5XK045FMRAQRJJ5QWKRJYQSZECN6C69YXC6YR6CQDPMMCU5GL9KX5VWT0WLN37F3JGZJNAFD44Z5WVZYQGSX5KM2V9NCNNSHXT35WWP0QZA9GF4EFN2HGNA6AKJCUEPDYHPSGZGZYP6JEQ879H3Y9UAKE0K56VQ66Q0UED4P7GJFEJC2FZRN26653T587QFZQGP4M3ZELFNQ44K8NC447ZXC7TV8EGCMST2XRXNQNWC9QGLS3PEW7',
        'UR:BYTES/2OF2/C3YV8V6ZLYC0XV3KCL3TLTYVJAMVAV2EGUKEA5XRPHHSTRFWR67QD0422H/VJ8XPZQYGZDUG0080MKV7J470KZDUQ6P059YR8WPJ0U86369FJVRAVV0W0CHSPZQH6RPNTKY4SU6TYH899522UP5U57DPPSG6P3D5F0AAH82C0X8MGGQYQSXPQPQQQQQQGYYGQZPN6WM3XJYXKHT6FHM6R8HPR2XC8GDEFDN6G4T8JY33PW5KKKAUDXQYZ5W53PQT8Z0TRG5SMRGS0TQP5800RJ3RUKC633EDAM7W8EXXFQ22049KK52GGRTHZ9N7NXPTTV083TTUYD3UKC0J33HQK5VXDXPXAS2Q3LPZRJAUE99T3ZQCPVUFAVDZJRVDZPAVQXSAAUW2Y0JMR2X89HH0ECLYCEYPFF75K663GUZ6XAVQESQQQGQQQQQZQQQQQQSQQSQQYQQQQQQQQQQQQQQGSXQDWUGK06VC9DD3U79D0S3K8JMP72XXUZ63SE5CYMKPGZ8UYGWTHNY8XN06KCSVQQQZQQQQQQSQQQQQYQQYQQPQQQQQQQQQQQQQQQQQQPQ9R4YGGZVF3PJGT620E528SZ5923Z0CVQ59ZCWRWTG3ZN7AE8H5GZU5M9QRZZQAMU3FPKA65Y4Y4P8ZR2NRZFKTWK26NTAAM940ESR5D4KVMPLSCUPF2UGSZQF3XYXFP0FFLX3G7Q2S42YFLPSZS5TPCDEDZY20MHY773QTJNV5QV8XN06KCSVQQQZQQQQQQSQQQQQYQQYQQPQQPQQQQQQCQQQQZYQSRH0J9YXMH2SJ5J5YUGD2VVFXED6ET2D0HHVK4LXQW3KKENV87RRSPC95D6CPNQQQQSQQQQQYQQQQQPQQPQQQGQQGQQQQQXQQQQQQQ2VFE47',
      ]),
    );

    psbt.combine(psbtFromCobo);
    const txhex = psbt.finalizeAllInputs().extractTransaction().toHex();
    assert.strictEqual(
      txhex,
      '020000000001018ef1dcfbd75bf2c71444d7505c2588207943b4bd737e28a994b0f51705636fe30000000023220020cf4edc4d221ad75e937de867b846a360e86e52d9e91559e448c42ea5ad6ef1a600000080021027000000000000160014fdc3de5975a8f9e7d6bc0352fb854083f8b784b1bc5601000000000017a914eee2ade6428d5b478f7e48fcd97b05e86fc0b51e87040047304402206a5b6a616789ce1732e347382f00ba5426b94cd5744fbaeda58e642d25c304090220752c80fe2de242f3b6cbed4d301ad01fccb6a1f2249ccb0a4887356b548ae87f0147304402204de21ef3bf7667a55f3ec26f01a0be8520cee0c9fc3ea3a2a64c1f58c7b9f8bc02205f430cd762561cd2c97394b452b81a729e68430468316d12fef6e7561e63ed080147522102ce27ac68a4363441eb006877bc7288f96c6a31cb7bbf38f931920529f52dad4521035dc459fa660ad6c79e2b5f08d8f2d87ca31b82d4619a609bb05023f08872ef3252ae00000000',
    );
  });

  it('can coordinate tx creation and sign 1 of 2', async () => {
    const path = "m/48'/0'/0'/1'";
    const Ypub1 = 'Ypub6jtUX12KGcqFosZWP4YcHc9qbKRTvgBpb8aE58hsYqby3SQVTr5KGfMmdMg38ekmQ9iLhCdgbAbjih7AWSkA7pgRhiLfah3zT6u1PFvVEbc';

    const utxos = [
      {
        height: 666,
        value: 100000,
        address: '38xA38nfy649CC2JjjZj1CYAhtrcRc67dk',
        vout: 0,
        txid: 'e36f630517f5b094a9287e73bdb443792088255c50d74414c7f25bd7fbdcf18e',
        wif: false,
        script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
        confirmations: 666,
        txhex:
          '0200000000010196d35e9f8f176e83895a3fe9595a6245dfbab28d6ab67b3792fd5de22e1f6b6601000000000000008002a08601000000000017a9144fa5e491491e9ff7a4a1acfad13b1f40394a807587cc1e040000000000160014266425288c8b2b0ff90f2cffb630f174b1e1915602473044022027a467bd3d4aeb3d7e37d9e1218016e06ad0d5d55ce36f2852dc685e4261d5fb022006acb3e4ecb6c8b887ad94893a8b447a7003a34c0422864d2403493d8ab07fd60121022974397dca958232181a717400dc31629b4daad87e1e314e3b02dd059e88141000000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(Ypub1, fp1cobo);
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(
      w.convertXpubToMultisignatureXpub(MultisigHDWallet.seedToXpub(process.env.MNEMONICS_COLDCARD, path)),
      'Ypub6kvtvTZpqGuWtQfg9bL5xe4vDWtwsirR8LzDvsY3vgXvyncW1NGXCUJ9Ps7CiizSSLV6NnnXSYyVDnxCu26QChWzWLg5YCAHam6cYjGtzRz',
    );
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w.getCosigner(1));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w.getCosigner(2));
    assert.strictEqual(w._getExternalAddressByIndex(0), '38xA38nfy649CC2JjjZj1CYAhtrcRc67dk');
    assert.strictEqual(w._getExternalAddressByIndex(1), '35ixkuzbrLb7Pr3j89uVYvYPe3jKSrbeB3');
    assert.strictEqual(w._getInternalAddressByIndex(0), '35yBZiSz9aBCz7HcobJzYpsuKhcgJ1Vrnd');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36uoZnudzSSUryHmWyNy3xfChmzvK35AL9');
    assert.strictEqual(w._getInternalAddressByIndex(3), '3PU8J9pdiKAMsLnrhyrG7RZ4LZiTURQp5r');
    assert.strictEqual(w.howManySignaturesCanWeMake(), 1);
    assert.ok(w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(!w.isLegacy());

    // transaction is gona be partially signed because we have one of two signing keys
    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 10000 }],
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(!tx, 'tx should not be provided when PSBT is only partially signed');
    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHUCAAAAAY7x3PvXW/LHFETXUFwliCB5Q7S9c34oqZSw9RcFY2/jAAAAAAAAAACAAhAnAAAAAAAAGXapFBkSnVPmMZuvGdugWb6tFm35Crj1iKy8VgEAAAAAABepFO7ireZCjVtHj35I/Nl7BehvwLUehwAAAAAAAQDfAgAAAAABAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAQAAAAAAAACAAqCGAQAAAAAAF6kUT6XkkUken/ekoaz60TsfQDlKgHWHzB4EAAAAAAAWABQmZCUojIsrD/kPLP+2MPF0seGRVgJHMEQCICekZ709Sus9fjfZ4SGAFuBq0NXVXONvKFLcaF5CYdX7AiAGrLPk7LbIuIetlIk6i0R6cAOjTAQihk0kA0k9irB/1gEhAil0OX3KlYIyGBpxdADcMWKbTarYfh4xTjsC3QWeiBQQAAAAAAEBIKCGAQAAAAAAF6kUT6XkkUken/ekoaz60TsfQDlKgHWHIgICziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUVHMEQCIHgfpvZsDT4VkHSxGL5nGcRpP55V4r7jmNRj4vr85NNXAiBio79Ta0Tr9skEiLJ/hXnNFR+3ZdRcpFRX59HIqGmorQEBBCIAIM9O3E0iGtdek33oZ7hGo2DoblLZ6RVZ5EjELqWtbvGmAQVHUiECziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUUhA13EWfpmCtbHnitfCNjy2HyjG4LUYZpgm7BQI/CIcu8yUq4iBgLOJ6xopDY0QesAaHe8coj5bGoxy3u/OPkxkgUp9S2tRRwWjdYDMAAAgAAAAIAAAACAAQAAgAAAAAAAAAAAIgYDXcRZ+mYK1seeK18I2PLYfKMbgtRhmmCbsFAj8Ihy7zIc036tiDAAAIAAAACAAAAAgAEAAIAAAAAAAAAAAAAAAQAiACCYQr+WuRlTpg8jQTuEDeCXgUIgmvONQI7Udadt6sFQcwEBR1IhAmJiGSF6U/NFHgKhVRE/DAUKLDhuWiIp+7k96IFymygGIQO75FIbd1QlSVCcQ1TGJNlusrU197stX5gOja2ZsP4Y4FKuIgICYmIZIXpT80UeAqFVET8MBQosOG5aIin7uT3ogXKbKAYc036tiDAAAIAAAACAAAAAgAEAAIABAAAAAwAAACICA7vkUht3VCVJUJxDVMYk2W6ytTX3uy1fmA6NrZmw/hjgHBaN1gMwAACAAAAAgAAAAIABAACAAQAAAAMAAAAA',
    );

    // got that from real Cobo vault device:
    const ur1 =
      'UR:BYTES/2OF2/TJX8DNDQAX50U29GZNW7RWEQ7JNZLLS6U2NKPKP35N4XX80J2WTQYYVK7D/76D7H8DNNFD6R4D79DKKC0Z8FP2E8ESHNQHUL4ASZYQ9SDTHMKAQG2FJM2YP6P7YXK72J77CJW7C3RSJ9YC594FHPY44UGQGPQS3QQGX0FMWY6GS66A0FXL0GV7UYDGMQAPH99K0FZ4V7GJXY96J66MH35CQS236JYYPVUFAVDZJRVDZPAVQXSAAUW2Y0JMR2X89HH0ECLYCEYPFF75K663FPQDWUGK06VC9DD3U79D0S3K8JMP72XXUZ63SE5CYMKPGZ8UYGWTHNY54WYGRQ9N384352GD35G84SQ6RHH3EG37TVDGCUK7AL8RUNRYS9986JMT29RSTGM4SRXQQQPQQQQQQGQQQQQZQQZQQQSQQQQQQQQQQQQQPZQCP4M3ZELFNQ44K8NC447ZXC7TV8EGCMST2XRXNQNWC9QGLS3PEW7VSU6DL2MZPSQQQGQQQQQZQQQQQQSQQSQQYQQQQQQQQQQQQQQQQQQYQZYQPQNPPTL94ER9F6VRERGYACGR0QJ7Q5YGY67WX5PRK5WKNKM6KP2PESZQ282GSSYCNZRYSH55LNG50Q9G24ZYLSCPG29SUXUK3Z98AMJ00GS9EFK2QXYYPMHEZJRDM4GF2F2ZWYX4XXYNVKAV44XHMMKT2LNQ8GMTVEKRLP3CZJ4C3QYQNZVGVJZ7JN7DZ3UQ4P25GN7RQ9PGKRSMJ6YG5LHWFAAZQH9XEGQCWDXL4D3QCQQQYQQQQQPQQQQQQGQQGQQZQQZQQQQQPSQQQQYGPQ8WLY2GDHW4P9F9GFCS65CCJDJM4JK56L0WEDT7VQARDDNXC0UX8QRSTGM4SRXQQQPQQQQQQGQQQQQZQQZQQQSQQSQQQQQVQQQQQQRSVZ9T';
    const ur2 =
      'UR:BYTES/1OF2/TJX8DNDQAX50U29GZNW7RWEQ7JNZLLS6U2NKPKP35N4XX80J2WTQYYVK7D/TYZR5URNVF607QGQW5PQQQQQQX80RH8M6ADL93C5GNT4QHP93QS8JSA5H4EHU29FJJC029C9VDH7XQQQQQQQQQQQQZQQYYP8QQQQQQQQQQVHD2G5RYFF65LXXXD67XWM5PVMATGKDHUS4W843ZKTC4SPQQQQQQQQZ753FMHZ4HNY9R2MG78HUJ8UM9AST6R0CZ63APCQQQQQQQQPQR0SYQQQQQQQZQVK6D0FLRCHD6PCJK3LA9V45CJ9M7AT9RT2KEAN0YHATH3ZU8MTVCQSQQQQQQQQQQYQQ2SGVQGQQQQQQQQH4Y2YLF0YJ9Y3A8LH5JS6E7K38V05QW22SP6C0NQ7QSQQQQQQQQTQQ9PXVSJJ3RYT9V8LJREVL7MRPUT5K8SEZ4SZGUCYGQ3QY7JX00FAFT4N6L3HM8SJRQQKUP4DP4W4TN3K72ZJM359USNP6HASYGQX4JE7FM9KEZUG0TV53YAGK3R6WQP6XNQYY2RY6FQRFY7C4VRL6CQJZQ3FWSUHMJ54SGEPSXN3WSQDCVTZNDX64KR7RCC5UWCZM5ZEAZQ5ZQQQQQQQQYQJPGYXQYQQQQQQQQT6J9Z05HJFZJG7NLM6FGDVLTGNK86Q899GQAV8YGPQ9N384352GD35G84SQ6RHH3EG37TVDGCUK7AL8RUNRYS9986JMT29GUCYGQ3Q0Q06DANVP5LPTYR5KYVTUECEC35NL8J4U2LW8XX5V0304L8Y6DTSYGRZ5WL4X66YA0MVJPYGKFLC27WDZ50MWEW5TJJ9G4L868Y2S6DG45QJYQSRTHZ9N7NXPTTV083TTUYD3UKC0J33HQK5VXDXPXAS2Q3LPZRJAUEYWVZYQGS929YQ92ZV8XF';
    const payload = decodeUR([ur1, ur2]);

    const psbtFromCobo = bitcoin.Psbt.fromHex(payload);
    psbt.combine(psbtFromCobo);
    const tx2 = psbt.finalizeAllInputs().extractTransaction();
    assert.strictEqual(
      tx2.toHex(),
      '020000000001018ef1dcfbd75bf2c71444d7505c2588207943b4bd737e28a994b0f51705636fe30000000023220020cf4edc4d221ad75e937de867b846a360e86e52d9e91559e448c42ea5ad6ef1a6000000800210270000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588acbc5601000000000017a914eee2ade6428d5b478f7e48fcd97b05e86fc0b51e8704004730440220781fa6f66c0d3e159074b118be6719c4693f9e55e2bee398d463e2fafce4d357022062a3bf536b44ebf6c90488b27f8579cd151fb765d45ca45457e7d1c8a869a8ad0147304402205514802a84c3993ed37d73b6734b743ab7c56dad8788e90ab27cc2f305f9faf602200b06aefbb74085265b5103a0f886b7952f7b1277b111c24526285aa6e1256bc40147522102ce27ac68a4363441eb006877bc7288f96c6a31cb7bbf38f931920529f52dad4521035dc459fa660ad6c79e2b5f08d8f2d87ca31b82d4619a609bb05023f08872ef3252ae00000000',
    );
  });

  it('can coordinate tx creation and sign 1 of 2 (spend from change)', async () => {
    const path = "m/48'/0'/0'/1'";
    const Ypub1 = 'Ypub6jtUX12KGcqFosZWP4YcHc9qbKRTvgBpb8aE58hsYqby3SQVTr5KGfMmdMg38ekmQ9iLhCdgbAbjih7AWSkA7pgRhiLfah3zT6u1PFvVEbc';

    const utxos = [
      {
        height: 666,
        value: 87740,
        address: '3PU8J9pdiKAMsLnrhyrG7RZ4LZiTURQp5r',
        vout: 1,
        txid: '31d614bc1d6fcbcb273f585f87d2e619784920f8cb0c2396e4a03f1bb86fed64',
        wif: false,
        script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
        confirmations: 666,
        txhex:
          '020000000001018ef1dcfbd75bf2c71444d7505c2588207943b4bd737e28a994b0f51705636fe30000000023220020cf4edc4d221ad75e937de867b846a360e86e52d9e91559e448c42ea5ad6ef1a6000000800210270000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588acbc5601000000000017a914eee2ade6428d5b478f7e48fcd97b05e86fc0b51e8704004730440220781fa6f66c0d3e159074b118be6719c4693f9e55e2bee398d463e2fafce4d357022062a3bf536b44ebf6c90488b27f8579cd151fb765d45ca45457e7d1c8a869a8ad0147304402207e13fe2321ab8b80f3d415b28e37a11224ff9b9caf8be710d0f30f41939ab3df0220031da773d0dd13f99b0c7e33e7cb2dbc5af480cf219e7933c092eeb354787f780147522102ce27ac68a4363441eb006877bc7288f96c6a31cb7bbf38f931920529f52dad4521035dc459fa660ad6c79e2b5f08d8f2d87ca31b82d4619a609bb05023f08872ef3252ae00000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(Ypub1, fp1cobo);
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(
      w.convertXpubToMultisignatureXpub(MultisigHDWallet.seedToXpub(process.env.MNEMONICS_COLDCARD, path)),
      'Ypub6kvtvTZpqGuWtQfg9bL5xe4vDWtwsirR8LzDvsY3vgXvyncW1NGXCUJ9Ps7CiizSSLV6NnnXSYyVDnxCu26QChWzWLg5YCAHam6cYjGtzRz',
    );
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w.getCosigner(1));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w.getCosigner(2));
    assert.strictEqual(w._getExternalAddressByIndex(0), '38xA38nfy649CC2JjjZj1CYAhtrcRc67dk');
    assert.strictEqual(w._getExternalAddressByIndex(1), '35ixkuzbrLb7Pr3j89uVYvYPe3jKSrbeB3');
    assert.strictEqual(w._getInternalAddressByIndex(0), '35yBZiSz9aBCz7HcobJzYpsuKhcgJ1Vrnd');
    assert.strictEqual(w._getInternalAddressByIndex(1), '36uoZnudzSSUryHmWyNy3xfChmzvK35AL9');
    assert.strictEqual(w._getInternalAddressByIndex(3), '3PU8J9pdiKAMsLnrhyrG7RZ4LZiTURQp5r');
    assert.strictEqual(w.howManySignaturesCanWeMake(), 1);
    assert.ok(w.isWrappedSegwit());
    assert.ok(!w.isNativeSegwit());
    assert.ok(!w.isLegacy());

    // transaction is gona be partially signed because we have one of two signing keys
    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }],
      10,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );
    assert.ok(!tx, 'tx should not be provided when PSBT is only partially signed');

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAFUCAAAAAWTtb7gbP6DkliMMy/ggSXgZ5tKHX1g/J8vLbx28FNYxAQAAAAAAAACAATxPAQAAAAAAGXapFBkSnVPmMZuvGdugWb6tFm35Crj1iKwAAAAAAAEA/XQBAgAAAAABAY7x3PvXW/LHFETXUFwliCB5Q7S9c34oqZSw9RcFY2/jAAAAACMiACDPTtxNIhrXXpN96Ge4RqNg6G5S2ekVWeRIxC6lrW7xpgAAAIACECcAAAAAAAAZdqkUGRKdU+Yxm68Z26BZvq0WbfkKuPWIrLxWAQAAAAAAF6kU7uKt5kKNW0ePfkj82XsF6G/AtR6HBABHMEQCIHgfpvZsDT4VkHSxGL5nGcRpP55V4r7jmNRj4vr85NNXAiBio79Ta0Tr9skEiLJ/hXnNFR+3ZdRcpFRX59HIqGmorQFHMEQCIH4T/iMhq4uA89QVso43oRIk/5ucr4vnENDzD0GTmrPfAiADHadz0N0T+ZsMfjPnyy28WvSAzyGeeTPAku6zVHh/eAFHUiECziesaKQ2NEHrAGh3vHKI+WxqMct7vzj5MZIFKfUtrUUhA13EWfpmCtbHnitfCNjy2HyjG4LUYZpgm7BQI/CIcu8yUq4AAAAAAQEgvFYBAAAAAAAXqRTu4q3mQo1bR49+SPzZewXob8C1HociAgO75FIbd1QlSVCcQ1TGJNlusrU197stX5gOja2ZsP4Y4EgwRQIhAP3v+3DseVI63T8N9TGi3j9mQvjkIFZTUu0aeQbRhm+NAiASJatbXcK+36jF34Eeg5Hvy+vx+Q5bNB3tJWWBS3tqDAEBBCIAIJhCv5a5GVOmDyNBO4QN4JeBQiCa841AjtR1p23qwVBzAQVHUiECYmIZIXpT80UeAqFVET8MBQosOG5aIin7uT3ogXKbKAYhA7vkUht3VCVJUJxDVMYk2W6ytTX3uy1fmA6NrZmw/hjgUq4iBgJiYhkhelPzRR4CoVURPwwFCiw4bloiKfu5PeiBcpsoBhzTfq2IMAAAgAAAAIAAAACAAQAAgAEAAAADAAAAIgYDu+RSG3dUJUlQnENUxiTZbrK1Nfe7LV+YDo2tmbD+GOAcFo3WAzAAAIAAAACAAAAAgAEAAIABAAAAAwAAAAAA',
    );

    // got that from real Cobo vault device:
    const payload = decodeUR([
      'UR:BYTES/2OF2/645VJ6CR74M52HV073W978F7QQ09MQGKMK9RECKH9R4W047TMWKQKHL9CD/QZ753FMHZ4HNY9R2MG78HUJ8UM9AST6R0CZ63APEZQGPXYCSEY9A98U69RCP2Z4G38UXQ2Z3V8PH95G3FLWUNM6YPW2DJSPJ8XPZQYGZ9MR2S3AG7D7H2A0SKF5NEHTAWKQXAJ5U3WAH6GNUKH0JC0M2795PZQANMMTXYKFW30745FSYMGH850MF4SQU82TZF4U6XJS8L27545AYRQY3QYQAMU3FPKA65Y4Y4P8ZR2NRZFKTWK26NTAAM940ESR5D4KVMPLSCUPYRQ3GZYYQ0MMLMWRK8J536M5LSMAF35T0R7EJZLRJZQ4JN2TK357GX6XRXLRGZYQFZT26MTHPTAHAGCH0CZ85RJ8HUH6L3LY89KDQAA5JKTQ2T0D4QCQGPQS3QQGYCG2LEDWGE2WNQ7G6P8WZQMCYHS9PZPXHN34QGA4R45AK74S2SWVQS236JYYPXYCSEY9A98U69RCP2Z4G38UXQ2Z3V8PH95G3FLWUNM6YPW2DJSP3PQWA7G5SMWA2Z2J2SN3P4F33YM9HT9DF477AJ6HUCP6X6MXDSLCVWQ54WYGRQYCNZRYSH55LNG50Q9G24ZYLSCPG29SUXUK3Z98AMJ00GS9EFK2QXRNFHATVGXQQQPQQQQQQGQQQQQZQQZQQQSQQSQQQQQVQQQQPZQCPMHEZJRDM4GF2F2ZWYX4XXYNVKAV44XHMMKT2LNQ8GMTVEKRLP3CQUZ6XAVQESQQQGQQQQQZQQQQQQSQQSQQYQQYQQQQQRQQQQQQQQTQLHYU',
      'UR:BYTES/1OF2/645VJ6CR74M52HV073W978F7QQ09MQGKMK9RECKH9R4W047TMWKQKHL9CD/TYPUYURNVF607QGQ25PQQQQQQ9JW6MACRVL6PEYKYVXVH7PQF9UPNEKJSA04S0E8E09K78DUZNTRZQGQQQQQQQQQQZQQZ0Z0QYQQQQQQQQVHD2G5RYFF65LXXXD67XWM5PVMATGKDHUS4W843ZKQQQQQQQQQZQ8AWSQSYQQQQQQQZQVW78W0H46M7TR3G3XH2PWZTZPQ09PMF0TN0C52N99S75TS2CM0UVQQQQQQYV3QQGX0FMWY6GS66A0FXL0GV7UYDGMQAPH99K0FZ4V7GJXY96J66MH35CQQQQYQQGGZWQQQQQQQQQQEW653GXGJN4F7VVVM4UVAHGZEH6K3VM0EP2U0TZ9VH3TQZQQQQQQQQ9AFZNHW9T0XG2X4K3U00EY0EKTMQH5XLS94R6RSGQZ8XPZQYGRCR7N0VMQD8C2EQA93RZLXWXWYDYLEU40ZHM3E34RRUTA0EEXN2UPZQC4RHAFKK38T7MYSFZ9J07ZHNNG4R7MKT4ZU53290E73EZ5XN29DQ9RNQ3QZYPLP8L3RYX4CHQ8N6S2M9R3H5YFZFLUMNJHCHECS6RES7SVNN2EA7Q3QQVW6WU7SM5FLNXCV0CE70JEDH3D0FQX0YX08JV7QJTHTX4RC0AUQZ36JYYPVUFAVDZJRVDZPAVQXSAAUW2Y0JMR2X89HH0ECLYCEYPFF75K663FPQDWUGK06VC9DD3U79D0S3K8JMP72XXUZ63SE5CYMKPGZ8UYGWTHNY54WQQQQQQQPQYSTC4SPQQQQQQQ',
    ]);

    const psbtFromCobo = bitcoin.Psbt.fromHex(payload);
    psbt.combine(psbtFromCobo);
    const tx2 = psbt.finalizeAllInputs().extractTransaction();
    assert.strictEqual(
      tx2.toHex(),
      '0200000000010164ed6fb81b3fa0e496230ccbf820497819e6d2875f583f27cbcb6f1dbc14d63101000000232200209842bf96b91953a60f23413b840de0978142209af38d408ed475a76deac1507300000080013c4f0100000000001976a91419129d53e6319baf19dba059bead166df90ab8f588ac0400473044022045d8d508f51e6faeaebe164d279bafaeb00dd95391776fa44f96bbe587ed5e2d0220767bdacc4b25d17fab44c09b45cf47ed358038752c49af346940ff57a95a748301483045022100fdeffb70ec79523add3f0df531a2de3f6642f8e420565352ed1a7906d1866f8d02201225ab5b5dc2bedfa8c5df811e8391efcbebf1f90e5b341ded2565814b7b6a0c0147522102626219217a53f3451e02a155113f0c050a2c386e5a2229fbb93de881729b28062103bbe4521b77542549509c4354c624d96eb2b535f7bb2d5f980e8dad99b0fe18e052ae00000000',
    );
  });
});

describe('multisig-wallet (native segwit)', () => {
  if (!process.env.MNEMONICS_COBO) {
    console.error('process.env.MNEMONICS_COBO not set, skipped');
    return;
  }
  if (!process.env.MNEMONICS_COLDCARD) {
    console.error('process.env.MNEMONICS_COLDCARD not set, skipped');
    return;
  }

  it('can sort buffers', async () => {
    let sorted;
    sorted = MultisigHDWallet.sortBuffers([Buffer.from('10', 'hex'), Buffer.from('0011', 'hex')]);
    assert.strictEqual(sorted[0].toString('hex'), '0011');
    assert.strictEqual(sorted[1].toString('hex'), '10');

    sorted = MultisigHDWallet.sortBuffers([
      Buffer.from('022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da', 'hex'),
      Buffer.from('03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9', 'hex'),
      Buffer.from('021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18', 'hex'),
    ]);
    assert.strictEqual(sorted[0].toString('hex'), '021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18');
    assert.strictEqual(sorted[1].toString('hex'), '022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da');
    assert.strictEqual(sorted[2].toString('hex'), '03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9');

    sorted = MultisigHDWallet.sortBuffers([
      Buffer.from('02632b12f4ac5b1d1b72b2a3b508c19172de44f6f46bcee50ba33f3f9291e47ed0', 'hex'),
      Buffer.from('027735a29bae7780a9755fae7a1c4374c656ac6a69ea9f3697fda61bb99a4f3e77', 'hex'),
      Buffer.from('02e2cc6bd5f45edd43bebe7cb9b675f0ce9ed3efe613b177588290ad188d11b404', 'hex'),
    ]);
    assert.strictEqual(sorted[0].toString('hex'), '02632b12f4ac5b1d1b72b2a3b508c19172de44f6f46bcee50ba33f3f9291e47ed0');
    assert.strictEqual(sorted[1].toString('hex'), '027735a29bae7780a9755fae7a1c4374c656ac6a69ea9f3697fda61bb99a4f3e77');
    assert.strictEqual(sorted[2].toString('hex'), '02e2cc6bd5f45edd43bebe7cb9b675f0ce9ed3efe613b177588290ad188d11b404');

    sorted = MultisigHDWallet.sortBuffers([
      Buffer.from('030000000000000000000000000000000000004141414141414141414141414141', 'hex'),
      Buffer.from('020000000000000000000000000000000000004141414141414141414141414141', 'hex'),
      Buffer.from('020000000000000000000000000000000000004141414141414141414141414140', 'hex'),
      Buffer.from('030000000000000000000000000000000000004141414141414141414141414140', 'hex'),
    ]);
    assert.strictEqual(sorted[0].toString('hex'), '020000000000000000000000000000000000004141414141414141414141414140');
    assert.strictEqual(sorted[1].toString('hex'), '020000000000000000000000000000000000004141414141414141414141414141');
    assert.strictEqual(sorted[2].toString('hex'), '030000000000000000000000000000000000004141414141414141414141414140');
    assert.strictEqual(sorted[3].toString('hex'), '030000000000000000000000000000000000004141414141414141414141414141');

    sorted = MultisigHDWallet.sortBuffers([
      Buffer.from('02ff12471208c14bd580709cb2358d98975247d8765f92bc25eab3b2763ed605f8', 'hex'),
      Buffer.from('02fe6f0a5a297eb38c391581c4413e084773ea23954d93f7753db7dc0adc188b2f', 'hex'),
    ]);
    assert.strictEqual(
      sorted[0].toString('hex'),
      '02fe6f0a5a297eb38c391581c4413e084773ea23954d93f7753db7dc0adc188b2f',
      JSON.stringify(sorted),
    );
    assert.strictEqual(sorted[1].toString('hex'), '02ff12471208c14bd580709cb2358d98975247d8765f92bc25eab3b2763ed605f8');
  });

  it('some validations work', () => {
    assert.ok(MultisigHDWallet.isXpubValid(Zpub1));
    assert.ok(!MultisigHDWallet.isXpubValid('invalid'));
    assert.ok(!MultisigHDWallet.isXpubValid('xpubinvalid'));
    assert.ok(!MultisigHDWallet.isXpubValid('ypubinvalid'));
    assert.ok(!MultisigHDWallet.isXpubValid('Zpubinvalid'));

    assert.ok(MultisigHDWallet.isPathValid("m/45'"));
    assert.ok(MultisigHDWallet.isPathValid("m/48'/0'/0'/2'"));
    assert.ok(!MultisigHDWallet.isPathValid('ROFLBOATS'));
    assert.ok(!MultisigHDWallet.isPathValid(''));

    assert.ok(
      MultisigHDWallet.isXprvValid(
        'ZprvAkUsoZMLiqxrhaM8VpmVJ6QhjH4dZnYpTNNHGMZ3VoE6vRv7xfDeMEiKAeH1eUcN3CFUP87CgM1anM2UytMkykUMtVmXkkohRsiVGth1VMG',
      ),
    );
    assert.ok(!MultisigHDWallet.isXprvValid(''));
    assert.ok(!MultisigHDWallet.isXprvValid('Zprvlabla'));
    assert.ok(!MultisigHDWallet.isXprvValid('xprvblabla'));
    assert.ok(
      !MultisigHDWallet.isXprvValid(
        'xprv9tpBCBeAwBnVgYroSvicqDR2XhAj6sth3idqBWhRqnrq99x17WZvZHQup679rXc3ndPLN3fwbpLkv4WTQhfhZN89B2NbTMmYFePPPHJ5jVP',
      ),
    ); // invalid fp

    assert.ok(MultisigHDWallet.isFpValid(fp1cobo));
    assert.ok(MultisigHDWallet.isFpValid(fp2coldcard));
    assert.ok(MultisigHDWallet.isFpValid('00000000'));
    assert.ok(MultisigHDWallet.isFpValid('DEADFEEF'));
    assert.ok(MultisigHDWallet.isFpValid('deadbeef'));
    assert.ok(MultisigHDWallet.isFpValid('dEaDbeEF'));
    assert.ok(!MultisigHDWallet.isFpValid('rmjiweg3'));
    assert.ok(!MultisigHDWallet.isFpValid('bruh'));
    assert.ok(!MultisigHDWallet.isFpValid('0'));
    assert.ok(!MultisigHDWallet.isFpValid('0'));
  });

  it('basic operations work', async () => {
    const path = "m/48'/0'/0'/2'";

    let w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(Zpub2, fp2coldcard);
    w.setDerivationPath(path);
    w.setM(2);
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');
    assert.strictEqual(
      w._getDerivationPathByAddressWithCustomPath(w._getExternalAddressByIndex(2), w.getDerivationPath()),
      "m/48'/0'/0'/2'/0/2",
    );
    assert.strictEqual(
      w._getDerivationPathByAddressWithCustomPath(w._getInternalAddressByIndex(3), w.getDerivationPath()),
      "m/48'/0'/0'/2'/1/3",
    );
    assert.strictEqual(
      MultisigHDWallet.seedToXpub(process.env.MNEMONICS_COLDCARD, path),
      'xpub6FCYVZAU7dofgor9fQaqyqqA9NqBAn83iQpoayuWrwBPfwiPgCXGCD7dvAG93M5MZs5VWVP7FErGA5UeiALqaPt7KV67fL9WX9bqXTyeWxb',
    );
    assert.strictEqual(
      w.convertXpubToMultisignatureXpub(
        'xpub6FCYVZAU7dofgor9fQaqyqqA9NqBAn83iQpoayuWrwBPfwiPgCXGCD7dvAG93M5MZs5VWVP7FErGA5UeiALqaPt7KV67fL9WX9bqXTyeWxb',
      ),
      Zpub2,
    );
    assert.throws(() => w.addCosigner('invalid'));
    assert.throws(() => w.addCosigner('xpubinvalid'));
    assert.throws(() => w.addCosigner('ypubinvalid'));
    assert.throws(() => w.addCosigner('Zpubinvalid'));
    assert.throws(() => w.addCosigner(Zpub1, fp1cobo, 'ROFLBOATS')); // invalid path
    assert.throws(() => w.addCosigner(Zpub1, fp1cobo)); // duplicates are not allowed
    assert.throws(() => w.addCosigner(Zpub2, fp2coldcard)); // duplicates are not allowed
    assert.throws(() => w.addCosigner(process.env.MNEMONICS_COBO)); // duplicates are not allowed
    assert.throws(() => w.addCosigner(process.env.MNEMONICS_COLDCARD)); // duplicates are not allowed

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.getDerivationPath(), path);
    assert.strictEqual(w.getCosigner(1), Zpub1);
    assert.strictEqual(w.getCosigner(2), Zpub2);
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), Zpub1);
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), Zpub2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
    assert.ok(!w.isWrappedSegwit());
    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isLegacy());
    assert.strictEqual(w.getFormat(), MultisigHDWallet.FORMAT_P2WSH);

    // now, one of cosigners is mnemonics

    w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qvwd2d7r46j7u9qyxpedfhe5p075sxuhzd0n6napuvvhq2u5nrmqs9ex90q');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qv84pedzkqz2p4sd2dxm9krs0tcfatqcn73nndycaky9qttczj9qq3az9ma');

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.getDerivationPath(), path);
    assert.strictEqual(w.getCosigner(1), Zpub1);
    assert.strictEqual(w.getCosigner(2), process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), Zpub1);
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 1);

    // now, provide fp with mnemonics and expect that wallet wont recalculate fp, and will use provided
    w = new MultisigHDWallet();
    w.addCosigner(process.env.MNEMONICS_COLDCARD, 'DEADBABE');
    w.addCosigner(process.env.MNEMONICS_COBO);
    assert.strictEqual(w.getFingerprint(1), 'DEADBABE');
    assert.strictEqual(w.getCosignerForFingerprint('DEADBABE'), process.env.MNEMONICS_COLDCARD);
  });

  it('basic operations work for 2-of-3', async () => {
    const path = "m/48'/0'/0'/2'";

    const w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(Zpub2, fp2coldcard);
    w.addCosigner(
      'accident olympic spawn spider cable track pluck fat code grab fine salt garment kidney crime old often worth member impulse brother smoke garden trash',
    );
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(
      w.convertXpubToMultisignatureXpub(
        MultisigHDWallet.seedToXpub(
          'accident olympic spawn spider cable track pluck fat code grab fine salt garment kidney crime old often worth member impulse brother smoke garden trash',
          path,
        ),
      ),
      'Zpub74k35j5DkSA6t6SFhPeHv8ENBHdNgAPALWodSWoWxsHo6vbAu2FUGq9QmUEvdEPzBoMswizfsAbTWQYU2ZnvCjdKsFje5TEfjLxuH8arBtp',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qnpy7c7wz6tvmhdwgyk8ka4du3s9x6uhgjal305xdatmwfa538zxsys5l0t');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qvuum7egsw4r4utzart88pergghy9rp8m4j5m4s464lz6u39sn6usn89w7c');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qatmvfj5nzh4z3njxeg8z86y592clqe7sfgvp5cpund47knnm6pxsswl2lr');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qpqa9c6nkqgcruegnh8wcsr0gzc4x9y90v9k0nxr6lww0gts430zqp7wm86');

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 3);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 1);
    assert.ok(!w.isWrappedSegwit());
    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isLegacy());
  });

  it('can coordinate tx creation', async () => {
    const path = "m/48'/0'/0'/2'";

    const utxos = [
      {
        height: 666,
        value: 100000,
        address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85',
        vout: 0,
        txid: '666b1f2ee25dfd92377bb66a8db2badf45625a59e93f5a89836e178f9f5ed396',
        wif: false,
        script: { length: 95 }, // incorrect value so old tests pass. in reality its calculated on the fly
        confirmations: 0,
        txhex:
          '02000000000101b67e455069a0f44c9df4849ee1167b06c26f8478daefa9c8aeedf1da3d7d81860f000000000000008002a08601000000000022002030862bd71d77b314666e5fdab34d6293ecb4ffdbba55fbd5323dfd79d98b662b04b005000000000016001461e37702582ecf8c87c1eb5008f2afb17acc9d3c02473044022077268bb0f3060b737b657c3c990107be5db41fd311cc64abeab96cff621146fc0220766e2409c0669020ea2160b358037fdb17f49e59faf8e9c50ac946019be079e6012103c3ed17035033b2cb0ce03694d402c37a307f0eea2b909b0272816bfcea83714f00000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(Zpub2, fp2coldcard);
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), path); // not provided, so should be default
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), w.getDerivationPath()); // not provided, so should be default
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), w.getDerivationPath()); // not provided, so should be default

    const { psbt } = w.createTransaction(
      utxos,
      [{ address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85' }], // sendMax
      1,
      w._getInternalAddressByIndex(0), // there should be no change in this tx
      false,
      false,
    );

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAF4CAAAAAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAAAAAAAAAACAAeCFAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisAAAAAAAEA6gIAAAAAAQG2fkVQaaD0TJ30hJ7hFnsGwm+EeNrvqciu7fHaPX2Bhg8AAAAAAAAAgAKghgEAAAAAACIAIDCGK9cdd7MUZm5f2rNNYpPstP/bulX71TI9/XnZi2YrBLAFAAAAAAAWABRh43cCWC7PjIfB61AI8q+xesydPAJHMEQCIHcmi7DzBgtze2V8PJkBB75dtB/TEcxkq+q5bP9iEUb8AiB2biQJwGaQIOohYLNYA3/bF/SeWfr46cUKyUYBm+B55gEhA8PtFwNQM7LLDOA2lNQCw3owfw7qK5CbAnKBa/zqg3FPAAAAAAEBK6CGAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisBBUdSIQL3PcZ3OXAqrpAGpxAfeH8tGlIosSQDQjFhbP8RIOZRyyED1Ql1CX8NiH3x6Uj22iu8SEwewHmhRSyqJtbmfw+g11pSriIGAvc9xnc5cCqukAanEB94fy0aUiixJANCMWFs/xEg5lHLHNN+rYgwAACAAAAAgAAAAIACAACAAAAAAAAAAAAiBgPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWhwWjdYDMAAAgAAAAIAAAACAAgAAgAAAAAAAAAAAAAA=',
    );

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 0);

    const signedOnColdcard =
      'cHNidP8BAF4CAAAAAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAAAAAAAAAACAAeCFAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisAAAAAAAEA6gIAAAAAAQG2fkVQaaD0TJ30hJ7hFnsGwm+EeNrvqciu7fHaPX2Bhg8AAAAAAAAAgAKghgEAAAAAACIAIDCGK9cdd7MUZm5f2rNNYpPstP/bulX71TI9/XnZi2YrBLAFAAAAAAAWABRh43cCWC7PjIfB61AI8q+xesydPAJHMEQCIHcmi7DzBgtze2V8PJkBB75dtB/TEcxkq+q5bP9iEUb8AiB2biQJwGaQIOohYLNYA3/bF/SeWfr46cUKyUYBm+B55gEhA8PtFwNQM7LLDOA2lNQCw3owfw7qK5CbAnKBa/zqg3FPAAAAAAEBK6CGAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisiAgPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWkcwRAIgfydmSzg/YjlUZDjgfrZGPKOXv5z7do3r5L8YePt5srYCIAD0JWkLVVPeeMsLOUHngsTd01Dx8OezzEmzRGYg9I+2AQEDBAEAAAAiBgPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWhwWjdYDMAAAgAAAAIAAAACAAgAAgAAAAAAAAAAAIgYC9z3GdzlwKq6QBqcQH3h/LRpSKLEkA0IxYWz/ESDmUcsc036tiDAAAIAAAACAAAAAgAIAAIAAAAAAAAAAAAEFR1IhAvc9xnc5cCqukAanEB94fy0aUiixJANCMWFs/xEg5lHLIQPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWlKuAAA=';
    const psbtSignedOnColdcard = bitcoin.Psbt.fromBase64(signedOnColdcard);
    psbt.combine(psbtSignedOnColdcard); // should not throw
    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);

    // signed on real Cobo device:
    const psbtFromCobo = bitcoin.Psbt.fromHex(
      decodeUR([
        'UR:BYTES/2OF2/KP2PVX8V4F6ERP7X6ZZC9TDQ8VQQVASXMM4EUF9TL5AST2HDXSVS30JH3S/J9ZCJGQ6ZX9SKELC3YRN9RJ68XPZQYGQVTXZCWR85MH933S8YXJVVEA7M6G262E4ADTRJR5ZTXJWEKMCLPYPZQ3FDYRG9ZJEUZMM5Q5KFM6SV3VXCHZY3FEPGV0T40ULWX2SXGF2ZQY3QYQ74P96SJLCD3P7LR62G7MDZH0ZGFS0VQ7DPG5K25FKKUELSLGXHTFRNQ3QZYPLJWEJT8QLKYW25VSUWQL4KGC7289ALNNAHDR0TUJL3S78M0XETVQ3QQR6Z26GT24FAU7XTPVU5REUZCNWAX5837RNM8NZFKDZXVG8537MQZQGRQSQSQQQQQYZ5W53PQTMNM3NH89CZ4T5SQ6N3Q8MC0UK3553GKYJQXS33V9K07YFQUEGUKGGR65YH2ZTLPKY8MU0FFRMD52AUFPXPASRE59ZJE23X6MN87RAQ6AD99T3ZQCP0W0WXWUUHQ24WJQR2WYQL0PLJ6XJJ9ZCJGQ6ZX9SKELC3YRN9RJCU6DL2MZPSQQQGQQQQQZQQQQQQSQPQQQYQQQQQQQQQQQQQQGSXQ02SJAGF0UXCSL03A9Y0DK3TH3YYC8KQ0XS52T92YMTWVLC05RT458QK3HTQXVQQQZQQQQQQSQQQQQYQQGQQPQQQQQQQQQQQQQQQQQQZR7R39',
        'UR:BYTES/1OF2/KP2PVX8V4F6ERP7X6ZZC9TDQ8VQQVASXMM4EUF9TL5AST2HDXSVS30JH3S/TYPJKURNVF607QGQTCPQQQQQQXTDXH5L3UTKAQUFTGL7JK26VFZALW4J344TV7EHJT74MC3WRA4KVQQQQQQQQQQQQZQQRCY9QYQQQQQQQQ3QQGPSSC4AW8THKV2XVMJLM2E56C5NAJ60LKA62HAA2V3AL4UANZMX9VQQQQQQQQQSP6SZQQQQQQQPQXM8U32SDXS0GNYA7JZFACGK0VRVYMUY0RDWL2WG4MKLRK3A0KQCVRCQQQQQQQQQQZQQ9GYXQYQQQQQQQQ3QQGPSSC4AW8THKV2XVMJLM2E56C5NAJ60LKA62HAA2V3AL4UANZMX9VZTQPGQQQQQQQQKQQ2XRCMHQFVZANUVSLQ7K5QG72HMZ7KVN57QY3ESGSPZQAEX3WC0XPSTWDAK2LPUNYQS00JAKS0AXYWVVJ474WTVLA3PZ3HUQGS8VM3YP8QXDYPQAGSKPV6CQDLAK9L5NEVL478FC59VJ3SPN0S8NESPYYPU8MGHQDGR8VKTPNSRD9X5QTPH5VRLPM4ZHYYMQFEGZ6LUA2PHZNCQQQQQQQGP9WSGVQGQQQQQQQPZQQSRPP3T6UWH0VC5VEH9LK4NF43F8M95LLDM540M65ERMLTEMX9KV2EZQGP0W0WXWUUHQ24WJQR2WYQL0PLJ6XJ',
      ]),
    );

    psbt.combine(psbtFromCobo);
    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);
    const txhex = psbt.finalizeAllInputs().extractTransaction().toHex();
    assert.strictEqual(
      txhex,
      '0200000000010196d35e9f8f176e83895a3fe9595a6245dfbab28d6ab67b3792fd5de22e1f6b6600000000000000008001e08501000000000022002030862bd71d77b314666e5fdab34d6293ecb4ffdbba55fbd5323dfd79d98b662b040047304402200c5985870cf4ddcb18c0e43498ccf7dbd215a566bd6ac721d04b349d9b6f1f090220452d20d0514b3c16f74052c9dea0c8b0d8b88914e42863d757f3ee32a06425420147304402207f27664b383f6239546438e07eb6463ca397bf9cfb768debe4bf1878fb79b2b6022000f425690b5553de78cb0b3941e782c4ddd350f1f0e7b3cc49b3446620f48fb60147522102f73dc67739702aae9006a7101f787f2d1a5228b124034231616cff1120e651cb2103d50975097f0d887df1e948f6da2bbc484c1ec079a1452caa26d6e67f0fa0d75a52ae00000000',
    );

    // now, tx with change and weird paths for keys:

    const w2 = new MultisigHDWallet();
    w2.addCosigner(Zpub1, fp1cobo, "m/6'/7'/8'/2'");
    w2.addCosigner(Zpub2, fp2coldcard, "m/5'/4'/3'/2'");
    w2.setDerivationPath(path);
    w2.setM(2);

    assert.strictEqual(w2.getCustomDerivationPathForCosigner(1), "m/6'/7'/8'/2'");
    assert.strictEqual(w2.getCustomDerivationPathForCosigner(2), "m/5'/4'/3'/2'");

    const { psbt: psbt2 } = w2.createTransaction(
      utxos,
      [{ address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85', value: 10000 }],
      1,
      w2._getInternalAddressByIndex(3),
      false,
      false,
    );

    assert.ok(w2.calculateFeeFromPsbt(psbt2) < 300);
    assert.ok(w2.calculateFeeFromPsbt(psbt2) > 0);

    assert.strictEqual(uint8ArrayToHex(psbt2.data.outputs[1].bip32Derivation[0].masterFingerprint).toUpperCase(), fp1cobo);
    assert.strictEqual(uint8ArrayToHex(psbt2.data.outputs[1].bip32Derivation[1].masterFingerprint).toUpperCase(), fp2coldcard);
    assert.strictEqual(psbt2.data.outputs[1].bip32Derivation[0].path, "m/6'/7'/8'/2'" + '/1/3');
    assert.strictEqual(psbt2.data.outputs[1].bip32Derivation[1].path, "m/5'/4'/3'/2'" + '/1/3');

    assert.strictEqual(psbt2.data.inputs[0].bip32Derivation[0].path, "m/6'/7'/8'/2'/0/0");
    assert.strictEqual(psbt2.data.inputs[0].bip32Derivation[1].path, "m/5'/4'/3'/2'/0/0");

    assert.strictEqual(uint8ArrayToHex(psbt2.data.inputs[0].bip32Derivation[0].masterFingerprint).toUpperCase(), fp1cobo);
    assert.strictEqual(
      uint8ArrayToHex(psbt2.data.inputs[0].bip32Derivation[0].pubkey).toUpperCase(),
      '02F73DC67739702AAE9006A7101F787F2D1A5228B124034231616CFF1120E651CB',
    );
    assert.strictEqual(uint8ArrayToHex(psbt2.data.inputs[0].bip32Derivation[1].masterFingerprint).toUpperCase(), fp2coldcard);
    assert.strictEqual(
      uint8ArrayToHex(psbt2.data.inputs[0].bip32Derivation[1].pubkey).toUpperCase(),
      '03D50975097F0D887DF1E948F6DA2BBC484C1EC079A1452CAA26D6E67F0FA0D75A',
    );
  });

  it('can export/import wallet with all seeds in place, and also export coordination setup', () => {
    const path = "m/48'/0'/0'/2'";

    const w = new MultisigHDWallet();
    w.addCosigner(process.env.MNEMONICS_COBO, false, path);
    w.addCosigner(process.env.MNEMONICS_COLDCARD, false, path);
    w.setDerivationPath(path);
    w.setM(2);

    const ww = new MultisigHDWallet();
    ww.setSecret(w.getSecret());

    assert.strictEqual(ww._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
    assert.strictEqual(ww._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');

    assert.strictEqual(ww.getM(), 2);
    assert.strictEqual(ww.getN(), 2);
    assert.strictEqual(ww.howManySignaturesCanWeMake(), 2);
    assert.ok(!ww.isWrappedSegwit());
    assert.ok(ww.isNativeSegwit());
    assert.ok(!ww.isLegacy());

    assert.strictEqual(w.getID(), ww.getID());
    assert.ok(w.getID() !== new MultisigHDWallet().getID());

    // now, exporting coordination setup:

    const w3 = new MultisigHDWallet();
    w3.setSecret(ww.getXpub());
    assert.strictEqual(w3._getExternalAddressByIndex(0), ww._getExternalAddressByIndex(0));
    assert.strictEqual(w3._getInternalAddressByIndex(0), ww._getInternalAddressByIndex(0));
    assert.strictEqual(w3.getM(), 2);
    assert.strictEqual(w3.getN(), 2);
    assert.strictEqual(w3.howManySignaturesCanWeMake(), 0);
    assert.ok(!w3.isWrappedSegwit());
    assert.ok(w3.isNativeSegwit());
    assert.ok(!w3.isLegacy());
    assert.ok(MultisigHDWallet.isXpubString(w3.getCosigner(1)) && MultisigHDWallet.isXpubValid(w3.getCosigner(1)));
    assert.ok(MultisigHDWallet.isXpubString(w3.getCosigner(2)) && MultisigHDWallet.isXpubValid(w3.getCosigner(2)));
  });

  it('can coordinate tx creation and cosign 1 of 2', async () => {
    const path = "m/48'/0'/0'/2'";

    const utxos = [
      {
        height: 666,
        value: 100000,
        address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85',
        vout: 0,
        txid: '666b1f2ee25dfd92377bb66a8db2badf45625a59e93f5a89836e178f9f5ed396',
        wif: false,
        script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
        confirmations: 0,
        txhex:
          '02000000000101b67e455069a0f44c9df4849ee1167b06c26f8478daefa9c8aeedf1da3d7d81860f000000000000008002a08601000000000022002030862bd71d77b314666e5fdab34d6293ecb4ffdbba55fbd5323dfd79d98b662b04b005000000000016001461e37702582ecf8c87c1eb5008f2afb17acc9d3c02473044022077268bb0f3060b737b657c3c990107be5db41fd311cc64abeab96cff621146fc0220766e2409c0669020ea2160b358037fdb17f49e59faf8e9c50ac946019be079e6012103c3ed17035033b2cb0ce03694d402c37a307f0eea2b909b0272816bfcea83714f00000000',
      },
    ];

    const w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(process.env.MNEMONICS_COLDCARD, false, path);
    w.setDerivationPath(path);
    w.setM(2);

    // transaction is gona be partially signed because we have one of two signing keys
    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: 'bc1qlhpaukt44ru7044uqdf0hp2qs0ut0p93g66k8h' }], // sendMax
      10,
      w._getInternalAddressByIndex(0), // there should be no change in this tx
      false,
      false,
    );

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);

    assert.strictEqual(psbt.data.inputs[0].partialSig.length, 1);
    assert.ok(!tx, 'tx should not be provided when PSBT is only partially signed');
    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAFICAAAAAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAAAAAAAAAACAASB/AQAAAAAAFgAU/cPeWXWo+efWvANS+4VAg/i3hLEAAAAAAAEA6gIAAAAAAQG2fkVQaaD0TJ30hJ7hFnsGwm+EeNrvqciu7fHaPX2Bhg8AAAAAAAAAgAKghgEAAAAAACIAIDCGK9cdd7MUZm5f2rNNYpPstP/bulX71TI9/XnZi2YrBLAFAAAAAAAWABRh43cCWC7PjIfB61AI8q+xesydPAJHMEQCIHcmi7DzBgtze2V8PJkBB75dtB/TEcxkq+q5bP9iEUb8AiB2biQJwGaQIOohYLNYA3/bF/SeWfr46cUKyUYBm+B55gEhA8PtFwNQM7LLDOA2lNQCw3owfw7qK5CbAnKBa/zqg3FPAAAAAAEBK6CGAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisiAgPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWkgwRQIhAMlUC0EwNieytD8U9AUITLBvorNMUfWwJqsGJXRdZA2TAiA7k6ddbqnLKPwswk/D9ehGBIMNzKEfJYW7DkGGYRJdYAEBBUdSIQL3PcZ3OXAqrpAGpxAfeH8tGlIosSQDQjFhbP8RIOZRyyED1Ql1CX8NiH3x6Uj22iu8SEwewHmhRSyqJtbmfw+g11pSriIGAvc9xnc5cCqukAanEB94fy0aUiixJANCMWFs/xEg5lHLHNN+rYgwAACAAAAAgAAAAIACAACAAAAAAAAAAAAiBgPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWhwWjdYDMAAAgAAAAIAAAACAAgAAgAAAAAAAAAAAAAA=',
    );

    // got that from real Cobo vault device:
    const payload = decodeUR([
      'UR:BYTES/1OF2/WDZ4928G5MLENN8JFGWM988QCZPUZQ8P64N34EWP3C3TTQRR4C7QH86JMF/TYP3JURNVF607QGQ2GPQQQQQQXTDXH5L3UTKAQUFTGL7JK26VFZALW4J344TV7EHJT74MC3WRA4KVQQQQQQQQQQQQZQQZGRLQYQQQQQQQQTQQ98AC009JADGL8NAD0QR2TAC2SYRLZMCFVGQQQQQQQQPQR4QYQQQQQQQZQDK0EZ4Q6DQ73XFMAYYNMS3V7CXCFHCG7X6A75U3THD78DR6LVPSC8SQQQQQQQQQQYQQ2SGVQGQQQQQQQPZQQSRPP3T6UWH0VC5VEH9LK4NF43F8M95LLDM540M65ERMLTEMX9KV2CYKQZSQQQQQQQPVQQ5V83HWQJC9M8CEP7PADGQ3U40K9AVE8FUQFRNQ3QZYPMJDZAS7VRQKUMMV47REXGPQ7L9MDQL6VGUCE9TA2UKELMZZ9R0CQ3QWEHZGZWQV6GZP63PVZE4SQMLMVTLF8JELTUWN3G2E9RQRXLQ08NQZGGRC0K3WQ6SXWEVKR8QX62DGQKR0GC87RH29WGFKQNJS94LE65RW98SQQQQQQQSZ2AQSCQSQQQQQQQZYQPQXZRZH4CAW7E3GENWTLDTXNTZJ0KTFL7MHF2LH4FJ8H7HNKVTVC4JYQSZ7U7UVAEEWQ42AYQX5UGP77RL95D9Y293',
      'UR:BYTES/2OF2/WDZ4928G5MLENN8JFGWM988QCZPUZQ8P64N34EWP3C3TTQRR4C7QH86JMF/YSP5YVTPDNL3ZG8X2895WVZYQGS9980HLVW7QEG5V8YHAJLZJ5TDHWNSH6HRZ34QHQHJSYSL0E23G7GZYPAXMSVNDXD2GYE597LSU89DYW2RYTTLXP0H4UR4VTMPQHPH3AHTYQFZQGPA2ZT4P9LSMZRA78553AK69W7YSNQ7CPU6Z3FV4GNDDENLP7SDWKJGXPZSYGGQE92QKSFSXCNM9DPLZN6Q2ZZVKPH69V6V286MQF4TQCJHGHTYPKFSYGPMJWN46M4FEV50CTXZFLPLT6ZXQJPSMN9PRUJCTWCWGXRXZYJAVQQSZP282GSS9AEACEMNJUP246GQDFCSRAU87TG62G5TZFQRGGCKZM8LZYSWV5WTYYPA2ZT4P9LSMZRA78553AK69W7YSNQ7CPU6Z3FV4GNDDENLP7SDWKJJ4C3QVQHH8HR8WWTS92HFQP48ZQ0HSLEDRFFZ3VFYQDPRZCTVLUGJPEJ3EVWDXL4D3QCQQQYQQQQQPQQQQQQGQQSQQZQQQQQQQQQQQQQQYGRQ84GFW5YH7RVG0HC7JJ8KMG4MCJZVRMQ8NG299J4ZD4HX0U86P466RSTGM4SRXQQQPQQQQQQGQQQQQZQQYQQQSQQQQQQQQQQQQQQQQQK820JL',
    ]);

    const psbtFromCobo = bitcoin.Psbt.fromHex(payload);
    psbt.combine(psbtFromCobo);
    assert.strictEqual(psbt.data.inputs[0].partialSig.length, 2);

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);

    const tx2 = psbt.finalizeAllInputs().extractTransaction();
    assert.strictEqual(
      tx2.toHex(),
      '0200000000010196d35e9f8f176e83895a3fe9595a6245dfbab28d6ab67b3792fd5de22e1f6b6600000000000000008001207f010000000000160014fdc3de5975a8f9e7d6bc0352fb854083f8b784b104004730440220529df7fb1de0651461c97ecbe29516dbba70beae3146a0b82f28121f7e55147902207a6dc193699aa413342fbf0e1cad2394322d7f305f7af07562f6105c378f6eb201483045022100c9540b41303627b2b43f14f405084cb06fa2b34c51f5b026ab0625745d640d9302203b93a75d6ea9cb28fc2cc24fc3f5e84604830dcca11f2585bb0e418661125d600147522102f73dc67739702aae9006a7101f787f2d1a5228b124034231616cff1120e651cb2103d50975097f0d887df1e948f6da2bbc484c1ec079a1452caa26d6e67f0fa0d75a52ae00000000',
    );

    // to be precise in that case we dont need combine, we could just do:
    // psbtFromCobo.finalizeAllInputs().extractTransaction().toHex()
  });

  it('can cosign PSBT that was created somewhere else (1 sig)', async () => {
    const path = "m/48'/0'/0'/2'";
    const walletWithNoKeys = new MultisigHDWallet();
    walletWithNoKeys.addCosigner(Zpub1, fp1cobo);
    walletWithNoKeys.addCosigner(Zpub2, fp2coldcard);
    walletWithNoKeys.setDerivationPath(path);
    walletWithNoKeys.setM(2);

    const utxos = [
      {
        height: 666,
        value: 100000,
        address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85',
        vout: 0,
        txid: '666b1f2ee25dfd92377bb66a8db2badf45625a59e93f5a89836e178f9f5ed396',
        wif: false,
        confirmations: 0,
        script: { length: 95 }, // incorrect value so old tests pass. in reality its calculated on the fly
        txhex:
          '02000000000101b67e455069a0f44c9df4849ee1167b06c26f8478daefa9c8aeedf1da3d7d81860f000000000000008002a08601000000000022002030862bd71d77b314666e5fdab34d6293ecb4ffdbba55fbd5323dfd79d98b662b04b005000000000016001461e37702582ecf8c87c1eb5008f2afb17acc9d3c02473044022077268bb0f3060b737b657c3c990107be5db41fd311cc64abeab96cff621146fc0220766e2409c0669020ea2160b358037fdb17f49e59faf8e9c50ac946019be079e6012103c3ed17035033b2cb0ce03694d402c37a307f0eea2b909b0272816bfcea83714f00000000',
      },
    ];

    const { psbt } = walletWithNoKeys.createTransaction(
      utxos,
      [{ address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85' }], // sendMax
      1,
      walletWithNoKeys._getInternalAddressByIndex(0), // there should be no change in this tx
      false,
      false,
    );
    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAF4CAAAAAZbTXp+PF26DiVo/6VlaYkXfurKNarZ7N5L9XeIuH2tmAAAAAAAAAACAAeCFAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisAAAAAAAEA6gIAAAAAAQG2fkVQaaD0TJ30hJ7hFnsGwm+EeNrvqciu7fHaPX2Bhg8AAAAAAAAAgAKghgEAAAAAACIAIDCGK9cdd7MUZm5f2rNNYpPstP/bulX71TI9/XnZi2YrBLAFAAAAAAAWABRh43cCWC7PjIfB61AI8q+xesydPAJHMEQCIHcmi7DzBgtze2V8PJkBB75dtB/TEcxkq+q5bP9iEUb8AiB2biQJwGaQIOohYLNYA3/bF/SeWfr46cUKyUYBm+B55gEhA8PtFwNQM7LLDOA2lNQCw3owfw7qK5CbAnKBa/zqg3FPAAAAAAEBK6CGAQAAAAAAIgAgMIYr1x13sxRmbl/as01ik+y0/9u6VfvVMj39edmLZisBBUdSIQL3PcZ3OXAqrpAGpxAfeH8tGlIosSQDQjFhbP8RIOZRyyED1Ql1CX8NiH3x6Uj22iu8SEwewHmhRSyqJtbmfw+g11pSriIGAvc9xnc5cCqukAanEB94fy0aUiixJANCMWFs/xEg5lHLHNN+rYgwAACAAAAAgAAAAIACAACAAAAAAAAAAAAiBgPVCXUJfw2IffHpSPbaK7xITB7AeaFFLKom1uZ/D6DXWhwWjdYDMAAAgAAAAIAAAACAAgAAgAAAAAAAAAAAAAA=',
    );

    assert.throws(() => psbt.finalizeAllInputs()); // as it is not fully signed yet
    walletWithNoKeys.cosignPsbt(psbt); // should do nothing, we have no keys
    assert.strictEqual(walletWithNoKeys.calculateHowManySignaturesWeHaveFromPsbt(psbt), 0);

    const walletWithFirstKey = new MultisigHDWallet();
    walletWithFirstKey.addCosigner(Zpub1, fp1cobo);
    walletWithFirstKey.addCosigner(process.env.MNEMONICS_COLDCARD, false, path);
    walletWithFirstKey.setDerivationPath(path);
    walletWithFirstKey.setM(2);

    walletWithFirstKey.cosignPsbt(psbt); // <-------------------------------------------------------------------------

    assert.strictEqual(walletWithFirstKey.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);
    assert.throws(() => psbt.finalizeAllInputs()); // as it is not fully signed yet

    walletWithFirstKey.cosignPsbt(psbt); // should do nothing, we already cosigned with this key
    assert.strictEqual(walletWithFirstKey.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1); // didnt change

    const walletWithSecondKey = new MultisigHDWallet();
    walletWithSecondKey.addCosigner(process.env.MNEMONICS_COBO);
    walletWithSecondKey.addCosigner(Zpub2, fp2coldcard);
    walletWithSecondKey.setDerivationPath(path);
    walletWithSecondKey.setM(2);

    const { tx } = walletWithSecondKey.cosignPsbt(psbt); // <---------------------------------------------------------

    assert.strictEqual(walletWithFirstKey.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);
    assert.ok(tx);
    assert.throws(() => psbt.finalizeAllInputs()); // as it is already finalized
    assert.ok(tx.toHex());
  });

  it('can cosign PSBT that comes from electrum', async () => {
    const wallet = new MultisigHDWallet();
    wallet.setSecret(
      'Name: Multisig Vault\n' +
        'Policy: 2 of 2\n' +
        "Derivation: m/48'/0'/0'/2'\n" +
        'Format: P2WSH\n' +
        '\n' +
        '00000000: Zpub6yjw2xcmSY3uD1KbYLnrSuP2PaxDXajA1YymjzstkZCGnBX3Z1oC6dVFtA1TQNPoTaguixnjYfRK3edDDoP3xxJZSSv1S9NrG5zqK5YzKHE\n' +
        '\n' +
        'seed: point match rack notable poverty welcome slice stem warfare later skirt dream',
    );

    const psbt = bitcoin.Psbt.fromBase64(
      'cHNidP8BAHsCAAAAAn99yxH8deILgpB2qT23xRUvfnu8v98JSREOvhP5SFhHAAAAAAD9////2NGbHPsAqZoKkO+PsxfYuLT9pN8T5/LtHnQnStXsyWsAAAAAAP3///8B2LECAAAAAAAWABTNx1+3yJfKJVcFfHn3KBn9EVdBLmIkCgAAAQDrAgAAAAABAdjRmxz7AKmaCpDvj7MX2Li0/aTfE+fy7R50J0rV7MlrAQAAAAAAAACAAqCGAQAAAAAAIgAgNjviJkwSkV3MVJI0X8KnLUc+MfW/d4EQvWgykrvTwHDeDAIAAAAAABYAFGPIzN0T0b+DfXhLYiOUdT2c5pEBAkgwRQIhAIyPdquXeaHAXL7PpaYt5+G9rl0lLXMPaDM2u9fVuCp4AiA7EIZQm8bIdC4Z+oWtXh0xCKSvTgiwDQWGsQ2kMC2+LwEhA7+3G393F7pqELKBkYzEka2iEvVsLpGjdTvVuP6nufrLAAAAACICA6qDyEv6617qV3VEJoGIQowgTguor7GTI1qOYIz/M6PpRzBEAiBN+gF6Xa7PO1/NbL7K8Nqa3W5vPiuaAov6v+7zjTNDlgIgf9jYQ76Hf4xoOBdveYCyaOeoq+jwXN05nvJlVgZFngkBAQVHUiEDWcyClcxZ8xFXyF1LM8kiGaXqdqM3aHgKK2/Di976NAohA6qDyEv6617qV3VEJoGIQowgTguor7GTI1qOYIz/M6PpUq4iBgNZzIKVzFnzEVfIXUszySIZpep2ozdoeAorb8OL3vo0CgyRUA3SAAAAAAEAAAAiBgOqg8hL+ute6ld1RCaBiEKMIE4LqK+xkyNajmCM/zOj6RCvgJIDAQAAgAAAAAABAAAAAAEA6wIAAAAAAQHWV2FCU0XMuya/nkpDw/yIOK7U3NehUDZmechoTJQFlQEAAAAAAAAAgAKghgEAAAAAACIAIJi9hmdhYfHNmOEaEADqxlNRmtsZIU/NisM8/b4UVU67JqUDAAAAAAAWABSOkTpoURBU5UZG1VIoBj+EHlF6cgJIMEUCIQCJjUIn/LFJNknngMXEfHUNegppt/olh+2RCYGDZ/yw7AIgLw7SwWCaZvHB8PwMj+9F4Rjhvmq4BZ7gozr7tQZMOY0BIQN3F33l/rnJgyIJQHHYEwfxCympfDiFZ8rV76gttJdnLwAAAAAiAgKk1ZQ+v8BXIY1q1aQcRA1Qy6XQVrrhXEcWtXrOvOzf8kcwRAIgPYRi8+wJVym+EF3LNyOylj1RcdPzMiLxKRqlVm64IUgCIH1JVGxAIvmwKpg1TqlvbeXZbUMCjnr7CkYWqxBqghLfAQEFR1IhAqTVlD6/wFchjWrVpBxEDVDLpdBWuuFcRxa1es687N/yIQPo29i9fz5IsDSF1lSMDBbhehw+ydEhNYmjujZiSfyQD1KuIgYCpNWUPr/AVyGNatWkHEQNUMul0Fa64VxHFrV6zrzs3/IQr4CSAwEAAIAAAAAAAAAAACIGA+jb2L1/PkiwNIXWVIwMFuF6HD7J0SE1iaO6NmJJ/JAPDJFQDdIAAAAAAAAAAAAA',
    );
    assert.strictEqual(wallet.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);

    const { tx } = wallet.cosignPsbt(psbt); // <---------------------------------------------------------

    assert.strictEqual(wallet.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);
    assert.ok(tx);
    assert.throws(() => psbt.finalizeAllInputs()); // as it is already finalized
    assert.ok(tx.toHex());
  });

  it('can export/import when one of cosigners is mnemonic seed', async () => {
    const path = "m/48'/0'/0'/2'";

    const w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(process.env.MNEMONICS_COLDCARD, false, path);
    w.setDerivationPath(path);
    w.setM(2);

    assert.ok(w.getID());

    const w2 = new MultisigHDWallet();
    w2.setSecret(w.getSecret());
    assert.strictEqual(w2.getID(), w.getID());

    assert.strictEqual(w._getExternalAddressByIndex(0), w2._getExternalAddressByIndex(0));
    assert.strictEqual(w._getExternalAddressByIndex(1), w2._getExternalAddressByIndex(1));
    assert.strictEqual(w._getInternalAddressByIndex(0), w2._getInternalAddressByIndex(0));
    assert.strictEqual(w._getInternalAddressByIndex(1), w2._getInternalAddressByIndex(1));
    assert.strictEqual(w.getM(), w2.getM());
    assert.strictEqual(w.getN(), w2.getN());
    assert.strictEqual(w.getDerivationPath(), w2.getDerivationPath());
    assert.strictEqual(w.getCosigner(1), w2.getCosigner(1));
    assert.strictEqual(w.getCosigner(2), w2.getCosigner(2));
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w2.getCosignerForFingerprint(fp1cobo));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w2.getCosignerForFingerprint(fp2coldcard));
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), w2.getCustomDerivationPathForCosigner(1));
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), w2.getCustomDerivationPathForCosigner(2));
    assert.strictEqual(w.howManySignaturesCanWeMake(), w2.howManySignaturesCanWeMake());
    assert.strictEqual(w.isNativeSegwit(), w2.isNativeSegwit());
    assert.strictEqual(w.isWrappedSegwit(), w2.isWrappedSegwit());
    assert.strictEqual(w.isLegacy(), w2.isLegacy());
    assert.strictEqual(w.getLabel(), w2.getLabel());
  });

  it('can import txt from Cobo and export it back', async () => {
    const path = "m/48'/0'/0'/2'";

    // can work with same secret win different formats: as TXT and as same TXT encoded in UR:
    const secrets = [
      txtFileFormatMultisigNativeSegwit,
      Buffer.from(decodeUR([txtFileFormatMultisigNativeSegwit]), 'hex').toString(),
      txtFileFormatMultisigNativeSegwit.toLowerCase(),
      txtFileFormatMultisigNativeSegwit.toUpperCase(),
    ];

    for (const secret of secrets) {
      const w = new MultisigHDWallet();
      w.setSecret(secret);

      assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
      assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qvwd2d7r46j7u9qyxpedfhe5p075sxuhzd0n6napuvvhq2u5nrmqs9ex90q');
      assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');
      assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qv84pedzkqz2p4sd2dxm9krs0tcfatqcn73nndycaky9qttczj9qq3az9ma');
      assert.strictEqual(w.getM(), 2);
      assert.strictEqual(w.getN(), 2);
      assert.strictEqual(w.getDerivationPath(), path);
      assert.strictEqual(w.getCosigner(1), Zpub1);
      assert.strictEqual(w.getCosigner(2), Zpub2);
      assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), Zpub1);
      assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), Zpub2);
      assert.strictEqual(w.getCustomDerivationPathForCosigner(1), path); // default since custom was not provided
      assert.strictEqual(w.getCustomDerivationPathForCosigner(2), path); // default since custom was not provided
      assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
      assert.strictEqual(w.getLabel(), 'CV_33B5B91A_2-2');

      const w2 = new MultisigHDWallet();
      w2.setSecret(w.getSecret());

      assert.strictEqual(w._getExternalAddressByIndex(0), w2._getExternalAddressByIndex(0));
      assert.strictEqual(w._getExternalAddressByIndex(1), w2._getExternalAddressByIndex(1));
      assert.strictEqual(w._getInternalAddressByIndex(0), w2._getInternalAddressByIndex(0));
      assert.strictEqual(w._getInternalAddressByIndex(1), w2._getInternalAddressByIndex(1));
      assert.strictEqual(w.getM(), w2.getM());
      assert.strictEqual(w.getN(), w2.getN());
      assert.strictEqual(w.getDerivationPath(), w2.getDerivationPath());
      assert.strictEqual(w.getCosigner(1), w2.getCosigner(1));
      assert.strictEqual(w.getCosigner(2), w2.getCosigner(2));
      assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w2.getCosignerForFingerprint(fp1cobo));
      assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w2.getCosignerForFingerprint(fp2coldcard));
      assert.strictEqual(w.getCustomDerivationPathForCosigner(1), w2.getCustomDerivationPathForCosigner(1)); // default since custom was not provided
      assert.strictEqual(w.getCustomDerivationPathForCosigner(2), w2.getCustomDerivationPathForCosigner(2)); // default since custom was not provided
      assert.strictEqual(w.howManySignaturesCanWeMake(), w2.howManySignaturesCanWeMake());
      assert.strictEqual(w.isNativeSegwit(), w2.isNativeSegwit());
      assert.strictEqual(w.isWrappedSegwit(), w2.isWrappedSegwit());
      assert.strictEqual(w.isLegacy(), w2.isLegacy());
      assert.strictEqual(w.getLabel(), w2.getLabel());
    }
  });

  it('can import txt with custom paths per each cosigner (and export it back)', async () => {
    const secret =
      '# CoboVault Multisig setup file (created on D37EAD88)\n' +
      '#\n' +
      'Name: CV_33B5B91A_2-2\n' +
      'Policy: 2 of 2\n' +
      'Format: P2WSH\n' +
      '\n' +
      "# derivation: m/47'/0'/0'/1'\n" +
      'D37EAD88: Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ\n' +
      '\n' +
      "# derivation: m/46'/0'/0'/1'\n" +
      '168DD603: Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn\n';

    const w = new MultisigHDWallet();
    w.setSecret(secret);

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qvwd2d7r46j7u9qyxpedfhe5p075sxuhzd0n6napuvvhq2u5nrmqs9ex90q');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qv84pedzkqz2p4sd2dxm9krs0tcfatqcn73nndycaky9qttczj9qq3az9ma');
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/47'/0'/0'/1'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/46'/0'/0'/1'");
    assert.strictEqual(w.getDerivationPath(), '');
    assert.strictEqual(w.getCosigner(1), Zpub1);
    assert.strictEqual(w.getCosigner(2), Zpub2);
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), Zpub1);
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), Zpub2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);

    const utxos = [
      {
        height: 666,
        value: 100000,
        address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85',
        vout: 0,
        txid: '666b1f2ee25dfd92377bb66a8db2badf45625a59e93f5a89836e178f9f5ed396',
        wif: false,
        confirmations: 0,
        txhex:
          '02000000000101b67e455069a0f44c9df4849ee1167b06c26f8478daefa9c8aeedf1da3d7d81860f000000000000008002a08601000000000022002030862bd71d77b314666e5fdab34d6293ecb4ffdbba55fbd5323dfd79d98b662b04b005000000000016001461e37702582ecf8c87c1eb5008f2afb17acc9d3c02473044022077268bb0f3060b737b657c3c990107be5db41fd311cc64abeab96cff621146fc0220766e2409c0669020ea2160b358037fdb17f49e59faf8e9c50ac946019be079e6012103c3ed17035033b2cb0ce03694d402c37a307f0eea2b909b0272816bfcea83714f00000000',
      },
    ];

    const { psbt: psbt2 } = w.createTransaction(
      utxos,
      [{ address: 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85', value: 10000 }],
      1,
      w._getInternalAddressByIndex(3),
      false,
      false,
    );

    assert.strictEqual(psbt2.data.outputs[1].bip32Derivation[0].path, "m/47'/0'/0'/1'" + '/1/3');
    assert.strictEqual(psbt2.data.outputs[1].bip32Derivation[1].path, "m/46'/0'/0'/1'" + '/1/3');

    assert.strictEqual(psbt2.data.inputs[0].bip32Derivation[0].path, "m/47'/0'/0'/1'/0/0");
    assert.strictEqual(psbt2.data.inputs[0].bip32Derivation[1].path, "m/46'/0'/0'/1'/0/0");

    // testing that custom paths survive export/import

    const w2 = new MultisigHDWallet();
    w2.setSecret(w.getSecret());

    assert.strictEqual(w._getExternalAddressByIndex(0), w2._getExternalAddressByIndex(0));
    assert.strictEqual(w._getExternalAddressByIndex(1), w2._getExternalAddressByIndex(1));
    assert.strictEqual(w._getInternalAddressByIndex(0), w2._getInternalAddressByIndex(0));
    assert.strictEqual(w._getInternalAddressByIndex(1), w2._getInternalAddressByIndex(1));
    assert.strictEqual(w.getM(), w2.getM());
    assert.strictEqual(w.getN(), w2.getN());
    assert.strictEqual(w.getDerivationPath(), w2.getDerivationPath());
    assert.strictEqual(w.getCosigner(1), w2.getCosigner(1));
    assert.strictEqual(w.getCosigner(2), w2.getCosigner(2));
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), w2.getCosignerForFingerprint(fp1cobo));
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), w2.getCosignerForFingerprint(fp2coldcard));
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), w2.getCustomDerivationPathForCosigner(1));
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), w2.getCustomDerivationPathForCosigner(2));
    assert.strictEqual(w.howManySignaturesCanWeMake(), w2.howManySignaturesCanWeMake());
    assert.strictEqual(w.getLabel(), w2.getLabel());
  });

  it('can parse p2sh colcard format from caravan', () => {
    const cc =
      '# Coldcard Multisig setup file (exported from unchained-wallets)\n' +
      '# https://github.com/unchained-capital/unchained-wallets\n' +
      '# v1.0.0\n' +
      '#\n' +
      'Name: yIm388Ib_x3g6ruuY\n' +
      'Policy: 2 of 3\n' +
      'Format: P2SH\n' +
      '\n' +
      'Derivation: m/0/0/0/0\n' +
      '0dfd4a3b: xpub6EDykLBC5EbV78g9QiFKZtsPnesv2m4Xtbvzi8FjwzGmBJbKVGRUDKcnpf9QyFQrv3vh6C9N92rKaqURHmhhs8EigCTZY7qAsFDGg4QeaU7\n' +
      "Derivation: m/45'/0/0/0\n" +
      '8887a204: xpub6Dma5xev7J5QJuVQ7tGRWGY56FNkt9qX5gCdFQe8fHp4DmtBuxUpxGMo1oBhKYi7fYxqHa2UpPR87Xdc6i7AeZt3tdFRykiqnRk7vKyDcbY\n' +
      "Derivation: m/45'/0/0/0\n" +
      '77c5100e: xpub6DqutttHLMzHBHk6LFJnVkv2EydG6LqN5GAFLFyCFix446y8iMqvavic9zTvgS3kynpD5ycLNKiaKx9c96qvL5VXHqfNZEuGJstJ5tpFfwL\n';

    const w = new MultisigHDWallet();
    w.setSecret(cc);

    assert.strictEqual(w._getExternalAddressByIndex(0), '3KEDMaBiSEmqvkjHgsFZt73MsArxK2LKKq');
  });

  it('can import incomplete wallet from Coldcard', async () => {
    const Zpub = 'Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn';

    const w = new MultisigHDWallet();
    w.setSecret(coldcardExport);

    assert.throws(() => w._getExternalAddressByIndex(0));
    assert.throws(() => w._getInternalAddressByIndex(0));

    assert.strictEqual(w.getM(), 0); // zero means unknown
    assert.strictEqual(w.getN(), 1); // added only one cosigner
    assert.strictEqual(w.getCosigner(1), Zpub);
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), Zpub);
    assert.strictEqual(w.getDerivationPath(), ''); // unknown
  });

  it('can import electrum json file format', () => {
    assert.strictEqual(MultisigHDWallet.ckccXfp2fingerprint(64392470), '168DD603');
    assert.strictEqual(MultisigHDWallet.ckccXfp2fingerprint('64392470'), '168DD603');
    assert.strictEqual(MultisigHDWallet.ckccXfp2fingerprint(2389277556), '747B698E');
    assert.strictEqual(MultisigHDWallet.ckccXfp2fingerprint(1130956047), '0F056943');
    assert.strictEqual(MultisigHDWallet.ckccXfp2fingerprint(2293071571), 'D37EAD88');

    const w = new MultisigHDWallet();
    w.setSecret(electumJson);

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/48'/1'/0'/1'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/48'/1'/0'/1'");
    assert.strictEqual(w.getCosigner(1), Zpub1);
    assert.strictEqual(w.getCosigner(2), Zpub2);
    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), Zpub1);
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), Zpub2);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isWrappedSegwit());
    assert.ok(!w.isLegacy());

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qvwd2d7r46j7u9qyxpedfhe5p075sxuhzd0n6napuvvhq2u5nrmqs9ex90q');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qv84pedzkqz2p4sd2dxm9krs0tcfatqcn73nndycaky9qttczj9qq3az9ma');
  });

  it('can import electrum json file format with seeds', () => {
    const json = require('./fixtures/electrum-multisig-wallet-with-seed.json');
    delete json['x1/'].xpub;
    const json2 = JSON.parse(JSON.stringify(json)); // full copy
    delete json2['x1/'].seed;
    const secrets = [
      JSON.stringify(json),
      JSON.stringify(json2), // has only xprv
    ];

    for (const s of secrets) {
      const w = new MultisigHDWallet();
      w.setSecret(s);

      assert.strictEqual(w.getM(), 2);
      assert.strictEqual(w.getN(), 3);

      assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qkzg22vej70cqnrlsxcee9nfnstcr70jalvsmjn0c8rjf0klwyydsk8nggs');
      assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1q2mkhkvx9l7aqksvyf0dwd2x4yn8qx2w3sythjltdkjw70r8hsves2evfg6');
      assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qqj0zx85x3d2frn4nmdn32fgskq5c2qkvk9sukxp3xsdzuf234mds85w068');
      assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qwpxkr4ac7fyp6y8uegfpqa6phyqex3vdf5mwwrfayrp8889adpgszge8m5');

      if (JSON.parse(s)['x1/'].seed) {
        assert.strictEqual(w.howManySignaturesCanWeMake(), 1);
      } else {
        assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
      }

      assert.ok(w.isNativeSegwit());
      assert.ok(!w.isWrappedSegwit());
      assert.ok(!w.isLegacy());

      assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/1'");
      assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/1'");

      assert.strictEqual(w.getFingerprint(1), '8aaa5d05'.toUpperCase());
      assert.strictEqual(w.getFingerprint(2), 'ef748d2c'.toUpperCase());
      assert.strictEqual(w.getFingerprint(3), 'fdb6c4d8'.toUpperCase());

      const utxos = [
        {
          height: 666,
          value: 100000,
          address: 'bc1q2mkhkvx9l7aqksvyf0dwd2x4yn8qx2w3sythjltdkjw70r8hsves2evfg6',
          vout: 0,
          txid: 'c097161e8ae3b12ae2c90da95ade1185e368269a861ea9a8da023714d6fea31e',
          wif: false,
          script: { length: 107 }, // incorrect value so old tests pass. in reality its calculated on the fly
          confirmations: 666,
          txhex:
            '020000000001021b43a3a3ba5ff4a23538cc2703fd8346a36431ea471a3f4dd5f0cd7f94f5c15d010000001716001426458e62e6e3c6c86f337a01419b033b19296fafffffffff058afa9f432909398bb960056ad94d25d750ebe363edb61580fa1e995ab9e70b00000000171600149807251b3dffaf026fa29efd0f33d4f3bc853105ffffffff02102700000000000022002056ed7b30c5ffba0b41844bdae6a8d524ce0329d18117797d6db49de78cf78333000300000000000017a91498a34ffa21c4b810eee5cb94cd038a9c1979aa81870247304402204e90bd4bc06f5de27c0c78bbdbcf14d18eee39c2341c8cbdd6d30c172bd83fb2022058a37442adb49f745b07c0f9cf8a06144f103856976356b2a782b5916c95728b012103a9acc34fc8e68e19bee16ca356c597c8f6336d319471dddf86dfd4e28d17264702483045022100fef44f4645da1718363fbe3a7ffde8460faa3d7ca02c9437ab4fed2cf0724cf50220575ce1b64846ffb44b5868092072727b08465d2b8884aecf25e5526f9b536e88012103c3f029468e9fd9741b26228bb71f730e24f55a7569de1f84f1e9826396999bcd00000000',
        },
      ];
      const { psbt, tx } = w.createTransaction(
        utxos,
        [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }],
        1,
        w._getInternalAddressByIndex(3),
        false,
        false,
      );
      assert.ok(psbt);
      assert.ok(!tx);
    }
  });

  it('can import electrum json file format with seeds and passphrase', () => {
    const json = require('./fixtures/electrum-multisig-wallet-with-seed-and-passphrase.json');
    const w = new MultisigHDWallet();
    w.setSecret(JSON.stringify(json));

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qmpyrvv6fmkv494r9qk9nllyuyngtqj62fywcl2xzessgwf9qgrssxff69u');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1q7n8twph2zlfw6w0p5ms9vkvj9klxqhpjy5mv5tnqpcf2pl3d3qrst2pjz7');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1q2ltyvkrs0uay39acfk4y0gmw7flghd3403p94x26tc8579t9adwsjp83yz');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1q24rc4v9r6fjtkrwfp4j57ufef56ez46rrpyjtdkhjpr687f5de0sa7ryv5');

    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isWrappedSegwit());
    assert.ok(!w.isLegacy());

    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/1'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/48'/0'/0'/2'");

    assert.strictEqual(w.getFingerprint(1), '8de7b2c3'.toUpperCase());
    assert.strictEqual(w.getFingerprint(2), '84431270'.toUpperCase());

    const utxos = [
      {
        address: 'bc1qmpyrvv6fmkv494r9qk9nllyuyngtqj62fywcl2xzessgwf9qgrssxff69u',
        height: 0,
        txhex:
          '02000000000101d7bf498a92b19bab8a58260efedd7e6cd3b7713ff1e9d2603ff9f06a64f66291000000001716001440512e04b685a0cd66a03bea0896c27000c828dcffffffff01430b010000000000220020d848363349dd9952d465058b3ffc9c24d0b04b4a491d8fa8c2cc208724a040e10247304402201ad742ffee74e5ae4b3867d9818b8ad6505ca5239280138f9da3f93e4c27ee0802202918fa6034485077596bf64501ae6954371e91d250ee98f5a3c5889d4dee923e012103a681da832358050bd9b197aaa55d921f1447025b999eadb018aa67c5b8f64a0900000000',
        txid: '2d40b967bb3a4ecd8517843d01042b0dd4227192acbe0e1ad1f1cf144a1ec0c9',
        value: 68419,
        vout: 0,
        wif: false,
      },
    ];
    const { psbt } = w.createTransaction(
      utxos,
      [{ address: '39RXMPjwKwoEGJeABJvdG1N4nQAzfEgcos' }],
      1,
      w._getInternalAddressByIndex(3),
      false,
      true,
    );
    assert.ok(psbt);
    // we are using .cosignPsbt for now, because .createTransaction throws
    // Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint
    // https://github.com/MalinWallet/MalinWallet/pull/2466
    const { tx } = w.cosignPsbt(psbt);
    assert.ok(tx);
  });

  it('cant import garbage', () => {
    const w = new MultisigHDWallet();
    w.setSecret('garbage');
    assert.strictEqual(w.getM(), 0);
    assert.strictEqual(w.getN(), 0);

    w.setSecret(Zpub1);
    assert.strictEqual(w.getM(), 0);
    assert.strictEqual(w.getN(), 0);

    w.setSecret(process.env.MNEMONICS_COBO);
    assert.strictEqual(w.getM(), 0);
    assert.strictEqual(w.getN(), 0);

    w.setSecret(MultisigHDWallet.seedToXpub(process.env.MNEMONICS_COLDCARD, "m/48'/0'/0'/1'"));
    assert.strictEqual(w.getM(), 0);
    assert.strictEqual(w.getN(), 0);
  });

  it('can import from caravan', () => {
    const json = JSON.stringify({
      name: 'My Multisig Wallet',
      addressType: 'P2WSH',
      network: 'mainnet',
      client: {
        type: 'public',
      },
      quorum: {
        requiredSigners: 2,
        totalSigners: 3,
      },
      extendedPublicKeys: [
        {
          name: 'Extended Public Key 1',
          bip32Path: 'Unknown (make sure you have written this down previously!)',
          xpub: 'xpub6EA866cxYyjQa2mupVnEP5mg1vU5fqkyUo97Sm6SN73KWbXAUQ78dBRTisYHJxj5cTyduxhG2Qxd6QNNjtHoHaGDR7aeUrJUvh9GfqvsRQQ',
          method: 'text',
        },
        {
          name: 'Extended Public Key 2',
          bip32Path: 'Unknown (make sure you have written this down previously!)',
          xpub: 'xpub6FCYVZAU7dofgor9fQaqyqqA9NqBAn83iQpoayuWrwBPfwiPgCXGCD7dvAG93M5MZs5VWVP7FErGA5UeiALqaPt7KV67fL9WX9bqXTyeWxb',
          method: 'text',
        },
        {
          name: 'Extended Public Key 3',
          bip32Path: 'Unknown (make sure you have written this down previously!)',
          xpub: 'xpub6EBRM9zwt7Wmkvte61c4fshZ7ZJDaZiaC27WxTkCq5hdNYPodJY4wayCvMNH4ysF944HaBoS4dVrcfhaHwowTn9TJ7EPWE8hJAZjv7gwtew',
          method: 'text',
        },
      ],
    });
    let w = new MultisigHDWallet();
    w.setSecret(json);

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 3);
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qnpy7c7wz6tvmhdwgyk8ka4du3s9x6uhgjal305xdatmwfa538zxsys5l0t');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qvuum7egsw4r4utzart88pergghy9rp8m4j5m4s464lz6u39sn6usn89w7c');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qatmvfj5nzh4z3njxeg8z86y592clqe7sfgvp5cpund47knnm6pxsswl2lr');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1qpqa9c6nkqgcruegnh8wcsr0gzc4x9y90v9k0nxr6lww0gts430zqp7wm86');
    assert.ok(!w.isWrappedSegwit());
    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isLegacy());

    // take 2

    const json2 = JSON.stringify({
      name: 'My Multisig Wallet',
      addressType: 'P2WSH',
      network: 'mainnet',
      client: {
        type: 'public',
      },
      quorum: {
        requiredSigners: 2,
        totalSigners: 2,
      },
      extendedPublicKeys: [
        {
          name: 'Extended Public Key 1',
          bip32Path: 'Unknown (make sure you have written this down previously!)',
          xpub: 'xpub6EA866cxYyjQa2mupVnEP5mg1vU5fqkyUo97Sm6SN73KWbXAUQ78dBRTisYHJxj5cTyduxhG2Qxd6QNNjtHoHaGDR7aeUrJUvh9GfqvsRQQ',
          method: 'text',
        },
        {
          name: 'Extended Public Key 2',
          bip32Path: 'Unknown (make sure you have written this down previously!)',
          xpub: 'xpub6FCYVZAU7dofgor9fQaqyqqA9NqBAn83iQpoayuWrwBPfwiPgCXGCD7dvAG93M5MZs5VWVP7FErGA5UeiALqaPt7KV67fL9WX9bqXTyeWxb',
          method: 'text',
        },
      ],
      startingAddressIndex: 0,
    });

    w = new MultisigHDWallet();
    w.setSecret(json2);

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qtah0p50d4qlftn049k7lldcwh7cs3zkjy9g8xegv63p308hsh9zsf5567q');

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 2);
    assert.strictEqual(w.getFingerprint(1), '00000000'); // should be fp1cobo, but stupid caravan doesnt store fp
    assert.strictEqual(w.getFingerprint(2), '00000000'); // should be fp2coldcard, but stupid caravan doesnt store fp
    assert.strictEqual(w.howManySignaturesCanWeMake(), 0);
    assert.ok(!w.isWrappedSegwit());
    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isLegacy());
  });

  it('base43 works', () => {
    const electrum43TransactionString =
      '71OUKK$VH33.J1Y/K8Q8T3-F8X59N/YIO*LXY.7320F/5.KN$EG47LC*I1VP$S7FS2+.KAJR5:8$-MDQTMHA54/QT3R$JVX/WRDLONP/*TJLGIHRB.KNSGZWVUW9TOSOE6G1::..-NLQNJD-R1GNJ.HA7A1M.6CS:-60X9LR9XHHB6B1KLTX4T/EZN3$ZWW+J10-Z9QU-N9HHU$EV865ED$3JD$ZUJ6IA2Z:.WXKXTCK2:BMZFW3F+QI.GS54BN3*Q1T*3C1ESF0QA:ZOX1RLG/I/I1GPL:FPLRKAKH:KO4*U0YAK16-CGI-Z7A3EQAJ8Q484VA05FE7JO$-U.HBFWNFSFD8EGPJR*QV3YJD5SHA3BLWM+FR0*FS7M89S115/PU7:6-XW:EPL4/+7N2RFM/**Z6J*/--97OD2QWSLUE7G5F42ATP0SAV52U1GV+WZAJX$T0R:49QIDYJUKOXWX.$UUTR5596EOVK88E$ALJ-/MEML4883J5572D1-LRSXTRYL:X39U8QQ0XII09I5M3:13$U+B7V3S1+YUQM3:G+A/IH9+$.CHEOGE-3NX:OZ+H1D*N3IFC9+/ZT*S/O45QLRC';
    const hexTransactionString =
      '0100000001ac01d39c405d31d3d20b00254e84dce9838b9c280f3aa07bf77a1510d8f8779900000000fd4201004830450221009a4065d3b869f20b6e858e0722d9b511213e09dcf1b61072cccbff340c7f424e022034c42927a64fe323d8e8b76d99960322bf0664fdad9994939aedac74a32ca8c701483045022100dda3d5974ae1c06d9742c7aa5e2f789218054c60476f049300c7d4d0395819aa02201f484d7a2b4cc6186b23f54ea4099a728760d71fcc0c7a82bd056c6eaeacf3ab014cad5221020de4d18c5b852a3c1d1f1033a812b019c396b75cab2a248089b09632c7bbdda221024ee8ab3639ea02d7fac7e90078b16c06811573d7046cd06b5d1d8d7e50e0767a21025392159aaf967c2f7e1dca92b68d1b3abaf44a9d3903f7382e76f9f64e7bfa242102df269b98c7ea5bdec1aac268d6107b827163d3a0ca8bd3522279d14c46e1bf1a2103cfbf85d74dddf892b3b6f918fd36dab13cc904d9ba3c9306e9e25fe53ebde08155aeffffffff01131f0000000000001976a914e9cc1b59c97f860f5c629c23d93920da60648d0388ac00000000';
    const badString = 'invalid characters';

    assert.throws(() => {
      Base43.decode(badString);
    });
    assert.strictEqual(Base43.decode(electrum43TransactionString), hexTransactionString);
    assert.ok(
      Base43.decode(
        '8+065FQS++FH76-QX$/RI8KR6O*V+WR-I0FH.9B49H1+L6I5N1JJ$M+P:3AH:QM2QUFSRR2D1XFX+I2:WTTG3F2HL4P02O2+6JE8VYJNXP:EPJ6KPMHQEJO-I/W.6*ESN:YC6FZ24PJS/QRU0YEAKSZAZM8:$7$HI7UKPG+H:+BNRO20QPOOCI8P45/TNGX-QR.X0P*WP0TAGCHMMO-UGONFLCG2QMMIA$GU6HPNI.9TK2+X99L7GLD0$OHSX2N55/1.X8ZCRH.-06B8L+6A865PIWM8Q.*8BLD2/AY+1E2F-FH6VD+JFZC*-G*IDZQ/U-8G0UOGYV1GA6BC1N.X95R:E12L987Q$TG61X4+SR4SO*IG083GH4L77DF6FL-JAFDX/W5BR4.I*$3S*9CDIW0Z4MXWJE-R9TP-OU3T$L0RHXXV885$GJ$VMOP6DX700GU7CASZGM:-XZQ+QSFXUOE:P/OKNUEIBT.BV8G.V5GRDQ3DT-W5*L4GHD-X2WFV9940YL:4LCTAWQDL..GAD9X6H:ZU064-5MUBKG0O20ZY8FV0RX+O7IL3T3YL0CKGLYZQUYXB+.F2JNN4MV83/V70UWZA6AGSU5SVSJMYXN7RRO02IXX8*QBDCYJU2G*N7+U',
      ).startsWith('70736274'),
    );
  });

  it('can import from specter-desktop/fullynoded', () => {
    // @see https://github.com/Fonta1n3/FullyNoded/blob/master/Docs/Wallets/Wallet-Export-Spec.md
    const json = JSON.stringify({
      label: 'Multisig',
      blockheight: 649459,
      descriptor:
        'wsh(sortedmulti(2,[1104442d/48h/0h/0h/2h]xpub6ERaLLFZ3qu7X4cpiMAvSZ6UZVXJfxY5FoNvVJgai1V78DmeNHTcNVfu4cK2RmvTNXU4s1tFpGMPTwqoQ1RraE2o9iiNw2s2aHESpandSFY/0/*,[8cce63f8/48h/0h/0h/2h]xpub6FCSLcRY99737oUAnvXd1k2gSz9P4zi4gQJ8UChSPSCxCK7XS9kLzoLHKNBiR26d3ivT7w3oka9f4BepVLoQ875XzgejjbDo626R6NBUJDW/0/*,[bf27bd7b/48h/0h/0h/2h]xpub6FE9uTPh1RxPRAfFVaET75vdfdQzXKZrT7LxukkqY4KhwUm4haMSPCwERfPouG6da6uZTRCXettvYFDck7nbw6JdBztGr1VBLonWch7NpJo/0/*))#erxvm6x2',
    });
    const w = new MultisigHDWallet();
    w.setSecret(json);
    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 3);
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1q338rmdygx0weah4pdrp9xyycxlv2t48276gk3gxmg6m7xdkkglsqgzm6mz');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qcgn73pjlwtt6krs2u6as0kh2jp486fa0t93yyq4d7xxxc37rf24qg67ewq');
    assert.strictEqual(w.getLabel(), 'Multisig');
    assert.ok(!w.isWrappedSegwit());
    assert.ok(w.isNativeSegwit());
    assert.ok(!w.isLegacy());

    assert.strictEqual(w.getFingerprint(1), '1104442D');
    assert.strictEqual(w.getFingerprint(2), '8CCE63F8');
    assert.strictEqual(w.getFingerprint(3), 'BF27BD7B');

    assert.strictEqual(
      w.getCosigner(1),
      'xpub6ERaLLFZ3qu7X4cpiMAvSZ6UZVXJfxY5FoNvVJgai1V78DmeNHTcNVfu4cK2RmvTNXU4s1tFpGMPTwqoQ1RraE2o9iiNw2s2aHESpandSFY',
    );
    assert.strictEqual(
      w.getCosigner(2),
      'xpub6FCSLcRY99737oUAnvXd1k2gSz9P4zi4gQJ8UChSPSCxCK7XS9kLzoLHKNBiR26d3ivT7w3oka9f4BepVLoQ875XzgejjbDo626R6NBUJDW',
    );
    assert.strictEqual(
      w.getCosigner(3),
      'xpub6FE9uTPh1RxPRAfFVaET75vdfdQzXKZrT7LxukkqY4KhwUm4haMSPCwERfPouG6da6uZTRCXettvYFDck7nbw6JdBztGr1VBLonWch7NpJo',
    );

    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/48'/0'/0'/2'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/48'/0'/0'/2'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(3), "m/48'/0'/0'/2'");
    assert.strictEqual(w.getDerivationPath(), '');
  });

  it('can import from specter-desktop/fullynoded (p2sh-p2wsh)', () => {
    // @see https://github.com/Fonta1n3/FullyNoded/blob/master/Docs/Wallets/Wallet-Export-Spec.md

    const secrets = [
      JSON.stringify({
        label: 'nested2of3',
        blockheight: 481824,
        descriptor:
          'sh(wsh(sortedmulti(2,[99fe7770/48h/0h/0h/1h]xpub6FEEbEaYM9pmY8rxz4g6AuaJVszwKt8g6cFg9nFWeE85EdBrGBcnhHqXAaPbQ4Hi3Xu9vijtYdYnNjERw9eSniF3235Vjde11GieeHjv7XT/0/*,[636bdad0/48h/0h/0h/1h]xpub6F67TyyWngU5rkVPxHTdmuYkaXHXeRwwVg5SsDeiPPjt6Mithh4Qzpu2yHjNa5W7nhcTbV6QaJMvppYMDSnB3SxArCkp9GvHQqpr5P17yFv/0/*,[99c90b2f/48h/0h/0h/1h]xpub6E6FyTrwmuUYeRMULXSAGvUKeP5ba6pQKVhWNuvVZFmGPnDYb9m5vP2XsSEQ4gKUGfXtLcKs4AV31vpfx2P5KuWm9co4HM3FtGov8enmJ6f/0/*)))#wy7xtlnw',
      }),
      'sh(wsh(sortedmulti(2,[99fe7770/48h/0h/0h/1h]xpub6FEEbEaYM9pmY8rxz4g6AuaJVszwKt8g6cFg9nFWeE85EdBrGBcnhHqXAaPbQ4Hi3Xu9vijtYdYnNjERw9eSniF3235Vjde11GieeHjv7XT/0/*,[636bdad0/48h/0h/0h/1h]xpub6F67TyyWngU5rkVPxHTdmuYkaXHXeRwwVg5SsDeiPPjt6Mithh4Qzpu2yHjNa5W7nhcTbV6QaJMvppYMDSnB3SxArCkp9GvHQqpr5P17yFv/0/*,[99c90b2f/48h/0h/0h/1h]xpub6E6FyTrwmuUYeRMULXSAGvUKeP5ba6pQKVhWNuvVZFmGPnDYb9m5vP2XsSEQ4gKUGfXtLcKs4AV31vpfx2P5KuWm9co4HM3FtGov8enmJ6f/0/*)))#wy7xtlnw',
    ];

    for (const secret of secrets) {
      const w = new MultisigHDWallet();
      w.setSecret(secret);
      assert.strictEqual(w.getM(), 2);
      assert.strictEqual(w.getN(), 3);
      assert.strictEqual(w._getExternalAddressByIndex(0), '3GSZaKT3LujScx6JeWejc6xjZsCDRzptsA');
      assert.strictEqual(w._getExternalAddressByIndex(1), '3GT11kStn8W6q2kj257uZqW9xEKJwPMDkw');
      assert.ok(w.getLabel() === 'nested2of3' || w.getLabel() === 'Multisig vault');
      assert.ok(w.isWrappedSegwit());
      assert.ok(!w.isNativeSegwit());
      assert.ok(!w.isLegacy());

      assert.strictEqual(w.getFingerprint(1), '99FE7770');
      assert.strictEqual(w.getFingerprint(2), '636BDAD0');
      assert.strictEqual(w.getFingerprint(3), '99C90B2F');

      assert.strictEqual(
        w.getCosigner(1),
        'xpub6FEEbEaYM9pmY8rxz4g6AuaJVszwKt8g6cFg9nFWeE85EdBrGBcnhHqXAaPbQ4Hi3Xu9vijtYdYnNjERw9eSniF3235Vjde11GieeHjv7XT',
      );
      assert.strictEqual(
        w.getCosigner(2),
        'xpub6F67TyyWngU5rkVPxHTdmuYkaXHXeRwwVg5SsDeiPPjt6Mithh4Qzpu2yHjNa5W7nhcTbV6QaJMvppYMDSnB3SxArCkp9GvHQqpr5P17yFv',
      );
      assert.strictEqual(
        w.getCosigner(3),
        'xpub6E6FyTrwmuUYeRMULXSAGvUKeP5ba6pQKVhWNuvVZFmGPnDYb9m5vP2XsSEQ4gKUGfXtLcKs4AV31vpfx2P5KuWm9co4HM3FtGov8enmJ6f',
      );

      assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/48'/0'/0'/1'");
      assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/48'/0'/0'/1'");
      assert.strictEqual(w.getCustomDerivationPathForCosigner(3), "m/48'/0'/0'/1'");
      assert.strictEqual(w.getDerivationPath(), '');
    }

    const ww = new MultisigHDWallet();
    ww.addCosigner('equal emotion skin exchange scale inflict half expose awkward deliver series broken');
    ww.addCosigner('spatial road snack luggage buddy media seek charge people pool neither family');
    ww.addCosigner('sing author lyrics expand ladder embody frost rapid survey similar flight unknown');
    ww.setM(2);
    ww.setDerivationPath("m/48'/0'/0'/1'");
    ww.setWrappedSegwit();
    assert.strictEqual(ww._getExternalAddressByIndex(0), '3GSZaKT3LujScx6JeWejc6xjZsCDRzptsA');
    assert.strictEqual(ww.getFingerprint(1), '99FE7770');
  });

  it('can edit cosigners', () => {
    const path = "m/48'/0'/0'/2'";

    const w = new MultisigHDWallet();
    w.addCosigner(Zpub1, fp1cobo);
    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    w.setDerivationPath(path);
    w.setM(2);
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qxzrzh4caw7e3genwtldtxntzj0ktfl7mhf2lh4fj8h7hnkvtvc4salvp85');

    assert.strictEqual(w.getCosigner(1), Zpub1);
    assert.strictEqual(w.getCosigner(2), process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), path);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), path);

    assert.strictEqual(w.getCosignerForFingerprint(fp1cobo), Zpub1);
    assert.strictEqual(w.getCosignerForFingerprint(fp2coldcard), process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.howManySignaturesCanWeMake(), 1);

    w.replaceCosignerSeedWithXpub(2);
    assert.strictEqual(w.getCosigner(2), Zpub2);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), path);

    w.replaceCosignerXpubWithSeed(2, process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.getCosigner(2), process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.getFingerprint(2), fp2coldcard);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), path);

    w.deleteCosigner(fp2coldcard);
    assert.ok(!w.getCosigner(2));
    assert.ok(!w.getFingerprint(2));
    assert.ok(!w.getCustomDerivationPathForCosigner(2));
    assert.strictEqual(w.getN(), 1);
    assert.strictEqual(w.getM(), 2);

    w.addCosigner(process.env.MNEMONICS_COLDCARD);
    assert.strictEqual(w.getN(), 2);
    w.deleteCosigner(fp2coldcard);
    assert.ok(!w.getCosigner(2));
    assert.ok(!w.getFingerprint(2));
    assert.ok(!w.getCustomDerivationPathForCosigner(2));
    assert.strictEqual(w.getN(), 1);
    assert.strictEqual(w.getM(), 2);

    w.addCosigner(Zpub2, fp2coldcard, path);
    assert.strictEqual(w.getN(), 2);
    w.deleteCosigner(fp2coldcard);
    assert.ok(!w.getCosigner(2));
    assert.ok(!w.getFingerprint(2));
    assert.ok(!w.getCustomDerivationPathForCosigner(2));
    assert.strictEqual(w.getN(), 1);
    assert.strictEqual(w.getM(), 2);

    w.addCosigner(
      'salon smoke bubble dolphin powder govern rival sport better arrest certain manual',
      undefined,
      undefined,
      '9WDdFSZX4d6mPxkr',
    );
    assert.strictEqual(w.getN(), 2);

    w.replaceCosignerSeedWithXpub(2);
    assert.strictEqual(
      w.getCosigner(2),
      'Zpub752NRx3S4ax3S5oLHLB2DAQx9X3Ek4EGvtsyYTpzQ2VRdXB6DjL5ZKiHhcUqfZM6M2KCVB5vSXEQ4jMosHWuF4dD5pwowfzL4fmJz5FaJHh',
    );
    assert.strictEqual(w.getFingerprint(2), '2C0908B6');
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), path);
    assert.ok(!w.getCosignerPassphrase(2));

    w.replaceCosignerXpubWithSeed(
      2,
      'salon smoke bubble dolphin powder govern rival sport better arrest certain manual',
      '9WDdFSZX4d6mPxkr',
    );
    assert.strictEqual(w.getCosigner(2), 'salon smoke bubble dolphin powder govern rival sport better arrest certain manual');
    assert.strictEqual(w.getFingerprint(2), '2C0908B6');
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), path);
    assert.strictEqual(w.getCosignerPassphrase(2), '9WDdFSZX4d6mPxkr');

    // test that after deleting cosinger with passphrase, it has been cleaned out properly
    w.deleteCosigner('2C0908B6');
    assert.ok(!w.getCosigner(2));
    assert.ok(!w.getFingerprint(2));
    assert.ok(!w.getCustomDerivationPathForCosigner(2));
    assert.ok(!w.getCosignerPassphrase(2));
    assert.strictEqual(w.getN(), 1);
    assert.strictEqual(w.getM(), 2);

    // after chaning first cosigner, make sure that he changed, not the second one
    w.replaceCosignerXpubWithSeed(1, process.env.MNEMONICS_COBO);
    assert.strictEqual(w.getCosigner(1), process.env.MNEMONICS_COBO);
    assert.strictEqual(w.getFingerprint(1), fp1cobo);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), path);
    assert.strictEqual(w.getCosignerPassphrase(1), undefined);
  });

  it('can sign valid tx if we have more keys than quorum ("Too many signatures" error)', async () => {
    const w = new MultisigHDWallet();
    w.setSecret(
      '# MalinWallet Multisig setup file\n' +
        '# this file may contain private information\n' +
        '#\n' +
        'Name: Multisig Vault\n' +
        'Policy: 3 of 6\n' +
        "Derivation: m/48'/0'/0'/2'\n" +
        'Format: P2WSH\n' +
        '\n' +
        'seed: start local figure rose pony artist voice agent pyramid still spot walk\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: empty fall vanish sheriff vibrant diary route lock purity noodle ripple clutch\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: else heart suggest proof travel announce reason priority trick bargain author duty\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: craft response kitchen column feed fitness pill loyal capital together usage either\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: trigger zebra image engine inhale employ floor soul glimpse version extra pizza\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: thank post talent polar hire model trophy elevator wide green hungry gossip\n' +
        '# warning! sensitive information, do not disclose ^^^',
    );

    const utxos = [
      {
        height: 662352,
        value: 100000,
        address: 'bc1qlkh0zgq5ypcdfs9rdvrucra96c5gmjgaufm0au8cglkkrah29nesrkvewg',
        vout: 0,
        txid: 'e112e3b109aff5fe76d4fde90bd3c2df58bfb250280a4404421fff42d6801fd2',
        wif: false,
        confirmations: 1,
        txhex:
          '020000000001020d0f713ba314566ea9b7e7d64eb8538dd0a88826377945464e9bb25eed61d665010000000000000080f570a2bb8faff02b848a4a5b2d334324a1ccc6cebf1c1cc27e231316f579e66d01000000000000008002a086010000000000220020fdaef120142070d4c0a36b07cc0fa5d6288dc91de276fef0f847ed61f6ea2cf3d6eb060000000000160014696154a1ed38813c4c45b58ece291c1a8d9cd7d102483045022100d02ef858d129ba50aeee126e41e9cca5fa58232def7934d6705747e81bcd61a402206d2565c336cd32cb128ae9e80af60d610154af0d4e77cb60e015dead349b368b012103471950f9952608d9db6d3698b731d89387b7b55026ae020919ee7da7a2a4866d0247304402204088a68fc4654c0cedb724f6e8fe3820845d5e7184b0363806ea77f8a739f58702202bf7b3b20d6d6db28617e8edd6d0ea3870ab7e3bc62307ad77fa9717a3689bcb01210371d2366d9fc32c5a83bb78d7ced38d5e318a96dc43a18074742e567defe4585d00000000',
      },
    ];

    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }], // sendMax
      1,
      w._getInternalAddressByIndex(0),
    );

    assert.ok(tx);
    assert.ok(psbt);

    assert.strictEqual(psbt.data.inputs.length, 1);
    assert.strictEqual(psbt.data.outputs.length, 1);
  });

  it('can sign multiple inputs', async () => {
    const w = new MultisigHDWallet();
    w.setSecret(
      '# MalinWallet Multisig setup file\n' +
        '# this file may contain private information\n' +
        '#\n' +
        'Name: Multisig Vault\n' +
        'Policy: 2 of 3\n' +
        "Derivation: m/48'/0'/0'/2'\n" +
        'Format: P2WSH\n' +
        '\n' +
        'seed: certain cruise forum ladder reveal frame company book sausage flat wasp mouse\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: sting tumble brave remember sadness embrace increase under year joke drum skate\n' +
        '# warning! sensitive information, do not disclose ^^^ \n' +
        '\n' +
        'seed: daughter parade neck suit brick wife horror inquiry leopard exhibit body mobile\n' +
        '# warning! sensitive information, do not disclose ^^^',
    );

    const utxos = [
      {
        address: 'bc1qzwt595g0q0xauxzr4h56kw4zavfrnq3r4zkx42relm8rvwuuxyvsqndmgl',
        confirmations: 33,
        height: 668483,
        txhex:
          '020000000001019e590dee7124728b988e32c1daad3a550663327b3478c4f9ee15eeaf740b898f0100000017160014018958ab9e2b29b7313a39c1a62189affeac94a8ffffffff014808000000000000220020139742d10f03cdde1843ade9ab3aa2eb12398223a8ac6aa879fece363b9c311902483045022100f431ad4d213265531f600ebf242cabd3adcb7b5c27464ad080a34ce4fb4a5e5702206fad42768d29ee1121e19dc4489366d0c02a412e9d60431cac59d49642868c7b0121037a24a1d8a4e86946e89478f352bda9d6b40843e01b86af5c94b99634cbb0c6b200000000',
        txid: '43b2ac418539b61610c3ae2e216052d634b9b20fcece05940b5662fe5cf3f3b5',
        value: 2120,
        vout: 0,
        wif: false,
      },
      {
        address: 'bc1qn0j7y5hau6s8tdcpnxyyumck256lfet78ehpxdkytv5nt570dr4qxl9s3p',
        confirmations: 1,
        height: 668515,
        txhex:
          '02000000000101a1fba4a09a1a7ed090c64f15024de4b9008b6ec4ee5e336f0f0fc43f78022dfa01000000171600142f78bf055b26feb8f2f6b3caa5956b991c507e49ffffffff0210270000000000002200209be5e252fde6a075b70199884e6f165535f4e57e3e6e1336c45b2935d3cf68ea9a8705000000000017a91484d55f28fc28676c5f195ce649851428ec5010a3870248304502210098a970398bc40a34423d5661ecc499240bb0edb6e6bea74a752269f92e588b1b022031fcdf66c4ed8378f352a5a096c438e7a8c1415c47c119a4c69ef787e1cdf5d9012102ade0a25d66406f67dc3e4a6c8bedd989dd3ceed7a623fb4c2839a84b5262ca0900000000',
        txid: '3a2753147121c2ab312a419f0788cb534232d3c0bd4838de718487aca495ac7a',
        value: 10000,
        vout: 0,
        wif: false,
      },
    ];

    const { psbt, tx } = w.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }], // sendMax
      6,
      w._getInternalAddressByIndex(0),
    );

    assert.ok(tx);
    assert.ok(psbt);

    assert.strictEqual(psbt.data.inputs.length, 2);
    assert.strictEqual(psbt.data.outputs.length, 1);
  });

  it('can generate proper addresses for wallets with passphrases. Export and import such wallet', () => {
    // test case from https://github.com/MalinWallet/MalinWallet/issues/3665#issuecomment-907377442
    const path = "m/48'/0'/0'/2'";
    const w = new MultisigHDWallet();
    w.addCosigner(
      'salon smoke bubble dolphin powder govern rival sport better arrest certain manual',
      undefined,
      undefined,
      '9WDdFSZX4d6mPxkr',
    );
    w.addCosigner('chaos word void picture gas update shop wave task blossom close inner', undefined, undefined, 'E5jMAzsf464Hgwns');
    w.addCosigner(
      'plate inform scissors pill asset scatter people emotion dose primary together expose',
      undefined,
      undefined,
      'RyBFfLr7weK3nDUG',
    );
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(w.getCosignerPassphrase(1), '9WDdFSZX4d6mPxkr');
    assert.strictEqual(w.getCosignerPassphrase(2), 'E5jMAzsf464Hgwns');
    assert.strictEqual(w.getCosignerPassphrase(3), 'RyBFfLr7weK3nDUG');
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1q8rks34ypj5edxx82f7z7yzy4qy6dynfhcftjs9axzr2ml37p4pfs7j4uvm');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qjpjgumzs2afrr3mk85anwdnzd9qg5hc5p6f62un4umpyf4ccde5q4cywgy');

    const w2 = new MultisigHDWallet();
    w2.setSecret(w.getSecret());

    assert.strictEqual(w._getExternalAddressByIndex(0), w2._getExternalAddressByIndex(0));
    assert.strictEqual(w._getExternalAddressByIndex(1), w2._getExternalAddressByIndex(1));
    assert.strictEqual(w.getCosignerPassphrase(1), w2.getCosignerPassphrase(1));
    assert.strictEqual(w.getCosignerPassphrase(2), w2.getCosignerPassphrase(2));
    assert.strictEqual(w.getCosignerPassphrase(3), w2.getCosignerPassphrase(3));
  });

  it('can work with passphrases when seeds are the same but passwords differ', () => {
    // test case from https://github.com/MalinWallet/MalinWallet/issues/3665#issuecomment-907377442
    const path = "m/48'/0'/0'/2'";
    const w = new MultisigHDWallet();
    w.addCosigner(
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
      undefined,
      undefined,
      '1',
    );
    w.addCosigner(
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
      undefined,
      undefined,
      '2',
    );
    w.setDerivationPath(path);
    w.setM(2);

    assert.strictEqual(w.getCosignerPassphrase(1), '1');
    assert.strictEqual(w.getCosignerPassphrase(2), '2');

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qhlxgpu8deq24p3hgyh0f9zkj3uxzg2hcs4ccfy65cr9fg8vm30tqdlssmv');

    assert.strictEqual(
      w.convertXpubToMultisignatureXpub(
        MultisigHDWallet.seedToXpub(w.getCosigner(1), w.getCustomDerivationPathForCosigner(1), w.getCosignerPassphrase(1)),
      ),
      'Zpub74GDyQuS45cpaH8C24Mfrk3Kvrtw78ZtX918Wj4T7dBQSW5BMcxiJAYh95Upjf9ywSbzomNf1SqVrzeZLpwxBjH488uWNaFWkXv1B93HRe7',
    );

    //

    const w2 = new MultisigHDWallet();
    w2.setSecret(w.getSecret());

    assert.strictEqual(w._getExternalAddressByIndex(0), w2._getExternalAddressByIndex(0));
    assert.strictEqual(w._getExternalAddressByIndex(1), w2._getExternalAddressByIndex(1));
    assert.strictEqual(w.getCosignerPassphrase(1), w2.getCosignerPassphrase(1));
    assert.strictEqual(w.getCosignerPassphrase(2), w2.getCosignerPassphrase(2));

    const w3coordinator = new MultisigHDWallet();
    w3coordinator.setSecret(w.getXpub());
    assert.strictEqual(w3coordinator.getFingerprint(1), '126CF4F5');
    assert.strictEqual(
      w3coordinator.getCosigner(1),
      'Zpub74GDyQuS45cpaH8C24Mfrk3Kvrtw78ZtX918Wj4T7dBQSW5BMcxiJAYh95Upjf9ywSbzomNf1SqVrzeZLpwxBjH488uWNaFWkXv1B93HRe7',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), w3coordinator._getExternalAddressByIndex(0));
    assert.strictEqual(w._getInternalAddressByIndex(0), w3coordinator._getInternalAddressByIndex(0));
  });

  it('can import wallet descriptor from Casa multisig', () => {
    const w = new MultisigHDWallet();
    w.setSecret(
      'sh(wsh(sortedmulti(3,[35282ae3]Ypub6j9gr7f7uvWfTHdwVwhYRowZH9oqkh9DZz2hdbeKJw7yjQbsfqaruLva2piTZqN7jSKT43LpsnAqHU4vufUGAyGBzD6UJpwTeKiG5JRYUnm/<0;1>/*,[1b373e31/49/0/5]Ypub6iPAfqqinG5VHf2sJ3XfRjFh8BXm4C6x4U3DaPyu4RKocnqzb1peStw8Q624jwXpMZ5G81s7uwq8qLQ8rW55aZ3LvBbr9XVLTYxG78k28PE/<0;1>/*,[0d7bb846/49/0/5]Ypub6hwdyxEzktht47xgyyFY7TFrAzW7XgGbMSqS3QzfosYekG9LibhpohY6LrsjfP55VyU8i7iWS2s2Vs6RkAeze6bSpU3rNHsmESymE8X3J3k/<0;1>/*,[faa45c74/49/0/5]Ypub6iSiDkVrTTEh6eFbkCvohn1FfuhGr1Co9MCCHi6VPTT6crnX9Avq3PnZj7JcqhDTkWoDLEyeWmaPyxDY22b7k652Sg2eMc2g5tU6GDTvSng/<0;1>/*,[0551354e/49/0/5]Ypub6ipvk7JbDUXormRsSxXRf9eTUAVFwcjDfZXWYxRdN6nV7MNnnuD3WZBYjjWnMTncHhKJsnfkUGVYMRgQthZqY2wfHfMaJoVYBBhHT7MACGs/<0;1>/*)))',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), '3HJiAohE25FFBLPLZGVDwv7ZbSXVsSiZH7');
    assert.strictEqual(w._getExternalAddressByIndex(1), '3GBvQK1iHJ9dw7H8datM4REtYdAu9iQjeh');
    assert.strictEqual(w._getExternalAddressByIndex(2), '3KrAqZwVwND5XFNEAnCuWyf4nPNAfF2JCF');
    assert.strictEqual(w._getInternalAddressByIndex(0), '36oNF12VNk4G5hPRR5zuZixnNjJikkTSWD');
    assert.strictEqual(w._getInternalAddressByIndex(1), '3Q7SnCQK9DYPpFviiEB7NQHa1FJqprCWNX');
    assert.strictEqual(w._getInternalAddressByIndex(2), '33Rkb8XURWkxZBN6dpdk64qa4raK2bRFJS');
  });

  it('can import descriptor from Sparrow', () => {
    const payload =
      'UR:CRYPTO-OUTPUT/TAADMETAADMSOEADAOAOLSTAADDLOLAOWKAXHDCLAOCEBDFLNNTKJTIOJSFSURBNFXRPEEHKDLGYRTEMRPYTGYZOCASWENCYMKPAVWJKHYAAHDCXJEFTGSZOIMFEYNDYHYZEJTBAMSJEHLDSRDDIYLSRFYTSZTKNRNYLRNDPAMTLDPZCAHTAADEHOEADAEAOAEAMTAADDYOTADLOCSDYYKAEYKAEYKAOYKAOCYUOHFJPKOAXAAAYCYCSYASAVDTAADDLOLAOWKAXHDCLAXMSZTWZDIGERYDKFSFWTYDPFNDKLNAYSWTTMUHYZTOXHSETPEWSFXPEAYWLJSDEMTAAHDCXSPLTSTDPNTLESANSUTTLPRPFHNVSPFCNMHESOYGASTLRPYVAATNNDKFYHLQZPKLEAHTAADEHOEADAEAOAEAMTAADDYOTADLOCSDYYKAEYKAEYKAOYKAOCYWZFEPLETAXAAAYCYCPCKRENBTAADDLOLAOWKAXHDCLAOLSFWYKYLKTFHJLPYEMGLCEDPFNSNRDDSRFASEOZTGWIALFLUIYDNFXHGVESFEMMEAAHDCXHTZETLJNKPHHAYLSCXWPNDSWPSTPGTEOJKKGHDAELSKPNNBKBSYAWZJTFWNNBDKTAHTAADEHOEADAEAOAEAMTAADDYOTADLOCSDYYKAEYKAEYKAOYKAOCYSKTPJPMSAXAAAYCYCEBKWLAMTDWZGRZE\n';
    const decoder = new MalinURDecoder();
    decoder.receivePart(payload);

    const data = decoder.toString();

    const w = new MultisigHDWallet();
    w.setSecret(data);

    assert.strictEqual(w.getM(), 2);
    assert.strictEqual(w.getN(), 3);
    assert.strictEqual(w.getFingerprint(1), 'DC567276');
    assert.strictEqual(w.getFingerprint(2), 'F245AE38');
    assert.strictEqual(w.getFingerprint(3), 'C5D87297');
    assert.strictEqual(w.isNativeSegwit(), true);
    assert.strictEqual(w.getCustomDerivationPathForCosigner(1), "m/48'/0'/0'/2'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(2), "m/48'/0'/0'/2'");
    assert.strictEqual(w.getCustomDerivationPathForCosigner(3), "m/48'/0'/0'/2'");
    assert.strictEqual(w.getFormat(), 'p2wsh');

    assert.strictEqual(
      w.getCosigner(1),
      'xpub6DiYrfRwNnjeX4vHsWMajJVFKrbEEnu8gAW9vDuQzgTWEsEHE16sGWeXXUV1LBWQE1yCTmeprSNcqZ3W74hqVdgDbtYHUv3eM4W2TEUhpan',
    );
    assert.strictEqual(
      w.getCosigner(2),
      'xpub6DnT4E1fT8VxuAZW29avMjr5i99aYTHBp9d7fiLnpL5t4JEprQqPMbTw7k7rh5tZZ2F5g8PJpssqrZoebzBChaiJrmEvWwUTEMAbHsY39Ge',
    );
    assert.strictEqual(
      w.getCosigner(3),
      'xpub6DjrnfAyuonMaboEb3ZQZzhQ2ZEgaKV2r64BFmqymZqJqviLTe1JzMr2X2RfQF892RH7MyYUbcy77R7pPu1P71xoj8cDUMNhAMGYzKR4noZ',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1q4taqq6q6l8fvguva6ftvrz3qgdjy6p3w2s0ds0nl6qrjw7t0hfhqgrqcwd');
  });
});

describe('multisig-cosigner', () => {
  it('can parse cobo json', () => {
    const cosigner = new MultisigCosigner(
      '{"xfp":"D37EAD88","xpub":"Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ","path":"m\\/48\'\\/0\'\\/0\'\\/2\'"}',
    );
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), fp1cobo);
    assert.strictEqual(cosigner.getXpub(), Zpub1);
    assert.strictEqual(cosigner.getPath(), "m/48'/0'/0'/2'");
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
    assert.ok(cosigner.isNativeSegwit());
    assert.ok(!cosigner.isLegacy());
    assert.ok(!cosigner.isWrappedSegwit());
  });

  it('can parse cobo json, if xpub is plain xpub (not Zpub or Ypub)', () => {
    const tempWallet = new MultisigHDWallet();
    let xpub = tempWallet._zpubToXpub(Zpub1);
    assert.ok(xpub.startsWith('xpub'));
    let cosigner = new MultisigCosigner(`{"xfp":"${fp1cobo}","xpub":"${xpub}","path":"${MultisigHDWallet.PATH_NATIVE_SEGWIT}"}`);
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), fp1cobo);
    assert.strictEqual(cosigner.getXpub(), Zpub1);
    assert.strictEqual(cosigner.getPath(), MultisigHDWallet.PATH_NATIVE_SEGWIT);
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
    assert.ok(cosigner.isNativeSegwit());
    assert.ok(!cosigner.isLegacy());
    assert.ok(!cosigner.isWrappedSegwit());

    //

    const Ypub1 = 'Ypub6jtUX12KGcqFosZWP4YcHc9qbKRTvgBpb8aE58hsYqby3SQVTr5KGfMmdMg38ekmQ9iLhCdgbAbjih7AWSkA7pgRhiLfah3zT6u1PFvVEbc';
    xpub = tempWallet._zpubToXpub(Ypub1);
    assert.ok(xpub.startsWith('xpub'));
    cosigner = new MultisigCosigner(`{"xfp":"${fp1cobo}","xpub":"${xpub}","path":"${MultisigHDWallet.PATH_WRAPPED_SEGWIT}"}`);
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), fp1cobo);
    assert.strictEqual(cosigner.getXpub(), Ypub1);
    assert.strictEqual(cosigner.getPath(), MultisigHDWallet.PATH_WRAPPED_SEGWIT);
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
    assert.ok(!cosigner.isNativeSegwit());
    assert.ok(!cosigner.isLegacy());
    assert.ok(cosigner.isWrappedSegwit());

    //

    xpub = tempWallet._zpubToXpub(Ypub1);
    assert.ok(xpub.startsWith('xpub'));
    cosigner = new MultisigCosigner(`{"xfp":"${fp1cobo}","xpub":"${xpub}","path":"${MultisigHDWallet.PATH_LEGACY}"}`);
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), fp1cobo);
    assert.strictEqual(cosigner.getXpub(), xpub);
    assert.strictEqual(cosigner.getPath(), MultisigHDWallet.PATH_LEGACY);
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
    assert.ok(!cosigner.isNativeSegwit());
    assert.ok(cosigner.isLegacy());
    assert.ok(!cosigner.isWrappedSegwit());
  });

  it('can parse cobo URv2 account', () => {
    let decoded = decodeUR([
      'UR:CRYPTO-ACCOUNT/OEADCYADWMTNKIAOLYTAADMETAADDLOLAOWKAXHDCLAXHPDIHNWKMYCFHNROCARHSESKLDPDSWOTMWGTJNGWIYHYYNWSOLENTSUEMKTOTAVDAAHDCXBDHHBZSBURBSMKZOECOEHHJPHTSRVACMBGHEROMYCKHHNBHFHGNBGMNYAESPNDFHAHTAADEHOEADADAOAEAMTAADDYOTADLOCSDYYKAEYKAEYKAOYKAOCYADWMTNKIAXAAAYCYLOWLDITOJTCNDTAY',
    ]);
    decoded = Buffer.from(decoded, 'hex').toString('ascii');

    const cosigner = new MultisigCosigner(decoded);
    assert.ok(cosigner.isValid());
    assert.strictEqual(
      cosigner.getXpub(),
      'Zpub756tPxxwHiYkYiT12G2WUD2cpAHyVWhjvKPbXoY5jDZSyo71yG5C14LCuwhycTTAzgTUcQfddR8FFTQ1bSWR6kzmNbMEaVzUrj4Lhxbonjo',
    );
    assert.strictEqual(cosigner.getPath(), "m/48'/0'/0'/2'");
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
    assert.strictEqual(cosigner.getFp(), '01EBDA7D');
  });

  it('can parse plain Zpub', () => {
    const cosigner = new MultisigCosigner(Zpub1);
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), '00000000');
    assert.strictEqual(cosigner.getXpub(), Zpub1);
    assert.strictEqual(cosigner.getPath(), "m/48'/0'/0'/2'");
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
  });

  it('can parse wallet descriptor', () => {
    let cosigner = new MultisigCosigner(
      '[73c5da0a/48h/0h/0h/2h]Zpub74Jru6aftwwHxCUCWEvP6DgrfFsdA4U6ZRtQ5i8qJpMcC39yZGv3egBhQfV3MS9pZtH5z8iV5qWkJsK6ESs6mSzt4qvGhzJxPeeVS2e1zUG',
    );
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), '73c5da0a');
    assert.strictEqual(
      cosigner.getXpub(),
      'Zpub74Jru6aftwwHxCUCWEvP6DgrfFsdA4U6ZRtQ5i8qJpMcC39yZGv3egBhQfV3MS9pZtH5z8iV5qWkJsK6ESs6mSzt4qvGhzJxPeeVS2e1zUG',
    );
    assert.strictEqual(cosigner.getPath(), "m/48'/0'/0'/2'");
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);

    cosigner = new MultisigCosigner(
      '[73c5da0a/48h/0h/0h/2h]xpub6DkFAXWQ2dHxq2vatrt9qyA3bXYU4ToWQwCHbf5XB2mSTexcHZCeKS1VZYcPoBd5X8yVcbXFHJR9R8UCVpt82VX1VhR28mCyxUFL4r6KFrf',
    );
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), '73c5da0a');
    assert.strictEqual(
      cosigner.getXpub(),
      'xpub6DkFAXWQ2dHxq2vatrt9qyA3bXYU4ToWQwCHbf5XB2mSTexcHZCeKS1VZYcPoBd5X8yVcbXFHJR9R8UCVpt82VX1VhR28mCyxUFL4r6KFrf',
    );
    assert.strictEqual(cosigner.getPath(), "m/48'/0'/0'/2'");
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 1);
  });

  it('cant parse bs', () => {
    const cosigner = new MultisigCosigner('asdfasdgsqwrgqwegq');
    assert.ok(!cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), '');
    assert.strictEqual(cosigner.getXpub(), '');
    assert.strictEqual(cosigner.getPath(), '');
  });

  it('can parse file from coldcard with multiple xpubs (for different formats)', () => {
    const cc =
      '{\n' +
      '  "p2sh_deriv": "m/45\'",\n' +
      '  "p2sh": "xpub6847W6cYUqq4ixcmFb83iqPtJZfnMPTkpYiCsuUybzFppJp2qzh3KCVHsLGQy4WhaxGqkK9aDDZnSfhB92PkHDKihbH6WLztzmN7WW9GYpR",\n' +
      '  "p2wsh_p2sh_deriv": "m/48\'/0\'/0\'/1\'",\n' +
      '  "p2wsh_p2sh": "Ypub6kvtvTZpqGuWtQfg9bL5xe4vDWtwsirR8LzDvsY3vgXvyncW1NGXCUJ9Ps7CiizSSLV6NnnXSYyVDnxCu26QChWzWLg5YCAHam6cYjGtzRz",\n' +
      '  "p2wsh_deriv": "m/48\'/0\'/0\'/2\'",\n' +
      '  "p2wsh": "Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn",\n' +
      '  "xfp": "168DD603"\n' +
      '}\n';

    const cosigner = new MultisigCosigner(cc);
    assert.strictEqual(cosigner.howManyCosignersWeHave(), 3);
    assert.ok(cosigner.isValid());
    assert.strictEqual(cosigner.getFp(), '');
    assert.strictEqual(cosigner.getXpub(), '');
    assert.strictEqual(cosigner.getPath(), '');

    const [c1, c2, c3] = cosigner.getAllCosigners();

    assert.strictEqual(
      c1.getXpub(),
      'xpub6847W6cYUqq4ixcmFb83iqPtJZfnMPTkpYiCsuUybzFppJp2qzh3KCVHsLGQy4WhaxGqkK9aDDZnSfhB92PkHDKihbH6WLztzmN7WW9GYpR',
    );
    assert.strictEqual(c1.getFp(), '168DD603');
    assert.strictEqual(c1.getPath(), "m/45'");

    assert.strictEqual(
      c2.getXpub(),
      'Ypub6kvtvTZpqGuWtQfg9bL5xe4vDWtwsirR8LzDvsY3vgXvyncW1NGXCUJ9Ps7CiizSSLV6NnnXSYyVDnxCu26QChWzWLg5YCAHam6cYjGtzRz',
    );
    assert.strictEqual(c2.getFp(), '168DD603');
    assert.strictEqual(c2.getPath(), "m/48'/0'/0'/1'");

    assert.strictEqual(
      c3.getXpub(),
      'Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn',
    );
    assert.strictEqual(c3.getFp(), '168DD603');
    assert.strictEqual(c3.getPath(), "m/48'/0'/0'/2'");
  });

  it('can parse files from sparrow wallet', () => {
    const secrets = [
      [JSON.stringify(require('./fixtures/fromsparrow-electrum.json')), false],
      [require('fs').readFileSync('./tests/unit/fixtures/fromsparrow-coldcard.txt', 'ascii'), true],
      [JSON.stringify(require('./fixtures/fromsparrow-specter.json')), true],
      [JSON.stringify(require('./fixtures/caravan-multisig.json')), true],
    ];

    for (const [s, verifyFingerprints] of secrets) {
      const w = new MultisigHDWallet();
      w.setSecret(s);

      if (verifyFingerprints) {
        assert.strictEqual(w.getFingerprint(1), 'A3909080');
        assert.strictEqual(w.getFingerprint(2), '7AB71DF0');
        assert.strictEqual(w.getFingerprint(3), 'F11B9FF2');
      }

      assert.ok(w.isNativeSegwit());
      assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qtysquqsjqjfqvhd6l2h470hdgwhcahs4nq2ca49cyxftwjnjt9ssh8emel');
    }
  });

  it('can parse files from Nunchuck', () => {
    const secrets = [[require('fs').readFileSync('./tests/unit/fixtures/nunchuck-bsms.txt', 'ascii'), true]];

    for (const [s, verifyFingerprints] of secrets) {
      const w = new MultisigHDWallet();
      w.setSecret(s);

      if (verifyFingerprints) {
        assert.strictEqual(w.getFingerprint(1), '3F5E4E09');
        assert.strictEqual(w.getFingerprint(2), 'B96BC7C7');
        assert.strictEqual(w.getFingerprint(3), '44437F41');
      }

      assert.ok(w.isNativeSegwit());
      assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qjppd555998lvpgdew30kdrvu2qg90n5gg684khrc2u5g7kj8cnuqujvz3p');
    }
  });

  it('can export to json', () => {
    const result = MultisigCosigner.exportToJson(fp1cobo, Zpub1, "m/48'/0'/0'/2'");
    assert.strictEqual(
      result,
      '{"xfp":"D37EAD88","xpub":"Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ","path":"m/48\'/0\'/0\'/2\'"}',
    );

    const cosigner = new MultisigCosigner(MultisigCosigner.exportToJson(fp1cobo, Zpub1, "m/48'/0'/0'/2'"));
    assert.strictEqual(cosigner.getFp(), 'D37EAD88');
    assert.strictEqual(
      cosigner.getXpub(),
      'Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ',
    );
    assert.strictEqual(cosigner.getPath(), "m/48'/0'/0'/2'");
    assert.strictEqual(cosigner.isValid(), true);
    assert.strictEqual(cosigner.isNativeSegwit(), true);
    assert.strictEqual(cosigner.isWrappedSegwit(), false);
    assert.strictEqual(cosigner.isLegacy(), false);

    // using bad xpub just to check chaincode & keyhex
    const c2 = new MultisigCosigner(
      MultisigCosigner.exportToJson(
        fp1cobo,
        'zpub6qT7amLcp2exr4mU4AhXZMjD9CFkopECVhUxc9LHW8pNsJG2B9ogs5sFbGZpxEeT5TBjLmc7EFYgZA9EeWEM1xkJMFLefzZc8eigRFhKB8Q',
        "m/48'/0'/0'/2'",
      ),
    );
    assert.strictEqual(c2.getChainCodeHex(), '906730ab8a03fb4baa32a912134f2c5bfe6ae70e0264e4e9fe4b0abe3a560692');
    assert.strictEqual(c2.getKeyHex(), '0395b643f45bd89fede6f4f6416b288e73005419b48cdcd88465913bd31b4be5ea');
    assert.strictEqual(c2.getParentFingerprintHex(), '125688b1');
    assert.strictEqual(c2.getDepthNumber(), 3);
  });

  it('can export cosigner to URv2', () => {
    let result = encodeUR(MultisigCosigner.exportToJson(fp1cobo, Zpub1, "m/48'/0'/0'/2'"));
    assert.deepStrictEqual(result, [
      'ur:crypto-account/oeadcytekbpmloaolytaadmetaaddloxaxhdclaofejnolgudllagdgodyweehzsmeyasnswrpdalnwzfenbmewlrtplsklbjkvdloweaahdcxltjzjpctayfsimuogtpypffrnlisflswwzntbecabtbdwdbstojnfrahdamnpfcyamtaaddyotadlocsdyykaeykaeykaoykaocytekbpmloaxaaaycyghykhpcmkgnstevs',
    ]);

    result = encodeUR(
      MultisigCosigner.exportToJson(
        '42A2460E',
        'Ypub6m2WhkZvujztfZVYWEB4Hfcq3mKfeZYMfZj2wfvgNmTDjcCncU9ua6VSxXno7FeF8P2kqp1S7N8UoYapR8YKnMLNq8bEDDd2PU6q7QCHoEb',
        "m/48'/0'/0'/1'",
      ),
    );
    assert.deepStrictEqual(result, [
      'ur:crypto-account/oeadcyfwoefgbaaolytaadmhtaadmetaaddloxaxhdclaxsblplucfptgtwywzcmnshtotqzleihrnndtoeodrfdpfoyeyqzsbenrplbhtdymuaahdcxlgbdsrcxatcmdpuokpwzvymttatphtlftplsvlgmeeflpdtanlromhfgvekbbznyamtaaddyotadlocsdyykaeykaeykadykaocyfwoefgbaaxaaaycywsutbeuyyndacaeh',
    ]);

    result = encodeUR(
      MultisigCosigner.exportToJson(
        'ED5C5B8A',
        'xpub69dgpFkP9mFYhaAWt6svmwd1BYsuGiyyNs8sJW1GwCn8GSK69mrCmNG6ZLcrPGvBSiJzfjXD66ntgJxdqQbhMk4j273VQYHEMc5knoqFGvt',
        "m/45'",
      ),
    );
    assert.deepStrictEqual(result, [
      'ur:crypto-account/oeadcywehhhpleaolytaadmhtaaddloxaxhdclaoamutctbahthnislelbwemnkeoefnhddienfetbpygrpaqdkemyrywyldaspyjkdtaahdcxhyneskwdhlehlfbwrpdnjlgsgakplkjtknvyttsgolnnlbwlcagoolcpfgsglkinamtaaddyotadlfcsdpykaocywehhhpleaxadaycywehhhplekpdwveih',
    ]);
  });
});


================================================
FILE: ./tests/unit/addresses.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import {
  TABS,
  filterByAddressType,
  getAddress,
  sortByAddressIndex,
  totalBalance
} from '../../screen/wallets/WalletAddresses';

jest.mock('../../malin_modules/currency', () => {
  return {
    initCurrencyDaemon: jest.fn(),
  }
});

jest.mock('../../malin_modules/MalinElectrum', () => {
  return {
    connectMain: jest.fn(),
  }
});

const mockAddressesList = [
  {
    index: 2,
    isInternal: false,
    key: 'third_external_address',
    address: '',
    balance: 0,
    transactions: 0
  },
  {
    index: 0,
    isInternal: true,
    key: 'first_internal_address',
    address: '',
    balance: 0,
    transactions: 0
  },
  {
    index: 1,
    isInternal: false,
    key: 'second_external_address',
    address: '',
    balance: 0,
    transactions: 0
  },
  {
    index: 1,
    isInternal: true,
    key: 'second_internal_address',
    address: '',
    balance: 0,
    transactions: 0
  },
  {
    index: 0,
    isInternal: false,
    key: 'first_external_address',
    address: '',
    balance: 0,
    transactions: 0
  }
]

describe('Addresses', () => {
  it('Sort by index', () => {
    const sortedList = mockAddressesList.sort(sortByAddressIndex);

    assert.strictEqual(sortedList[0].index, 0);
    assert.strictEqual(sortedList[2].index, 1);
    assert.strictEqual(sortedList[4].index, 2);
  })

  it('Have tabs defined', () => {
    const tabsEnum = {
      EXTERNAL: 'receive',
      INTERNAL: 'change',
    };

    assert.deepStrictEqual(TABS, tabsEnum);
  })

  it('Filter by type', () => {
    let currentTab: (typeof TABS)[keyof typeof TABS] = TABS.EXTERNAL;

    const externalAddresses = mockAddressesList.filter((address) =>
      filterByAddressType(TABS.INTERNAL, address.isInternal, currentTab)
    );

    currentTab = TABS.INTERNAL;

    const internalAddresses = mockAddressesList.filter((address) =>
      filterByAddressType(TABS.INTERNAL, address.isInternal, currentTab)
    );

    externalAddresses.forEach((address) => {
      assert.strictEqual(address.isInternal, false);
    })

    internalAddresses.forEach((address) => {
      assert.strictEqual(address.isInternal, true);
    })
  });

  it('Sum confirmed/unconfirmed balance', () => {
    const wallet1Balance = { c: 0, u: 0 };
    const wallet2Balance = { c: 7, u: 3 };
    const wallet3Balance = { c: 3, u: 7 };

    assert.strictEqual(totalBalance(wallet1Balance), 0);
    assert.strictEqual(totalBalance(wallet2Balance), 10);
    assert.strictEqual(totalBalance(wallet3Balance), 10);
  })

  it('Returns AddressItem object', () => {
    const fakeWallet = {
      _getExternalAddressByIndex: (index: number) =>
        `external_address_${index}`,
      _getInternalAddressByIndex: (index: number) =>
        `internal_address_${index}`,
      _balances_by_external_index: [{ c: 0, u: 0 }],
      _balances_by_internal_index: [{ c: 0, u: 0 }],
      _txs_by_external_index: { 0: [{}] },
      _txs_by_internal_index: { 0: [{}, {}] },
    }

    const firstExternalAddress = getAddress(fakeWallet, 0, false);
    const firstInternalAddress = getAddress(fakeWallet, 0, true);

    assert.deepStrictEqual(firstExternalAddress, {
      address: 'external_address_0',
      balance: 0,
      index: 0,
      isInternal: false,
      key: 'external_address_0',
      transactions: 1,
    })

    assert.deepStrictEqual(firstInternalAddress, {
      address: 'internal_address_0',
      balance: 0,
      index: 0,
      isInternal: true,
      key: 'internal_address_0',
      transactions: 2,
    })
  });
})


================================================
FILE: ./tests/unit/hd-segwit-electrum-seed-p2wpkh-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { HDSegwitElectrumSeedP2WPKHWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('HDSegwitElectrumSeedP2WPKHWallet', () => {
  it('wont accept BIP39 seed', () => {
    const hd = new HDSegwitElectrumSeedP2WPKHWallet();
    hd.setSecret('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');
    assert.ok(!hd.validateMnemonic());
  });

  it('wont accept electrum seed, but STANDARD p2pkh seed', () => {
    const hd = new HDSegwitElectrumSeedP2WPKHWallet();
    hd.setSecret('receive happy  wash prosper update    pet neck acid try profit proud hungry  ');
    assert.ok(!hd.validateMnemonic());
  });

  it('can import mnemonics and generate addresses and WIFs', async function () {
    const hd = new HDSegwitElectrumSeedP2WPKHWallet();
    hd.setSecret('method goddess  humble  crumble output snake essay carpet monster barely trip betray ');
    assert.ok(hd.validateMnemonic());
    assert.strictEqual(
      hd.getXpub(),
      'zpub6n6X5F7QEogTDXchPXXhrvDQ38D5JTFNFWhFrFyri3Sazo4x225nENMeN1kKs1cYbeZDtuDUXhDQepUkxjnAi67z2PJ4d33qo8Cu3HLw74c',
    );

    let address = hd._getExternalAddressByIndex(0);
    assert.strictEqual(address, 'bc1q2yv6rhtw9ycqeq2rkch65sucf66ytwsd3csawr');
    assert.ok(hd.getAllExternalAddresses().includes('bc1q2yv6rhtw9ycqeq2rkch65sucf66ytwsd3csawr'));

    address = hd._getInternalAddressByIndex(0);
    assert.strictEqual(address, 'bc1qvdu80q26ghe66zq8tf5y09qr29vay4cg65mvuk');

    let wif = hd._getExternalWIFByIndex(0);
    assert.strictEqual(wif, 'L5a1N5JQzT9wDUmVS9hb2mrd1SMkwPfrWYS8C3Kngp7kiuBkpY2V');

    wif = hd._getInternalWIFByIndex(0);
    assert.strictEqual(wif, 'KwsLfaB2y9QZRd5cxY3uM3L4r2fE7ZPzocwjkPbp1cSFMFfE9tBq');

    let u8a = hd._getPubkeyByAddress(hd._getExternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '023cb68c37a1ca627c414e63dfb23706091eafb50e50d7de4e2a1a56d7085d42e6');
    u8a = hd._getPubkeyByAddress(hd._getInternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '02e7e6a8dc1fe62f7de88a7de3c5030f36ec6aec28c610bc1d573435fab18b9f94');

    hd.setSecret('bs');
    assert.ok(!hd.validateMnemonic());
  });

  // from electrum tests https://github.com/spesmilo/electrum/blob/9c1a51547a301e765b9b0f9935c6d940bb9d658e/electrum/tests/test_wallet_vertical.py#L130
  it('can use mnemonic with passphrase', () => {
    const mnemonic = 'bitter grass shiver impose acquire brush forget axis eager alone wine silver';
    const UNICODE_HORROR = '          who knws wat horrors le in the dark heart f uncode?';
    const hd = new HDSegwitElectrumSeedP2WPKHWallet();
    hd.setSecret(mnemonic);
    hd.setPassphrase(UNICODE_HORROR);

    assert.strictEqual(
      hd.getXpub(),
      'zpub6nD7dvF6ArArjskKHZLmEL9ky8FqaSti1LN5maDWGwFrqwwGTp1b6ic4EHwciFNaYDmCXcQYxXSiF9BjcLCMPcaYkVN2nQD6QjYQ8vpSR3Z',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1qx94dutas7ysn2my645cyttujrms5d9p57f6aam');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1qcywwsy87sdp8vz5rfjh3sxdv6rt95kujdqq38g');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'KyBagP6JHrNTGanqBSDVzKrsBTVbD9hhkTeVe1zEhewKeCU6wJb7');
  });
});


================================================
FILE: ./tests/unit/loc.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { _setExchangeRate, _setPreferredFiatCurrency, _setSkipUpdateExchangeRate } from '../../malin_modules/currency';
import { _leaveNumbersAndDots, formatBalance, formatBalancePlain, formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { FiatUnit } from '../../models/fiatUnit';

describe('Localization', () => {
  it('internal formatter', () => {
    assert.strictEqual(_leaveNumbersAndDots('1,00'), '1');
    assert.strictEqual(_leaveNumbersAndDots('0,50"'), '0.50');
    assert.strictEqual(_leaveNumbersAndDots('RUB 1,00'), '1');
  });

  it('formatBalancePlain() && formatBalancePlain()', () => {
    _setExchangeRate('BTC_RUB', 660180.143);
    _setPreferredFiatCurrency(FiatUnit.RUB);
    let newInputValue = formatBalanceWithoutSuffix(152, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.ok(newInputValue === 'RUB1.00' || newInputValue === '1,00', 'Unexpected: ' + newInputValue);
    newInputValue = formatBalancePlain(152, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '1');

    newInputValue = formatBalanceWithoutSuffix(1515, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.ok(newInputValue === 'RUB10.00' || newInputValue === '10,00', 'Unexpected: ' + newInputValue);
    newInputValue = formatBalancePlain(1515, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '10');

    newInputValue = formatBalanceWithoutSuffix(16793829, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.ok(newInputValue === 'RUB110,869.52' || newInputValue === '110869,52', 'Unexpected: ' + newInputValue);
    newInputValue = formatBalancePlain(16793829, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '110869.52');

    newInputValue = formatBalancePlain(76, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '0.50');

    _setExchangeRate('BTC_USD', 10000);
    _setPreferredFiatCurrency(FiatUnit.USD);
    newInputValue = formatBalanceWithoutSuffix(16793829, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '$1,679.38');
    newInputValue = formatBalancePlain(16793829, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '1679.38');

    newInputValue = formatBalancePlain(16000000, BitcoinUnit.LOCAL_CURRENCY, false);
    assert.strictEqual(newInputValue, '1600');
  });

  it.each([
    [123000000, BitcoinUnit.SATS, false, '123000000', false],
    [123000000, BitcoinUnit.SATS, true, '123,000,000', false],
    [123456000, BitcoinUnit.BTC, true, '1.23456', false],
    ['123456000', BitcoinUnit.BTC, true, '1.23456', false], // can handle strings
    [100000000, BitcoinUnit.BTC, true, '1', false],
    [10000000, BitcoinUnit.BTC, true, '0.1', false],
    [1, BitcoinUnit.BTC, true, '0.00000001', false],
    [10000000, BitcoinUnit.LOCAL_CURRENCY, true, '...', true], // means unknown since we did not receive exchange rate
  ])(
    'can formatBalanceWithoutSuffix',
    async (balance, toUnit, withFormatting, expectedResult, shouldResetRate) => {
      _setExchangeRate('BTC_USD', 1);
      _setPreferredFiatCurrency(FiatUnit.USD);
      if (shouldResetRate) {
        _setExchangeRate('BTC_USD', false);
        _setSkipUpdateExchangeRate();
      }
      const actualResult = formatBalanceWithoutSuffix(balance, toUnit, withFormatting);
      assert.strictEqual(actualResult, expectedResult);
    },
    240000,
  );

  it.each([
    [123000000, BitcoinUnit.SATS, false, '123000000 sats'],
    [123000000, BitcoinUnit.BTC, false, '1.23 BTC'],
    [15, BitcoinUnit.BTC, false, '0.00000015 BTC'],
    [1, BitcoinUnit.BTC, false, '0.00000001 BTC'],
    [0, BitcoinUnit.BTC, false, '0 BTC'],
    [123000000, BitcoinUnit.LOCAL_CURRENCY, false, '$1.23'],
  ])(
    'can formatBalance',
    async (balance, toUnit, withFormatting, expectedResult) => {
      _setExchangeRate('BTC_USD', 1);
      _setPreferredFiatCurrency(FiatUnit.USD);
      const actualResult = formatBalance(balance, toUnit, withFormatting);
      assert.strictEqual(actualResult, expectedResult);
    },
    240000,
  );
});


================================================
FILE: ./tests/unit/provide-entropy.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { convertToBuffer, EActionType, entropyToHex, eReducer, getEntropy } from '../../screen/wallets/ProvideEntropy';

describe('Entropy reducer and format', () => {
  it('handles push and pop correctly', () => {
    let state = eReducer(undefined, { type: EActionType.noop });
    assert.equal(entropyToHex(state), '0x');

    state = eReducer(state, { type: EActionType.push, value: 0, bits: 1 });
    assert.equal(entropyToHex(state), '0x0');

    state = eReducer(state, { type: EActionType.push, value: 0, bits: 1 });
    assert.equal(entropyToHex(state), '0x0');

    state = eReducer(state, { type: EActionType.push, value: 0, bits: 3 });
    assert.equal(entropyToHex(state), '0x00');

    state = eReducer(state, { type: EActionType.pop });
    assert.equal(entropyToHex(state), '0x0');

    state = eReducer(state, { type: EActionType.pop });
    state = eReducer(state, { type: EActionType.pop });
    assert.equal(entropyToHex(state), '0x');

    state = eReducer(state, { type: EActionType.push, value: 1, bits: 1 });
    assert.equal(entropyToHex(state), '0x1'); // 0b1

    state = eReducer(state, { type: EActionType.push, value: 0, bits: 1 });
    assert.equal(entropyToHex(state), '0x2'); // 0b10

    state = eReducer(state, { type: EActionType.push, value: 0b01, bits: 2 });
    assert.equal(entropyToHex(state), '0x9'); // 0b1001

    state = eReducer(state, { type: EActionType.push, value: 0b10, bits: 2 });
    assert.equal(entropyToHex(state), '0x26'); // 0b100110
  });

  it('handles 128 bits correctly', () => {
    const state = eReducer(undefined, { type: EActionType.push, value: 0, bits: 128 });
    assert.equal(entropyToHex(state), '0x00000000000000000000000000000000');
  });

  it('handles 256 bits correctly', () => {
    let state = eReducer(undefined, { type: EActionType.noop }); // get init state

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const i of [...Array(256)]) {
      state = eReducer(state, { type: EActionType.push, value: 1, bits: 1 });
    }
    assert.equal(entropyToHex(state), '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
  });

  it('handles pop when empty without error', () => {
    const state = eReducer(undefined, { type: EActionType.pop });
    assert.equal(entropyToHex(state), '0x');
  });

  it('handles 256 bits limit', () => {
    let state = eReducer(undefined, { type: EActionType.push, value: 0, bits: 254 });
    state = eReducer(state, { type: EActionType.push, value: 0b101, bits: 3 });
    assert.equal(entropyToHex(state), '0x0000000000000000000000000000000000000000000000000000000000000002');
  });

  it('Throws error if you try to push value exceeding size in bits', () => {
    assert.throws(() => eReducer(undefined, { type: EActionType.push, value: 8, bits: 3 }), {
      name: 'TypeError',
      message: "Can't push value exceeding size in bits",
    });
  });
});

describe('getEntropy function', () => {
  it('handles coin', () => {
    assert.deepEqual(getEntropy(0, 2), { value: 0, bits: 1 });
    assert.deepEqual(getEntropy(1, 2), { value: 1, bits: 1 });
  });

  it('handles 6 sides dice', () => {
    assert.deepEqual(getEntropy(0, 6), { value: 0, bits: 2 });
    assert.deepEqual(getEntropy(1, 6), { value: 1, bits: 2 });
    assert.deepEqual(getEntropy(2, 6), { value: 2, bits: 2 });
    assert.deepEqual(getEntropy(3, 6), { value: 3, bits: 2 });
    assert.deepEqual(getEntropy(4, 6), { value: 0, bits: 1 });
    assert.deepEqual(getEntropy(5, 6), { value: 1, bits: 1 });
  });

  it('handles 20 sides dice', () => {
    assert.deepEqual(getEntropy(0, 20), { value: 0, bits: 4 });
    assert.deepEqual(getEntropy(15, 20), { value: 15, bits: 4 });

    assert.deepEqual(getEntropy(16, 20), { value: 0, bits: 2 });
    assert.deepEqual(getEntropy(17, 20), { value: 1, bits: 2 });
    assert.deepEqual(getEntropy(18, 20), { value: 2, bits: 2 });
    assert.deepEqual(getEntropy(19, 20), { value: 3, bits: 2 });
  });

  it('handles odd numbers', () => {
    assert.deepEqual(getEntropy(0, 3), { value: 0, bits: 1 });
    assert.deepEqual(getEntropy(1, 3), { value: 1, bits: 1 });
    assert.deepEqual(getEntropy(2, 3), null);
  });
});

describe('convertToBuffer function', () => {
  it('zero bits', () => {
    const state = eReducer(undefined, { type: EActionType.noop });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([]));
  });

  it('8 zero bits', () => {
    const state = eReducer(undefined, { type: EActionType.push, value: 0, bits: 8 });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([0]));
  });

  it('8 filled bits', () => {
    const state = eReducer(undefined, { type: EActionType.push, value: 0b11111111, bits: 8 });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([0b11111111]));
  });

  it('9 zero bits', () => {
    const state = eReducer(undefined, { type: EActionType.push, value: 0, bits: 9 });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([0]));
  });

  it('9 filled bits', () => {
    const state = eReducer(undefined, { type: EActionType.push, value: 0b111111111, bits: 9 });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([0b11111111]));
  });

  it('9 bits', () => {
    const state = eReducer(undefined, { type: EActionType.push, value: 0b111100111, bits: 9 });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([0b11100111]));
  });

  it('3 bytes', () => {
    let state = eReducer(undefined, { type: EActionType.push, value: 1, bits: 8 });
    state = eReducer(state, { type: EActionType.push, value: 2, bits: 8 });
    state = eReducer(state, { type: EActionType.push, value: 3, bits: 8 });
    assert.deepEqual(convertToBuffer(state), new Uint8Array([1, 2, 3]));
  });

  it('256 bits or 32bytes', () => {
    let state = eReducer(undefined, { type: EActionType.noop }); // get init state

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const i of [...Array(256)]) {
      state = eReducer(state, { type: EActionType.push, value: 1, bits: 1 });
    }

    const bytes = [...Array(32)].map(() => 255);

    assert.deepEqual(convertToBuffer(state), new Uint8Array(bytes));
  });
});


================================================
FILE: ./tests/unit/storage.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import assert from 'assert';

import { MalinApp, HDSegwitBech32Wallet, SegwitP2SHWallet } from '../../class';

jest.mock('../../malin_modules/MalinElectrum', () => {
  return {
    connectMain: jest.fn(),
  }
});

it('Appstorage - loadFromDisk works', async () => {
  /** @type {MalinApp} */
  const Storage = new MalinApp();
  const w = new SegwitP2SHWallet();
  w.setLabel('testlabel');
  await w.generate();
  Storage.wallets.push(w);
  Storage.tx_metadata = {
    txid: {
      memo: 'tx label',
    },
  }
  Storage.counterparty_metadata = {
    'payment code': {
      label: 'yegor letov',
    },
  }
  await Storage.saveToDisk();

  // saved, now trying to load

  const Storage2 = new MalinApp();
  await Storage2.loadFromDisk();
  assert.strictEqual(Storage2.wallets.length, 1);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');
  assert.strictEqual(Storage2.tx_metadata.txid.memo, 'tx label');
  assert.strictEqual(
    Storage2.counterparty_metadata['payment code'].label,
    'yegor letov',
  )
  let isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(!isEncrypted);

  // emulating encrypted storage (and testing flag)

  await AsyncStorage.setItem('data', false);
  await AsyncStorage.setItem(MalinApp.FLAG_ENCRYPTED, '1');
  const Storage3 = new MalinApp();
  isEncrypted = await Storage3.storageIsEncrypted();
  assert.ok(isEncrypted);
})

it('AppStorage - getTransactions() work', async () => {
  const Storage = new MalinApp();
  const w = new HDSegwitBech32Wallet();
  w.setLabel('testlabel');
  await w.generate();
  w._txs_by_internal_index = {
    0: [
      {
        blockhash:
          '000000000000000000054fae1935a8e5c3ac29ce04a45cca25d7329af5e5db2e',
        blocktime: 1678137003,
        confirmations: 61788,
        hash: '73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d',
        locktime: 0,
        size: 192,
        time: 1678137003,
        txid: '73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d',
        version: 1,
        vsize: 110,
        weight: 438,
        inputs: [
          {
            scriptSig: {
              asm: '',
              hex: '',
            },
            sequence: 4294967295,
            txid: '06b4c14587182fd0474f265a77b156519b4778769a99c21623863a8194d0fa4f',
            txinwitness: [
              '3045022100f2dfd9679719a5b10695c5142cb2998c0dde9d84fb3a0f6e2f82c972846da2b10220059c34862231eda0b8b4059859ae55e2fca5739c664f3ff45be71fbcf438a68d01',
              '034f150e09d0489a047b1299131180ce174769b28c03ca6a96054555211fdd7fd6',
            ],
            vout: 3,
            addresses: ['bc1qtnsyvl8zkteg7ap57j6w8hc7gk5nxk8vj5vrmz'],
            value: 0.00077308,
          }
        ],
        outputs: [
          {
            n: 0,
            scriptPubKey: {
              address: 'bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt',
              asm: '0 e98d8aa1c6d0dba1936079c0e09af9836b2070b1',
              desc: 'addr(bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt)#pl83f4nc',
              hex: '0014e98d8aa1c6d0dba1936079c0e09af9836b2070b1',
              type: 'witness_v0_keyhash',
              addresses: ['bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt'],
            },
            value: 0.00074822,
          }
        ],
        received: 1678137003000,
        value: -77308,
        sort_ts: 1678137003000,
      }
    ]
  };

  const w2 = new HDSegwitBech32Wallet();
  w2.setLabel('testlabel');
  await w2.generate();
  w2._txs_by_internal_index = {
    0: [
      {
        blockhash:
          '000000000000000000054fae1935a8e5c3ac29ce04a45cca25d7329af5e5db2e',
        blocktime: 1678137003,
        confirmations: 61788,
        hash: 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
        locktime: 0,
        size: 192,
        time: 1678137003,
        txid: 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
        version: 1,
        vsize: 110,
        weight: 438,
        inputs: [
          {
            scriptSig: {
              asm: '',
              hex: '',
            },
            sequence: 4294967295,
            txid: '06b4c14587182fd0474f265a77b156519b4778769a99c21623863a8194d0fa4f',
            txinwitness: [
              '3045022100f2dfd9679719a5b10695c5142cb2998c0dde9d84fb3a0f6e2f82c972846da2b10220059c34862231eda0b8b4059859ae55e2fca5739c664f3ff45be71fbcf438a68d01',
              '034f150e09d0489a047b1299131180ce174769b28c03ca6a96054555211fdd7fd6',
            ],
            vout: 3,
            addresses: ['bc1qtnsyvl8zkteg7ap57j6w8hc7gk5nxk8vj5vrmz'],
            value: 0.00077308,
          }
        ],
        outputs: [
          {
            n: 0,
            scriptPubKey: {
              address: 'bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt',
              asm: '0 e98d8aa1c6d0dba1936079c0e09af9836b2070b1',
              desc: 'addr(bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt)#pl83f4nc',
              hex: '0014e98d8aa1c6d0dba1936079c0e09af9836b2070b1',
              type: 'witness_v0_keyhash',
              addresses: ['bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt'],
            },
            value: 0.00074822,
          }
        ],
        received: 1678137003000,
        value: -77308,
        sort_ts: 1678137003000,
      }
    ]
  };

  Storage.wallets.push(w);
  Storage.wallets.push(w2);

  // setup complete. now we have a storage with 2 wallets, each wallet has
  // exactly one transaction

  let txs = Storage.getTransactions();
  assert.strictEqual(txs.length, 2); // getter for _all_ txs works

  for (const tx of txs) {
    assert.ok([w.getID(), w2.getID()].includes(tx.walletID));
    assert.strictEqual(
      tx.walletPreferredBalanceUnit,
      w.getPreferredBalanceUnit()
    );
    assert.strictEqual(tx.walletPreferredBalanceUnit, 'BTC');
  }

  //

  txs = Storage.getTransactions(0, 666, true);
  assert.strictEqual(txs.length, 1); // getter for a specific wallet works

  for (const tx of txs) {
    assert.ok([w.getID()].includes(tx.walletID));
    assert.strictEqual(
      tx.walletPreferredBalanceUnit,
      w.getPreferredBalanceUnit()
    );
    assert.strictEqual(tx.walletPreferredBalanceUnit, 'BTC');
  }

  //

  txs = Storage.getTransactions(1, 666, true);
  assert.strictEqual(txs.length, 1); // getter for a specific wallet works

  for (const tx of txs) {
    assert.ok([w2.getID()].includes(tx.walletID));
    assert.strictEqual(
      tx.walletPreferredBalanceUnit,
      w.getPreferredBalanceUnit()
    );
    assert.strictEqual(tx.walletPreferredBalanceUnit, 'BTC');
  }
});

it('Appstorage - encryptStorage & load encrypted storage works', async () => {
  /** @type {MalinApp} */
  const Storage = new MalinApp();
  let w = new SegwitP2SHWallet();
  w.setLabel('testlabel');
  await w.generate();
  Storage.wallets.push(w);
  await Storage.saveToDisk();
  let isEncrypted = await Storage.storageIsEncrypted();
  assert.ok(!isEncrypted);
  await Storage.encryptStorage('password');
  isEncrypted = await Storage.storageIsEncrypted();
  assert.strictEqual(Storage.cachedPassword, 'password');
  assert.ok(isEncrypted);

  // saved, now trying to load, using good password

  let Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  let loadResult = await Storage2.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage2.wallets.length, 1);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');

  // now trying to load, using bad password

  Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage2.loadFromDisk('passwordBAD');
  assert.ok(!loadResult);
  assert.strictEqual(Storage2.wallets.length, 0);

  // now, trying case with adding data after decrypt.
  // saveToDisk should be handled correctly

  Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage2.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage2.wallets.length, 1);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');
  w = new SegwitP2SHWallet();
  w.setLabel('testlabel2');
  await w.generate();
  Storage2.wallets.push(w);
  assert.strictEqual(Storage2.wallets.length, 2);
  assert.strictEqual(Storage2.wallets[1].getLabel(), 'testlabel2');
  await Storage2.saveToDisk();
  // saved to encrypted storage after load. next load should be successfull
  Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage2.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage2.wallets.length, 2);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');
  assert.strictEqual(Storage2.wallets[1].getLabel(), 'testlabel2');

  // next, adding new `fake` storage which should be unlocked with `fake` password
  const createFakeStorageResult =
    await Storage2.createFakeStorage('fakePassword');
  assert.ok(createFakeStorageResult);
  assert.strictEqual(Storage2.wallets.length, 0);
  assert.strictEqual(Storage2.cachedPassword, 'fakePassword');
  w = new SegwitP2SHWallet();
  w.setLabel('fakewallet');
  await w.generate();
  Storage2.wallets.push(w);
  await Storage2.saveToDisk();
  // now, will try to load & decrypt with real password and with fake password
  // real:
  let Storage3 = new MalinApp();
  loadResult = await Storage3.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage3.wallets.length, 2);
  assert.strictEqual(Storage3.wallets[0].getLabel(), 'testlabel');
  // fake:
  Storage3 = new MalinApp();
  loadResult = await Storage3.loadFromDisk('fakePassword');
  assert.ok(loadResult);
  assert.strictEqual(Storage3.wallets.length, 1);
  assert.strictEqual(Storage3.wallets[0].getLabel(), 'fakewallet');
});

it('Appstorage - encryptStorage & load encrypted, then decryptStorage and load storage works', async () => {
  /** @type {MalinApp} */
  const Storage = new MalinApp();
  let w = new SegwitP2SHWallet();
  w.setLabel('testlabel');
  await w.generate();
  Storage.wallets.push(w);
  await Storage.saveToDisk();
  let isEncrypted = await Storage.storageIsEncrypted();
  assert.ok(!isEncrypted);
  await Storage.encryptStorage('password');
  isEncrypted = await Storage.storageIsEncrypted();
  assert.strictEqual(Storage.cachedPassword, 'password');
  assert.ok(isEncrypted);

  // saved, now trying to load, using good password

  let Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  let loadResult = await Storage2.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage2.wallets.length, 1);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');

  // now trying to load, using bad password

  Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage2.loadFromDisk('passwordBAD');
  assert.ok(!loadResult);
  assert.strictEqual(Storage2.wallets.length, 0);

  // now, trying case with adding data after decrypt.
  // saveToDisk should be handled correctly

  Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage2.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage2.wallets.length, 1);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');
  w = new SegwitP2SHWallet();
  w.setLabel('testlabel2');
  await w.generate();
  Storage2.wallets.push(w);
  assert.strictEqual(Storage2.wallets.length, 2);
  assert.strictEqual(Storage2.wallets[1].getLabel(), 'testlabel2');
  await Storage2.saveToDisk();
  // saved to encrypted storage after load. next load should be successfull
  Storage2 = new MalinApp();
  isEncrypted = await Storage2.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage2.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage2.wallets.length, 2);
  assert.strictEqual(Storage2.wallets[0].getLabel(), 'testlabel');
  assert.strictEqual(Storage2.wallets[1].getLabel(), 'testlabel2');

  // next, adding new `fake` storage which should be unlocked with `fake` password
  const createFakeStorageResult =
    await Storage2.createFakeStorage('fakePassword');
  assert.ok(createFakeStorageResult);
  assert.strictEqual(Storage2.wallets.length, 0);
  assert.strictEqual(Storage2.cachedPassword, 'fakePassword');
  w = new SegwitP2SHWallet();
  w.setLabel('fakewallet');
  await w.generate();
  Storage2.wallets.push(w);
  await Storage2.saveToDisk();
  // now, will try to load & decrypt with real password and with fake password
  // real:
  let Storage3 = new MalinApp();
  loadResult = await Storage3.loadFromDisk('password');
  assert.ok(loadResult);
  assert.strictEqual(Storage3.wallets.length, 2);
  assert.strictEqual(Storage3.wallets[0].getLabel(), 'testlabel');
  // fake:
  Storage3 = new MalinApp();
  loadResult = await Storage3.loadFromDisk('fakePassword');
  assert.ok(loadResult);
  assert.strictEqual(Storage3.wallets.length, 1);
  assert.strictEqual(Storage3.wallets[0].getLabel(), 'fakewallet');

  // now will decrypt storage. label of wallet should be testlabel

  const Storage4 = new MalinApp();
  isEncrypted = await Storage4.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage4.loadFromDisk('password');
  assert.ok(loadResult);
  const decryptStorageResult = await Storage4.decryptStorage('password');
  assert.ok(decryptStorageResult);

  const Storage5 = new MalinApp();
  isEncrypted = await Storage5.storageIsEncrypted();
  assert.strictEqual(isEncrypted, false);
  const storage5loadResult = await Storage5.loadFromDisk();
  assert.ok(storage5loadResult);
  assert.strictEqual(Storage5.wallets.length, 2);
  assert.strictEqual(Storage5.wallets[0].getLabel(), 'testlabel');
  assert.strictEqual(Storage5.wallets[1].getLabel(), 'testlabel2');
});

it('can decrypt storage that is second in a list of buckets; and isPasswordInUse() works', async () => {
  /** @type {MalinApp} */
  const Storage = new MalinApp();
  let w = new SegwitP2SHWallet();
  w.setLabel('testlabel');
  await w.generate();
  Storage.wallets.push(w);
  await Storage.saveToDisk();
  let isEncrypted = await Storage.storageIsEncrypted();
  assert.ok(!isEncrypted);
  await Storage.encryptStorage('password');
  isEncrypted = await Storage.storageIsEncrypted();
  assert.strictEqual(Storage.cachedPassword, 'password');
  assert.ok(isEncrypted);

  // next, adding new `fake` storage which should be unlocked with `fake` password
  const createFakeStorageResult =
    await Storage.createFakeStorage('fakePassword');
  assert.ok(createFakeStorageResult);
  assert.strictEqual(Storage.wallets.length, 0);
  assert.strictEqual(Storage.cachedPassword, 'fakePassword');
  w = new SegwitP2SHWallet();
  w.setLabel('fakewallet');
  await w.generate();
  Storage.wallets.push(w);
  await Storage.saveToDisk();

  // now will decrypt storage. will try to decrypt FAKE storage (second in the list) while
  // currently decrypted is the MAIN (non-fake) storage. this should throw an exception

  const Storage4 = new MalinApp();
  isEncrypted = await Storage4.storageIsEncrypted();
  assert.ok(isEncrypted);
  let loadResult = await Storage4.loadFromDisk('password');
  assert.ok(loadResult);

  let wasException = false;
  try {
    await Storage4.decryptStorage('fakePassword');
  } catch (_) {
    wasException = true;
  }

  assert.ok(wasException);

  // now we will load fake storage, and we will decrypt it, which efficiently makes it main
  // storage, purging other buckets. this should be possible since if user wants to shoot himsel in the foot
  // he should be able to do it.

  const Storage5 = new MalinApp();
  isEncrypted = await Storage5.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage5.loadFromDisk('fakePassword');
  assert.ok(loadResult);

  // testing that isPasswordInUse() works:
  assert.ok(await Storage5.isPasswordInUse('fakePassword'));
  assert.ok(await Storage5.isPasswordInUse('password'));
  assert.ok(!(await Storage5.isPasswordInUse('blablablabla')));

  // now we will decrypt storage. label of wallet should be testlabel

  const Storage6 = new MalinApp();
  isEncrypted = await Storage6.storageIsEncrypted();
  assert.ok(isEncrypted);
  loadResult = await Storage6.loadFromDisk('fakePassword');
  assert.ok(loadResult);
  const decryptStorageResult = await Storage6.decryptStorage('fakePassword');
  assert.ok(decryptStorageResult);

  const Storage7 = new MalinApp();
  isEncrypted = await Storage7.storageIsEncrypted();
  assert.strictEqual(isEncrypted, false);
  const storage5loadResult = await Storage7.loadFromDisk();
  assert.ok(storage5loadResult);
  assert.strictEqual(Storage7.wallets[0].getLabel(), 'fakewallet');
});

it('Appstorage - hashIt() works', async () => {
  const storage = new MalinApp();
  assert.strictEqual(
    storage.hashIt('hello'),
    '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824',
  )
});


================================================
FILE: ./tests/unit/deeplink-schema-match.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import { HDSegwitBech32Wallet, LightningCustodianWallet } from '../../class';

jest.mock('../../malin_modules/MalinElectrum', () => {
  return {
    connectMain: jest.fn(),
  }
});

// helper function that promisifies function with a callback:
const asyncNavigationRouteFor = async function (event) {
  return new Promise(function (resolve) {
    DeeplinkSchemaMatch.navigationRouteFor(event, (navValue) => {
      resolve(navValue);
    })
  });
}

describe.each(['', '//'])('unit - DeepLinkSchemaMatch', function (suffix) {
  it('hasSchema', () => {
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `bitcoin:${suffix}12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `bitcoin:${suffix}bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7?amount=666&label=Yo`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `bitcoin:${suffix}BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7?amount=666&label=Yo`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `lightning:${suffix}lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde`,
      )
    )

    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `malinwallet:bitcoin:${suffix}12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `malinwallet:bitcoin:${suffix}bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7?amount=666&label=Yo`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `malinwallet:bitcoin:${suffix}BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7?amount=666&label=Yo`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `malinwallet:BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `malinwallet:BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.hasSchema(
        `malinwallet:lightning:${suffix}lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde`,
      )
    )
  })

  it('isBitcoin Address', () => {
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        '12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG',
      )
    );
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK',
      )
    );
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        'bc1qykcp2x3djgdtdwelxn9z4j2y956npte0a4sref',
      )
    );
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        'BC1QYKCP2X3DJGDTDWELXN9Z4J2Y956NPTE0A4SREF',
      )
    );
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        `bitcoin:${suffix}BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        `BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE`
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.isBitcoinAddress(
        `BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo`
      ),
    )
  });

  it('isLighting Invoice', () => {
    assert.ok(
      DeeplinkSchemaMatch.isLightningInvoice(
        `lightning:${suffix}lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde`,
      )
    )
  })

  it('isBoth Bitcoin & Invoice', () => {
    assert.ok(
      DeeplinkSchemaMatch.isBothBitcoinAndLightning(
        `bitcoin:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=0.000001&lightning=lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4`,
      )
    )
    assert.ok(
      DeeplinkSchemaMatch.isBothBitcoinAndLightning(
        `BITCOIN:${suffix}12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG?amount=0.000001&lightning=lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4`,
      )
    )

    const rez = DeeplinkSchemaMatch.isBothBitcoinAndLightning(
      `bitcoin:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=0.000001&lightning=lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4`,
    )
    assert.strictEqual(
      rez.bitcoin,
      'bitcoin:BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=0.000001&',
    )
    assert.strictEqual(
      rez.lndInvoice,
      'lightning:lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4',
    );

    const rez2 = DeeplinkSchemaMatch.isBothBitcoinAndLightning(
      `bitcoin:${suffix}bc1q8flg3jcnv6x6mpjrqty8h8h9mg0shgp5jc9smk?lightning=LNBC1P3WKFY3DQQPP5030V53XSDHSGJKZELYLE7EKTMEM38974498VNQDT2JAZ24TRW39QSP502JQJ4K6NR7AXQYMHKF3AX70JXFX6JZA4JYGVC66NJZHFS4TSA2Q9QRSGQCQPCXQY8AYQRZJQV06K0M23T593PNGL0JT7N9WZNP64FQNGVCTZ7VTS8NQ4TUKVTLJQZ2ZHYQQXQGQQSQQQQQQQQQQQQQQ9GRZJQTSJY9P55GDCEEVP36FVDMRKXQVZFHY8AK2TGC5ZGTJTRA9XLAZ97ZKCYVQQPRSQQVQQQQQQQQQQQQQQ9GY3X4N6RV6RCN53LDEV96AURLS3C66KPX74WA4UWCWU92JGKTPQE8NCQPZJ8JG6SUNYGZM320CDUTNVGSRC6XV286EVHRXEFSXXUZ0SSQWTM6DQ&amount=0`,
    )
    assert.strictEqual(
      rez2.bitcoin,
      'bitcoin:bc1q8flg3jcnv6x6mpjrqty8h8h9mg0shgp5jc9smk?',
    )
    assert.strictEqual(
      rez2.lndInvoice,
      'lightning:LNBC1P3WKFY3DQQPP5030V53XSDHSGJKZELYLE7EKTMEM38974498VNQDT2JAZ24TRW39QSP502JQJ4K6NR7AXQYMHKF3AX70JXFX6JZA4JYGVC66NJZHFS4TSA2Q9QRSGQCQPCXQY8AYQRZJQV06K0M23T593PNGL0JT7N9WZNP64FQNGVCTZ7VTS8NQ4TUKVTLJQZ2ZHYQQXQGQQSQQQQQQQQQQQQQQ9GRZJQTSJY9P55GDCEEVP36FVDMRKXQVZFHY8AK2TGC5ZGTJTRA9XLAZ97ZKCYVQQPRSQQVQQQQQQQQQQQQQQ9GY3X4N6RV6RCN53LDEV96AURLS3C66KPX74WA4UWCWU92JGKTPQE8NCQPZJ8JG6SUNYGZM320CDUTNVGSRC6XV286EVHRXEFSXXUZ0SSQWTM6DQ',
    );

    const rez3 = DeeplinkSchemaMatch.isBothBitcoinAndLightning(
      "bitcoin:bc1q8flg3jcnv6x6mpjrqty8h8h9mg0shgp5jc9smk?lightning=lnbc1p3wkfy3dqqpp5030v53xsdhsgjkzelyle7ektmem38974498vnqdt2jaz24trw39qsp502jqj4k6nr7axqymhkf3ax70jxfx6jza4jygvc66njzhfs4tsa2q9qrsgqcqpcxqy8ayqrzjqv06k0m23t593pngl0jt7n9wznp64fqngvctz7vts8nq4tukvtljqz2zhyqqxqgqqsqqqqqqqqqqqqqq9grzjqtsjy9p55gdceevp36fvdmrkxqvzfhy8ak2tgc5zgtjtra9xlaz97zkcyvqqprsqqvqqqqqqqqqqqqqq9gy3x4n6rv6rcn53ldev96aurls3c66kpx74wa4uwcwu92jgktpqe8ncqpzj8jg6sunygzm320cdutnvgsrc6xv286evhrxefsxxuz0ssqwtm6dq&amount=0",
    );
    assert.strictEqual(
      rez3.bitcoin,
      'bitcoin:bc1q8flg3jcnv6x6mpjrqty8h8h9mg0shgp5jc9smk?',
    )
    assert.strictEqual(
      rez3.lndInvoice,
      'lightning:lnbc1p3wkfy3dqqpp5030v53xsdhsgjkzelyle7ektmem38974498vnqdt2jaz24trw39qsp502jqj4k6nr7axqymhkf3ax70jxfx6jza4jygvc66njzhfs4tsa2q9qrsgqcqpcxqy8ayqrzjqv06k0m23t593pngl0jt7n9wznp64fqngvctz7vts8nq4tukvtljqz2zhyqqxqgqqsqqqqqqqqqqqqqq9grzjqtsjy9p55gdceevp36fvdmrkxqvzfhy8ak2tgc5zgtjtra9xlaz97zkcyvqqprsqqvqqqqqqqqqqqqqq9gy3x4n6rv6rcn53ldev96aurls3c66kpx74wa4uwcwu92jgktpqe8ncqpzj8jg6sunygzm320cdutnvgsrc6xv286evhrxefsxxuz0ssqwtm6dq',
    );

    // no amount
    const rez4 = DeeplinkSchemaMatch.isBothBitcoinAndLightning(
      "bitcoin:bc1q8flg3jcnv6x6mpjrqty8h8h9mg0shgp5jc9smk?lightning=lnbc1p3wkfy3dqqpp5030v53xsdhsgjkzelyle7ektmem38974498vnqdt2jaz24trw39qsp502jqj4k6nr7axqymhkf3ax70jxfx6jza4jygvc66njzhfs4tsa2q9qrsgqcqpcxqy8ayqrzjqv06k0m23t593pngl0jt7n9wznp64fqngvctz7vts8nq4tukvtljqz2zhyqqxqgqqsqqqqqqqqqqqqqq9grzjqtsjy9p55gdceevp36fvdmrkxqvzfhy8ak2tgc5zgtjtra9xlaz97zkcyvqqprsqqvqqqqqqqqqqqqqq9gy3x4n6rv6rcn53ldev96aurls3c66kpx74wa4uwcwu92jgktpqe8ncqpzj8jg6sunygzm320cdutnvgsrc6xv286evhrxefsxxuz0ssqwtm6dq",
    );
    assert.strictEqual(
      rez4.bitcoin,
      'bitcoin:bc1q8flg3jcnv6x6mpjrqty8h8h9mg0shgp5jc9smk?',
    )
    assert.strictEqual(
      rez4.lndInvoice,
      'lightning:lnbc1p3wkfy3dqqpp5030v53xsdhsgjkzelyle7ektmem38974498vnqdt2jaz24trw39qsp502jqj4k6nr7axqymhkf3ax70jxfx6jza4jygvc66njzhfs4tsa2q9qrsgqcqpcxqy8ayqrzjqv06k0m23t593pngl0jt7n9wznp64fqngvctz7vts8nq4tukvtljqz2zhyqqxqgqqsqqqqqqqqqqqqqq9grzjqtsjy9p55gdceevp36fvdmrkxqvzfhy8ak2tgc5zgtjtra9xlaz97zkcyvqqprsqqvqqqqqqqqqqqqqq9gy3x4n6rv6rcn53ldev96aurls3c66kpx74wa4uwcwu92jgktpqe8ncqpzj8jg6sunygzm320cdutnvgsrc6xv286evhrxefsxxuz0ssqwtm6dq',
    );
  })

  it('isLnurl', () => {
    assert.ok(
      DeeplinkSchemaMatch.isLnUrl(
        'LNURL1DP68GURN8GHJ7UM9WFMXJCM99E3K7MF0V9CXJ0M385EKVCENXC6R2C35XVUKXEFCV5MKVV34X5EKZD3EV56NYD3HXQURZEPEXEJXXEPNXSCRVWFNV9NXZCN9XQ6XYEFHVGCXXCMYXYMNSERXFQ5FNS',
      ),
    )
  });

  it('navigationForRoute', async () => {
    const events = [
      {
        argument: { url: "12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG" },
        expected: [
          'SendDetailsRoot',
          {
            screen: 'SendDetails',
            params: { uri: '12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG' }
          },
        ]
      },
      {
        argument: {
          url: `bitcoin:${suffix}12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG`
        },
        expected: [
          'SendDetailsRoot',
          {
            screen: 'SendDetails',
            params: { uri: 'bitcoin:12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG' }
          },
        ]
      },
      {
        argument: {
          url: `BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo`
        },
        expected: [
          'SendDetailsRoot',
          {
            screen: 'SendDetails',
            params: {
              uri: 'BITCOIN:BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo',
            }
          }
        ]
      },
      {
        argument: {
          url: `malinwallet:BITCOIN:${suffix}BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo`
        },
        expected: [
          'SendDetailsRoot',
          {
            screen: 'SendDetails',
            params: {
              uri: 'BITCOIN:BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE?amount=666&label=Yo',
            }
          }
        ]
      },
      {
        argument: {
          url: `lightning:${suffix}lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde`,
        },
        expected: [
          'ScanLNDInvoiceRoot',
          {
            screen: 'ScanLNDInvoice',
            params: {
              uri: 'lightning:lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde',
            },
          }
        ]
      },
      {
        argument: {
          url: `malinwallet:lightning:${suffix}lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde`,
        },
        expected: [
          'ScanLNDInvoiceRoot',
          {
            screen: 'ScanLNDInvoice',
            params: {
              uri: 'lightning:lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde',
            },
          }
        ]
      },
      {
        argument: {
          url: 'https://azte.co/?c1=3062&c2=2586&c3=5053&c4=5261',
        },
        expected: [
          'AztecoRedeemRoot',
          {
            screen: 'AztecoRedeem',
            params: {
              aztecoVoucher: { c1: '3062', c2: '2586', c3: '5053', c4: '5261' },
            }
          }
        ],
      },
      {
        argument: {
          url: 'https://azte.co/redeem?code=1111222233334444',
        },
        expected: [
          'AztecoRedeemRoot',
          {
            screen: 'AztecoRedeem',
            params: {
              aztecoVoucher: { c1: '1111', c2: '2222', c3: '3333', c4: '4444' },
            }
          }
        ],
      },
      {
        argument: {
          url: 'malinwallet:setelectrumserver?server=electrum1.malinwallet.io%3A443%3As',
        },
        expected: [
          'ElectrumSettings',
          {
            server: 'electrum1.malinwallet.io:443:s',
          },
        ]
      },
      {
        argument: {
          url: 'malinwallet:setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com',
        },
        expected: [
          'LightningSettings',
          {
            url: 'https://lndhub.herokuapp.com',
          },
        ]
      },
      {
        argument: {
          url: 'https://lnbits.com/?lightning=LNURL1DP68GURN8GHJ7MRWVF5HGUEWVDHK6TMHD96XSERJV9MJ7CTSDYHHVVF0D3H82UNV9UM9JDENFPN5SMMK2359J5RKWVMKZ5ZVWAV4VJD63TM',
        },
        expected: [
          'LNDCreateInvoiceRoot',
          {
            screen: 'LNDCreateInvoice',
            params: {
              uri: 'https://lnbits.com/?lightning=LNURL1DP68GURN8GHJ7MRWVF5HGUEWVDHK6TMHD96XSERJV9MJ7CTSDYHHVVF0D3H82UNV9UM9JDENFPN5SMMK2359J5RKWVMKZ5ZVWAV4VJD63TM',
            },
          }
        ]
      },
      {
        argument: {
          url: 'lnaddress@zbd.gg',
        },
        expected: [
          'ScanLNDInvoiceRoot',
          {
            screen: 'ScanLNDInvoice',
            params: {
              uri: 'lnaddress@zbd.gg',
            },
          }
        ]
      },
      {
        argument: {
          url: require('fs').readFileSync(
            './tests/unit/fixtures/skeleton-cobo.txt',
            'ascii',
          )
        },
        expected: [
          'AddWalletRoot',
          {
            screen: 'ImportWallet',
            params: {
              triggerImport: true,
              label: require('fs').readFileSync(
                './tests/unit/fixtures/skeleton-cobo.txt',
                'ascii',
              )
            }
          }
        ],
      },
      {
        argument: {
          url: require('fs').readFileSync(
            './tests/unit/fixtures/skeleton-coldcard.txt',
            'ascii',
          )
        },
        expected: [
          'AddWalletRoot',
          {
            screen: 'ImportWallet',
            params: {
              triggerImport: true,
              label: require('fs').readFileSync(
                './tests/unit/fixtures/skeleton-coldcard.txt',
                'ascii',
              )
            }
          }
        ],
      },
      {
        argument: {
          url: require('fs').readFileSync(
            './tests/unit/fixtures/skeleton-electrum.txt',
            'ascii',
          )
        },
        expected: [
          'AddWalletRoot',
          {
            screen: 'ImportWallet',
            params: {
              triggerImport: true,
              label: require('fs').readFileSync(
                './tests/unit/fixtures/skeleton-electrum.txt',
                'ascii',
              )
            }
          }
        ],
      },
      {
        argument: {
          url: require('fs').readFileSync(
            './tests/unit/fixtures/skeleton-walletdescriptor.txt',
            'ascii',
          )
        },
        expected: [
          'AddWalletRoot',
          {
            screen: 'ImportWallet',
            params: {
              triggerImport: true,
              label: require('fs').readFileSync(
                './tests/unit/fixtures/skeleton-walletdescriptor.txt',
                'ascii',
              )
            }
          }
        ],
      },
      {
        argument: {
          url: 'zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx',
        },
        expected: [
          'AddWalletRoot',
          {
            screen: 'ImportWallet',
            params: {
              triggerImport: true,
              label:
                'zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx',
            },
          }
        ]
      },
    ]

    for (const event of events) {
      const navValue = await asyncNavigationRouteFor(event.argument);
      assert.deepStrictEqual(navValue, event.expected);
    }

    // BIP21 w/BOLT11 support
    const rez = await asyncNavigationRouteFor({
      url: `bitcoin:${suffix}1DamianM2k8WfNEeJmyqSe2YW1upB7UATx?amount=0.000001&lightning=lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4`,
    })
    assert.strictEqual(rez[0], 'SelectWallet');
    assert.ok(rez[1].onWalletSelect);
    assert.ok(typeof rez[1].onWalletSelect === 'function');
  });

  it('decodes bip21', () => {
    let decoded = DeeplinkSchemaMatch.bip21decode(
      `bitcoin:${suffix}1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH?amount=20.3&label=Foobar`
    );
    assert.deepStrictEqual(decoded, {
      address: '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH',
      options: {
        amount: 20.3,
        label: 'Foobar',
      },
    })

    decoded = DeeplinkSchemaMatch.bip21decode(
      `bitcoin:${suffix}bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7?amount=0.0001&pj=https://btc.donate.kukks.org/BTC/pj`,
    )
    assert.strictEqual(
      decoded.options.pj,
      'https://btc.donate.kukks.org/BTC/pj',
    )

    decoded = DeeplinkSchemaMatch.bip21decode(
      `BITCOIN:${suffix}1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH?amount=20.3&label=Foobar`
    );
    assert.deepStrictEqual(decoded, {
      address: '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH',
      options: {
        amount: 20.3,
        label: 'Foobar',
      },
    })
  });

  it('encodes bip21', () => {
    let encoded = DeeplinkSchemaMatch.bip21encode(
      '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH',
    )
    assert.strictEqual(encoded, 'bitcoin:1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH');
    encoded = DeeplinkSchemaMatch.bip21encode(
      '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH',
      {
        amount: 20.3,
        label: 'Foobar',
      }
    );
    assert.strictEqual(
      encoded,
      'bitcoin:1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH?amount=20.3&label=Foobar',
    )
  });

  it('encodes bip21 and discards empty arguments', () => {
    const encoded = DeeplinkSchemaMatch.bip21encode(
      '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH',
      {
        label: ' ',
        amoount: undefined,
      }
    );
    assert.strictEqual(encoded, 'bitcoin:1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH');
  });

  it('can decodeBitcoinUri', () => {
    assert.deepStrictEqual(
      DeeplinkSchemaMatch.decodeBitcoinUri(
        `bitcoin:${suffix}bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7?amount=0.0001&pj=https://btc.donate.kukks.org/BTC/pj`,
      ),
      {
        address: 'bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7',
        amount: 0.0001,
        memo: '',
        payjoinUrl: 'https://btc.donate.kukks.org/BTC/pj',
      },
    )

    assert.deepStrictEqual(
      DeeplinkSchemaMatch.decodeBitcoinUri(
        `BITCOIN:${suffix}1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH?amount=20.3&label=Foobar`
      ),
      {
        address: '1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH',
        amount: 20.3,
        memo: 'Foobar',
        payjoinUrl: '',
      },
    )
  });

  it('recognizes files', () => {
    // txn files:
    assert.ok(
      DeeplinkSchemaMatch.isTXNFile(
        'file://com.android.externalstorage.documents/document/081D-1403%3Atxhex.txn',
      )
    );
    assert.ok(
      !DeeplinkSchemaMatch.isPossiblySignedPSBTFile(
        'file://com.android.externalstorage.documents/document/081D-1403%3Atxhex.txn',
      )
    );

    assert.ok(
      DeeplinkSchemaMatch.isTXNFile(
        'content://com.android.externalstorage.documents/document/081D-1403%3Atxhex.txn',
      )
    );
    assert.ok(
      !DeeplinkSchemaMatch.isPossiblySignedPSBTFile(
        'content://com.android.externalstorage.documents/document/081D-1403%3Atxhex.txn',
      )
    )

    // psbt files (signed):
    assert.ok(
      DeeplinkSchemaMatch.isPossiblySignedPSBTFile(
        'content://com.android.externalstorage.documents/document/081D-1403%3Atxhex-signed.psbt',
      ),
    )
    assert.ok(
      DeeplinkSchemaMatch.isPossiblySignedPSBTFile(
        'file://com.android.externalstorage.documents/document/081D-1403%3Atxhex-signed.psbt',
      )
    )

    assert.ok(
      !DeeplinkSchemaMatch.isTXNFile(
        'content://com.android.externalstorage.documents/document/081D-1403%3Atxhex-signed.psbt',
      )
    );
    assert.ok(
      !DeeplinkSchemaMatch.isTXNFile(
        'file://com.android.externalstorage.documents/document/081D-1403%3Atxhex-signed.psbt',
      )
    );

    // psbt files (unsigned):
    assert.ok(
      DeeplinkSchemaMatch.isPossiblyPSBTFile(
        'content://com.android.externalstorage.documents/document/081D-1403%3Atxhex.psbt',
      )
    );
    assert.ok(
      DeeplinkSchemaMatch.isPossiblyPSBTFile(
        'file://com.android.externalstorage.documents/document/081D-1403%3Atxhex.psbt',
      )
    );
  })

  it('can work with some deeplink actions', () => {
    assert.strictEqual(
      DeeplinkSchemaMatch.getServerFromSetElectrumServerAction('sgasdgasdgasd'),
      false
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(
        'malinwallet:setelectrumserver?server=electrum1.malinwallet.io%3A443%3As',
      ),
      'electrum1.malinwallet.io:443:s',
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(
        'setelectrumserver?server=electrum1.malinwallet.io%3A443%3As',
      ),
      'electrum1.malinwallet.io:443:s',
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(
        'ololo:setelectrumserver?server=electrum1.malinwallet.io%3A443%3As',
      ),
      false,
    )
    assert.strictEqual(
      DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(
        'setTrololo?server=electrum1.malinwallet.io%3A443%3As',
      ),
      false,
    )

    assert.strictEqual(
      DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction(
        'malinwallet:setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com',
      ),
      'https://lndhub.herokuapp.com',
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction(
        'malinwallet:setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com%3A443',
      ),
      'https://lndhub.herokuapp.com:443',
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction(
        'setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com%3A443',
      ),
      'https://lndhub.herokuapp.com:443',
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction(
        'gsom?url=https%3A%2F%2Flndhub.herokuapp.com%3A443',
      ),
      false
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction('sdfhserhsthsd'),
      false
    );
  })

  it('should accept only the one valid format', function () {
    // has all the necessary json keys
    const isAllowed1 =
      '{"xfp":"ffffffff", "path":"m/84\'/0\'/0\'", "xpub":"Zpubsnkjansdjnjnekjwcnwkjnc"}';
    // has all the necessary json keys, different order
    const isAllowed2 =
      '{"path":"m/84\'/0\'/0\'", "xpub":"Zpubsnkjansdjnjnekjwcnwkjnc", "xfp":"ffffffff"}';

    //

    assert.strictEqual(
      DeeplinkSchemaMatch.hasNeededJsonKeysForMultiSigSharing(isAllowed1),
      true
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.hasNeededJsonKeysForMultiSigSharing(isAllowed2),
      true
    );

    const isNotAllowed1 =
      '{"path":"m/84\'/0\'/0\'", "xpub":"Zpubsnkjansdjnjnekjwcnwkjnc"}';
    const isNotAllowed2 =
      '{"path":1233, "xpub":"Zpubsnkjansdjnjnekjwcnwkjnc", "xfp":"ffffffff"}';

    assert.strictEqual(
      DeeplinkSchemaMatch.hasNeededJsonKeysForMultiSigSharing(isNotAllowed1),
      false
    );
    assert.strictEqual(
      DeeplinkSchemaMatch.hasNeededJsonKeysForMultiSigSharing(isNotAllowed2),
      false
    );
  })

  it('onWalletSelect should work', async () => {
    const response = await asyncNavigationRouteFor({
      url: 'bitcoin:BC1QR7P8NSYPZEJY4KP7CJS0HL5T9X0VF3AYF6UQPC?amount=0.00185579&lightning=LNBC1855790N1PNUPWSFPP5P5RVQJA067PV6NJQ3EFKLP78TN6MHUK842ZFGDCTXRDSGNTY765QDZ62PSKJEPQW3HJQSNPD36XJCEQFPHKUETEVFSKGEM9WGSRYVPJXSSZSNMJV3JHYGZFGSAZQARFVD4K2AR5V95KCMMJ9YCQZPUXQZ6GSP53E4EX9YTD2MGDN2C2CFA0J0SM3E7PVLPJ208H5LMYPNJMGZ7RLGS9QXPQYSGQ6GQMEQXJKKF2DHXJK8XQ4WGLM5NTE3RKEXGYQC6HYGFKS9SHHA6HL9X4339MXHNNQFSH7TS62PU8T9RSWTK6HQ4LV4GW3DPD25DQ8UQQYC909N',
    });
    assert.ok(response[1].onWalletSelect);

    let popWasCalled = false;
    let navigateWasCalled = false;
    let popWasCalled2 = false;
    let navigateWasCalled2 = false;
    const lw = new LightningCustodianWallet();
    const bw = new HDSegwitBech32Wallet();

    // navigation for a case when user selected LN wallet when was given a choice
    const navigationMock = {
      pop: () => {
        popWasCalled = true;
        // console.log('pop called');
      },
      navigate: (...args) => {
        navigateWasCalled = true;
        assert.deepStrictEqual(args, [
          'ScanLNDInvoiceRoot',
          {
            params: {
              uri: 'lightning:LNBC1855790N1PNUPWSFPP5P5RVQJA067PV6NJQ3EFKLP78TN6MHUK842ZFGDCTXRDSGNTY765QDZ62PSKJEPQW3HJQSNPD36XJCEQFPHKUETEVFSKGEM9WGSRYVPJXSSZSNMJV3JHYGZFGSAZQARFVD4K2AR5V95KCMMJ9YCQZPUXQZ6GSP53E4EX9YTD2MGDN2C2CFA0J0SM3E7PVLPJ208H5LMYPNJMGZ7RLGS9QXPQYSGQ6GQMEQXJKKF2DHXJK8XQ4WGLM5NTE3RKEXGYQC6HYGFKS9SHHA6HL9X4339MXHNNQFSH7TS62PU8T9RSWTK6HQ4LV4GW3DPD25DQ8UQQYC909N',
              walletID:
                'bfcacb7288cf43c6c02a1154c432ec155b813798fa4e87cd2c1e5531d6363f71',
            },
            screen: 'ScanLNDInvoice',
          },
        ])
      }
    }

    // navigation for a case when user selected ONCHAIN wallet when was given a choice
    const navigationMock2 = {
      pop: () => {
        popWasCalled2 = true;
      },
      navigate: (...args) => {
        navigateWasCalled2 = true;
        assert.deepStrictEqual(args, [
          'SendDetailsRoot',
          {
            params: {
              uri: 'bitcoin:BC1QR7P8NSYPZEJY4KP7CJS0HL5T9X0VF3AYF6UQPC?amount=0.00185579&',
              walletID:
                'a1c50c266e229bb66aca0221d5b6a116720004c97437a0a6e279cfea027d0c87',
            },
            screen: 'SendDetails',
          },
        ])
      }
    }

    response[1].onWalletSelect(lw, { navigation: navigationMock });
    response[1].onWalletSelect(bw, { navigation: navigationMock2 });

    assert.ok(popWasCalled);
    assert.ok(navigateWasCalled);

    assert.ok(popWasCalled2);
    assert.ok(navigateWasCalled2);
  })
});


================================================
FILE: ./tests/unit/hd-taproot-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { HDTaprootWallet, TaprootWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

const utxos = [
  {
    height: 0,
    value: 181385,
    address: 'bc1p84mlccwgz7vz2y7xp0yy98zz5h8myyjd7zdncw6dzw9cm5yglu9qm4qrjg',
    txid: 'e97f982766537c5330b50ef521bbcd8811971eb7cc9fd64bda45266136f27b82',
    vout: 0,
    wif: 'L1qB2ugfwSjM1CCuZtq4T6Ban9tAWSETpoq6NyNR9W9wNK3d5L2p',
  },
];

describe('Taproot HD (BIP86)', () => {
  it('can create', async function () {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDTaprootWallet();
    hd.setSecret(mnemonic);

    assert.strictEqual(true, hd.validateMnemonic());
    assert.strictEqual(hd.getMasterFingerprintHex(), '73C5DA0A');
    assert.strictEqual(
      'xpub6BgBgsespWvERF3LHQu6CnqdvfEvtMcQjYrcRzx53QJjSxarj2afYWcLteoGVky7D3UKDP9QyrLprQ3VCECoY49yfdDEHGCtMMj92pReUsQ',
      hd.getXpub(),
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr');
    assert.strictEqual(hd._getExternalAddressByIndex(1), 'bc1p4qhjn9zdvkux4e44uhx8tc55attvtyu358kutcqkudyccelu0was9fqzwh');

    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1p3qkhfews2uk44qtvauqyr2ttdsw7svhkl9nkm9s9c3x4ax5h60wqwruhk7');

    assert.strictEqual(hd._getExternalWIFByIndex(0), 'KyRv5iFPHG7iB5E4CqvMzH3WFJVhbfYK4VY7XAedd9Ys69mEsPLQ');
    assert.ok(hd._getInternalWIFByIndex(0) !== hd._getInternalWIFByIndex(1));

    const w = new TaprootWallet();
    w.setSecret(hd._getExternalWIFByIndex(0) as string);

    assert.strictEqual(w.getAddress(), hd._getExternalAddressByIndex(0));

    assert.ok(hd.getAllExternalAddresses().includes('bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr'));

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/86'/0'/0'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(1)), "m/86'/0'/0'/0/1");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/86'/0'/0'/1/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(1)), "m/86'/0'/0'/1/1");

    assert.strictEqual(hd.getMasterFingerprintHex(), '73C5DA0A');

    let u8a = hd._getPubkeyByAddress(hd._getExternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), 'cc8a4bc64d897bddc5fbc2f670f7a8ba0b386779106cf1223c6fc5d7cd6fc115');
    u8a = hd._getPubkeyByAddress(hd._getInternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '399f1b2f4393f29a18c937859c5dd8a77350103157eb880f02e8c08214277cef');
  });

  it('can generate addresses only via zpub', function () {
    const xpub = 'xpub6BgBgsespWvERF3LHQu6CnqdvfEvtMcQjYrcRzx53QJjSxarj2afYWcLteoGVky7D3UKDP9QyrLprQ3VCECoY49yfdDEHGCtMMj92pReUsQ';
    const hd = new HDTaprootWallet();
    hd._xpub = xpub;
    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr');
    assert.strictEqual(hd._getExternalAddressByIndex(1), 'bc1p4qhjn9zdvkux4e44uhx8tc55attvtyu358kutcqkudyccelu0was9fqzwh');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1p3qkhfews2uk44qtvauqyr2ttdsw7svhkl9nkm9s9c3x4ax5h60wqwruhk7');
    assert.ok(hd._getInternalAddressByIndex(0) !== hd._getInternalAddressByIndex(1));

    assert.ok(hd.getAllExternalAddresses().includes('bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr'));
    assert.ok(hd.getAllExternalAddresses().includes('bc1p4qhjn9zdvkux4e44uhx8tc55attvtyu358kutcqkudyccelu0was9fqzwh'));
    assert.ok(!hd.getAllExternalAddresses().includes('bc1p3qkhfews2uk44qtvauqyr2ttdsw7svhkl9nkm9s9c3x4ax5h60wqwruhk7')); // not internal
  });

  it('can generate', async () => {
    const hd = new HDTaprootWallet();
    const hashmap: Record<string, boolean> = {};
    for (let c = 0; c < 1000; c++) {
      await hd.generate();
      const secret = hd.getSecret();
      assert.strictEqual(secret.split(' ').length, 12);
      if (hashmap[secret]) {
        throw new Error('Duplicate secret generated!');
      }
      hashmap[secret] = true;
      assert.ok(secret.split(' ').length === 12 || secret.split(' ').length === 24);
    }

    const hd2 = new HDTaprootWallet();
    hd2.setSecret(hd.getSecret());
    assert.ok(hd2.validateMnemonic());
  });

  it('can make xpub', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const hd = new HDTaprootWallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);

    assert.strictEqual(true, hd.validateMnemonic());
    assert.strictEqual(
      'xpub6D7Yb9GhEurKUHVVcpeaCRMBydwrJN3uoy2Mqt7UZXuVezdreniHwedHPGtzct3Fy7JgN6XqdJvw9svHvLHHDuh4RTDArPizwttxaHCzSCP',
      hd.getXpub(),
    );
  });

  it('can createTransaction with a correct feerate', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }
    const hd = new HDTaprootWallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);
    assert.ok(hd.validateMnemonic());

    const targetFeeRate = 1;
    const { tx, psbt, outputs } = hd.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }],
      targetFeeRate,
      hd._getInternalAddressByIndex(0),
    );

    assert.strictEqual(outputs.length, 1);
    assert(tx);

    const actualFeerate = Number(psbt.getFee()) / tx.virtualSize();
    assert.strictEqual(
      Math.round(actualFeerate) >= targetFeeRate && actualFeerate <= targetFeeRate + 1,
      true,
      `bad feerate, got ${actualFeerate}, expected at least ${targetFeeRate}; fee: ${psbt.getFee()}; virsualSize: ${tx.virtualSize()} vbytes; ${tx.toHex()}`,
    );

    // txid: 7a84a51cfd06db19037526ab60eb0f55fa6c9f4ff87bdfc5ec174e3375e38f0d
    assert.strictEqual(
      tx.toHex(),
      '02000000000101827bf236612645da4bd69fccb71e971188cdbb21f50eb530537c536627987fe90000000000000000800123c40200000000001976a91419129d53e6319baf19dba059bead166df90ab8f588ac0140bbf80293348710449dc44af7d9c31afb3935cce96687b29a0bab1e3dd344c1a604f5e7ee10586486940334c7b64bbbc034721275da3086822f2b1e987a79431500000000',
    );
  });

  it('can createTransaction with a correct feerate 2', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }
    const hd = new HDTaprootWallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);
    assert.ok(hd.validateMnemonic());

    const targetFeeRate = 10;
    const { tx, psbt, outputs } = hd.createTransaction(
      utxos,
      [
        { address: 'bc1pgrhjjw52p6a03v635f7cnl6ttvuz9f34ujhaefm6xqtscd3m473szkl92g', value: 10000 },
        { address: 'bc1pm6lqlel3qxefsx0v39nshtghasvvp6ghn3e5hd5q280j5m9h7csqrkzssu', value: 10000 },
        { address: 'bc1ptestlpef53v6vyku3f9rk0ve2mek2fdwnd9k6q3mnyn6vs9nqlsqqnejxf', value: 10000 },
      ],
      targetFeeRate,
      hd._getInternalAddressByIndex(0),
    );

    assert.strictEqual(outputs.length, 4);
    assert(tx);

    const actualFeerate = Number(psbt.getFee()) / tx.virtualSize();
    assert.strictEqual(
      Math.round(actualFeerate) >= targetFeeRate && actualFeerate <= targetFeeRate + 1,
      true,
      `bad feerate, got ${actualFeerate}, expected at least ${targetFeeRate}; fee: ${psbt.getFee()}; virsualSize: ${tx.virtualSize()} vbytes; ${tx.toHex()}`,
    );
  });
});


================================================
FILE: ./tests/unit/segwit-bech32-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { SegwitBech32Wallet } from '../../class';

describe('Segwit P2SH wallet', () => {
  it('can create transaction', async () => {
    const wallet = new SegwitBech32Wallet();
    wallet.setSecret('L4vn2KxgMLrEVpxjfLwxfjnPPQMnx42DCjZJ2H7nN4mdHDyEUWXd');
    assert.strictEqual(wallet.getAddress(), 'bc1q3rl0mkyk0zrtxfmqn9wpcd3gnaz00yv9yp0hxe');
    assert.deepStrictEqual(wallet.getAllExternalAddresses(), ['bc1q3rl0mkyk0zrtxfmqn9wpcd3gnaz00yv9yp0hxe']);
    assert.strictEqual(await wallet.getChangeAddressAsync(), wallet.getAddress());

    const feeRate = 1;
    const utxos = [
      {
        txid: '57d18bc076b919583ff074cfba6201edd577f7fe35f69147ea512e970f95ffeb',
        vout: 0,
        value: 100000,
      },
    ];

    let txNew = wallet.createTransaction(
      utxos,
      [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }],
      feeRate,
      wallet.getAddress(),
    );
    let tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    // check fee rate up to the second decimal place
    assert.strictEqual(Math.round((txNew.fee / tx.virtualSize()) * 10), feeRate * 10);
    assert.strictEqual(
      txNew.tx.toHex(),
      '02000000000101ebff950f972e51ea4791f635fef777d5ed0162bacf74f03f5819b976c08bd1570000000000ffffffff02905f0100000000001976a914aa381cd428a4e91327fd4434aa0a08ff131f1a5a88ac7e2600000000000016001488fefdd8967886b32760995c1c36289f44f7918502483045022100fc0ba843588a5156878cd9d6e3c6b0cbce6acd5c8cf04dc09dcb8d0f23da07f002207a2d5bed25936b1eeda7e836a4734f5a0e66b4996aff64b3b3759ae81805722301210314cf2bf53f221e58c5adc1dd95adba9239b248f39b09eb2c550aadc1926fe7aa00000000',
    );
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual(bitcoin.address.fromOutputScript(tx.outs[1].script), wallet.getAddress()); // change address

    // sendMax
    txNew = wallet.createTransaction(utxos, [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], feeRate, wallet.getAddress());
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(Math.round((txNew.fee / tx.virtualSize()) * 10), feeRate * 10);
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 1);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address

    // batch send + send max
    txNew = wallet.createTransaction(
      utxos,
      [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }, { address: '14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M', value: 10000 }],
      feeRate,
      wallet.getAddress(),
    );
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(Math.round((txNew.fee / tx.virtualSize()) * 10), feeRate * 10);
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual('14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M', bitcoin.address.fromOutputScript(tx.outs[1].script)); // to address
  });

  it('can create transaction with decimal fee rate', async () => {
    const wallet = new SegwitBech32Wallet();
    wallet.setSecret('L4vn2KxgMLrEVpxjfLwxfjnPPQMnx42DCjZJ2H7nN4mdHDyEUWXd');
    assert.strictEqual(wallet.getAddress(), 'bc1q3rl0mkyk0zrtxfmqn9wpcd3gnaz00yv9yp0hxe');
    assert.deepStrictEqual(wallet.getAllExternalAddresses(), ['bc1q3rl0mkyk0zrtxfmqn9wpcd3gnaz00yv9yp0hxe']);
    assert.strictEqual(await wallet.getChangeAddressAsync(), wallet.getAddress());

    const feeRate = 1.5;
    const utxos = [
      {
        txid: '57d18bc076b919583ff074cfba6201edd577f7fe35f69147ea512e970f95ffeb',
        vout: 0,
        value: 100000,
      },
    ];

    let txNew = wallet.createTransaction(
      utxos,
      [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }],
      feeRate,
      wallet.getAddress(),
    );
    let tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    // check fee rate up to the second decimal place
    assert.strictEqual(Math.round((txNew.fee / tx.virtualSize()) * 10), feeRate * 10);
    assert.strictEqual(
      txNew.tx.toHex(),
      '02000000000101ebff950f972e51ea4791f635fef777d5ed0162bacf74f03f5819b976c08bd1570000000000ffffffff02905f0100000000001976a914aa381cd428a4e91327fd4434aa0a08ff131f1a5a88ac352600000000000016001488fefdd8967886b32760995c1c36289f44f7918502483045022100ad3ae70792176c44718c0a3b6fd59012e8ca36b080265b91fcc861b36c3fb06402202fa1317fe07c192581f9eebdb137c5f1ba7d666d07ed6e0548d7dff3669b748401210314cf2bf53f221e58c5adc1dd95adba9239b248f39b09eb2c550aadc1926fe7aa00000000',
    );
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual(bitcoin.address.fromOutputScript(tx.outs[1].script), wallet.getAddress()); // change address

    // sendMax
    txNew = wallet.createTransaction(utxos, [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], feeRate, wallet.getAddress());
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(Math.round((txNew.fee / tx.virtualSize()) * 10), feeRate * 10);
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 1);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address

    // batch send + send max
    txNew = wallet.createTransaction(
      utxos,
      [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }, { address: '14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M', value: 10000 }],
      feeRate,
      wallet.getAddress(),
    );
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(Math.round((txNew.fee / tx.virtualSize()) * 10), feeRate * 10);
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual('14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M', bitcoin.address.fromOutputScript(tx.outs[1].script)); // to address
  });

  it('can sign and verify messages', async () => {
    const l = new SegwitBech32Wallet();
    l.setSecret('L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1'); // from bitcoinjs-message examples

    const signature = l.signMessage('This is an example of a signed message.', l.getAddress());
    assert.strictEqual(signature, 'J9L5yLFjti0QTHhPyFrZCT1V/MMnBtXKmoiKDZ78NDBjERki6ZTQZdSMCtkgoNmp17By9ItJr8o7ChX0XxY91nk=');
    assert.strictEqual(l.verifyMessage('This is an example of a signed message.', l.getAddress(), signature), true);
  });

  it('can coinselect with different decimal feeRate', async () => {
    const wallet = new SegwitBech32Wallet();
    wallet.setSecret('L4vn2KxgMLrEVpxjfLwxfjnPPQMnx42DCjZJ2H7nN4mdHDyEUWXd');
    const change = wallet.getAddress();
    const utxos = [
      {
        txid: '57d18bc076b919583ff074cfba6201edd577f7fe35f69147ea512e970f95ffeb',
        vout: 0,
        value: 100000,
      },
    ];
    for (let feeRate = 1; feeRate < 20; feeRate += 0.1) {
      wallet.coinselect(utxos, [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], feeRate);
      const txNew = wallet.createTransaction(utxos, [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], feeRate, change);
      const tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
      const actualFeeRate = txNew.fee / tx.virtualSize();
      const diffPercentage = (Math.abs(actualFeeRate - feeRate) / feeRate) * 100;
      // check that actual fee rate is not more that 3% different from the expected fee rate
      assert.ok(diffPercentage < 3, `Fee rate is too different: expected ${feeRate}, got ${actualFeeRate}`);
    }
  });
});


================================================
FILE: ./tests/unit/hd-segwit-p2sh-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { HDLegacyP2PKHWallet, HDSegwitP2SHWallet, LegacyWallet, SegwitBech32Wallet, SegwitP2SHWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('P2SH Segwit HD (BIP49)', () => {
  it('can create a wallet', async () => {
    const mnemonic =
      'honey risk juice trip orient galaxy win situate shoot anchor bounce remind horse traffic exotic since escape mimic ramp skin judge owner topple erode';
    const hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    assert.strictEqual('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', hd._getExternalAddressByIndex(0));
    assert.strictEqual('35p5LwCAE7mH2css7onyQ1VuS1jgWtQ4U3', hd._getExternalAddressByIndex(1));
    assert.strictEqual('32yn5CdevZQLk3ckuZuA8fEKBco8mEkLei', hd._getInternalAddressByIndex(0));
    assert.ok(hd.getAllExternalAddresses().includes('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK'));
    assert.ok(hd.getAllExternalAddresses().includes('35p5LwCAE7mH2css7onyQ1VuS1jgWtQ4U3'));
    assert.ok(!hd.getAllExternalAddresses().includes('32yn5CdevZQLk3ckuZuA8fEKBco8mEkLei')); // not internal
    assert.strictEqual(true, hd.validateMnemonic());

    let u8a = hd._getPubkeyByAddress(hd._getExternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '0348192db90b753484601aaf1e6220644ffe37d83a9a5feff32b4da43739f736be');
    u8a = hd._getPubkeyByAddress(hd._getInternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '03c107e6976d59e17490513fbed3fb321736b7231d24f3d09306c72714acf1859d');

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/49'/0'/0'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/49'/0'/0'/1/0");

    assert.strictEqual('L4MqtwJm6hkbACLG4ho5DF8GhcXdLEbbvpJnbzA9abfD6RDpbr2m', hd._getExternalWIFByIndex(0));
    assert.strictEqual(
      'ypub6WhHmKBmHNjcrUVNCa3sXduH9yxutMipDcwiKW31vWjcMbfhQHjXdyx4rqXbEtVgzdbhFJ5mZJWmfWwnP4Vjzx97admTUYKQt6b9D7jjSCp',
      hd.getXpub(),
    );
  });

  it('can convert witness to address', () => {
    let address = SegwitP2SHWallet.witnessToAddress('035c618df829af694cb99e664ce1b34f80ad2c3b49bcd0d9c0b1836c66b2d25fd8');
    assert.strictEqual(address, '34ZVGb3gT8xMLT6fpqC6dNVqJtJmvdjbD7');
    address = SegwitP2SHWallet.witnessToAddress('');
    assert.strictEqual(address, false);
    address = SegwitP2SHWallet.witnessToAddress('trololo');
    assert.strictEqual(address, false);

    address = SegwitP2SHWallet.scriptPubKeyToAddress('a914e286d58e53f9247a4710e51232cce0686f16873c87');
    assert.strictEqual(address, '3NLnALo49CFEF4tCRhCvz45ySSfz3UktZC');
    address = SegwitP2SHWallet.scriptPubKeyToAddress('');
    assert.strictEqual(address, false);
    address = SegwitP2SHWallet.scriptPubKeyToAddress('trololo');
    assert.strictEqual(address, false);

    address = SegwitBech32Wallet.witnessToAddress('035c618df829af694cb99e664ce1b34f80ad2c3b49bcd0d9c0b1836c66b2d25fd8');
    assert.strictEqual(address, 'bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv');
    address = SegwitBech32Wallet.witnessToAddress('');
    assert.strictEqual(address, false);
    address = SegwitBech32Wallet.witnessToAddress('trololo');
    assert.strictEqual(address, false);

    address = SegwitBech32Wallet.scriptPubKeyToAddress('00144d757460da5fcaf84cc22f3847faaa1078e84f6a');
    assert.strictEqual(address, 'bc1qf46hgcx6tl90snxz9uuy0742zpuwsnm27ysdh7');
    address = SegwitBech32Wallet.scriptPubKeyToAddress('');
    assert.strictEqual(address, false);
    address = SegwitBech32Wallet.scriptPubKeyToAddress('trololo');
    assert.strictEqual(address, false);

    address = LegacyWallet.scriptPubKeyToAddress('76a914d0b77eb1502c81c4093da9aa6eccfdf560cdd6b288ac');
    assert.strictEqual(address, '1L2bNMGRQQLT2AVUek4K9L7sn3SSMioMgE');
    address = LegacyWallet.scriptPubKeyToAddress('');
    assert.strictEqual(address, false);
    address = LegacyWallet.scriptPubKeyToAddress('trololo');
    assert.strictEqual(address, false);
  });

  it('Segwit HD (BIP49) can generate addressess only via ypub', function () {
    const ypub = 'ypub6WhHmKBmHNjcrUVNCa3sXduH9yxutMipDcwiKW31vWjcMbfhQHjXdyx4rqXbEtVgzdbhFJ5mZJWmfWwnP4Vjzx97admTUYKQt6b9D7jjSCp';
    const hd = new HDSegwitP2SHWallet();
    hd._xpub = ypub;
    assert.strictEqual('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK', hd._getExternalAddressByIndex(0));
    assert.strictEqual('35p5LwCAE7mH2css7onyQ1VuS1jgWtQ4U3', hd._getExternalAddressByIndex(1));
    assert.strictEqual('32yn5CdevZQLk3ckuZuA8fEKBco8mEkLei', hd._getInternalAddressByIndex(0));
    assert.ok(hd.getAllExternalAddresses().includes('3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK'));
    assert.ok(hd.getAllExternalAddresses().includes('35p5LwCAE7mH2css7onyQ1VuS1jgWtQ4U3'));
    assert.ok(!hd.getAllExternalAddresses().includes('32yn5CdevZQLk3ckuZuA8fEKBco8mEkLei')); // not internal
  });

  it('can generate Segwit HD (BIP49)', async () => {
    const hd = new HDSegwitP2SHWallet();
    const hashmap: Record<string, number> = {};
    for (let c = 0; c < 1000; c++) {
      await hd.generate();
      const secret = hd.getSecret();
      if (hashmap[secret]) {
        throw new Error('Duplicate secret generated!');
      }
      hashmap[secret] = 1;
      assert.ok(secret.split(' ').length === 12 || secret.split(' ').length === 24);
    }

    const hd2 = new HDSegwitP2SHWallet();
    hd2.setSecret(hd.getSecret());
    assert.ok(hd2.validateMnemonic());
  });

  it('can work with malformed mnemonic', () => {
    let mnemonic =
      'honey risk juice trip orient galaxy win situate shoot anchor bounce remind horse traffic exotic since escape mimic ramp skin judge owner topple erode';
    let hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    const seed1 = hd._getSeed().toString('hex');
    assert.ok(hd.validateMnemonic());

    mnemonic = 'hell';
    hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    assert.ok(!hd.validateMnemonic());

    // now, malformed mnemonic

    mnemonic =
      '    honey  risk   juice    trip     orient      galaxy win !situate ;; shoot   ;;;   anchor Bounce remind\nhorse \n traffic exotic since escape mimic ramp skin judge owner topple erode ';
    hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    const seed2 = hd._getSeed().toString('hex');
    assert.strictEqual(seed1, seed2);
    assert.ok(hd.validateMnemonic());
  });

  it('can generate addressess based on xpub', async function () {
    const xpub = 'xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6DXDs4PJDk5QVL2G2xaVjv7SM4roWHr1gR4xB3Z7Ps';
    const hd = new HDLegacyP2PKHWallet();
    hd._xpub = xpub;
    assert.strictEqual(hd._getExternalAddressByIndex(0), '12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '1KZjqYHm7a1DjhjcdcjfQvYfF2h6PqatjX');
    assert.strictEqual(hd._getExternalAddressByIndex(1), '1QDCFcpnrZ4yrAQxmbvSgeUC9iZZ8ehcR5');
    assert.strictEqual(hd._getInternalAddressByIndex(1), '13CW9WWBsWpDUvLtbFqYziWBWTYUoQb4nU');
    assert.ok(hd.getAllExternalAddresses().includes('12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG'));
    assert.ok(hd.getAllExternalAddresses().includes('1QDCFcpnrZ4yrAQxmbvSgeUC9iZZ8ehcR5'));
    assert.ok(!hd.getAllExternalAddresses().includes('1KZjqYHm7a1DjhjcdcjfQvYfF2h6PqatjX')); // not internal
  });

  it('can consume user generated entropy', async () => {
    const hd1 = new HDSegwitP2SHWallet();
    const zeroes16 = [...Array(16)].map(() => 0);
    await hd1.generateFromEntropy(Buffer.from(zeroes16));
    assert.strictEqual(hd1.getSecret(), 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');

    const hd2 = new HDSegwitP2SHWallet();
    const zeroes32 = [...Array(32)].map(() => 0);
    await hd2.generateFromEntropy(Buffer.from(zeroes32));
    assert.strictEqual(
      hd2.getSecret(),
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art',
    );
  });

  it('throws an error if not 32 bytes provided', async () => {
    const hd = new HDSegwitP2SHWallet();
    const values = [...Array(31)].map(() => 1);
    await assert.rejects(async () => await hd.generateFromEntropy(Buffer.from(values)), {
      message: 'Entropy has to be 16 or 32 bytes long',
    });
  });

  it('can sign and verify messages', async () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    let signature;

    // external address
    signature = hd.signMessage('vires is numeris', hd._getExternalAddressByIndex(0));
    assert.strictEqual(signature, 'JMgoRSlLLLw6mw/Gbbg8Uj3fACkIJ85CZ52T5ZQfBnpUBkz0myRju6Rmgvmq7ugytc4WyYbzdGEc3wufNbjP09g=');
    assert.strictEqual(hd.verifyMessage('vires is numeris', hd._getExternalAddressByIndex(0), signature), true);

    // internal address
    signature = hd.signMessage('vires is numeris', hd._getInternalAddressByIndex(0));
    assert.strictEqual(signature, 'I5WkniWTnJhTW74t3kTAkHq3HdiupTNgOZLpMp0hvUfAJw2HMuyRiNLl2pbNWobNCCrmvffSWM7IgkOBz/J9fYA=');
    assert.strictEqual(hd.verifyMessage('vires is numeris', hd._getInternalAddressByIndex(0), signature), true);
  });

  it('can show fingerprint', async () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    assert.strictEqual(hd.getMasterFingerprintHex(), '73C5DA0A');
  });

  it('can use mnemonic with passphrase', () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const passphrase = 'super secret passphrase';
    const hd = new HDSegwitP2SHWallet();
    hd.setSecret(mnemonic);
    hd.setPassphrase(passphrase);

    assert.strictEqual(
      hd.getXpub(),
      'ypub6Xa3WiyXHriYt1fxZGWS8B1iduw92yxHCMWKSwJkW6w92FUCTJxwWQQHLXjRHBSsMLY6SvRu8ErqFEC3JmrkTHEm7KSUfbzhUhj7Yopo2JR',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), '3BtnNenqpGTXwwjb5a1KgzzoKV4TjCuySm');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '3EJctafkUBvcSHYhunQRa2iYUHjrMGLXBV');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'L489rJZvUMrFsNop9EyuG2XdEmyKNTbjC1DWkg9WGEc1ddK6jgDg');
  });

  it('can create with custom derivation path', async () => {
    const hd = new HDSegwitP2SHWallet();
    hd.setSecret('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');
    hd.setDerivationPath("m/49'/0'/1'");

    assert.strictEqual(
      hd.getXpub(),
      'ypub6Ww3ibxVfGzLtJR4F9SRBicspAfvmvw54yern9Q6qZWFC9T6FYA34K57La5Sgs8pXuyvpDfEHX5KNZRiZRukUWaVPyL4NxA69sEAqdoV8ve',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), '35eszW2wmZ4hn7hfG5LGqxw5xCPjZcEJPM');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '35gZZo6xPJEPgcz1cj1mTQHRMiPP97NGRY');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'KxTxanpst8612uDETejiDfSfbC2paXJi7teZ1ZfW5RpNfXbXnszw');

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/49'/0'/1'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/49'/0'/1'/1/0");
  });
});


================================================
FILE: ./tests/unit/currency.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import {
  _setExchangeRate,
  _setPreferredFiatCurrency,
  BTCToLocalCurrency,
  satoshiToBTC,
  satoshiToLocalCurrency,
} from '../../malin_modules/currency';
import { FiatUnit } from '../../models/fiatUnit';

describe('currency', () => {
  it('formats everything correctly', async () => {
    _setExchangeRate('BTC_USD', 10000);

    assert.strictEqual(satoshiToLocalCurrency(1), '$0.0001');
    assert.strictEqual(satoshiToLocalCurrency(-1), '-$0.0001');
    assert.strictEqual(satoshiToLocalCurrency(123), '$0.01');
    assert.strictEqual(satoshiToLocalCurrency(156), '$0.02');
    assert.strictEqual(satoshiToLocalCurrency(51), '$0.01');
    assert.strictEqual(satoshiToLocalCurrency(45), '$0.0045');
    assert.strictEqual(satoshiToLocalCurrency(123456789), '$12,345.68');

    assert.strictEqual(BTCToLocalCurrency(1), '$10,000.00');
    assert.strictEqual(BTCToLocalCurrency(-1), '-$10,000.00');
    assert.strictEqual(BTCToLocalCurrency(1.00000001), '$10,000.00');
    assert.strictEqual(BTCToLocalCurrency(1.0000123), '$10,000.12');
    assert.strictEqual(BTCToLocalCurrency(1.0000146), '$10,000.15');

    assert.strictEqual(satoshiToBTC(1), '0.00000001');
    assert.strictEqual(satoshiToBTC(-1), '-0.00000001');
    assert.strictEqual(satoshiToBTC(100000000), '1');
    assert.strictEqual(satoshiToBTC(123456789123456789), '1234567891.2345678'); // eslint-disable-line @typescript-eslint/no-loss-of-precision

    _setPreferredFiatCurrency(FiatUnit.JPY);
    _setExchangeRate('BTC_JPY', 1043740.8614);

    assert.ok(satoshiToLocalCurrency(1) === '0.01' || satoshiToLocalCurrency(1) === '0.01', 'Unexpected: ' + satoshiToLocalCurrency(1));
  });
});


================================================
FILE: ./tests/unit/isValidBech32Address.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { isValidBech32Address } from '../../utils/isValidBech32Address';

describe('isValidBech32Address', () => {
  const validBech32Addresses: string[] = [
    'bc1qatswv5uv7qetzz4n8u9u2x2ckmaxvc8qng5s7r', // P2WPKH (SegWit v0)
    'bc1ph76f32dqjkvd523g02ucylqstljj5pysqe3lmyuepnuyz5d7lw9sl0pp4m', // P2TR (Taproot v1)
    'tb1ql4jps5nxnyz7qxgle9dp3q0mww2jk4ckfua6lr', // Testnet SegWit v0
    'tb1p4tp4l6glyr2gs94neqcpr5gha7344nfyznfkc8szkreflscsdkgqsdent4', // Testnet Taproot v1
  ];

  const invalidBech32Addresses: (string | null | undefined)[] = [
    'moKVV6XEhfrBCE3QCYq6ppT7AaMF8KsZ1B',
    '16X9EwoL5fgUr2ordTy8bs7wT4Ff3QGQPW', // Legacy (P2PKH)
    '3HFvmZJhc7KbqVXXQXaa34StUPk4gxcQyR', // P2SH
    'bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj', // Invalid checksum
    'tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kyd39', // Too short
    'BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KYGT080', // Uppercase (invalid Bech32)
    'bcrt1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh', // Regtest
    '', // Empty string
    null,
    undefined,
  ];

  test.each(validBech32Addresses)('should return true for valid Bech32 address: %s', (address: string) => {
    expect(isValidBech32Address(address)).toBe(true);
  });

  test.each(invalidBech32Addresses)('should return false for invalid Bech32 address: %s', (address: string | null | undefined) => {
    expect(isValidBech32Address(address as string)).toBe(false);
  });
});


================================================
FILE: ./tests/unit/hd-legacy-breadwallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { HDLegacyBreadwalletWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('HDLegacyBreadwalletWallet', () => {
  it('Legacy HD Breadwallet works', async () => {
    if (!process.env.HD_MNEMONIC_BREAD) {
      console.error('process.env.HD_MNEMONIC_BREAD not set, skipped');
      return;
    }
    const hdBread = new HDLegacyBreadwalletWallet();
    hdBread.setSecret(process.env.HD_MNEMONIC_BREAD);

    assert.strictEqual(hdBread.validateMnemonic(), true);
    assert.strictEqual(hdBread._getExternalAddressByIndex(0), '1M1UphJDb1mpXV3FVEg6b2qqaBieNuaNrt');
    assert.strictEqual(hdBread._getInternalAddressByIndex(0), '1A9Sc4opR6c7Ui6NazECiGmsmnUPh2WeHJ');
    hdBread._internal_segwit_index = 2;
    hdBread._external_segwit_index = 2;
    assert.ok(hdBread._getExternalAddressByIndex(0).startsWith('1'));
    assert.ok(hdBread._getInternalAddressByIndex(0).startsWith('1'));
    assert.strictEqual(hdBread._getExternalAddressByIndex(2), 'bc1qh0vtrnjn7zs99j4n6xaadde95ctnnvegh9l2jn');
    assert.strictEqual(hdBread._getInternalAddressByIndex(2), 'bc1qk9hvkxqsqmps6ex3qawr79rvtg8es4ecjfu5v0');

    assert.strictEqual(hdBread._getDerivationPathByAddress('1M1UphJDb1mpXV3FVEg6b2qqaBieNuaNrt'), "m/0'/0/0");
    assert.strictEqual(hdBread._getDerivationPathByAddress('bc1qk9hvkxqsqmps6ex3qawr79rvtg8es4ecjfu5v0'), "m/0'/1/2");

    assert.strictEqual(
      uint8ArrayToHex(hdBread._getPubkeyByAddress(hdBread._getExternalAddressByIndex(0))),
      '029ba027f3f0a9fa69ce680a246198d56a3b047108f26791d1e4aa2d10e7e7a29a',
    );
    assert.strictEqual(
      uint8ArrayToHex(hdBread._getPubkeyByAddress(hdBread._getInternalAddressByIndex(0))),
      '03074225b31a95af63de31267104e07863d892d291a33ef5b2b32d59c772d5c784',
    );

    assert.strictEqual(
      hdBread.getXpub(),
      'xpub68hPk9CrHimZMBQEja43qWRC2TuXmCDdgZcR5YMebr38XatUEPu2Q2oaBViSMshDcyuMDGkGbTS2aqNHFKdcN1sFWaZgK6SLg84dtN7Ym64',
    );

    assert.ok(hdBread.getAllExternalAddresses().includes('1M1UphJDb1mpXV3FVEg6b2qqaBieNuaNrt'));
    assert.ok(hdBread.getAllExternalAddresses().includes('bc1qh0vtrnjn7zs99j4n6xaadde95ctnnvegh9l2jn'));
  });

  it('Can use french seed', async () => {
    const hdBread = new HDLegacyBreadwalletWallet();
    hdBread.setSecret('abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abeille');
    assert.strictEqual(hdBread.validateMnemonic(), true);
    assert.strictEqual(hdBread._getExternalAddressByIndex(0), '1JFdzwd8SqFn5LeeiDKcbYUfXxvButqXgX');
  });
});


================================================
FILE: ./tests/unit/slip39-wallets.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { SLIP39LegacyP2PKHWallet, SLIP39SegwitBech32Wallet, SLIP39SegwitP2SHWallet } from '../../class';

global.crypto = require('crypto');

describe('SLIP39 wallets tests', () => {
  it('can validateMnemonic', async () => {
    const w = new SLIP39LegacyP2PKHWallet();
    // not enought shares
    w.setSecret(
      'shadow pistol academic always adequate wildlife fancy gross oasis cylinder mustang wrist rescue view short owner flip making coding armed',
    );
    assert.strictEqual(w.validateMnemonic(), false);

    // wrong words
    w.setSecret('qweasd ewqasd');
    assert.strictEqual(w.validateMnemonic(), false);
  });

  it('can generate ID', () => {
    const w = new SLIP39LegacyP2PKHWallet();
    // not enought shares
    w.setSecret(
      'shadow pistol academic always adequate wildlife fancy gross oasis cylinder mustang wrist rescue view short owner flip making coding armed',
    );

    assert.ok(w.getID());
  });

  it('SLIP39LegacyP2PKHWallet can generate addresses', async () => {
    const w = new SLIP39LegacyP2PKHWallet();
    // 4. Basic sharing 2-of-3 (128 bits)
    w.setSecret(
      'shadow pistol academic always adequate wildlife fancy gross oasis cylinder mustang wrist rescue view short owner flip making coding armed\n' +
        'shadow pistol academic acid actress prayer class unknown daughter sweater depict flip twice unkind craft early superior advocate guest smoking',
    );

    assert.ok(w.validateMnemonic());
    assert.strictEqual(w._getExternalAddressByIndex(0), '18pvMjy7AJbCDtv4TLYbGPbR7SzGzjqUpj');
    assert.strictEqual(w._getExternalAddressByIndex(1), '1LDm2yFgHesgVjENC4cEpvUnW5HdYp51gX');
    assert.strictEqual(w._getInternalAddressByIndex(0), '1EeW2xsK52vqBpsFLYa1vL6hyxmWCsK3Nx');
    assert.strictEqual(w._getInternalAddressByIndex(1), '1EM8ADickQ9WppVgSGGgjL8PGWhbbTqNpW');
  });

  it('SLIP39LegacyP2PKHWallet can work with truncated words', async () => {
    const w = new SLIP39LegacyP2PKHWallet();
    // 4. Basic sharing 2-of-3 (128 bits)
    w.setSecret(
      'SHAD PIS ACAD ALWA ADEQ WILD FANC GROS OASI CYLI MUST WRIS RESC VIEW SHOR OWNER FLIP MAKI CODI ARME\n' +
        'SHAD PIS ACAD ACI ACTR PRAY CLAS UNKN DAUG SWEA DEPI FLI TWIC UNKI CRAF EARL SUPE ADVO GUES SMOK',
    );

    assert.ok(w.validateMnemonic());
    assert.strictEqual(w._getExternalAddressByIndex(0), '18pvMjy7AJbCDtv4TLYbGPbR7SzGzjqUpj');
  });

  it('SLIP39SegwitP2SHWallet can generate addresses', async () => {
    const w = new SLIP39SegwitP2SHWallet();
    // 23. Basic sharing 2-of-3 (256 bits)
    w.setSecret(
      'humidity disease academic always aluminum jewelry energy woman receiver strategy amuse duckling lying evidence network walnut tactics forget hairy rebound impulse brother survive clothes stadium mailman rival ocean reward venture always armed unwrap\n' +
        'humidity disease academic agency actress jacket gross physics cylinder solution fake mortgage benefit public busy prepare sharp friar change work slow purchase ruler again tricycle involve viral wireless mixture anatomy desert cargo upgrade',
    );

    assert.ok(w.validateMnemonic());
    assert.strictEqual(w._getExternalAddressByIndex(0), '3G3HrQ7DrNJLm8gMrLHTeeD5DdzgeoScRJ');
    assert.strictEqual(w._getExternalAddressByIndex(1), '3HgGV4fhXz8GZYVMRT1tj9WoUdMQMDrGvw');
    assert.strictEqual(w._getInternalAddressByIndex(0), '3BdrAbZCo9BCmzP1nmpEVyGXMB9JF4MJ1L');
    assert.strictEqual(w._getInternalAddressByIndex(1), '3GFSjHbSRGZZavmY7YTm9UJfDbmJdpCeMA');
  });

  it('SLIP39SegwitBech32Wallet can generate addresses', async () => {
    const w = new SLIP39SegwitBech32Wallet();
    // 36. Threshold number of groups and members in each group (256 bits, case 1)
    w.setSecret(
      'wildlife deal ceramic round aluminum pitch goat racism employer miracle percent math decision episode dramatic editor lily prospect program scene rebuild display sympathy have single mustang junction relate often chemical society wits estate\n' +
        'wildlife deal decision scared acne fatal snake paces obtain election dryer dominant romp tactics railroad marvel trust helpful flip peanut theory theater photo luck install entrance taxi step oven network dictate intimate listen\n' +
        'wildlife deal ceramic scatter argue equip vampire together ruin reject literary rival distance aquatic agency teammate rebound false argue miracle stay again blessing peaceful unknown cover beard acid island language debris industry idle\n' +
        'wildlife deal ceramic snake agree voter main lecture axis kitchen physics arcade velvet spine idea scroll promise platform firm sharp patrol divorce ancestor fantasy forbid goat ajar believe swimming cowboy symbolic plastic spelling\n' +
        'wildlife deal decision shadow analysis adjust bulb skunk muscle mandate obesity total guitar coal gravity carve slim jacket ruin rebuild ancestor numerous hour mortgage require herd maiden public ceiling pecan pickup shadow club\n',
    );

    assert.ok(w.validateMnemonic());
    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qkchjws74hkuhamxk0qa280xc68643nu32pde20');
    assert.strictEqual(w._getExternalAddressByIndex(1), 'bc1qrslzpjwl7ksdxvealdq0qulgspey62vr3acwnp');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1qgx35amln8aryyr0lw6j2729l3gemzjftp5xrne');
    assert.strictEqual(w._getInternalAddressByIndex(1), 'bc1q48v0hcuz2jjsls628wj8jtn7rqp8wsyz2gxdxm');
  });

  // tests below are from https://github.com/spesmilo/electrum/pull/6917/files#diff-2940d8023ed102277f9c8b91135a9d6fa90fd2752b7b6147c1b5911f26db6d7fR497
  it('SLIP39LegacyP2PKHWallet can use passphrase', async () => {
    const w = new SLIP39LegacyP2PKHWallet();
    w.setSecret(
      'extra extend academic bishop cricket bundle tofu goat apart victim enlarge program behavior permit course armed jerky faint language modern\n' +
        'extra extend academic acne away best indicate impact square oasis prospect painting voting guest either argue username racism enemy eclipse\n' +
        'extra extend academic arcade born dive legal hush gross briefing talent drug much home firefly toxic analysis idea umbrella slice',
    );
    w.setPassphrase('TREZOR');

    assert.strictEqual(
      w.getXpub(),
      'xpub6CDgeTHt97zmW24XoYdjH9PVFMUj6qcYAe9SZXMKRKJbvTNeZhutNkQqajLyZrQ9DCqdnGenKhBD6UTrT1nHnoLCfFHkdeX8hDsZx1je6b2',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), '1NomKAUNnbASwbPuGHmkSVmnrJS5tZeVce');
    assert.strictEqual(w._getInternalAddressByIndex(0), '1Aw4wpXsAyEHSgMZqPdyewoAtJqH9Jaso3');
    assert.strictEqual(w._getExternalWIFByIndex(0), 'L55ZfXJgyXNPFrFtq2eqnwAkrjrarkKdmbkTEWxYXd2srXcfj3KF');
  });

  it('SLIP39SegwitP2SHWallet can use passphrase', async () => {
    const w = new SLIP39SegwitP2SHWallet();
    w.setSecret(
      'hobo romp academic axis august founder knife legal recover alien expect emphasis loan kitchen involve teacher capture rebuild trial numb spider forward ladle lying voter typical security quantity hawk legs idle leaves gasoline\n' +
        'hobo romp academic agency ancestor industry argue sister scene midst graduate profile numb paid headset airport daisy flame express scene usual welcome quick silent downtown oral critical step remove says rhythm venture aunt',
    );
    w.setPassphrase('TREZOR');

    assert.strictEqual(
      w.getXpub(),
      'ypub6Y6aCjkcjCP2y7jZStTevc8Tj3GjoXncqC4ReMzdVZWScB68vKZSZBZ88ENvuPUXXBBR58JXkuz1UrwLnCFvnFTUEpzu5yQabeYBRyd7Edf',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), '3GCgNoWWVqVdhBxWxrnWQHgwLtffGSYn7D');
    assert.strictEqual(w._getInternalAddressByIndex(0), '3FVvdRhR7racZhmcvrGAqX9eJoP8Sw3ypp');
  });

  it('SLIP39SegwitBech32Wallet can use passphrase', async () => {
    const w = new SLIP39SegwitBech32Wallet();
    w.setSecret(
      'eraser senior beard romp adorn nuclear spill corner cradle style ancient family general leader ambition exchange unusual garlic promise voice\n' +
        'eraser senior ceramic snake clay various huge numb argue hesitate auction category timber browser greatest hanger petition script leaf pickup\n' +
        'eraser senior ceramic shaft dynamic become junior wrist silver peasant force math alto coal amazing segment yelp velvet image paces\n' +
        'eraser senior ceramic round column hawk trust auction smug shame alive greatest sheriff living perfect corner chest sled fumes adequate',
    );
    w.setPassphrase('TREZOR');

    assert.strictEqual(
      w.getXpub(),
      'zpub6rs6bFckxdWVHBucVX129aNAYqiwPwh1HgsWt6HEQBa9F9QBKRcYzsw7WZR7rPSCWKmRVTUaEgrGrHStx2LSTpbgAEerbnrh4XxkRXbUUZF',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qaggygkqgqjjpt58zrmhvjz5m9dj8mjshw0lpgu');
    assert.strictEqual(w._getInternalAddressByIndex(0), 'bc1q8l6hcvlczu4mtjcnlwhczw7vdxnvwccpjl3cwz');
  });
});


================================================
FILE: ./tests/unit/hd-legacy-electrum-seed-p2pkh-wallet.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { HDLegacyElectrumSeedP2PKHWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('HDLegacyElectrumSeedP2PKHWallet', () => {
  it('wont accept BIP39 seed', () => {
    const hd = new HDLegacyElectrumSeedP2PKHWallet();
    hd.setSecret(
      'honey risk juice trip orient galaxy win situate shoot anchor bounce remind horse traffic exotic since escape mimic ramp skin judge owner topple erode',
    );
    assert.ok(!hd.validateMnemonic());
  });

  it('wont accept electrum seed, but SEGWIT seed', () => {
    const hd = new HDLegacyElectrumSeedP2PKHWallet();
    hd.setSecret('method goddess  humble  crumble output snake essay carpet monster barely trip betray ');
    assert.ok(!hd.validateMnemonic());
  });

  it('can import mnemonics and generate addresses and WIFs', async function () {
    const hd = new HDLegacyElectrumSeedP2PKHWallet();
    hd.setSecret('receive happy  wash prosper update    pet neck acid try profit proud hungry  ');
    assert.ok(hd.validateMnemonic());
    assert.strictEqual(
      hd.getXpub(),
      'xpub661MyMwAqRbcG6vx5SspHUzrhRtPKyeGp41JJLBi3kgeMCFkR6mzGkhEttBHTZg6FYYij52pqD2cW7XsutiZrRukXNLqeo87mZAV5k5bC22',
    );

    let address = hd._getExternalAddressByIndex(0);
    assert.strictEqual(address, '1Ca9ZVshGdKiiMEMNTG1bYqbifYMZMwV8');
    assert.ok(hd.getAllExternalAddresses().includes('1Ca9ZVshGdKiiMEMNTG1bYqbifYMZMwV8'));

    address = hd._getInternalAddressByIndex(0);
    assert.strictEqual(address, '1JygAvTQS9haAYgRfPSdHgmXd3syjB8Fnp');

    let wif = hd._getExternalWIFByIndex(0);
    assert.strictEqual(wif, 'KxGPz9dyib26p6bL2vQPvBPHBMA8iHVqEetg3x5XA4Rk1trZ11Kz');

    wif = hd._getInternalWIFByIndex(0);
    assert.strictEqual(wif, 'L52d26QmYGW8ctHo1omM5fZeJMgaonSkEWCGpnEekNvkVUoqTsNF');

    let u8a = hd._getPubkeyByAddress(hd._getExternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '02a6e6b674f82796cb4776673d824bf0673364fab24e62dcbfff4c1a5b69e3519b');
    u8a = hd._getPubkeyByAddress(hd._getInternalAddressByIndex(0));
    assert(u8a);
    assert.strictEqual(uint8ArrayToHex(u8a), '0344708260d2a832fd430285a0b915859d73e6ed4c6c6a9cb73e9069a9de56fb23');

    hd.setSecret('bs');
    assert.ok(!hd.validateMnemonic());
  });

  it('can use mnemonic with passphrase', () => {
    const mnemonic = 'receive happy  wash prosper update    pet neck acid try profit proud hungry  ';
    const passphrase = 'super secret passphrase';
    const hd = new HDLegacyElectrumSeedP2PKHWallet();
    hd.setSecret(mnemonic);
    hd.setPassphrase(passphrase);

    assert.strictEqual(
      hd.getXpub(),
      'xpub661MyMwAqRbcGSUBZaVtq8qEoRkJM1TZNNvUJEgQvtiZE73gS1wKWQoTj6R2E46UDYS2SBpmGGrSHGsJUNxtr1krixFuq8JA772pG43Mo6R',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), '13sPvsrgRN8XibZNHtZXNqVDJPnNZLjTap');
    assert.strictEqual(hd._getInternalAddressByIndex(0), '16oEuy5H7ejmapqc2AtKAYerdfkDkoyrDX');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'Ky9WTDUTTZUKKYSPEE6uah2y5sJa89z6177kD23xh5cq1znX2HDj');
  });
});


================================================
FILE: ./tests/unit/contact-list.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { ContactList } from '../../class/contact-list';

describe('ContactList', () => {
  it('isAddressValid()', () => {
    const cl = new ContactList();
    assert.ok(cl.isAddressValid('3BDsBDxDimYgNZzsqszNZobqQq3yeUoJf2'));
    assert.ok(cl.isAddressValid('bc1quuafy8htjjj263cvpj7md84magzmc8svmh8lrm'));
    assert.ok(cl.isAddressValid('BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7'));

    assert.ok(!cl.isAddressValid('sfhsdhsdf'));
  });

  it('isPaymentCodeValid()', async () => {
    const cl = new ContactList();

    assert.ok(!cl.isPaymentCodeValid('sfdgsfdghsfd'));
    assert.ok(
      cl.isPaymentCodeValid(
        'PM8TJS2JxQ5ztXUpBBRnpTbcUXbUHy2T1abfrb3KkAAtMEGNbey4oumH7Hc578WgQJhPjBxteQ5GHHToTYHE3A1w6p7tU6KSoFmWBVbFGjKPisZDbP97',
      ),
    );

    assert.ok(
      cl.isPaymentCodeValid(
        'sp1qqgste7k9hx0qftg6qmwlkqtwuy6cycyavzmzj85c6qdfhjdpdjtdgqjuexzk6murw56suy3e0rd2cgqvycxttddwsvgxe2usfpxumr70xc9pkqwv',
      ),
    );

    assert.ok(!cl.isPaymentCodeValid('sp1qq'));
  });
});


================================================
FILE: ./tests/unit/checksumWords.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import { validateMnemonic } from '../../malin_modules/bip39';
import { generateChecksumWords } from '../../malin_modules/checksumWords';

describe('generateChecksumWords', () => {
  it('generates 128 valid words for an 11 word input', () => {
    const input = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon';
    const result = generateChecksumWords(input) as string[];
    assert.ok(result);
    assert.strictEqual(result.length, 128);

    for (let i = 0; i < 128; i++) {
      assert.ok(validateMnemonic(input + ' ' + result[i]));
    }
  });

  it('generates 8 valid words for a 23 word input', () => {
    const input =
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon ' +
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon';
    const result = generateChecksumWords(input) as string[];
    assert.ok(result);
    assert.strictEqual(result.length, 8);

    for (let i = 0; i < 8; i++) {
      assert.ok(validateMnemonic(input + ' ' + result[i]));
    }
  });

  it('fails with an invalid partial phrase', () => {
    const result = generateChecksumWords('lorem ipsum dolor sit amet');
    assert.strictEqual(result, false);
  });

  it('fails with a completed phrase', () => {
    const result = generateChecksumWords('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');
    assert.strictEqual(result, false);
  });
});


================================================
FILE: ./tests/unit/lnurl.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import Lnurl from '../../class/lnurl';

describe('LNURL', function () {
  it('can findlnurl', () => {
    const base = 'lnurl1dp68gurn8ghj7mrww3uxymm59e3xjemnw4hzu7re0ghkcmn4wfkz7urp0ylh2um9wf5kg0fhxycnv9g9w58';
    assert.strictEqual(Lnurl.findlnurl(base), base);
    assert.strictEqual(Lnurl.findlnurl(base.toUpperCase()), base);
    assert.strictEqual(Lnurl.findlnurl('https://site.com/?lightning=' + base), base);
    assert.strictEqual(Lnurl.findlnurl('https://site.com/?lightning=' + base.toUpperCase()), base);
    assert.strictEqual(Lnurl.findlnurl('https://site.com/?nada=nada&lightning=' + base), base);
    assert.strictEqual(Lnurl.findlnurl('https://site.com/?nada=nada&lightning=' + base.toUpperCase()), base);
    assert.strictEqual(Lnurl.findlnurl('bs'), null);
    assert.strictEqual(Lnurl.findlnurl('https://site.com'), null);
    assert.strictEqual(Lnurl.findlnurl('https://site.com/?bs=' + base), null);
  });

  it('can getUrlFromLnurl()', () => {
    assert.strictEqual(
      Lnurl.getUrlFromLnurl('LNURL1DP68GURN8GHJ7MRWW3UXYMM59E3XJEMNW4HZU7RE0GHKCMN4WFKZ7URP0YLH2UM9WF5KG0FHXYCNV9G9W58'),
      'https://lntxbot.bigsun.xyz/lnurl/pay?userid=7116',
    );
    assert.strictEqual(
      Lnurl.getUrlFromLnurl(
        'https://lnbits.com/?lightning=LNURL1DP68GURN8GHJ7MRWVF5HGUEWVDHK6TMHD96XSERJV9MJ7CTSDYHHVVF0D3H82UNV9UM9JDENFPN5SMMK2359J5RKWVMKZ5ZVWAV4VJD63TM',
      ),
      'https://lnbits.com/withdraw/api/v1/lnurl/6Y73HgHovThYPvs7aPLwYV',
    );
    assert.strictEqual(Lnurl.getUrlFromLnurl('bs'), false);
  });

  it('can isLnurl()', () => {
    assert.ok(Lnurl.isLnurl('LNURL1DP68GURN8GHJ7MRWW3UXYMM59E3XJEMNW4HZU7RE0GHKCMN4WFKZ7URP0YLH2UM9WF5KG0FHXYCNV9G9W58'));
    assert.ok(
      Lnurl.isLnurl(
        'https://site.com/?lightning=LNURL1DP68GURN8GHJ7MRWW3UXYMM59E3XJEMNW4HZU7RE0GHKCMN4WFKZ7URP0YLH2UM9WF5KG0FHXYCNV9G9W58',
      ),
    );
    assert.ok(
      !Lnurl.isLnurl('https://site.com/?bs=LNURL1DP68GURN8GHJ7MRWW3UXYMM59E3XJEMNW4HZU7RE0GHKCMN4WFKZ7URP0YLH2UM9WF5KG0FHXYCNV9G9W58'),
    );
    assert.ok(!Lnurl.isLnurl('bs'));
  });

  it('can parseOnionUrl()', () => {
    const vectors = [
      {
        test: 'http://abc.onion/path',
        expected: ['http://abc.onion', '/path'],
      },
      {
        test: 'http://abc.onion:12345/path',
        expected: ['http://abc.onion:12345', '/path'],
      },
      {
        test: 'http://abc.onion/',
        expected: ['http://abc.onion', '/'],
      },
      {
        test: 'http://abc.onion',
        expected: ['http://abc.onion', undefined],
      },
      {
        test: 'https://abc.onion',
        expected: null,
      },
      {
        test: 'http://abc.com',
        expected: null,
      },
      {
        test: 'http://a@bc.onion',
        expected: null,
      },
      {
        test: 'http://a/bc.onion',
        expected: null,
      },
      {
        test: 'http://a:bc.onion',
        expected: null,
      },
    ];
    for (const { test, expected } of vectors) {
      assert.deepStrictEqual(Lnurl.parseOnionUrl(test), expected);
    }
  });

  it('can callLnurlPayService() and requestBolt11FromLnurlPayService()', async () => {
    const LN = new Lnurl('LNURL1DP68GURN8GHJ7MRWW3UXYMM59E3XJEMNW4HZU7RE0GHKCMN4WFKZ7URP0YLH2UM9WF5KG0FHXYCNV9G9W58');

    // poor-man's mock:
    LN._fetchGet = LN.fetchGet;
    LN.fetchGet = () => {
      return {
        status: 'OK',
        callback: 'https://lntxbot.bigsun.xyz/lnurl/pay/callback?userid=7116',
        tag: 'payRequest',
        maxSendable: 1000000000,
        minSendable: 1000,
        metadata: '[["text/plain","Fund @overtorment account on t.me/lntxbot."]]',
      };
    };
    const lnurlpayPayload = await LN.callLnurlPayService();
    assert.deepStrictEqual(lnurlpayPayload, {
      amount: 1,
      callback: 'https://lntxbot.bigsun.xyz/lnurl/pay/callback?userid=7116',
      commentAllowed: undefined,
      description: 'Fund @overtorment account on t.me/lntxbot.',
      domain: 'lntxbot.bigsun.xyz',
      fixed: false,
      image: undefined,
      max: 1000000,
      metadata: '[["text/plain","Fund @overtorment account on t.me/lntxbot."]]',
      min: 1,
    });

    // mock:
    LN.fetchGet = () => {
      return {
        status: 'OK',
        successAction: null,
        routes: [],
        pr: 'lnbc20n1p03s853pp58v9lrqahj2zyuzsdqqm3wnt2damlnkkuzwm8s7jkmnauhtkq4fjshp5z766racq95ncpk27nksev2ntu8wte77zd46g8uvzlnm5hhwukjrqcqzysxq9p5hsqrzjq29zewx4rezd04lpprpwsz5cesrfz30qtfkjqfw0249a3pn0uv5exzdefqqqxecqqqqqqqlgqqqq03sq9qsp52guktgy9u0xpky06n7slhjcvkassj0xpc3t9wadfsa0sl5x4fz9s9qy9qsqff5ycjg6xh3cc0vf8wxzxdajrdl9pka3nl3v37vcqj0qrdkzhsqxs8atfnxm2xenlkz7fpghlnuypux7hdp63zct3fr9px2e349kyqspu3gswx',
        disposable: false,
      };
    };
    const rez = await LN.requestBolt11FromLnurlPayService(2);
    assert.deepStrictEqual(rez, {
      status: 'OK',
      successAction: null,
      routes: [],
      pr: 'lnbc20n1p03s853pp58v9lrqahj2zyuzsdqqm3wnt2damlnkkuzwm8s7jkmnauhtkq4fjshp5z766racq95ncpk27nksev2ntu8wte77zd46g8uvzlnm5hhwukjrqcqzysxq9p5hsqrzjq29zewx4rezd04lpprpwsz5cesrfz30qtfkjqfw0249a3pn0uv5exzdefqqqxecqqqqqqqlgqqqq03sq9qsp52guktgy9u0xpky06n7slhjcvkassj0xpc3t9wadfsa0sl5x4fz9s9qy9qsqff5ycjg6xh3cc0vf8wxzxdajrdl9pka3nl3v37vcqj0qrdkzhsqxs8atfnxm2xenlkz7fpghlnuypux7hdp63zct3fr9px2e349kyqspu3gswx',
      disposable: false,
    });

    assert.strictEqual(LN.getSuccessAction(), null);
    assert.strictEqual(LN.getDomain(), 'lntxbot.bigsun.xyz');
    assert.strictEqual(LN.getDescription(), 'Fund @overtorment account on t.me/lntxbot.');
    assert.strictEqual(LN.getImage(), undefined);
    assert.strictEqual(LN.getLnurl(), 'LNURL1DP68GURN8GHJ7MRWW3UXYMM59E3XJEMNW4HZU7RE0GHKCMN4WFKZ7URP0YLH2UM9WF5KG0FHXYCNV9G9W58');
    assert.strictEqual(LN.getDisposable(), false);
    assert.strictEqual(LN.getCommentAllowed(), false);
  });

  it('can callLnurlPayService() and requestBolt11FromLnurlPayService() with comment', async () => {
    const LN = new Lnurl('lnurl1dp68gurn8ghj7cmgv96zucnvd9u8gampd3kx2apwvdhk6tmpwp5j7um9dejz6ar90p6q3eqkzd');

    // poor-man's mock:
    LN._fetchGet = LN.fetchGet;
    LN.fetchGet = () => {
      return {
        status: 'OK',
        callback: 'https://lntxbot.bigsun.xyz/lnurl/pay/callback?userid=7116',
        tag: 'payRequest',
        maxSendable: 1000000000,
        minSendable: 1000,
        metadata: '[["text/plain","Comment on lnurl-pay chat "]]',
        commentAllowed: 144,
      };
    };
    const lnurlpayPayload = await LN.callLnurlPayService();
    assert.deepStrictEqual(lnurlpayPayload, {
      amount: 1,
      callback: 'https://lntxbot.bigsun.xyz/lnurl/pay/callback?userid=7116',
      commentAllowed: 144,
      description: 'Comment on lnurl-pay chat ',
      domain: 'lntxbot.bigsun.xyz',
      fixed: false,
      image: undefined,
      max: 1000000,
      metadata: '[["text/plain","Comment on lnurl-pay chat "]]',
      min: 1,
    });

    assert.strictEqual(LN.getDomain(), 'lntxbot.bigsun.xyz');
    assert.strictEqual(LN.getDescription(), 'Comment on lnurl-pay chat ');
    assert.strictEqual(LN.getImage(), undefined);
    assert.strictEqual(LN.getLnurl(), 'lnurl1dp68gurn8ghj7cmgv96zucnvd9u8gampd3kx2apwvdhk6tmpwp5j7um9dejz6ar90p6q3eqkzd');
    assert.strictEqual(LN.getCommentAllowed(), 144);
    assert.strictEqual(LN.getAmount(), LN.getMin());
    assert.strictEqual(LN.getMin(), 1);
    assert.strictEqual(LN.getMax(), 1000000);

    // mock only to get fetched url:
    let urlUsed = '';
    LN.fetchGet = urlToFetch => {
      urlUsed = urlToFetch;
      return {
        disposable: true,
        pr: 'lnbc100n1psj8g53pp50t7xmnvnzsm6y78kcvqqudlnnushc04sevtneessp463ndpf83qshp5nh0t5w4w5zh8jdnn5a03hk4pk279l3eex4nzazgkwmqpn7wga6hqcqzpgxqr23ssp5ddpxstde98ekccnvzms67h9uflxmpj939aj4rwc5xwru0x6nfkus9qyyssq55n5hn9gwmrzx2ekajlqshvu53u8h3p0npu7ng4d0lnttgueprzr4mtpwa83jrpz4skhdx3p0xnh9jc92ysnu8umuwa70hkxhp44svsq9u5uqr',
        successAction: null,
      };
    };

    try {
      await LN.requestBolt11FromLnurlPayService(10, 'hola pendejo!');
    } finally {
      assert.ok(urlUsed.includes('&comment=hola%20pendejo!'));
    }
  });

  it('can decipher AES', () => {
    const ciphertext = 'vCWn4TMhIKubUc5+aBVfvw==';
    const iv = 'eTGduB45hWTOxHj1dR+LJw==';
    const preimage = 'bf62911aa53c017c27ba34391f694bc8bf8aaf59b4ebfd9020e66ac0412e189b';

    assert.strictEqual(Lnurl.decipherAES(ciphertext, preimage, iv), '1234');
  });
});

describe('lightning address', function () {
  it('can getUrlFromLnurl()', () => {
    assert.strictEqual(Lnurl.getUrlFromLnurl('lnaddress@zbd.gg'), 'https://zbd.gg/.well-known/lnurlp/lnaddress');
    assert.strictEqual(Lnurl.getUrlFromLnurl('lnaddress@hidden.onion'), 'http://hidden.onion/.well-known/lnurlp/lnaddress');
  });

  it('can detect', async () => {
    assert.ok(Lnurl.isLightningAddress('lnaddress@zbd.gg'));
    assert.ok(Lnurl.isLightningAddress('avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion'));
    assert.ok(Lnurl.isLightningAddress(' lnaddress@zbd.gg '));
    assert.ok(Lnurl.isLightningAddress(' lnaddress@zbd.gg '));
    assert.ok(Lnurl.isLightningAddress(' lnaddress@8.8.8.8 '));
    assert.ok(Lnurl.isLightningAddress(' lnaddress@hidden.onion '));
    assert.ok(!Lnurl.isLightningAddress(' bla bla '));
    assert.ok(!Lnurl.isLightningAddress(''));
    assert.ok(!Lnurl.isLightningAddress('@'));
    assert.ok(!Lnurl.isLightningAddress('@a'));
    assert.ok(!Lnurl.isLightningAddress('a@'));
  });

  it('can authenticate', async () => {
    const LN = new Lnurl(
      'LNURL1DP68GURN8GHJ7MRFVA58GMNFDENKCMM8D9HZUMRFWEJJ7MR0VA5KU0MTXY7NYVFEX93X2DFK8P3KVEFKVSEXZWR98PSNJVRRV5CRGCE3X4JKGE3HXPNXGCMPV5MXXVTZ89NXZENXXCURGCTRV93RVE35XQCXVCFSVSN8GCT884KX7EMFDCDKKXQ0',
    );

    // poor-man's mock:
    LN._fetchGet = LN.fetchGet;
    let requestedUri = -1;
    LN.fetchGet = actuallyRequestedUri => {
      requestedUri = actuallyRequestedUri;
      return {
        status: 'OK',
      };
    };

    await assert.doesNotReject(LN.authenticate('lndhub://dc56b8cf8ef3b60060cf:94eac57510de2738451d'));
    assert.strictEqual(
      requestedUri,
      'https://lightninglogin.live/login?k1=2191be568cfe6d2a8e8a90ce04c15edf70fdcae6c1b9faff684acab6f400fa0d&tag=login&sig=304502210093ab4ead8dd619f2ddb3d52bd4bb01725badcb2a3daa3870fb41a38096f9a37d0220464a32e94e13dcec20ea94b94df0fa52f45cd88b01d7247042136ad0c71752d2&key=03e7b61e57efff1925ab9082625400cae2c8ad88a984e7aa4987abb77818570018',
    );
  });

  it('returns the server error response as the reject error from lnurl-auth', async () => {
    const LN = new Lnurl(
      'LNURL1DP68GURN8GHJ7MRFVA58GMNFDENKCMM8D9HZUMRFWEJJ7MR0VA5KU0MTXY7NYVFEX93X2DFK8P3KVEFKVSEXZWR98PSNJVRRV5CRGCE3X4JKGE3HXPNXGCMPV5MXXVTZ89NXZENXXCURGCTRV93RVE35XQCXVCFSVSN8GCT884KX7EMFDCDKKXQ0',
    );

    // poor-man's mock:
    LN._fetchGet = LN.fetchGet;
    LN.fetchGet = () => {
      return {
        reason: 'Invalid signature',
        status: 'ERROR',
      };
    };

    await assert.rejects(LN.authenticate('lndhub://dc56b8cf8ef3b60060cf:94eac57510de2738451d'), err => {
      assert.strictEqual(err, 'Invalid signature');
      return true;
    });
  });

  it('works', async () => {
    const LN = new Lnurl('lnaddress@zbd.gg');

    // poor-man's mock:
    LN._fetchGet = LN.fetchGet;
    let requestedUri = -1;
    LN.fetchGet = actuallyRequestedUri => {
      requestedUri = actuallyRequestedUri;
      return {
        minSendable: 1000,
        maxSendable: 45000000,
        commentAllowed: 150,
        tag: 'payRequest',
        metadata: '[["text/plain","lnaddress - lightningaddress.com"],["text/identifier","lnaddress@zbd.gg"],["image/png;base64","img"]]',
        callback: 'https://api.zebedee.io/v0/process-static-charges/9a44621d-0665-44eb-96af-e06534311be5',
      };
    };

    const lnurlpayPayload = await LN.callLnurlPayService();
    assert.deepStrictEqual(lnurlpayPayload, {
      amount: 1,
      callback: 'https://api.zebedee.io/v0/process-static-charges/9a44621d-0665-44eb-96af-e06534311be5',
      commentAllowed: 150,
      description: 'lnaddress - lightningaddress.com',
      domain: 'api.zebedee.io',
      fixed: false,
      image: 'data:image/png;base64,img',
      max: 45000,
      metadata: '[["text/plain","lnaddress - lightningaddress.com"],["text/identifier","lnaddress@zbd.gg"],["image/png;base64","img"]]',
      min: 1,
    });

    assert.strictEqual(requestedUri, 'https://zbd.gg/.well-known/lnurlp/lnaddress');
  });

  it('works with onion', async () => {
    assert.ok(Lnurl.isLightningAddress('avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion'));

    const LN = new Lnurl('avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion');

    // poor-man's mock:
    LN._fetchGet = LN.fetchGet;
    let requestedUri = -1;
    LN.fetchGet = actuallyRequestedUri => {
      requestedUri = actuallyRequestedUri;
      return {
        status: 'OK',
        callback: 'http://st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion/.well-known/lnurlp/avatar',
        tag: 'payRequest',
        maxSendable: 100000000,
        minSendable: 1000,
        metadata:
          '[["text/identifier", "avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion"], ["text/plain", "Sats for avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion"]]',
        commentAllowed: 0,
      };
    };

    const lnurlpayPayload = await LN.callLnurlPayService();
    assert.deepStrictEqual(lnurlpayPayload, {
      amount: 1,
      callback: 'http://st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion/.well-known/lnurlp/avatar',
      commentAllowed: 0,
      description: 'Sats for avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion',
      domain: 'st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion',
      fixed: false,
      image: undefined,
      max: 100000,
      metadata:
        '[["text/identifier", "avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion"], ["text/plain", "Sats for avatar@st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion"]]',
      min: 1,
    });

    assert.strictEqual(requestedUri, 'http://st5owtpsa2e62yf64luxogbecj7lk3t5vmesshsnrzu2untyf2i4t4ad.onion/.well-known/lnurlp/avatar');
  });
});


================================================
FILE: ./tests/unit/bip38.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import bip38 from 'bip38';
import wif from 'wif';

jest.setTimeout(180 * 1000);

it('bip38 decodes', async () => {
  const encryptedKey = '6PRVWUbkzq2VVjRuv58jpwVjTeN46MeNmzUHqUjQptBJUHGcBakduhrUNc';
  const decryptedKey = await bip38.decryptAsync(
    encryptedKey,
    'TestingOneTwoThree',
    () => {},
    { N: 1, r: 8, p: 8 }, // using non-default parameters to speed it up (not-bip38 compliant)
  );

  assert.strictEqual(
    wif.encode(0x80, decryptedKey.privateKey, decryptedKey.compressed),
    '5KN7MzqK5wt2TP1fQCYyHBtDrXdJuXbUzm4A9rKAteGu3Qi5CVR',
  );
});

// too slow, even on CI. unskip and manually run it if you need it
// eslint-disable-next-line jest/no-disabled-tests
it.skip('bip38 decodes slow', async () => {
  if (!(process.env.CI || process.env.TRAVIS)) {
    // run only on CI
    return;
  }

  const encryptedKey = '6PnU5voARjBBykwSddwCdcn6Eu9EcsK24Gs5zWxbJbPZYW7eiYQP8XgKbN';
  let callbackWasCalled = false;
  const decryptedKey = await bip38.decryptAsync(encryptedKey, 'qwerty', () => {
    // callbacks make sense only with pure js scrypt implementation (nodejs and browsers).
    // on RN scrypt is handled by native module and takes ~4 secs
    callbackWasCalled = true;
  });

  assert.ok(callbackWasCalled);

  assert.strictEqual(
    wif.encode(0x80, decryptedKey.privateKey, decryptedKey.compressed),
    'KxqRtpd9vFju297ACPKHrGkgXuberTveZPXbRDiQ3MXZycSQYtjc',
  );

  await assert.rejects(async () => await bip38.decryptAsync(encryptedKey, 'a'), {
    message: 'Incorrect passphrase.',
  });
});


================================================
FILE: ./tests/unit/ecc.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import { ECPairFactory } from 'ecpair';

import ecc from '../../malin_modules/noble_ecc';

const h = (hex: string) => Buffer.from(hex, 'hex');

describe('ecc', () => {
  it('ECPair accepts noble', () => {
    const ECPair = ECPairFactory(ecc);
    assert.ok(ECPair);
  });

  it('works (basic)', () => {
    assert.ok(ecc.isPoint(Buffer.from('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', 'hex')));
    assert.ok(
      !ecc.isPoint(
        Buffer.from(
          '0100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001',
          'hex',
        ),
      ),
    );
    assert.ok(!ecc.isPoint(Buffer.from('00', 'hex')));

    /*

    muted because of that:

    ```
        if (!isWithinCurveOrder(num))
        throw new Error('Expected private key: 0 < key < n');
    ````

    in `node_modules/@noble/secp256k1/lib/index.js`
    (this test runs in runtime in some versions if `ECPairFactory`)


    const rez = ecc.privateAdd(
      h('0000000000000000000000000000000000000000000000000000000000000001'),
      h('0000000000000000000000000000000000000000000000000000000000000000'),
    );


    assert.strictEqual(
      Buffer.from(rez).toString('hex'),
      h('0000000000000000000000000000000000000000000000000000000000000001').toString('hex'),
    );
*/

    const rez2 = ecc.privateAdd(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
      h('0000000000000000000000000000000000000000000000000000000000000003'),
    );
    assert.strictEqual(rez2, null);

    assert.ok(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
  });
});


================================================
FILE: ./tests/unit/watch-only-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import { Psbt } from 'bitcoinjs-lib';

import { MalinURDecoder, clearUseURv1, decodeUR, encodeUR, extractSingleWorkload, setUseURv1 } from '../../malin_modules/ur';
import { WatchOnlyWallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('Watch only wallet', () => {
  it('can validate address', async () => {
    const w = new WatchOnlyWallet();
    for (const secret of [
      'bc1quhnve8q4tk3unhmjts7ymxv8cd6w9xv8wy29uv',
      '12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG',
      '3BDsBDxDimYgNZzsqszNZobqQq3yeUoJf2',
      'BC1QUHNVE8Q4TK3UNHMJTS7YMXV8CD6W9XV8WY29UV',
    ]) {
      w.setSecret(secret);
      assert.ok(w.valid());
      assert.deepStrictEqual(
        w.getAllExternalAddresses().map(elem => elem.toUpperCase()),
        [secret.toUpperCase()],
      );
      assert.strictEqual(w.isHd(), false);
      assert.ok(!w.useWithHardwareWalletEnabled());
    }

    w.setSecret('not valid');
    assert.ok(!w.valid());

    for (const secret of [
      'xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6DXDs4PJDk5QVL2G2xaVjv7SM4roWHr1gR4xB3Z7Ps',
      'ypub6XRzrn3HB1tjhhvrHbk1vnXCecZEdXohGzCk3GXwwbDoJ3VBzZ34jNGWbC6WrS7idXrYjjXEzcPDX5VqnHEnuNf5VAXgLfSaytMkJ2rwVqy',
      'zpub6r7jhKKm7BAVx3b3nSnuadY1WnshZYkhK8gKFoRLwK9rF3Mzv28BrGcCGA3ugGtawi1WLb2vyjQAX9ZTDGU5gNk2bLdTc3iEXr6tzR1ipNP',
    ]) {
      w.setSecret(secret);
      assert.ok(w.valid());
      assert.strictEqual(w.isHd(), true);
      assert.strictEqual(w.getMasterFingerprint(), 0);
      assert.strictEqual(w.getMasterFingerprintHex(), '00000000');
      assert.ok(w.isXpubValid(), w.secret);
      assert.ok(!w.useWithHardwareWalletEnabled());
    }
  });

  it('can validate xpub', () => {
    const w = new WatchOnlyWallet();
    w.setSecret('xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6DXDs4PJDk5QVL2G2xaVjv7SM4roWHr1gR4xB3Z7Ps');
    assert.ok(w.isXpubValid());
    assert.ok(w.valid());
    w.setSecret('ypub6XRzrn3HB1tjhhvrHbk1vnXCecZEdXohGzCk3GXwwbDoJ3VBzZ34jNGWbC6WrS7idXrYjjXEzcPDX5VqnHEnuNf5VAXgLfSaytMkJ2rwVqy');
    assert.ok(w.isXpubValid());
    assert.ok(w.valid());
    w.setSecret('zpub6r7jhKKm7BAVx3b3nSnuadY1WnshZYkhK8gKFoRLwK9rF3Mzv28BrGcCGA3ugGtawi1WLb2vyjQAX9ZTDGU5gNk2bLdTc3iEXr6tzR1ipNP');
    assert.ok(w.isXpubValid());
    assert.ok(w.valid());
    w.setSecret('xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6D');
    assert.ok(!w.isXpubValid());
    assert.ok(!w.valid());
    w.setSecret('ypub6XRzrn3HB1tjhhvrHbk1vnXCecZEdXohGzCk3GXwwbDoJ3VBzZ34jNGWbC6WrS7idXr');
    assert.ok(!w.isXpubValid());
    assert.ok(!w.valid());
    w.setSecret('ypub6XRzrn3HB1tjhhvrHbk1vnXCecZEdXohGzCk3GXwwbDoJ3VBzZ34jNGWbC6WrS7idXr');
    assert.ok(!w.isXpubValid());
    assert.ok(!w.valid());
  });

  it('can create PSBT base64 without signature for HW wallet xpub', async () => {
    for (const cleanupInternals of [false, true]) {
      const w = new WatchOnlyWallet();
      w.setSecret('xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6DXDs4PJDk5QVL2G2xaVjv7SM4roWHr1gR4xB3Z7Ps');
      w.init();
      const changeAddress = '1KZjqYHm7a1DjhjcdcjfQvYfF2h6PqatjX';
      // hardcoding so we wont have to call w.getChangeAddressAsync()
      const utxos = [
        {
          height: 530926,
          value: 1000,
          address: '12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG',
          txid: 'd0432027a86119c63a0be8fa453275c2333b59067f1e559389cd3e0e377c8b96',
          vout: 1,
          txhex:
            '0100000001b630ac364a04b83548994ded4705b98316b2d1fe18b9fffa2627be9eef11bf60000000006b48304502210096e68d94d374e3a688ed2e6605289f81172540abaab5f6cc431c231919860746022075ee4e64c867ed9d369d01a9b35d8b1689a821be8d729fff7fb3dfcc75d16f6401210281d2e40ba6422fc97b61fd5643bee83dd749d8369339edc795d7b3f00e96c681fdffffff02ef020000000000001976a914e4271ef9e9a03a89b981c73d3d6936d2f6fccc0688ace8030000000000001976a914120ad7854152901ebeb269acb6cef20e71b3cf5988acea190800',
        },
      ];
      // hardcoding utxo so we wont have to call w.fetchUtxo() and w.getUtxo()

      const { psbt } = await w.createTransaction(utxos, [{ address: '1QDCFcpnrZ4yrAQxmbvSgeUC9iZZ8ehcR5' }], 1, changeAddress);

      if (cleanupInternals) {
        // these might be purged when preparing for serialization before saving to disk
        w._hdWalletInstance._node0 = undefined;
        w._hdWalletInstance._node1 = undefined;
      }

      assert.strictEqual(
        psbt.toBase64(),
        'cHNidP8BAFUCAAAAAZaLfDcOPs2Jk1UefwZZOzPCdTJF+ugLOsYZYagnIEPQAQAAAAAAAACAASgDAAAAAAAAGXapFP6ZRvxlaU5S/9HQFr1i2lsgp58AiKwAAAAAAAEA4gEAAAABtjCsNkoEuDVImU3tRwW5gxay0f4Yuf/6Jie+nu8Rv2AAAAAAa0gwRQIhAJbmjZTTdOOmiO0uZgUon4EXJUCrqrX2zEMcIxkZhgdGAiB17k5kyGftnTadAamzXYsWiaghvo1yn/9/s9/MddFvZAEhAoHS5AumQi/Je2H9VkO+6D3XSdg2kzntx5XXs/AOlsaB/f///wLvAgAAAAAAABl2qRTkJx756aA6ibmBxz09aTbS9vzMBois6AMAAAAAAAAZdqkUEgrXhUFSkB6+smmsts7yDnGzz1mIrOoZCAAiBgPGm5BfckKzaIEi8GlRM5oe4A2mUvbsxlJ+pmMhRsrOYhgAAAAALAAAgAAAAIAAAACAAAAAAAAAAAAAAA==',
      );
    }
  });

  it('can create PSBT base64 without signature for HW wallet ypub', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('ypub6XRzrn3HB1tjhhvrHbk1vnXCecZEdXohGzCk3GXwwbDoJ3VBzZ34jNGWbC6WrS7idXrYjjXEzcPDX5VqnHEnuNf5VAXgLfSaytMkJ2rwVqy');
    w.init();
    const changeAddress = '333R1N8zst8bK7xMtqBndmwcd288qxEBmr';
    // hardcoding so we wont have to call w.getChangeAddressAsync()
    const utxos = [
      {
        height: 566299,
        value: 250000,
        address: '37EX3KrmopubWPLB8Y8NR36wXs7icu2kjQ',
        txid: '786f05d0c531c4bb399ab8cf406b2f118504280bd015e26e4ff9539f8201d4f4',
        vout: 0,
      },
    ];
    // hardcoding utxo so we wont have to call w.fetchUtxo() and w.getUtxo()

    const { psbt } = await w.createTransaction(utxos, [{ address: '398qz3BtNG8DABpEGa2VkHBcficxkgeKvX' }], 1, changeAddress);

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAFMCAAAAAfTUAYKfU/lPbuIV0AsoBIURL2tAz7iaObvEMcXQBW94AAAAAAAAAACAAQnQAwAAAAAAF6kUUatl8TFvnlvB8H/KsqbnR6kpUluHAAAAAAABASCQ0AMAAAAAABepFDzN1E7LDjAMNARzCHsU4rXqBf55hwEEFgAUG3vPJhyWYtt/ikPpOCW6jCqkmxsiBgLHMhb0QhE8eyJBnE9syGAtMehGmHe1sxpm+TlxjgFXERgAAAAAMQAAgAAAAIAAAACAAAAAAAAAAAAAAA==',
    );
  });

  it('can create PSBT base64 without signature for HW wallet zpub', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('zpub6rjLjQVqVnj7crz9E4QWj4WgczmEseJq22u2B6k2HZr6NE2PQx3ZYg8BnbjN9kCfHymSeMd2EpwpM5iiz5Nrb3TzvddxW2RMcE3VXdVaXHk');
    // zpub provided by Stepan @ CryptoAdvance
    w.init();
    const changeAddress = 'bc1quuafy8htjjj263cvpj7md84magzmc8svmh8lrm';
    // hardcoding so we wont have to call w.getChangeAddressAsync()
    const utxos = [
      {
        height: 596736,
        value: 20000,
        address: 'bc1qhu8jqyzfazgatpctqn44xr7pdd3mdx6qy2r6xa',
        txid: '7f3b9e032a84413d7a5027b0d020f8acf80ad28f68b5bce8fa8ac357248c5b80',
        vout: 0,
      },
    ];
    // hardcoding utxo so we wont have to call w.fetchUtxo() and w.getUtxo()

    const { psbt } = w.createTransaction(utxos, [{ address: 'bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu', value: 5000 }], 1, changeAddress);

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHECAAAAAYBbjCRXw4r66Ly1aI/SCvis+CDQsCdQej1BhCoDnjt/AAAAAAAAAACAAogTAAAAAAAAFgAUwM681sPTyox13F7GLr5VMw75EOIGOgAAAAAAABYAFOc6kh7rlKStRwwMvbaeu+oFvB4MAAAAAAABAR8gTgAAAAAAABYAFL8PIBBJ6JHVhwsE61MPwWtjtptAIgYDWOHbOE3D4KiuoR7kHtmTtFZ7KXQB+8zb51QALLJxTx8YAAAAAFQAAIAAAACAAAAAgAAAAAAAAAAAAAAiAgM005BVD8MgH5kiSGnwXSfzaxLeDSl3y17Vhrx3F/9XxBgAAAAAVAAAgAAAAIAAAACAAQAAAAAAAAAA',
    );
  });

  it('can import coldcard/electrum compatible JSON skeleton wallet, and create a tx with master fingerprint', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(require('fs').readFileSync('./tests/unit/fixtures/skeleton-coldcard.txt', 'ascii'));
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx',
    );
    assert.strictEqual(w.getMasterFingerprint(), 64392470);
    assert.strictEqual(w.getMasterFingerprintHex(), '168dd603');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
    assert.ok(w.useWithHardwareWalletEnabled());

    const utxos = [
      {
        height: 618811,
        value: 66600,
        address: 'bc1qzqjwye4musmz56cg44ttnchj49zueh9yr0qsxt',
        vout: 0,
        txid: '5df595dc09ee7a5c245b34ea519288137ffee731629c4ff322a6de4f72c06222',
        wif: false,
        confirmations: 1,
      },
    ];

    const { psbt } = await w.createTransaction(
      utxos,
      [{ address: 'bc1qdamevhw3zwm0ajsmyh39x8ygf0jr0syadmzepn', value: 5000 }],
      22,
      'bc1qtutssamysdkgd87df0afjct0mztx56qpze7wqe',
    );
    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHECAAAAASJiwHJP3qYi80+cYjHn/n8TiJJR6jRbJFx67gnclfVdAAAAAAAAAACAAogTAAAAAAAAFgAUb3eWXdETtv7KGyXiUxyIS+Q3wJ0U5AAAAAAAABYAFF8XCHdkg2yGn81L+plhb9iWamgBAAAAAAABAR8oBAEAAAAAABYAFBAk4ma75DYqawitVrni8qlFzNykIgYDNK9TxoCjQ8P0+qI2Hu4hrnXnJuYAC3h2puZbgRORp+sYFo3WA1QAAIAAAACAAAAAgAAAAAAAAAAAAAAiAgL1DWeV+AfIP5RRB5zHv5vuXsIt8+rF9rrsji3FhQlhzBgWjdYDVAAAgAAAAIAAAACAAQAAAAAAAAAA',
    );
  });

  it('can import coldcard json', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(
      '{"seed_version": 17, "use_encryption": false, "wallet_type": "standard", "keystore": {"type": "hardware", "hw_type": "coldcard", "label": "Coldcard Import 96749544", "ckcc_xfp": 1150645398, "ckcc_xpub": "xpub661MyMwAqRbcGR5LnL22SYYJesG8PAm4wkT5dcJ76U8RT72NNZjaLQFHvaLe88pp45DcdfDSQ1hVzfJ371VHzYGNgVroS9N6Y31C6uGQ9St", "derivation": "m/84h/0h/0h", "xpub": "zpub6rCuTB3jGcJZkGjP7LNwGxg24yBSbi1gCr33DJkrxSsPTwMgYFE8khr8GWEC3bGKA2kG6GTU9WEkLAaYnFFQvn6y3w8MZJZua5GkcbA8nrd"}}',
    );
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rCuTB3jGcJZkGjP7LNwGxg24yBSbi1gCr33DJkrxSsPTwMgYFE8khr8GWEC3bGKA2kG6GTU9WEkLAaYnFFQvn6y3w8MZJZua5GkcbA8nrd',
    );
    assert.strictEqual(w.getMasterFingerprint(), 1150645398);
    assert.strictEqual(w.getMasterFingerprintHex(), '96749544');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
    assert.ok(w.useWithHardwareWalletEnabled());
  });

  it('can import Electrum compatible backup wallet, and create a tx with master fingerprint', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(require('fs').readFileSync('./tests/unit/fixtures/skeleton-electrum.txt', 'ascii'));
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx',
    );
    assert.strictEqual(w.getMasterFingerprint(), 64392470);
    assert.strictEqual(w.getMasterFingerprintHex(), '168dd603');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/1'");
    assert.ok(w.useWithHardwareWalletEnabled());

    const utxos = [
      {
        height: 618811,
        value: 66600,
        address: 'bc1qzqjwye4musmz56cg44ttnchj49zueh9yr0qsxt',
        vout: 0,
        txid: '5df595dc09ee7a5c245b34ea519288137ffee731629c4ff322a6de4f72c06222',
        wif: false,
        confirmations: 1,
      },
    ];

    const { psbt } = await w.createTransaction(
      utxos,
      [{ address: 'bc1qdamevhw3zwm0ajsmyh39x8ygf0jr0syadmzepn', value: 5000 }],
      22,
      'bc1qtutssamysdkgd87df0afjct0mztx56qpze7wqe',
    );
    assert.strictEqual(psbt.data.inputs[0].bip32Derivation[0].path, "m/84'/0'/1'/0/0");
    assert.strictEqual(psbt.data.outputs[1].bip32Derivation[0].path, "m/84'/0'/1'/1/0");
    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAHECAAAAASJiwHJP3qYi80+cYjHn/n8TiJJR6jRbJFx67gnclfVdAAAAAAAAAACAAogTAAAAAAAAFgAUb3eWXdETtv7KGyXiUxyIS+Q3wJ0U5AAAAAAAABYAFF8XCHdkg2yGn81L+plhb9iWamgBAAAAAAABAR8oBAEAAAAAABYAFBAk4ma75DYqawitVrni8qlFzNykIgYDNK9TxoCjQ8P0+qI2Hu4hrnXnJuYAC3h2puZbgRORp+sYFo3WA1QAAIAAAACAAQAAgAAAAAAAAAAAAAAiAgL1DWeV+AfIP5RRB5zHv5vuXsIt8+rF9rrsji3FhQlhzBgWjdYDVAAAgAAAAIABAACAAQAAAAAAAAAA',
    );
  });

  it('can import Electrum compatible backup wallet, and create a tx with master fingerprint hex', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(require('fs').readFileSync('./tests/unit/fixtures/skeleton-electrum-hex-only.txt', 'ascii'));
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx',
    );
    assert.strictEqual(w.getMasterFingerprint(), 1455298230);
    assert.strictEqual(w.getMasterFingerprintHex(), 'b616be56');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
    assert.ok(w.useWithHardwareWalletEnabled());
  });

  it('can import Electrum compatible backup wallet, and create a tx with master fingerprint hex with a length of 7', async () => {
    const w = new WatchOnlyWallet();
    let str = require('fs').readFileSync('./tests/unit/fixtures/skeleton-electrum-hex-only.txt', 'ascii');
    str = str.replace('b616be56', '616be56');
    // console.log(str)
    w.setSecret(str);
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx',
    );
    assert.strictEqual(w.getMasterFingerprint(), 1455298054);
    assert.strictEqual(w.getMasterFingerprintHex(), '0616be56');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
    assert.ok(w.useWithHardwareWalletEnabled());
  });

  it('will fail to import Electrum compatible backup wallet when fingerprint hex is less than 7', async () => {
    const w = new WatchOnlyWallet();
    let str = require('fs').readFileSync('./tests/unit/fixtures/skeleton-electrum-hex-only.txt', 'ascii');
    str = str.replace('b616be56', '16be56');
    w.setSecret(str);
    w.init();
    assert.throws(w.valid, 'invalid fingerprint hex');
  });

  it('will fail to import Electrum compatible backup wallet when fingerprint is an invalid hex value', async () => {
    const w = new WatchOnlyWallet();
    let str = require('fs').readFileSync('./tests/unit/fixtures/skeleton-electrum-hex-only.txt', 'ascii');
    str = str.replace('b616be56', 'j16be56');
    w.setSecret(str);
    w.init();
    assert.throws(w.valid, 'invalid fingerprint hex');
  });

  it('can import cobo vault JSON skeleton wallet', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(require('fs').readFileSync('./tests/unit/fixtures/skeleton-cobo.txt', 'ascii'));
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rcabYFcdr41zyUNRWRyHYs2Sm86E5XV8RjjRzTFYsiCngteeZnkwaF2xuhjmM6kpHjuNpFW42BMhzPmFwXt48e1FhddMB7xidZzN4SF24K',
    );
    assert.strictEqual(w.getMasterFingerprint(), 1908437330);
    assert.strictEqual(w.getMasterFingerprintHex(), '5271c071');
    assert.strictEqual(w.getLabel(), 'Wallet');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
    assert.ok(w.useWithHardwareWalletEnabled());
  });

  it('can import taproot BIP86 from keystone with zpub instead of xpub', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(
      JSON.stringify({
        ExtPubKey: 'zpub6rxQT4vrGrdLmFicJZnLxx1odj1C8xNtHW5pW84hMSXdtoFnCbqBFJm3bF5PrwYL5ScxFhdzRuv3pb9beyoraQLMuQWkV9faGuxstBPgLw4',
        MasterFingerprint: 'B68AF6E4',
        AccountKeyPath: "m/86'/0'/0'",
      }),
    );
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6rxQT4vrGrdLmFicJZnLxx1odj1C8xNtHW5pW84hMSXdtoFnCbqBFJm3bF5PrwYL5ScxFhdzRuv3pb9beyoraQLMuQWkV9faGuxstBPgLw4',
    );
    assert.strictEqual(w.getMasterFingerprintHex(), 'B68AF6E4'.toLowerCase());
    assert.strictEqual(w.getLabel(), 'Wallet');
    assert.strictEqual(w.getDerivationPath(), "m/86'/0'/0'");
    assert.ok(w._getExternalAddressByIndex(0).startsWith('bc1p'), `not taproot address generated: ${w._getExternalAddressByIndex(0)}`);
    assert.ok(w.allowMasterFingerprint());
    // assert.ok(w.useWithHardwareWalletEnabled());
  });

  it('can import zpub with master fingerprint and derivation path', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(require('fs').readFileSync('./tests/unit/fixtures/skeleton-walletdescriptor.txt', 'ascii'));
    w.init();
    assert.ok(w.valid());
    assert.strictEqual(
      w.getSecret(),
      'zpub6s2RJ9qAEBW8Abhojs6LyDzF7gttcDr6EsR3Umu2aptZBb45e734rGtt4KqsCMmNyR1EEzUU2ugdVYez2VywQvAbBjUSKn8ho4Zk2c5otkk',
    );
    assert.strictEqual(w.getMasterFingerprint(), 4167290508);
    assert.strictEqual(w.getMasterFingerprintHex(), '8cce63f8');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
    assert.ok(!w.useWithHardwareWalletEnabled());
  });

  it('can import wallet descriptor for BIP84, but with xpub instead of zpub', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(
      '[dafedf1c/84h/0h/0h]xpub6DFMZMLizqqnyyHoWTG7qzmCR1irpiDEGT4JQX7ubeoFtV838ABKPfgAPQbM1TEekEyCuJF1BrmnA7JPrnzqi2VbycD3tVE3v5xsDQqYA3A',
    );
    w.init();
    assert.ok(w.valid());

    assert.strictEqual(w.getMasterFingerprintHex(), 'dafedf1c');
    assert.strictEqual(w.getMasterFingerprint(), 484441818);
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");

    assert.strictEqual(
      w.getSecret(),
      'zpub6rutAggZJCvkgZg3BAqNGAxCkx1khxCE6g6jyJugMfZ1zgkVdUWSdnzSRpWX1GYVZXCpQFS87BUsvgXXJBpsJVroiHbu4Js2TY69zbWcTNb',
    );

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1q68y6r45k4kvxe42xl37dgjueg2suqwnh4ze0sr');

    assert.ok(!w.useWithHardwareWalletEnabled());
  });

  it('can import wallet descriptor for BIP84 from Sparrow Wallet', async () => {
    const payload =
      'UR:CRYPTO-OUTPUT/TAADMWTAADDLOLAOWKAXHDCLAXINTOCTFTNNIERONTNYGALYEMAAWPHDAXDIEOWPJEGHKPGMKERHIABDTBLUBNMUMWAAHDCXFHSNBGTSGWSWPTDWVTDIHYHNHPLBBSJEOLSNFZBDIYJLTTPFIMEYTEECKTGSBZBDAHTAADEHOEADAEAOAEAMTAADDYOTADLNCSGHYKAEYKAEYKAOCYFNLBCYGMAXAXAYCYSRRTSPGADLMKBGTD';

    const decoder = new MalinURDecoder();
    decoder.receivePart(payload);
    let data;
    if (decoder.isComplete()) {
      data = decoder.toString();
    }

    const w = new WatchOnlyWallet();
    w.setSecret(data);
    w.init();
    assert.ok(w.valid());

    assert.strictEqual(w.getMasterFingerprintHex(), '3c7f1a52');
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");

    assert.strictEqual(w._getExternalAddressByIndex(0), 'bc1qr0y5c96xtfeulnzxnjl086f2njcmf8qmhenvpp');

    assert.strictEqual(
      w.getSecret(),
      'zpub6rkkMBH6dE8bUPM9MC3WTMYQ3pDYR1kHnNDrqEGY3FotR4EUifR1S4xd7ynwczREFCbfWyk5S4mhzPL8YuGsCSgey1AwH7fk4w9AULpyDYL',
    );
  });

  it('can import BIP86 (taproot) wallet descriptor', async () => {
    const descriptors = [
      "tr([97311f91/86'/0'/0']xpub6C85eQDGy5NKEqCPnrnf4QcvxQCzRiTZFTa6YfuDU1hSQGWQHf6QBHogKXaS8hUhtvk6ND4btTdiWic26UKrk1pWrU4CQGrQoGxd6DP33Sw/<0;1>/*)",
      "tr([97311f91/86'/0'/0']xpub6C85eQDGy5NKEqCPnrnf4QcvxQCzRiTZFTa6YfuDU1hSQGWQHf6QBHogKXaS8hUhtvk6ND4btTdiWic26UKrk1pWrU4CQGrQoGxd6DP33Sw)",
      "tr([97311f91/86'/0'/0']xpub6C85eQDGy5NKEqCPnrnf4QcvxQCzRiTZFTa6YfuDU1hSQGWQHf6QBHogKXaS8hUhtvk6ND4btTdiWic26UKrk1pWrU4CQGrQoGxd6DP33Sw",
      "[97311f91/86'/0'/0']xpub6C85eQDGy5NKEqCPnrnf4QcvxQCzRiTZFTa6YfuDU1hSQGWQHf6QBHogKXaS8hUhtvk6ND4btTdiWic26UKrk1pWrU4CQGrQoGxd6DP33Sw",
    ];
    for (const descriptor of descriptors) {
      const w = new WatchOnlyWallet();
      w.setSecret(descriptor);
      w.init();
      assert.ok(w.valid());

      assert.strictEqual(w.getMasterFingerprintHex(), '97311f91');
      assert.strictEqual(w.getDerivationPath(), "m/86'/0'/0'");

      assert.strictEqual(
        w.getSecret(),
        'xpub6C85eQDGy5NKEqCPnrnf4QcvxQCzRiTZFTa6YfuDU1hSQGWQHf6QBHogKXaS8hUhtvk6ND4btTdiWic26UKrk1pWrU4CQGrQoGxd6DP33Sw',
      );

      assert.ok(w._getExternalAddressByIndex(0).startsWith('bc1p'), 'not taproot address, got: ' + w._getExternalAddressByIndex(0));
      assert.ok(w.allowMasterFingerprint());
      assert.ok(!w.useWithHardwareWalletEnabled());
    }
  });

  it('can import BIP86 (taproot) wallet descriptor but with zpub instead of xpub', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret(
      "tr([b68af6e4/86'/0'/0']zpub6rxQT4vrGrdLmFicJZnLxx1odj1C8xNtHW5pW84hMSXdtoFnCbqBFJm3bF5PrwYL5ScxFhdzRuv3pb9beyoraQLMuQWkV9faGuxstBPgLw4)",
    );
    w.init();
    assert.ok(w.valid());

    assert.strictEqual(w.getMasterFingerprintHex(), 'b68af6e4');
    assert.strictEqual(w.getDerivationPath(), "m/86'/0'/0'");

    assert.strictEqual(
      w.getSecret(),
      'zpub6rxQT4vrGrdLmFicJZnLxx1odj1C8xNtHW5pW84hMSXdtoFnCbqBFJm3bF5PrwYL5ScxFhdzRuv3pb9beyoraQLMuQWkV9faGuxstBPgLw4',
    );

    assert.ok(w._getExternalAddressByIndex(0).startsWith('bc1p'), 'not taproot address, got: ' + w._getExternalAddressByIndex(0));

    assert.ok(!w.useWithHardwareWalletEnabled());
  });

  it('can import BIP86 (taproot) wallet descriptor and create transaction', async () => {
    for (const cleanupInternals of [false, true]) {
      const w = new WatchOnlyWallet();
      // MNEMONICS_KEYSTONE
      w.setSecret(
        "tr([b68af6e4/86'/0'/0']zpub6rxQT4vrGrdLmFicJZnLxx1odj1C8xNtHW5pW84hMSXdtoFnCbqBFJm3bF5PrwYL5ScxFhdzRuv3pb9beyoraQLMuQWkV9faGuxstBPgLw4)",
      );
      w.init();
      assert.ok(w.valid());

      assert.strictEqual(w.getMasterFingerprintHex(), 'b68af6e4');
      assert.strictEqual(w.getDerivationPath(), "m/86'/0'/0'");

      assert.strictEqual(
        w.getSecret(),
        'zpub6rxQT4vrGrdLmFicJZnLxx1odj1C8xNtHW5pW84hMSXdtoFnCbqBFJm3bF5PrwYL5ScxFhdzRuv3pb9beyoraQLMuQWkV9faGuxstBPgLw4',
      );

      assert.ok(w._getExternalAddressByIndex(0).startsWith('bc1p'), 'not taproot address, got: ' + w._getExternalAddressByIndex(0));

      const utxos = [
        {
          height: 923789,
          value: 10108,
          address: 'bc1pyren45uwytsghuxelahgyjflrx9dhq9zhavangrcmw2avfre6spqtwxgm4',
          txid: 'dd8a90cfef8b5966781cfaddf8a5e8f1e2dce12e7ceed25c6d329c1df2e17c4f',
          vout: 0,
          wif: false,
          confirmations: 7,
        },
      ];

      if (cleanupInternals) {
        // these might be purged when preparing for serialization before saving to disk
        w._hdWalletInstance._node0 = undefined;
        w._hdWalletInstance._node1 = undefined;
      }

      const { psbt } = w.createTransaction(utxos, [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }], 1, w._getInternalAddressByIndex(0));
      assert.ok(psbt);

      assert.ok(!w.useWithHardwareWalletEnabled());
    }
  });

  it('can combine signed PSBT and prepare it for broadcast', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('zpub6rjLjQVqVnj7crz9E4QWj4WgczmEseJq22u2B6k2HZr6NE2PQx3ZYg8BnbjN9kCfHymSeMd2EpwpM5iiz5Nrb3TzvddxW2RMcE3VXdVaXHk');
    w.init();
    const signedPsbt =
      'cHNidP8BAHECAAAAAYBbjCRXw4r66Ly1aI/SCvis+CDQsCdQej1BhCoDnjt/AAAAAAAAAACAAogTAAAAAAAAFgAUwM681sPTyox13F7GLr5VMw75EOK3OQAAAAAAABYAFOc6kh7rlKStRwwMvbaeu+oFvB4MAAAAAAAiAgNY4ds4TcPgqK6hHuQe2ZO0VnspdAH7zNvnVAAssnFPH0cwRAIgPR9zZzNTnfPqZJifyUwdM2cWW8PZqCnSCsfCePlZ2aoCIFbhr/5P/bS6eGQZtX3+6q+nUO6KaSKYgaaZrUZENF6BAQAAAA==';
    const unsignedPsbt =
      'cHNidP8BAHECAAAAAYBbjCRXw4r66Ly1aI/SCvis+CDQsCdQej1BhCoDnjt/AAAAAAAAAACAAogTAAAAAAAAFgAUwM681sPTyox13F7GLr5VMw75EOK3OQAAAAAAABYAFOc6kh7rlKStRwwMvbaeu+oFvB4MAAAAAAABAR8gTgAAAAAAABYAFL8PIBBJ6JHVhwsE61MPwWtjtptAIgYDWOHbOE3D4KiuoR7kHtmTtFZ7KXQB+8zb51QALLJxTx8YAAAAAFQAAIAAAACAAAAAgAAAAAAAAAAAAAAiAgM005BVD8MgH5kiSGnwXSfzaxLeDSl3y17Vhrx3F/9XxBgAAAAAVAAAgAAAAIAAAACAAQAAAAAAAAAA';

    const Tx = w.combinePsbt(unsignedPsbt, signedPsbt);

    assert.strictEqual(
      Tx.toHex(),
      '02000000000101805b8c2457c38afae8bcb5688fd20af8acf820d0b027507a3d41842a039e3b7f000000000000000080028813000000000000160014c0cebcd6c3d3ca8c75dc5ec62ebe55330ef910e2b739000000000000160014e73a921eeb94a4ad470c0cbdb69ebbea05bc1e0c0247304402203d1f736733539df3ea64989fc94c1d3367165bc3d9a829d20ac7c278f959d9aa022056e1affe4ffdb4ba786419b57dfeeaafa750ee8a69229881a699ad4644345e8101210358e1db384dc3e0a8aea11ee41ed993b4567b297401fbccdbe754002cb2714f1f00000000',
    );

    // checking that combine can work with both base64 and pure Psbt objects
    const Tx2 = w.combinePsbt(Psbt.fromBase64(unsignedPsbt), Psbt.fromBase64(signedPsbt));

    assert.strictEqual(Tx2.toHex(), Tx.toHex());
  });

  it('ypub watch-only can generate addresses', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('ypub6Y9u3QCRC1HkZv3stNxcQVwmw7vC7KX5Ldz38En5P88RQbesP2oy16hNyQocVCfYRQPxdHcd3pmu9AFhLv7NdChWmw5iNLryZ2U6EEHdnfo');
    w.init();
    assert.ok((await w._getExternalAddressByIndex(0)).startsWith('3'));
    assert.ok(w.getAllExternalAddresses().includes(await w._getExternalAddressByIndex(0)));
  });

  it('xpub watch-only can generate addresses', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6DXDs4PJDk5QVL2G2xaVjv7SM4roWHr1gR4xB3Z7Ps');
    w.init();
    assert.ok((await w._getExternalAddressByIndex(0)).startsWith('1'));
    assert.ok(w.getAllExternalAddresses().includes(await w._getExternalAddressByIndex(0)));
  });

  it('can determine change address for HD wallet', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('ypub6Y9u3QCRC1HkZv3stNxcQVwmw7vC7KX5Ldz38En5P88RQbesP2oy16hNyQocVCfYRQPxdHcd3pmu9AFhLv7NdChWmw5iNLryZ2U6EEHdnfo');
    w.init();
    assert.ok(!w.addressIsChange(await w._getExternalAddressByIndex(0)));
    assert.ok(w.addressIsChange(await w._getInternalAddressByIndex(0)));
  });

  it('can craft correct psbt for HW wallet to sign', async () => {
    const w = new WatchOnlyWallet();
    w.setSecret('ypub6Y9u3QCRC1HkZv3stNxcQVwmw7vC7KX5Ldz38En5P88RQbesP2oy16hNyQocVCfYRQPxdHcd3pmu9AFhLv7NdChWmw5iNLryZ2U6EEHdnfo');
    w.init();

    // a hack to make it find pubkey for address correctly:
    w._hdWalletInstance.next_free_address_index = 110;
    w._hdWalletInstance.next_free_change_address_index = 110;

    const utxos = [
      {
        height: 557538,
        value: 51432,
        address: '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK',
        vout: 0,
        txid: 'b2ac59bc282083498d1e87805d89bef9d3f3bc216c1d2c4dfaa2e2911b547100',
        wif: false,
        confirmations: 132402,
      },
    ];

    const changeAddress = '3DrZBgntD8kBBbuKLJtPVAeGT75BMC7NxU';

    const { psbt } = w.createTransaction(utxos, [{ address: 'bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu', value: 5000 }], 1, changeAddress);

    assert.strictEqual(
      uint8ArrayToHex(psbt.data.outputs[1].bip32Derivation[0].pubkey),
      '03e060c9b5bb85476caa53e3b8cd3d40c9dc2c36a8a5e8ed87e48bfc9bbe1760ad',
    );
    assert.strictEqual(psbt.data.inputs[0].bip32Derivation[0].path, "m/49'/0'/0'/1/45");
    assert.strictEqual(psbt.data.outputs[1].bip32Derivation[0].path, "m/49'/0'/0'/1/46");

    // now, changing derivation path of a watch-only wallet and expect that new crafted psbt will have this new path:

    const newPath = "m/66'/6'/6'";
    assert.strictEqual(w.getDerivationPath(), "m/49'/0'/0'");
    w.setDerivationPath(newPath);
    assert.strictEqual(w.getDerivationPath(), newPath);

    const { psbt: psbt2 } = await w.createTransaction(
      utxos,
      [{ address: 'bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu', value: 5000 }],
      1,
      changeAddress,
    );

    assert.strictEqual(
      uint8ArrayToHex(psbt2.data.outputs[1].bip32Derivation[0].pubkey),
      '03e060c9b5bb85476caa53e3b8cd3d40c9dc2c36a8a5e8ed87e48bfc9bbe1760ad',
    );
    assert.strictEqual(psbt2.data.inputs[0].bip32Derivation[0].path, newPath + '/1/45');
    assert.strictEqual(psbt2.data.outputs[1].bip32Derivation[0].path, newPath + '/1/46');
  });

  it('xpub watch only has derivation path set to BIP44 default', () => {
    const w = new WatchOnlyWallet();
    w.setSecret('xpub6CQdfC3v9gU86eaSn7AhUFcBVxiGhdtYxdC5Cw2vLmFkfth2KXCMmYcPpvZviA89X6DXDs4PJDk5QVL2G2xaVjv7SM4roWHr1gR4xB3Z7Ps');
    w.init();

    assert.strictEqual(w.getDerivationPath(), "m/44'/0'/0'");
  });

  it('ypub watch only has derivation path set to BIP49 default', () => {
    const w = new WatchOnlyWallet();
    w.setSecret('ypub6Y9u3QCRC1HkZv3stNxcQVwmw7vC7KX5Ldz38En5P88RQbesP2oy16hNyQocVCfYRQPxdHcd3pmu9AFhLv7NdChWmw5iNLryZ2U6EEHdnfo');
    w.init();

    assert.strictEqual(w.getDerivationPath(), "m/49'/0'/0'");
  });

  it('zpub watch only has derivation path set to BIP84 default', () => {
    const w = new WatchOnlyWallet();
    w.setSecret('zpub6rjLjQVqVnj7crz9E4QWj4WgczmEseJq22u2B6k2HZr6NE2PQx3ZYg8BnbjN9kCfHymSeMd2EpwpM5iiz5Nrb3TzvddxW2RMcE3VXdVaXHk');
    w.init();

    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
  });
});

describe('BC-UR', () => {
  it('v1: can decodeUR() and then combine unfinalized signed PSBT', () => {
    const unsignedPayload = decodeUR([
      'UR:BYTES/TYQ4XURNVF607QGQWYPQQQQQQ9U63JU4AD5C93Y057WNRNTV24AE8QK4DDHVT04GHTKNQZCXYHNW5QGQQQQQPLHLLLLS9LRRQQQQQQQQQQTQQ9P9YMAAVV5GVUNKD49W4GDNJ4C9GJP7383QFCQQQQQQQQQPVQQ5CXKNG9PNTGMDRV0GNWNJZS23KGG3V0KXQQQQQQQQQYQ375XRQQQQQQQQQQTQQ98UXJHTKAHE83Q8W5VGHH2G93698VZLP6PZQCPXW47RAFD36W04SNHNTZK8CLCWHXDJJRRZ2EP998STFNRYWFQPC0CC3N8X87Z5QQQGQQQQQZQQQQQQSQQQQQQQQQQQQQQQYGPQY5M4J23F3Z9TK6HZTRDD6M89QX955DEH3HXGXAC6NJQMT3CHYTJHRZXVUCLC2SQQPQQQQQQGQQQQQZQQZQQQQQQQQQQQQQ3QYQK6E2MCA75ZCRMMWZYWXNQKGKNNJC7JUXPNWR5QPYQC3EYRM4NDQ5VGENNRLP2QQQYQQQQQPQQQQQQGQQQQQQQQZQQQQQQQ6GYX3G',
    ]);
    const uPsbtB64 = Buffer.from(unsignedPayload, 'hex').toString('base64');

    const payloadSignedButNotFinalized = decodeUR([
      'UR:BYTES/TR58QUMZWNLSZQR3QGQQQQQP0X5VH90TDXPVFRA8N5CU6MZ40WFC94TTDMZMA296A5CQKP39UM4QZQQQQQQ0ALLLLUP0CCCQQQQQQQQQZCQPGFFXL0TR9ZR8YANDFT42RVU4WP2YS05FUGZWQQQQQQQQQQTQQ9XP456PGV66XMGMR6YM5US5Z5DJZYTRA3SQQQQQQQPZQGPXW47RAFD36W04SNHNTZK8CLCWHXDJJRRZ2EP998STFNRYWFQPC068XPZQYGRH45ESDZ623KSNPTY2VJ37LWA2HTCCLGSDWPDDEPK48JAKNSVZTQPZQD0W5ND2M7D62YYQ74A85DRKM8ESQS2WSTZ5F4V2YNNGY9S7F0NSQYQQQQQ7VRJ5Z',
    ]);
    const sPsbtB64 = Buffer.from(payloadSignedButNotFinalized, 'hex').toString('base64');

    const w = new WatchOnlyWallet();
    w.setSecret('zpub6s2RJ9qAEBW8Abhojs6LyDzF7gttcDr6EsR3Umu2aptZBb45e734rGtt4KqsCMmNyR1EEzUU2ugdVYez2VywQvAbBjUSKn8ho4Zk2c5otkk');
    w.init();

    const tx = w.combinePsbt(uPsbtB64, sPsbtB64);
    assert.strictEqual(
      tx.toHex(),
      '0200000000010179a8cb95eb6982c48fa79d31cd6c557b9382d56b6ec5bea8baed300b0625e6ea0100000000feffffff02fc630000000000001600142526fbd63288672766d4aeaa1b3957054483e89e204e000000000000160014c1ad3414335a36d1b1e89ba7214151b211163ec602473044022077ad33068b4a8da130ac8a64a3efbbaabaf18fa20d705adc86d53cbb69c18258022035eea4daadf9ba51080f57a7a3476d9f300414e82c544d58a24e682161e4be700121026757c3ea5b1d39f584ef358ac7c7f0eb99b290c625642529e0b4cc6472401c3f00000000',
    );
  });

  it('v1: decodeUR() txt works', () => {
    const txtFileFormatMultisigNativeSegwit =
      'UR:BYTES/TYQHKGEQGDHKYM6KV96KCAPQF46KCARFWD5KWGRNV4682UPQVE5KCEFQ9P3HYETPW3JKGGR0DCSYGVEHG4Q5GWPC9Y9ZXZJWV9KK2W3QGDT97VENGG65YWF3G90NYTFJPFGX7MRFVDUN5GPJYPHKVGPJPFZX2UNFWESHG6T0DCAZQMF0XSUZWTESYUHNQFE0XGNS53N0WFKKZAP6YPGRY46NFQ9Q53PNXAZ5Z3PC8QAZQKNSW43RWDRFDFCXV6Z92F9YU6NGGD94S5NNWP2XGNZ22C6K2M69D4F4YKNYFPC5GANS8944VARY2EZHJ62CDVMHQKRC2F3XVKN629M8X3ZXWPNYGJZ9FPT8G4NS0Q6YG73EG3R42468DCE9S6E40FRN2AF5X4G4GNTNT9FNYAN2DA5YU5G2XYMRS3ZYXCCRXW3QTFC82C3HX4K5Z3FCG448J7ZN0FHHJ5RDGAHXGD29XEXHJ3PHG9XYWNNWV3E824MKX5E8SUR6D9K4552TW44HWAJ9VEV9GJR3D4YRSMNZVF3NVCMR2Q6HGVNPF5EK6AMNXDCYKK2NDE9HQJ6DF4UHGERZFEZ453J40P9H57N5T9RY6WZSDC9QWZ5LU2';
    const rez = decodeUR([txtFileFormatMultisigNativeSegwit]);
    const b = Buffer.from(rez, 'hex');
    assert.strictEqual(
      b.toString('ascii'),
      "# CoboVault Multisig setup file (created on D37EAD88)\n#\nName: CV_33B5B91A_2-2\nPolicy: 2 of 2\nDerivation: m/48'/0'/0'/2'\nFormat: P2WSH\n\nD37EAD88: Zpub74ijpfhERJNjhCKXRspTdLJV5eoEmSRZdHqDvp9kVtdVEyiXk7pXxRbfZzQvsDFpfDHEHVtVpx4Dz9DGUWGn2Xk5zG5u45QTMsYS2vjohNQ\n168DD603: Zpub75mAE8EjyxSzoyPmGnd5E6MyD7ALGNndruWv52xpzimZQKukwvEfXTHqmH8nbbc6ccP5t2aM3mws3pKYSnKpKMMytdbNEZFUxKzztYFM8Pn\n",
    );
  });

  it('v2: decodeUR() crypto-account works', () => {
    const payload =
      'UR:CRYPTO-ACCOUNT/OEADCYADWMTNKIAOLYTAADMWTAADDLOSAOWKAXHDCLAXMDRPFXWKHPTPNEWEVAWKYNFPJEDEMNJKAEGHCFQZLKUOTPLRIHMEFRTECWGRVWWDAAHDCXMHIODYPYLEAXZOGRPKEYPTBGBWGWDWHPZEIMVDBAAOIEVEWLZEGRBKRNFTHFAMMOAHTAADEHOEADADAOAEAMTAADDYOTADLNCSGHYKAEYKAEYKAOCYADWMTNKIAXAXATTAADDYOEADLRAEWKLAWKAXAEAYCYBGHFLOPACMIOWZLB';

    const [index, total] = extractSingleWorkload(payload);
    assert.strictEqual(index, 1);
    assert.strictEqual(total, 1);

    const decoded = decodeUR([payload]);

    assert.strictEqual(
      Buffer.from(decoded, 'hex').toString('ascii'),
      '{"ExtPubKey":"zpub6qT7amLcp2exr4mU4AhXZMjD9CFkopECVhUxc9LHW8pNsJG2B9ogs5sFbGZpxEeT5TBjLmc7EFYgZA9EeWEM1xkJMFLefzZc8eigRFhKB8Q","MasterFingerprint":"01EBDA7D","AccountKeyPath":"m/84\'/0\'/0\'"}',
    );

    const w = new WatchOnlyWallet();
    w.setSecret(Buffer.from(decoded, 'hex').toString('ascii'));
    w.init();
    assert.strictEqual(w.getDerivationPath(), "m/84'/0'/0'");
  });

  it('v2: can decodeUR() PSBT', () => {
    const payload = decodeUR([
      'UR:CRYPTO-PSBT/HKADGSJOJKIDJYZMADAEJYAOAEAEAEADWKMTGWJPPFGMCKJLKPNDNDBWAHBEAXCNFHPKRHUTPMGTBAFNWEBTLBECKENNBDJKADAEAEAEAEZMZMZMZMAONBLNADAEAEAEAEAECFKOPTBBCFBGNTGUVAEHNDPECFUYNBHKRNPMCMJNYTBKROYKLOPSVOHTADAEAEAEAEAECMAEBBWEWETAYKBETTTDISVDGYTTGMEHLSDMASFYPSPYDRAEAEAEAEAEADADCTLNZMAOAEAEAEAEAECMAEBBJYLSWNATMWIOEMHTPMFXCWMTGLZSTPVSCMWDLBKKADAYJEAOFLDYFYAOCXGYFNRKKPVYWFWEGLFZTYLDSFWNNEFGCTIMPEFHWMCWNNMTCHHTMYGRSOFRLODSAEAOCXKTKBHDNDCEFLMEBYOESETTIOAACHAXZMVWDNRDHEISHKETAMCHDSEOFXIYDECPHGADCLAOHSHHTYMTPAWKLNFYESCWNBKSWDVDNNYNMNCFLOFNTTWTNYFYNTHERORKDKQDWEGWAEAECPAOAXIHWEMNLPPDZTKSTEJLBNMOWFCSVYKNMNHKHFGDRNKELFRTSFCTSRZSSGJZAXRNHYCSADWMTNKIGHAEAELAAEAEAELAAEAEAELAADAEAEAELNAEAEAEAESSAOMKSP',
    ]);

    const uPsbtB64 = Buffer.from(payload, 'hex').toString('base64');

    const psbtTx = Psbt.fromBase64(uPsbtB64);
    assert.strictEqual(
      psbtTx.extractTransaction().toHex(),
      '02000000000101f4964f72b0521e6f759b9b13051003233faab9ddad4d0e3ced0d7f357c9e0b730100000000ffffffff02a0860100000000001976a91419129d53e6319baf19dba059bead166df90ab8f588ace25a010000000000160014ededd9f510d1d268e751d15231832e0944acab2a024730440220513cbb75e1f3ed4e40d489ccf19f461f6aaf3feb1b9e96175a8f4bc93b8826000220777e589b1c479111a2c1d167041703ffe52bba5f685938061726334366282257012102615cd496b1f48644391ba078eae79ef68e19883cd1f09a449d5fb8bb24b3ed4f00000000',
    );

    // now, full psbt tx via parts:
    const decoder = new MalinURDecoder();
    decoder.receivePart(
      'UR:CRYPTO-PSBT/33-2/LPCSCLAOCFAOIOCYCSKEMSHLHKADEEFZZEMETDFRIEAEAXFPTACLNTMTTKGRAXKTKGUOFPMOGWCWIYMEKKVDVONETLPRKGBSONGAKKEMCNGALGOXBDFTLSJLHERNWKINJPADAYJEZCROTKRKGHJPFEAMSRJNJLMYETDSGYWFBSSNPFUTPFDIJOCYWZFLZENSKOYNSOVLVSPTVTHFPKTAAOCXCPFYMKKPKPBEGLMSCMDNVSPYJNTNLKGTFMZMRSFWSNZEPYVTWFPTQDDTPERPPSLREEHLNSKNLOENSTFYFDTSSOFZNEIAVYTDISWEOTUYHLFMGWOLCNMSTKZSFLNSPFKTWSDNECCFTNOYFGETGMBBJNYTBKROYKNNPSBBJYLSWNATMDIYDEGLTYFWCWMTGLZSTPZECMZEGADMNNLDDWREFSZTGHLOOSYTEMIEWKBWHKHHNTCPGHBNMELSLGBAPDGELAHYSBWLAMYNCSFRNLFRKPMWFNUEKSAEURNNLYPLPMLTVWVDDKBTVWBWLDJKYKWPCTJZIEEHSANYMHZMNDZEDYCWBZDPKBGSBARKIMAYFLGYIMCFLSMKENPEEOPSRFWSJKINLFYLPECYQZZCLBLSKOHLHGJZRHRYVTLOGLCMHGHLPAHNWYMULS',
    );
    decoder.receivePart(
      'UR:CRYPTO-PSBT/47-2/LPCSDLAOCFAOIOCYCSKEMSHLHKADEEFZZEMETDFRIEAEAXFPTACLNTMTTKGRAXKTKGUOFPMOGWCWIYMEKKVDVONETLPRKGBSONGAKKEMCNGALGOXBDFTLSJLHERNWKINJPADAYJEZCROTKRKGHJPFEAMSRJNJLMYETDSGYWFBSSNPFUTPFDIJOCYWZFLZENSKOYNSOVLVSPTVTHFPKTAAOCXCPFYMKKPKPBEGLMSCMDNVSPYJNTNLKGTFMZMRSFWSNZEPYVTWFPTQDDTPERPPSLREEHLNSKNLOENSTFYFDTSSOFZNEIAVYTDISWEOTUYHLFMGWOLCNMSTKZSFLNSPFKTWSDNECCFTNOYFGETGMBBJNYTBKROYKNNPSBBJYLSWNATMDIYDEGLTYFWCWMTGLZSTPZECMZEGADMNNLDDWREFSZTGHLOOSYTEMIEWKBWHKHHNTCPGHBNMELSLGBAPDGELAHYSBWLAMYNCSFRNLFRKPMWFNUEKSAEURNNLYPLPMLTVWVDDKBTVWBWLDJKYKWPCTJZIEEHSANYMHZMNDZEDYCWBZDPKBGSBARKIMAYFLGYIMCFLSMKENPEEOPSRFWSJKINLFYLPECYQZZCLBLSKOHLHGJZRHRYVTLOGLCMHGHLPAYKAOHEGU',
    );
    decoder.receivePart(
      'UR:CRYPTO-PSBT/73-2/LPCSGAAOCFAOIOCYCSKEMSHLHKADEEFZZEMETDFRIEAEAXFPTACLNTMTTKGRAXKTKGUOFPMOGWCWIYMEKKVDVONETLPRKGBSONGAKKEMCNGALGOXBDFTLSJLHERNWKINJPADAYJEZCROTKRKGHJPFEAMSRJNJLMYETDSGYWFBSSNPFUTPFDIJOCYWZFLZENSKOYNSOVLVSPTVTHFPKTAAOCXCPFYMKKPKPBEGLMSCMDNVSPYJNTNLKGTFMZMRSFWSNZEPYVTWFPTQDDTPERPPSLREEHLNSKNLOENSTFYFDTSSOFZNEIAVYTDISWEOTUYHLFMGWOLCNMSTKZSFLNSPFKTWSDNECCFTNOYFGETGMBBJNYTBKROYKNNPSBBJYLSWNATMDIYDEGLTYFWCWMTGLZSTPZECMZEGADMNNLDDWREFSZTGHLOOSYTEMIEWKBWHKHHNTCPGHBNMELSLGBAPDGELAHYSBWLAMYNCSFRNLFRKPMWFNUEKSAEURNNLYPLPMLTVWVDDKBTVWBWLDJKYKWPCTJZIEEHSANYMHZMNDZEDYCWBZDPKBGSBARKIMAYFLGYIMCFLSMKENPEEOPSRFWSJKINLFYLPECYQZZCLBLSKOHLHGJZRHRYVTLOGLCMHGHLPASAVWCXNE',
    );
    decoder.receivePart(
      'UR:CRYPTO-PSBT/75-2/LPCSGRAOCFAOIOCYCSKEMSHLHKADEECFZTYKOEFDAMJYZTFZTALNNEMTTKGRAEADADCTCYWMAOAEAEAEAEAECMAEBBTYKNASSBGUVSCFDYOEUOWYDRKPSEJOUYMORPISJPADAYJEAOFLDYFYAOCXBYYKBYFMMTSPFYFZFYWESNHNEYSWGDWSIOBNHYBTGETNSBJOEYLNOSGUGOVOPYTAAOCXCPRKIOLELEVETPTPIENDRDREAOPECHTBDPZSPEFPWYSEADHKDMAAZEDIMUHPOYZOADCLAOJSZOEMSTFYFDTSENRSHNNSVTLNFGWDOTUYHLFMGWRSGOFMUYVLGOADVLMEUEPFNYAEADADCTLNZMAOAEAEAEAEAECMAEBBJYLSWNATMWIOEMHTPMFXCWMTGLZSTPVSCMWDLBKKADAYJEAOFLDYFYAOCXIYQZMEGUDAAXSOKNWMGOAAZSLYSGFMWPFDNBDPBDJEFSMSDLPFJSWMHLAXKNTDGEAOCXDKHEPTGMZMYACWCEDEJEEORHOYCAHYSRJTFYDSMHROFTDYPEFGZMRSRLJZBDAMONADCLAOHSHHTYMTPAWKLNFYESCWNBKSWDVDNNYNMNCFLOFNTTWTNYFYNTHERORKDKQDWEGWAEAEAEPDBAJSAH',
    );
    assert.strictEqual(decoder.estimatedPercentComplete(), 1);
    const psbt = Psbt.fromBase64(decoder.toString());
    assert.ok(psbt);
  });

  it('v2: can decodeUR() multipart bytes', () => {
    const decoder = new MalinURDecoder();
    decoder.receivePart(
      'UR:BYTES/246-2/LPCSYNAOCFADKECYCEBTIDBGHDRNGRISEEECIOEYFWFLGEFPGOKOFWKSFXGTKTKKHTKOEYEEGOJLECKNJPEEGRGRIAHKHKESEEEOFXFYGEGMGEJNETHSJNFDGOIHJOIOFPHFIEKPGOGOEYINKSGOJOGYESIYGYKNEHBKDYEHFEFWFYFPEMFYFTCXHTJOKPIDEMECENJYGDKSKSKTFDINHKJEHKINGHEHEYFLEYHGGOFYEYIAJOFPFDKKHFHGISIMKOGRGDIDHDJLHKECIMFYHTGUKKJLEMEHKKFLECFXEHEEGSFXKPKTISKKIAGHGHFPKNIOGHGOIAGYIYIEIEGMETFGFGGHGYEHIDGUHGGMENJEKNJNGLIDGTFEHSHFKNGOJPIMEEGSISKSIDJLJTIMJLBKCFCFRYME',
    );
    decoder.receivePart(
      'UR:BYTES/243-2/LPCSWFAOCFADKECYCEBTIDBGHDRNBGINGTCMFLKKDIFMESECFTCSDIHDBAETCWBTEOAHHPGUKPCEGDBAATFYJEDPBKECFNCFCEGDEHCLDNDSDLASCSBAAXISIHGHECDAAHCHGUEHKEHEBYIAENEECAEEAXFGCEBSHLKBHKFWDWDAIECHHFEHHFGHGDCXCYBAHYHFGWGLJOGEHDCSDMGAJEHSCABNDSHDFYDSFGFMFTDRAYFXCAJTKEFPJSKSHDGTHKKGKTGTIMFDGUJKAHENEMEYBTGOCHHSGRBEIYBDFRFMASKTEOFLDWFRGMIYJTHSCXCHCLEMGHIHCNDRCKCHJTCTATDKFRHKGYASENDRGWCFAYGHAABGAXFHFRCHFMADDYDYKPDNCWBKHPCEBDAODIJTBBFGRHFH',
    );
    decoder.receivePart(
      'UR:BYTES/240-2/LPCSWTAOCFADKECYCEBTIDBGHDRNHKADKKCNCXGRIHKKJKJYJLJTIHCXGTKPJZJYINJKINIOCXJKIHJYKPJOCXIYINJZIHCXDEIAJPIHHSJYIHIECXJLJTCXDYEHFEFWFYFPEMFYDTBKCNBKGLHSJNIHFTCXGTKPJZJYINJKINIOCXHFHSKPJZJYBKGDJLJZINIAKKFTCXEYCXJLIYCXEYBKFYIHJPINKOHSJYINJLJTFTCXJNDLEEETDIDLDYDIDLDYDIDLEYDIBKFGJLJPJNHSJYFTCXGDEYHGGUFDBKBKFEEEFGDYFYFWEHEYFTCXHTJOKPIDEMEEFEGLKNFEHFHKFPJOIMISEOHTHSKSKKJPJPESGEJOGLKNHTFPFYGHFWHTFPIOJKJPESJKIHISFDIEIYENASAX',
    );
    decoder.receivePart(
      'UR:BYTES/238-2/LPCSWYAOCFADKECYCEBTIDBGHDRNGRISEEECIOEYFWFLGEFPGOKOFWKSFXGTKTKKHTKOEYEEGOJLECKNJPEEGRGRIAHKHKESEEEOFXFYGEGMGEJNETHSJNFDGOIHJOIOFPHFIEKPGOGOEYINKSGOJOGYESIYGYKNEHBKDYEHFEFWFYFPEMFYFTCXHTJOKPIDEMECENJYGDKSKSKTFDINHKJEHKINGHEHEYFLEYHGGOFYEYIAJOFPFDKKHFHGISIMKOGRGDIDHDJLHKECIMFYHTGUKKJLEMEHKKFLECFXEHEEGSFXKPKTISKKIAGHGHFPKNIOGHGOIAGYIYIEIEGMETFGFGGHGYEHIDGUHGGMENJEKNJNGLIDGTFEHSHFKNGOJPIMEEGSISKSIDJLJTIMJLBKNYBTOSBE',
    );
    decoder.receivePart(
      'UR:BYTES/235-2/LPCSWMAOCFADKECYCEBTIDBGHDRNHKADKKCNCXGRIHKKJKJYJLJTIHCXGTKPJZJYINJKINIOCXJKIHJYKPJOCXIYINJZIHCXDEIAJPIHHSJYIHIECXJLJTCXDYEHFEFWFYFPEMFYDTBKCNBKGLHSJNIHFTCXGTKPJZJYINJKINIOCXHFHSKPJZJYBKGDJLJZINIAKKFTCXEYCXJLIYCXEYBKFYIHJPINKOHSJYINJLJTFTCXJNDLEEETDIDLDYDIDLDYDIDLEYDIBKFGJLJPJNHSJYFTCXGDEYHGGUFDBKBKFEEEFGDYFYFWEHEYFTCXHTJOKPIDEMEEFEGLKNFEHFHKFPJOIMISEOHTHSKSKKJPJPESGEJOGLKNHTFPFYGHFWHTFPIOJKJPESJKIHISFDIETODMPFCY',
    );
    decoder.receivePart(
      'UR:BYTES/224-2/LPCSVTAOCFADKECYCEBTIDBGHDRNBGINGTCMFLKKDIFMESECFTCSDIHDBAETCWBTEOAHHPGUKPCEGDBAATFYJEDPBKECFNCFCEGDEHCLDNDSDLASCSBAAXISIHGHECDAAHCHGUEHKEHEBYIAENEECAEEAXFGCEBSHLKBHKFWDWDAIECHHFEHHFGHGDCXCYBAHYHFGWGLJOGEHDCSDMGAJEHSCABNDSHDFYDSFGFMFTDRAYFXCAJTKEFPJSKSHDGTHKKGKTGTIMFDGUJKAHENEMEYBTGOCHHSGRBEIYBDFRFMASKTEOFLDWFRGMIYJTHSCXCHCLEMGHIHCNDRCKCHJTCTATDKFRHKGYASENDRGWCFAYGHAABGAXFHFRCHFMADDYDYKPDNCWBKHPCEBDAODIJTSAPMYNHK',
    );
    assert.strictEqual(decoder.estimatedPercentComplete(), 1);
    const str = decoder.toString();

    assert.ok(str.includes('E4F0DB12'));
    assert.ok(str.includes('Keystone Multisig setup file'));
  });

  it('v2: can decodeUR() into accounts', () => {
    const decoder = new MalinURDecoder();
    decoder.receivePart(
      'UR:CRYPTO-ACCOUNT/OEADCYJKSKTNBKAOLSTAADMWTAADDLONAXHDCLAOJOKNIDZCPSSAJTPTRPFRCECFKKAMYKJTVTCSBTBDTKCFIYVYOETNEEYKWFNBNYNDAAHDCXGEGUNBPYCLRHUOMDLNNSGLMOOYHSCFGLAXRTWSFHYKADGESWMOWKEOSSKOGHMHZTAMTAADDYOTADLNCSGHYKAEYKAEYKAOCYJKSKTNBKAXAXATTAADDYOYADLRAEWKLAWKAYCYKBWFDNUYTAADMHTAADMWTAADDLONAXHDCLAOWNWFFLLDCWCXYLHFMNPLFMSOLNNERSRPKGSGRPWFHDEYJLBEWPSSCNHFRYGOMUNTAAHDCXJTPKVLIHPLBABKBKPYLREYHHZEKETSJZFRMHMHECYALDVDTEWNROFLPTNBKKKBSBAMTAADDYOTADLNCSEHYKAEYKAEYKAOCYJKSKTNBKAXAXATTAADDYOYADLRAEWKLAWKAYCYFSAHZMKPTAADMUTAADDLONAXHDCLAXKTGSMEBSTKATZSMTLOJTOSMWWTTLSGWENYZEDYQZGRLSYLVOBWRKMOMUBAKIWKRYAAHDCXFSOXRFCFBKDSLABYCAEHZSURUOMHHEDRLBJZVDKEJLBENLCFBYJLDAFSFXFYGMCFAMTAADDYOTADLNCSDWYKAEYKAEYKAOCYJKSKTNBKAXAXATTAADDYOYADLRAEWKLAWKAYCYBZHPSGHKSOPAJSLN',
    );
    let data = '';
    if (decoder.isComplete()) {
      data = decoder.toString();
    }

    const json = JSON.parse(data);

    assert.ok(Array.isArray(json));
    assert.strictEqual(json.length, 3);

    assert.ok(json[0].ExtPubKey.startsWith('zpub'));
    assert.ok(json[0].AccountKeyPath.startsWith('m/84'));
    assert.ok(json[0].MasterFingerprint === '73C5DA0A');

    assert.ok(json[1].ExtPubKey.startsWith('ypub'));
    assert.ok(json[1].AccountKeyPath.startsWith('m/49'));
    assert.ok(json[1].MasterFingerprint === '73C5DA0A');

    assert.ok(json[2].ExtPubKey.startsWith('xpub'));
    assert.ok(json[2].AccountKeyPath.startsWith('m/44'));
    assert.ok(json[2].MasterFingerprint === '73C5DA0A');
  });

  it('v1: decodeUR() works', async () => {
    await new Promise(resolve => setTimeout(resolve, 1000)); // sleep
    // sleep is needed because in test envirnment setUseURv1() and init function have a race condition
    await setUseURv1();
    const txt = 'hello world';
    const b = Buffer.from(txt, 'ascii');
    let fragments = encodeUR(b.toString('hex'), 666);
    assert.deepStrictEqual(fragments, ['ur:bytes/fd5x2mrvdus8wmmjd3jqugwtl9']);
    assert.strictEqual(Buffer.from(decodeUR(fragments), 'hex').toString('ascii'), txt);

    fragments = encodeUR(b.toString('hex'), 10);
    assert.deepStrictEqual(fragments, [
      'ur:bytes/1of3/fc38n9ue84vu8ra8ue6cdnrghws0dwep4f46q4rlrgdncwsg49lsw38e6m/fd5x2mrvdu',
      'ur:bytes/2of3/fc38n9ue84vu8ra8ue6cdnrghws0dwep4f46q4rlrgdncwsg49lsw38e6m/s8wmmjd3jq',
      'ur:bytes/3of3/fc38n9ue84vu8ra8ue6cdnrghws0dwep4f46q4rlrgdncwsg49lsw38e6m/ugwtl9',
    ]);
    assert.strictEqual(Buffer.from(decodeUR(fragments), 'hex').toString('ascii'), txt);
  });

  it('v2: decodeUR() bytes works', () => {
    const payload =
      'UR:BYTES/HKADKNCNCXGRIHKKJKJYJLJTIHCXGTKPJZJYINJKINIOCXJKIHJYKPJOCXIYINJZIHCXDEIAJPIHHSJYIHIECXJLJTCXDYEHFEFWFYFPEMFYDTBKCNBKGLHSJNIHFTCXGRGHHEFGFPFPESDYFEFWENHEEYDPEYBKGDJLJZINIAKKFTCXEYCXJLIYCXEYBKFYIHJPINKOHSJYINJLJTFTCXJNDLEEETDIDLDYDIDLDYDIDLEYDIBKFGJLJPJNHSJYFTCXGDEYHGGUFDBKBKDYEHFEFWFYFPEMFYFTCXHTJOKPIDEMECENJYGDKSKSKTFDINHKJEHKINGHEHEYFLEYHGGOFYEYIAJOFPFDKKHFHGISIMKOGRGDIDHDJLHKECIMFYHTGUKKJLEMEHKKFLECFXEHEEGSFXKPKTISKKIAGHGHFPKNIOGHGOIAGYIYIEIEGMETFGFGGHGYEHIDGUHGGMENJEKNJNGLIDGTFEHSHFKNGOJPIMEEGSISKSIDJLJTIMJLBKESEMFXFWEHECEEEYFTCXHTJOKPIDEMECHFKPHKIYKTJPFXIMEYGLHDKTFGGSGMIEIDKKKOGDGDJNGDKOEMGMJYIHGYKTFGGTHDFDGEGTGDJKFYKPFXEMKOISKOIDHGJSJLJNFEIEEMETHKJOJLGRIEEMJEGRJEIAIAGHGHFXFPJNJNIDECHFJNHDFPEHESHSISEMIMHDGYINIOGRGOIHKSJEIHGSIHKPGRIMKTJYFDKKENECJLBKYLYAHNRS';
    const result = Buffer.from(decodeUR([payload]), 'hex').toString();
    assert.ok(result.includes('Keystone Multisig setup file'));
  });

  it('v2: encodeUR() psbt works', async () => {
    await clearUseURv1();
    const psbtHex =
      '70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f000000000000000000';

    const fragments = encodeUR(psbtHex, 100);
    assert.strictEqual(fragments.length, 2);
    assert.deepStrictEqual(fragments, [
      'ur:crypto-psbt/1-2/lpadaocsptcybkgdcarhhdgohdosjojkidjyzmadaenyaoaeaeaeaohdvsknclrejnpebncnrnmnjojofejzeojlkerdonspkpkkdkykfelokgprpyutkpaeaeaeaeaezmzmzmzmlslgaaditiwpihbkispkfgrkbdaslewdfycprtjsprsgksecdratkkhktimndacnch',
      'ur:crypto-psbt/2-2/lpaoaocsptcybkgdcarhhdgokewdcaadaeaeaeaezmzmzmzmaojopkwtayaeaeaeaecmaebbtphhdnjstiambdassoloimwmlyhygdnlcatnbggtaevyykahaeaeaeaecmaebbaeplptoevwwtyakoonlourgofgvsjydpcaltaemyaeaeaeaeaeaeaeaeaeaeswhhtptt',
    ]);
  });

  it('v1: extractSingleWorkload() works', () => {
    const [index, total] = extractSingleWorkload('ur:bytes/2of3/fc38n9ue84vu8ra8ue6cdnrghws0dwep4f46q4rlrgdncwsg49lsw38e6m/s8wmmjd3jq');
    assert.strictEqual(index, 2);
    assert.strictEqual(total, 3);
  });
});


================================================
FILE: ./tests/unit/payjoin-transaction.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';
import { PayjoinClient } from 'payjoin-client';

import { HDSegwitBech32Wallet } from '../../class';
import PayjoinTransaction from '../../class/payjoin-transaction';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

const utxos = [
  {
    height: 666,
    value: 100000,
    address: 'bc1q2j76s63hx6ue4hfklhtkny4fx822kzw2ycyn5r',
    vout: 0,
    txid: '8e8c982479c18b4331748c97c424891a4a474a61e5fdf6ac442c47cd44f13614',
    wif: '',
    confirmations: 666,
  },
];

describe('PayjoinTransaction', () => {
  it('throws if smth is wrong with pj transaction', async () => {
    if (!process.env.MNEMONICS_COLDCARD) {
      console.error('process.env.MNEMONICS_COLDCARD not set, skipped');
      return;
    }
    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.MNEMONICS_COLDCARD);
    const { tx: txOrig, psbt: psbtOrig } = w.createTransaction(
      utxos,
      [{ address: 'bc1qyvdzueznsh0rsyfqzdtj9ce7nlx4rlg2v93lcl', value: 10000 }],
      6,
      w._getInternalAddressByIndex(0),
    );

    assert.ok(txOrig);
    assert.strictEqual(txOrig.ins.length, 1);
    assert.strictEqual(txOrig.outs.length, 2);

    let broadcastWasCalled;
    const wallet = new PayjoinTransaction(
      psbtOrig,
      async txhex => {
        broadcastWasCalled = true;
        assert.strictEqual(txhex, txOrig.toHex());
        return true;
      },
      w,
    );

    const payjoinRequesterMock = {
      requestPayjoin: async function () {
        // should return payjoined PSBT, but we return original
        return psbtOrig;
      },
    };

    const payjoinClient = new PayjoinClient({
      paymentScript: Buffer.from(uint8ArrayToHex(bitcoin.address.toOutputScript('bc1qyvdzueznsh0rsyfqzdtj9ce7nlx4rlg2v93lcl')), 'hex'),
      // @ts-ignore idk too lazy to figure out, seems to work
      wallet,
      // @ts-ignore idk too lazy to figure out, seems to work
      payjoinRequester: payjoinRequesterMock,
    });

    await assert.rejects(payjoinClient.run());

    assert.ok(broadcastWasCalled);
    const payjoinPsbt = wallet.getPayjoinPsbt();
    assert.ok(!payjoinPsbt);
  });

  it('works', async () => {
    if (!process.env.MNEMONICS_COLDCARD) {
      console.error('process.env.MNEMONICS_COLDCARD not set, skipped');
      return;
    }
    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.MNEMONICS_COLDCARD);
    // bitcoin:bc1qy0ydthpa35m37pvwl5tu76j0srcmcwtmaur3aw?amount=0.0001&pj=https://btc.donate.kukks.org/BTC/pj

    // because `createTransaction()` has now readjusted coinselect algo, actual created psbt differs, and wont work
    // with hardcoded psbt from btcpayserver. so instead of redoing whole process to get fresh psbt, we hardcode
    // created cransaction:
    const psbtOrigin = bitcoin.Psbt.fromBase64(
      'cHNidP8BAHECAAAAARQ28UTNRyxErPb95WFKR0oaiSTEl4x0MUOLwXkkmIyOAAAAAAAAAACAAhAnAAAAAAAAFgAUI8jV3D2NNx8Fjv0Xz2pPgPG8OXtiWQEAAAAAABYAFF8XCHdkg2yGn81L+plhb9iWamgBAAAAAAABAR+ghgEAAAAAABYAFFS9qGo3Nrma3Tb912mSqTHUqwnKAQhsAkgwRQIhAKsmnGPh1vqoW5zlhjJUUs9rcdG9xMwtlf4Hoij7ul+XAiANlyXTuYshsmTIz6/734ChqQzAGp/HreRulypr0wevswEhAolzW1ViXE+a+hqxD825RNPNdq2Gd7dhUeJ4atRH12vaAAAiAgL1DWeV+AfIP5RRB5zHv5vuXsIt8+rF9rrsji3FhQlhzBgAAAAAVAAAgAAAAIAAAACAAQAAAAAAAAAA',
    );
    const txOrigin = bitcoin.Transaction.fromHex(
      '020000000001011436f144cd472c44acf6fde5614a474a1a8924c4978c7431438bc17924988c8e00000000000000008002102700000000000016001423c8d5dc3d8d371f058efd17cf6a4f80f1bc397b62590100000000001600145f17087764836c869fcd4bfa99616fd8966a680102483045022100ab269c63e1d6faa85b9ce586325452cf6b71d1bdc4cc2d95fe07a228fbba5f9702200d9725d3b98b21b264c8cfaffbdf80a1a90cc01a9fc7ade46e972a6bd307afb301210289735b55625c4f9afa1ab10fcdb944d3cd76ad8677b76151e2786ad447d76bda00000000',
    );

    assert.strictEqual(txOrigin.ins.length, 1);
    assert.strictEqual(txOrigin.outs.length, 2);

    let broadcastWasCalled = 0;
    const wallet = new PayjoinTransaction(
      psbtOrigin,
      async txhex => {
        broadcastWasCalled++;
        const tx2broadcast = bitcoin.Transaction.fromHex(txhex);
        assert.strictEqual(tx2broadcast.ins.length, 2);
        assert.strictEqual(tx2broadcast.outs.length, 2);

        assert.notStrictEqual(txhex, txOrigin.toHex());
        return true;
      },
      w,
    );

    wallet.scheduleBroadcastTx = async function () {}; // mock so no real timers are called

    const payjoinRequesterMock = {
      requestPayjoin: async function () {
        // should return payjoined PSBT (real result obtained from btcpayserver)
        return bitcoin.Psbt.fromBase64(
          'cHNidP8BAJoCAAAAAhQ28UTNRyxErPb95WFKR0oaiSTEl4x0MUOLwXkkmIyOAAAAAAAAAACA2IofvhtoPtrKvZJbyK/S++qLDDL/kE+U1yThC9QiYbIAAAAAAAAAAIACdcEAAAAAAAAWABQjyNXcPY03HwWO/RfPak+A8bw5e2JZAQAAAAAAFgAUXxcId2SDbIafzUv6mWFv2JZqaAEAAAAAAAABAR9lmgAAAAAAABYAFGNhu+9x0LmtgIqPMnlRqj/YHfrGAQhsAkgwRQIhALWjdkl7QZNh0rsgt9bAKfH5r157vzuTh7p/ZukdL9YYAiAFiWNrZ5Ui71PZ5xlofDhStKWmj3jtWG27R3mBKZ1tMwEhA0tfv49EbHkYaeNwx5XTF+PT8Jffba1qnn7GB5wR5dLWAAAA',
        );
      },
    };

    const payjoinClient = new PayjoinClient({
      paymentScript: Buffer.from(uint8ArrayToHex(bitcoin.address.toOutputScript('bc1qy0ydthpa35m37pvwl5tu76j0srcmcwtmaur3aw')), 'hex'),
      // @ts-ignore idk too lazy to figure out, seems to work
      wallet,
      // @ts-ignore idk too lazy to figure out, seems to work
      payjoinRequester: payjoinRequesterMock,
    });

    await payjoinClient.run();

    const payjoinPsbt = wallet.getPayjoinPsbt();
    assert.ok(payjoinPsbt);
    const txPayjoin = payjoinPsbt.extractTransaction();
    assert.strictEqual(txPayjoin.ins.length, 2);
    assert.strictEqual(txPayjoin.outs.length, 2);
    assert.strictEqual(broadcastWasCalled, 1);
  });
});


================================================
FILE: ./tests/unit/hd-segwit-bech32-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { HDSegwitBech32Wallet } from '../../class';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

describe('Bech32 Segwit HD (BIP84)', () => {
  it('can create', async function () {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(mnemonic);

    assert.strictEqual(true, hd.validateMnemonic());
    assert.strictEqual(
      'zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs',
      hd.getXpub(),
    );

    assert.strictEqual(hd._getExternalWIFByIndex(0), 'KyZpNDKnfs94vbrwhJneDi77V6jF64PWPF8x5cdJb8ifgg2DUc9d');
    assert.strictEqual(hd._getExternalWIFByIndex(1), 'Kxpf5b8p3qX56DKEe5NqWbNUP9MnqoRFzZwHRtsFqhzuvUJsYZCy');
    assert.strictEqual(hd._getInternalWIFByIndex(0), 'KxuoxufJL5csa1Wieb2kp29VNdn92Us8CoaUG3aGtPtcF3AzeXvF');
    assert.ok(hd._getInternalWIFByIndex(0) !== hd._getInternalWIFByIndex(1));

    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu');
    assert.strictEqual(hd._getExternalAddressByIndex(1), 'bc1qnjg0jd8228aq7egyzacy8cys3knf9xvrerkf9g');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el');
    assert.ok(hd._getInternalAddressByIndex(0) !== hd._getInternalAddressByIndex(1));

    assert.ok(hd.getAllExternalAddresses().includes('bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu'));
    assert.ok(hd.getAllExternalAddresses().includes('bc1qnjg0jd8228aq7egyzacy8cys3knf9xvrerkf9g'));
    assert.ok(!hd.getAllExternalAddresses().includes('bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el')); // not internal

    assert.ok(hd.addressIsChange('bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el'));
    assert.ok(!hd.addressIsChange('bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu'));

    assert.strictEqual(
      uint8ArrayToHex(hd._getPubkeyByAddress(hd._getExternalAddressByIndex(0))),
      '0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c',
    );
    assert.strictEqual(
      uint8ArrayToHex(hd._getPubkeyByAddress(hd._getInternalAddressByIndex(0))),
      '03025324888e429ab8e3dbaf1f7802648b9cd01e9b418485c5fa4c1b9b5700e1a6',
    );

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/84'/0'/0'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(1)), "m/84'/0'/0'/0/1");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/84'/0'/0'/1/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(1)), "m/84'/0'/0'/1/1");

    assert.strictEqual(hd.getMasterFingerprintHex(), '73C5DA0A');
  });

  it('can generate addresses only via zpub', function () {
    const zpub = 'zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs';
    const hd = new HDSegwitBech32Wallet();
    hd._xpub = zpub;
    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu');
    assert.strictEqual(hd._getExternalAddressByIndex(1), 'bc1qnjg0jd8228aq7egyzacy8cys3knf9xvrerkf9g');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el');
    assert.ok(hd._getInternalAddressByIndex(0) !== hd._getInternalAddressByIndex(1));

    assert.ok(hd.getAllExternalAddresses().includes('bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu'));
    assert.ok(hd.getAllExternalAddresses().includes('bc1qnjg0jd8228aq7egyzacy8cys3knf9xvrerkf9g'));
    assert.ok(!hd.getAllExternalAddresses().includes('bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el')); // not internal
  });

  it('can generate', async () => {
    const hd = new HDSegwitBech32Wallet();
    const hashmap = {};
    for (let c = 0; c < 1000; c++) {
      await hd.generate();
      const secret = hd.getSecret();
      assert.strictEqual(secret.split(' ').length, 12);
      if (hashmap[secret]) {
        throw new Error('Duplicate secret generated!');
      }
      hashmap[secret] = 1;
      assert.ok(secret.split(' ').length === 12 || secret.split(' ').length === 24);
    }

    const hd2 = new HDSegwitBech32Wallet();
    hd2.setSecret(hd.getSecret());
    assert.ok(hd2.validateMnemonic());
  });

  it('can coin control', async () => {
    const hd = new HDSegwitBech32Wallet();

    // fake UTXO so we don't need to use fetchUtxo
    hd._utxo = [
      { txid: '11111', vout: 0, value: 11111 },
      { txid: '22222', vout: 0, value: 22222 },
    ];

    assert.ok(hd.getUtxo().length === 2);

    // freeze one UTXO and set a memo on it
    hd.setUTXOMetadata('11111', 0, { memo: 'somememo', frozen: true });
    assert.strictEqual(hd.getUTXOMetadata('11111', 0).memo, 'somememo');
    assert.strictEqual(hd.getUTXOMetadata('11111', 0).frozen, true);

    // now .getUtxo() should return a limited UTXO set
    assert.ok(hd.getUtxo().length === 1);
    assert.strictEqual(hd.getUtxo()[0].txid, '22222');

    // now .getUtxo(true) should return a full UTXO set
    assert.ok(hd.getUtxo(true).length === 2);

    // for UTXO with no metadata .getUTXOMetadata() should return an empty object
    assert.ok(Object.keys(hd.getUTXOMetadata('22222', 0)).length === 0);
  });

  it('can sign and verify messages', async () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(mnemonic);
    let signature;

    // external address
    signature = hd.signMessage('vires is numeris', hd._getExternalAddressByIndex(0));
    assert.strictEqual(signature, 'KGW4FfrptS9zV3UptUWxbEf65GhC2mCUz86G0GpN/H4MUC29Y5TsRhWGIqG2lettEpZXZETuc2yL+O7/UvDhxhM=');
    assert.strictEqual(hd.verifyMessage('vires is numeris', hd._getExternalAddressByIndex(0), signature), true);

    // internal address
    signature = hd.signMessage('vires is numeris', hd._getInternalAddressByIndex(0));
    assert.strictEqual(signature, 'KJ5B9JkZ042FhtGeObU/MxLCzQWHbrpXNQxhfJj9wMboa/icLIIaAlsKaSkS27fZLvX3WH0qyj3aAaXscnWsfSw=');
    assert.strictEqual(hd.verifyMessage('vires is numeris', hd._getInternalAddressByIndex(0), signature), true);

    // multiline message
    signature = hd.signMessage('vires\nis\nnumeris', hd._getExternalAddressByIndex(0));
    assert.strictEqual(signature, 'KFI22tlJVGq2HGQM5rcBtYu+Jq8oc7QyjSBP1ZQup3a/GEw1Khu2qFbL/iLzqw95wN22a/Tll1oMLdWxg9cWMYM=');
    assert.strictEqual(hd.verifyMessage('vires\nis\nnumeris', hd._getExternalAddressByIndex(0), signature), true);

    // can't sign if address doesn't belong to wallet
    assert.throws(() => hd.signMessage('vires is numeris', '186FBQmCV5W1xY7ywaWtTZPAQNciVN8Por'));

    // can't verify wrong signature
    assert.throws(() => hd.verifyMessage('vires is numeris', hd._getInternalAddressByIndex(0), 'wrong signature'));

    // can verify electrum message signature
    // bech32 segwit (p2wpkh)
    assert.strictEqual(
      hd.verifyMessage(
        'vires is numeris',
        'bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el',
        'Hya6IaZGbKF83eOmC5i1CX5V42Wqkf+eSMi8S+hvJuJrDmp5F56ivrHgAzcxNIShIpY2lJv76M2LB6zLV70KxWQ=',
      ),
      true,
    );
    // p2sh-segwit (p2wpkh-p2sh)
    assert.strictEqual(
      hd.verifyMessage(
        'vires is numeris',
        '37VucYSaXLCAsxYyAPfbSi9eh4iEcbShgf',
        'IBm8XAd/NdWjjUBXr3pkXdVk1XQBHKPkBy4DCmSG0Ox4IKOLb1O+V7cTXPQ2vm3rcYquF+6iKSPJDiE1TPrAswY=',
      ),
      true,
    );
    // legacy
    assert.strictEqual(
      hd.verifyMessage(
        'vires is numeris',
        '1LqBGSKuX5yYUonjxT5qGfpUsXKYYWeabA',
        'IDNPawFev2E+W1xhHYi6NKuj7BY2Xe9qvXfddoWL4XZcPridoizzm8pda6jGEIwHlVYe4zrGhYqUR+j2hOsQxD8=',
      ),
      true,
    );
  });

  it('can use mnemonic with passphrase', () => {
    const mnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
    const passphrase = 'super secret passphrase';
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(mnemonic);
    hd.setPassphrase(passphrase);

    assert.strictEqual(
      hd.getXpub(),
      'zpub6qNvUL1qNQwaReccveprgd4urE2EUvShpcFe7WB9tzf9L4NJNcWhPzJSk4fzNXqBNZdRr6135hBKaqqp5RVvyxZ6eMbZXL6u5iK4zrfkCaQ',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1qgaj3satczjem43pz46ct6r3758twhnny4y720z');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1qthe7wh5eplzxczslvthyrer36ph3kxpnfnxgjg');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'L1tfV6fbRjDNwGQdJqHC9fneM9bTHigApnWgoKoU8JwgziwbbE7i');
  });

  it('can create with custom derivation path', async () => {
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');
    hd.setDerivationPath("m/84'/0'/1'");

    assert.strictEqual(
      hd.getXpub(),
      'zpub6rFR7y4Q2AijF6Gk1bofHLs1d66hKFamhXWdWBup1Em25wfabZqkDqvaieV63fDQFaYmaatCG7jVNUpUiM2hAMo6SAVHcrUpSnHDpNzucB7',
    );

    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1qku0qh0mc00y8tk0n65x2tqw4trlspak0fnjmfz');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1qt0x83f5vmnapgl2gjj9r3d67rcghvjaqrvgpck');
    assert.strictEqual(hd._getExternalWIFByIndex(0), 'L4ouJZjss1Ua8LPhsJNkzN8V8uXrQpfADNsqzsaT5JHs1G752c9j');

    assert.strictEqual(hd._getDerivationPathByAddress(hd._getExternalAddressByIndex(0)), "m/84'/0'/1'/0/0");
    assert.strictEqual(hd._getDerivationPathByAddress(hd._getInternalAddressByIndex(0)), "m/84'/0'/1'/1/0");
  });

  it('can generate ID', () => {
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret('abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about');
    const id1 = hd.getID();
    hd.setPassphrase('super secret passphrase');
    const id2 = hd.getID();
    hd.setDerivationPath("m/84'/0'/1'");
    const id3 = hd.getID();

    assert.notStrictEqual(id1, id2);
    assert.notStrictEqual(id2, id3);
    assert.notStrictEqual(id1, id3);
  });

  it('can createTransaction with a correct feerate (with lenghty segwit address)', () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);
    assert.ok(hd.validateMnemonic());

    const utxo = [
      {
        address: 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl',
        vout: 0,
        txid: '8b0ab2c7196312e021e0d3dc73f801693826428782970763df6134457bd2ec20',
        value: 69909,
        wif: '-',
      },
    ];

    const { tx, psbt, outputs } = hd.createTransaction(
      utxo,
      [{ address: 'bc1qtmcfj7lvgjp866w8lytdpap82u7eege58jy52hp4ctk0hsncegyqel8prp', value: 546 }],
      10,
      'bc1qtmcfj7lvgjp866w8lytdpap82u7eege58jy52hp4ctk0hsncegyqel8prp',
    );

    assert.strictEqual(outputs.length, 2);

    const actualFeerate = Number(psbt.getFee()) / tx.virtualSize();
    assert.strictEqual(
      Math.round(actualFeerate) >= 10 && actualFeerate <= 11,
      true,
      `bad feerate, got ${actualFeerate}, expected at least 10; fee: ${psbt.getFee()}; virsualSize: ${tx.virtualSize()} vbytes; ${tx.toHex()}`,
    );
  });

  it('can createTransaction with OP_RETURN', () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(process.env.HD_MNEMONIC_BIP84);
    assert.ok(hd.validateMnemonic());

    const utxo = [
      {
        address: 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl',
        vout: 0,
        txid: '8b0ab2c7196312e021e0d3dc73f801693826428782970763df6134457bd2ec20',
        value: 69909,
        wif: '-',
      },
    ];

    const { tx, psbt, outputs } = hd.createTransaction(
      utxo,
      [
        { address: hd._getExternalAddressByIndex(0), value: 546 },
        { script: { hex: '00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff' }, value: 0 },
      ],
      150,
      hd._getInternalAddressByIndex(0),
    );

    assert.strictEqual(outputs.length, 3); // destination, op_return, change
    assert.ok(!outputs[1].address); // should not be there as it should be OP_RETURN

    const decodedTx = bitcoin.Transaction.fromHex(tx.toHex());
    // console.log(decodedTx.outs);

    assert.strictEqual(decodedTx.outs[0].value, 546n); // first output - destination
    assert.strictEqual(decodedTx.outs[1].value, 0n); // second output - op_return
    assert.ok(decodedTx.outs[2].value > 0); // third output - change

    assert.strictEqual(uint8ArrayToHex(decodedTx.outs[1].script), '00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff'); // custom script that we are passing

    // console.log(outputs);

    const actualFeerate = Number(psbt.getFee()) / tx.virtualSize();
    assert.strictEqual(
      Math.round(actualFeerate) >= 150 && actualFeerate < 151,
      true,
      `bad feerate, got ${actualFeerate}, expected at least 11; fee: ${psbt.getFee()}; virsualSize: ${tx.virtualSize()} vbytes; ${tx.toHex()}`,
    );
  });

  it('can use french seed', async () => {
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret('abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abaisser abeille');

    assert.strictEqual(true, hd.validateMnemonic());
    assert.strictEqual(hd._getExternalAddressByIndex(0), 'bc1q3gsf7a6es9603g9a2k50lqxxxtd7x9pt7r5z9s');
    assert.strictEqual(hd._getInternalAddressByIndex(0), 'bc1q3ugpcustjrtt806uc5kqutlv5ue5sv0cfcr93c');
  });

  it('can import from standard SeedQR', () => {
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret('008607501025021714880023171503630517020917211425');
    assert.strictEqual(hd.getSecret(), 'approve fruit lens brass ring actual stool coin doll boss strong rate');
    assert.ok(hd.validateMnemonic());

    const hd2 = new HDSegwitBech32Wallet();
    hd2.setSecret('075707570757075700000000043911730136013601360757');
    assert.strictEqual(hd2.getSecret(), 'gadget gadget gadget gadget abandon abandon dad naive baby baby baby gadget');
    assert.ok(hd2.validateMnemonic());

    const hd3 = new HDSegwitBech32Wallet();
    hd3.setSecret('0757075707570757000000000439117301360136013607'); // invalid length
    assert.ok(!hd3.validateMnemonic());

    const hd4 = new HDSegwitBech32Wallet();
    hd4.setSecret('07570757075707abcdef0000043911730136013601360757'); // invalid symbols

    assert.ok(!hd4.validateMnemonic());
  });
});


================================================
FILE: ./tests/unit/encryption.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';

import * as c from '../../malin_modules/encryption';

describe('unit - encryption', function () {
  it('encrypts and decrypts', function () {
    const data2encrypt = 'really long data string bla bla really long data string bla bla really long data string bla bla';
    const crypted = c.encrypt(data2encrypt, 'password');
    const decrypted = c.decrypt(crypted, 'password');

    assert.ok(crypted);
    assert.ok(decrypted);
    assert.strictEqual(decrypted, data2encrypt);
    assert.ok(crypted !== data2encrypt);

    let decryptedWithBadPassword;
    try {
      decryptedWithBadPassword = c.decrypt(crypted, 'passwordBad');
    } catch (e) {}
    assert.ok(!decryptedWithBadPassword);

    let exceptionRaised = false;
    try {
      c.encrypt('yolo', 'password');
    } catch (_) {
      exceptionRaised = true;
    }
    assert.ok(exceptionRaised);
  });

  it('handles ok malformed data', function () {
    const decrypted = c.decrypt(
      'U2FsdGVkX1/OSNdi0JrLANn9qdNEiXgP20MJgT13CMKC7xKe+sb7x0An6r8lzrYeL2vjoPm2Xi5I3UdBcsgjgh0TR4PypNdDaW1tW8LhFH1wVCh1hacrFsJjoKMBmdCn4IVMwtIffGPptqBrGZl+6kjOc3BBbgq4uaAavFIwTS86WdaRt9qAboBcoPJZxsj37othbZfZfl2GBTCWnR1tOYAbElKWv4lBwNQpX7HqX3wTQkAbamBslsH5FfZRY1c38lOHrZMwNSyxhgspydksTxKkhPqWQu3XWT4GpRoRuVvYlBNvJOCUu2JbiVSp4NiOMSfnA8ahvpCGRNy+qPWsXqmJtz9BwyzedzDkgg6QOqxXz4oOeEJa/XLKiuv3ItsLrZb+sSA6wjB1Cx6/Oh2vW7eiHjCITeC7KUK1fAxVwufLcprNkvG8qFzkOcHxDyzG+sNL0cMipAxhpMX7qIcYcZFoLYkQRQHpOZKZCIAdNTfPGJ7M4cxGM0V+Uuirjyn+KAPJwNElwmPpX8sTQyEqlIlEwVjFXBpz28N5RAGN2zzCzEjD8NVYQJ2QyHj0gfWe',
      'fakePassword',
    );
    assert.ok(!decrypted);
  });

  it('can decrypt cipher created by CryptoJS@3.1.9-1', () => {
    const data2decrypt = 'really long data string bla bla really long data string bla bla really long data string bla bla';
    const crypted =
      'U2FsdGVkX19fJ4PcLum+tmBpEVNgGGsGKOhRS21cEcYAox+Df8VqmnnG9t2PvpM05eWImCRArorVUUegtcfSq314WMFzxKmiPIl9eqV1aOY+VFGuIBx0VIVsCWix2Q7sRZZwnOVpG5bdveZI0+Azyw==';
    const decrypted = c.decrypt(crypted, 'password');
    assert.deepEqual(data2decrypt, decrypted);
  });
});


================================================
FILE: ./tests/unit/cosign.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/* global it, describe */
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { HDLegacyP2PKHWallet, HDSegwitBech32Wallet, HDSegwitP2SHWallet, WatchOnlyWallet } from '../../class';
import { CreateTransactionUtxo } from '../../class/wallets/types.ts';
import { Transaction } from 'bitcoinjs-lib';
import { hexToUint8Array } from '../../malin_modules/uint8array-extras/index';

describe('AbstractHDElectrumWallet.cosign', () => {
  it('different descendants of AbstractHDElectrumWallet can cosign one transaction', async () => {
    if (!process.env.HD_MNEMONIC || !process.env.HD_MNEMONIC_BIP49) {
      console.error('process.env.HD_MNEMONIC or HD_MNEMONIC_BIP49 not set, skipped');
      return;
    }

    const w1 = new HDLegacyP2PKHWallet();
    w1.setSecret(process.env.HD_MNEMONIC);
    assert.ok(w1.validateMnemonic());
    const w1Utxo = [
      {
        height: 554830,
        value: 10000,
        address: '186FBQmCV5W1xY7ywaWtTZPAQNciVN8Por',
        vout: 0,
        txid: '4f65c8cb159585c00d4deba9c5b36a2bcdfb1399a561114dcf6f2d0c1174bc5f',
        amount: 10000,
        confirmations: 1,
        txhex:
          '01000000000101e8d98effbb4fba4f0a89bcf217eb5a7e2f8efcae44f32ecacbc5d8cc3ce683c301000000171600148ba6d02e74c0a6e000e8b174eb2ed44e5ea211a6ffffffff0510270000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac204e0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac30750000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac409c0000000000001976a914bc2db6b74c8db9b188711dcedd511e6a305603f588ac204716000000000017a914e286d58e53f9247a4710e51232cce0686f16873c8702483045022100af3800cd8171f154785cf13f46c092f61c1668f97db432bb4e7ed7bc812a8c6d022051bddca1eaf1ad8b5f3bd0ccde7447e56fd3c8709e5906f02ec6326e9a5b2ff30121039a421d5eb7c9de6590ae2a471cb556b60de8c6b056beb907dbdc1f5e6092f58800000000',
      },
    ];

    const w2 = new HDSegwitBech32Wallet();
    w2.setSecret(process.env.HD_MNEMONIC);
    assert.ok(w2.validateMnemonic());
    const w2Utxo = [
      {
        height: 563077,
        value: 50000,
        address: 'bc1qt4t9xl2gmjvxgmp5gev6m8e6s9c85979ta7jeh',
        vout: 1,
        txid: 'ad00a92409d8982a1d7f877056dbed0c4337d2ebab70b30463e2802279fb936d',
        amount: 50000,
        confirmations: 1,
      },
    ];

    const w3 = new HDSegwitP2SHWallet();
    w3.setSecret(process.env.HD_MNEMONIC_BIP49);
    assert.ok(w3.validateMnemonic());
    const w3Utxo = [
      {
        height: 591862,
        value: 26000,
        address: '3C5iv2Hp6nfuhkfTZibb7GJPkXj367eurD',
        txid: 'fe9c4d1b240f270e9cda227c48e29b2983cb26aaab183b34454871d5d9acc987',
        vout: 0,
        amount: 26000,
        confirmations: 1,
      },
    ];

    // now let's create transaction with 3 different inputs for each wallet and one output
    // maybe in future bitcoin-js will support psbt.join() and this test can be simplified to:
    //  const { psbt } = w1.createTransaction(w1Utxo, [{address: w1._getExternalAddressByIndex(0)}], 1, w1._getInternalAddressByIndex(0), undefined, true)
    //  const { psbt:psbt2 } = w2.createTransaction(w2Utxo, [{address: w2._getExternalAddressByIndex(0)}], 1, w2._getInternalAddressByIndex(0), undefined, true)
    //  const { psbt:psbt3 } = w3.createTransaction(w3Utxo, [{address: w3._getExternalAddressByIndex(0)}], 1, w3._getInternalAddressByIndex(0), undefined, true)
    //  psbt.join(psbt2, psbt3)
    // but for now, we will construct psbt by hand

    const sequence = HDSegwitBech32Wallet.defaultRBFSequence;
    const masterFingerprintBuffer = new Uint8Array([0x00, 0x00, 0x00, 0x00]);
    const psbt = new bitcoin.Psbt();

    // add one input from each wallet
    {
      // w1
      const input = w1Utxo[0];
      const pubkey = w1._getPubkeyByAddress(input.address);
      const path = w1._getDerivationPathByAddress(input.address);
      assert.ok(path);
      assert.ok(pubkey);

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        bip32Derivation: [
          {
            masterFingerprint: masterFingerprintBuffer,
            path,
            pubkey,
          },
        ],
        // non-segwit inputs now require passing the whole previous tx as Buffer
        nonWitnessUtxo: hexToUint8Array(input.txhex),
      });
    }

    {
      // w2
      const input = w2Utxo[0];
      const pubkey = w2._getPubkeyByAddress(input.address);
      const path = w2._getDerivationPathByAddress(input.address);
      assert.ok(pubkey);
      assert.ok(path);
      const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });
      assert.ok(p2wpkh.output);

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        bip32Derivation: [
          {
            masterFingerprint: masterFingerprintBuffer,
            path,
            pubkey,
          },
        ],
        witnessUtxo: {
          script: p2wpkh.output,
          value: BigInt(input.value),
        },
      });
    }

    {
      // w3
      const input = w3Utxo[0];
      const pubkey = w3._getPubkeyByAddress(input.address);
      const path = w3._getDerivationPathByAddress(input.address);
      assert.ok(pubkey);
      assert.ok(path);
      const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });
      const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });
      assert.ok(p2sh.output);

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        bip32Derivation: [
          {
            masterFingerprint: masterFingerprintBuffer,
            path,
            pubkey,
          },
        ],
        witnessUtxo: {
          script: p2sh.output,
          value: BigInt(input.value),
        },
        redeemScript: p2wpkh.output,
      });
    }

    // send all to the one output
    psbt.addOutput({
      address: w1._getExternalAddressByIndex(0),
      value: 10000n,
    });

    assert.strictEqual(
      psbt.toBase64(),
      'cHNidP8BAKcCAAAAA1+8dBEMLW/PTRFhpZkT+80rarPFqetNDcCFlRXLyGVPAAAAAAAAAACAbZP7eSKA4mMEs3Cr69I3Qwzt21Zwh38dKpjYCSSpAK0BAAAAAAAAAICHyazZ1XFIRTQ7GKuqJsuDKZviSHwi2pwOJw8kG02c/gAAAAAAAAAAgAEQJwAAAAAAABl2qRRNxsv2TfmrEGzugSx1AZYLk+khd4isAAAAAAABAP1gAQEAAAAAAQHo2Y7/u0+6TwqJvPIX61p+L478rkTzLsrLxdjMPOaDwwEAAAAXFgAUi6bQLnTApuAA6LF06y7UTl6iEab/////BRAnAAAAAAAAGXapFE3Gy/ZN+asQbO6BLHUBlguT6SF3iKwgTgAAAAAAABl2qRS8Lba3TI25sYhxHc7dUR5qMFYD9YisMHUAAAAAAAAZdqkUTcbL9k35qxBs7oEsdQGWC5PpIXeIrECcAAAAAAAAGXapFLwttrdMjbmxiHEdzt1RHmowVgP1iKwgRxYAAAAAABepFOKG1Y5T+SR6RxDlEjLM4GhvFoc8hwJIMEUCIQCvOADNgXHxVHhc8T9GwJL2HBZo+X20MrtOfte8gSqMbQIgUb3coerxrYtfO9DM3nRH5W/TyHCeWQbwLsYybppbL/MBIQOaQh1et8neZZCuKkcctVa2DejGsFa+uQfb3B9eYJL1iAAAAAAiBgMW6EolVvMKGZVBYz9d2meHcQzKsmdxtwhPTJ4RBPR2ZxgAAAAALAAAgAAAAIAAAACAAAAAAAAAAAAAAQEfUMMAAAAAAAAWABRdVlN9SNyYZGw0RlmtnzqBcHoXxSIGAnqv8b0nSBLQEkZL4l3AZYcoektXhnjljJSaEzufuTx/GAAAAABUAACAAAAAgAAAAIAAAAAAAQAAAAABASCQZQAAAAAAABepFHH8oGeDfo3SSYkgJqW15AVPiyXhhwEEFgAUojm2oMvHqtwud2Q942MGphZ/rRUiBgICrDvRWeVNwx5lhCrV+aELTrAk6DhkoxmyfeZe4IsqORgAAAAAMQAAgAAAAIAAAACAAAAAAAAAAAAAAA==',
    );

    // now signing this psbt usign wallets one by one
    // because BW users will pass psbt from one device to another base64 encoded, let's do the same

    let tx;

    assert.strictEqual(w1.calculateHowManySignaturesWeHaveFromPsbt(psbt), 0);
    tx = w1.cosignPsbt(psbt).tx;
    assert.strictEqual(w1.calculateHowManySignaturesWeHaveFromPsbt(psbt), 1);
    assert.strictEqual(tx, false); // not yet fully-signed

    tx = w2.cosignPsbt(psbt).tx;
    assert.strictEqual(w2.calculateHowManySignaturesWeHaveFromPsbt(psbt), 2);
    assert.strictEqual(tx, false); // not yet fully-signed

    tx = w3.cosignPsbt(psbt).tx; // GREAT SUCCESS!
    assert.strictEqual(w3.calculateHowManySignaturesWeHaveFromPsbt(psbt), 3);
    assert.ok(tx);
    assert.ok(tx instanceof Transaction);

    assert.strictEqual(
      tx.toHex(),
      '020000000001035fbc74110c2d6fcf4d1161a59913fbcd2b6ab3c5a9eb4d0dc0859515cbc8654f000000006a473044022041df555e5f6a3769fafdbe23bfe29de84a1341b8fd85ffd279e238309c5df07702207cf1628b35ccacdb7d34e20fd46a3bc8adc0b1bd3b63249a3a4442b5a993d73501210316e84a2556f30a199541633f5dda6787710ccab26771b7084f4c9e1104f47667000000806d93fb792280e26304b370abebd237430ceddb5670877f1d2a98d80924a900ad01000000000000008087c9acd9d5714845343b18abaa26cb83299be2487c22da9c0e270f241b4d9cfe0000000017160014a239b6a0cbc7aadc2e77643de36306a6167fad15000000800110270000000000001976a9144dc6cbf64df9ab106cee812c7501960b93e9217788ac0002483045022100efe66403aba1441041dfdeff1f24b5e89ab5728ae7ceb9edb264eee004d5883c02207bf03cb611c9322086ac75fa97c374e9540c911359ede4f62de3c94c429ea2320121027aaff1bd274812d012464be25dc06587287a4b578678e58c949a133b9fb93c7f0247304402207a99c115f0b372d151caf991bb5af9f880e7d87625eeb4233fefa671489ed8e702200e5675b92e4e22b2fe37f563b2a0e75fb81def5a6efb431c7ca3b654ef63fe5801210202ac3bd159e54dc31e65842ad5f9a10b4eb024e83864a319b27de65ee08b2a3900000000',
    );
  });

  it('HDSegwitBech32Wallet can cosign psbt with correct fingerprint', async () => {
    if (!process.env.MNEMONICS_COBO) {
      console.error('process.env.HD_MNEMONIC or HD_MNEMONIC_BIP49 not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.MNEMONICS_COBO);
    assert.ok(w.validateMnemonic());

    const psbtWithCorrectFpBase64 =
      'cHNidP8BAFUCAAAAAfsmeQ1mJJqC9cD0DxDRFQoG2hvU6S4koB0jl+8TEDKjAAAAAAD/////AQpfAAAAAAAAGXapFBkSnVPmMZuvGdugWb6tFm35Crj1iKwAAAAAAAEBH8p3AAAAAAAAFgAUf8fcrCg92McSzWkmw+UAluC4IjsiBgLfsmddhS3oxlnlGrUPDBVoVHSMa8RcXlGsyhfc8CcGpRjTfq2IVAAAgAAAAIAAAACAAAAAAAQAAAAAAA==';
    const psbtWithCorrectFp = bitcoin.Psbt.fromBase64(psbtWithCorrectFpBase64);

    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbtWithCorrectFp), 0);

    const { tx } = w.cosignPsbt(psbtWithCorrectFp);
    assert.ok(tx instanceof Transaction);
    assert.ok(tx && tx.toHex());
    assert.strictEqual(w.calculateHowManySignaturesWeHaveFromPsbt(psbtWithCorrectFp), 1);
  });

  it('can cosign with non-zero account', async () => {
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    const signerWallet = new HDSegwitBech32Wallet();
    signerWallet.setSecret(process.env.HD_MNEMONIC_BIP84);
    signerWallet.setDerivationPath("m/84'/0'/1'"); // account 1

    // setting up watch-only wallet that tracks signer wallet, with the same fp & path:
    const watchOnlyWallet = new WatchOnlyWallet();
    watchOnlyWallet.setSecret(
      `{"ExtPubKey":"${signerWallet.getXpub()}","MasterFingerprint":"${signerWallet.getMasterFingerprintHex()}","AccountKeyPath":"${signerWallet.getDerivationPath()}"}`,
    );
    watchOnlyWallet.init();

    // hardcoding valid utxo (unspent at the momend of coding):
    const utxos: CreateTransactionUtxo[] = [
      {
        value: 10000,
        address: 'bc1q79hsqzg9q6d36ftyncwv2drg7pyt66pamghn9n',
        vout: 0,
        txid: 'e598c705bef463e2e12d7bebc15e3cf0a34477679c3c21de9693987c6de8f15e',
        wif: '',
      },
    ];

    // creating a tx on watch-only wallet:
    const { psbt } = watchOnlyWallet.createTransaction(
      utxos,
      [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 1000 }],
      1,
      watchOnlyWallet._getInternalAddressByIndex(0),
    );
    assert.strictEqual(psbt.data.outputs.length, 2);
    assert.strictEqual(psbt.data.inputs.length, 1);

    // signing this tx with signer wallet
    const { tx } = signerWallet.cosignPsbt(psbt);
    assert.ok(tx);
    assert.ok(tx instanceof Transaction);
    assert.ok(tx.toHex());

    assert.strictEqual(
      tx.toHex(),
      '020000000001015ef1e86d7c989396de213c9c677744a3f03c5ec1eb7b2de1e263f4be05c798e500000000000000008002e8030000000000001976a91419129d53e6319baf19dba059bead166df90ab8f588ac9622000000000000160014063e495b0228ad29d537f90586ff0965718ee78602483045022100f56f9337a7c4f2e4176852131a6176bdf72daab1a64c6c00d1e4ae8a53c0caf50220159f36793bad0bbacdff5660991c3246d9930796a0a34a9d7a8f4bc3da67c9d90121024328b820f06c591b1a8790a4a3ee7a8679f672879b750a205d6e2c02660e19ac00000000',
    );
  });
});


================================================
FILE: ./tests/unit/legacy-wallet.test.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import { LegacyWallet } from '../../class';

describe('Legacy wallet', () => {
  it('can validate addresses', () => {
    const w = new LegacyWallet();
    assert.ok(w.isAddressValid('12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG'));
    assert.ok(!w.isAddressValid('12eQ9m4sgAwTSQoNXkRABKhCXCsjm2j'));
    assert.ok(w.isAddressValid('3BDsBDxDimYgNZzsqszNZobqQq3yeUoJf2'));
    assert.ok(!w.isAddressValid('3BDsBDxDimYgNZzsqszNZobqQq3yeUo'));
    assert.ok(!w.isAddressValid('12345'));
    assert.ok(w.isAddressValid('bc1quuafy8htjjj263cvpj7md84magzmc8svmh8lrm'));
    assert.ok(w.isAddressValid('BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7'));

    // taproot:
    assert.ok(!w.isAddressValid('bc1pw5dgrnzv')); // v1, data length != 32
    assert.ok(!w.isAddressValid('bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7v8n0nx0muaewav253zgeav')); // v1, data length != 32
    assert.ok(!w.isAddressValid('bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqh2y7hd')); // P2TR example with errors (using Bech32 instead of Bech32m)
    assert.ok(!w.isAddressValid('bc1p38j9r5y49hruaue7wxjce0updqjuyyx0kh56v8s25huc6995vvpql3jow4')); // invalid char
    assert.ok(!w.isAddressValid('BC130XLXVLHEMJA6C4DQV22UAPCTQUPFHLXM9H8Z3K2E72Q4K9HCZ7VQ7ZWS8R')); // invalid char
    assert.ok(!w.isAddressValid('bc1pllllllllllllllllllllllllllllllllllllllllllllallllscqlhrddu')); // X is modulo P + 1 (invalid X, but 1 is valid, testing if wrapped modulo (P+1 mod P === 1) will pass)
    assert.ok(!w.isAddressValid('bc1pllllllllllllllllllllllllllllllllllllllllllllallllshqcgyklh')); // X is modulo P - 1 (invalid X)
    assert.ok(!w.isAddressValid('bc1pqtllllllllllllllllllllllllllllllllllllllllllllhlll7zcsqylfl')); // data length is 33 (valid point in compressed DER format (33 bytes))
    assert.ok(!w.isAddressValid('bc1plllllllllllllllllllllllllllllllllllllllllll0lllu9cegrnmx')); // data is length 31 (valid X value with leading 0x00 trimmed)

    assert.ok(w.isAddressValid('bc1pw38ttcljvgv9x64xpsq99dl9auy8vv50n25xcstuj2cagzcpx3us2m25kg'));
    assert.ok(w.isAddressValid('bc1pqyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqsyjer9e'));
    assert.ok(w.isAddressValid('bc1pmfr3p9j00pfxjh0zmgp99y8zftmd3s5pmedqhyptwy6lm87hf5sspknck9'));
    assert.ok(w.isAddressValid('bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqzk5jj0'));

    assert.ok(!w.isAddressValid('BC1SW50QGDZ25J')); // v16, valid but unsafe
    assert.ok(!w.isAddressValid('bc1zw508d6qejxtdg4y5r3zarvaryvaxxpcs')); // v2, valid but unsafe
  });

  it('can create transaction', async () => {
    const l = new LegacyWallet();
    l.setSecret('L4ccWrPMmFDZw4kzAKFqJNxgHANjdy6b7YKNXMwB4xac4FLF3Tov');
    assert.strictEqual(l.getAddress(), '14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M');
    assert.deepStrictEqual(l.getAllExternalAddresses(), ['14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M']);
    assert.strictEqual(await l.getChangeAddressAsync(), l.getAddress());

    const utxos = [
      {
        txid: 'cc44e933a094296d9fe424ad7306f16916253a3d154d52e4f1a757c18242cec4',
        vout: 0,
        value: 100000,
        txhex:
          '0200000000010161890cd52770c150da4d7d190920f43b9f88e7660c565a5a5ad141abb6de09de00000000000000008002a0860100000000001976a91426e01119d265aa980390c49eece923976c218f1588ac3e17000000000000160014c1af8c9dd85e0e55a532a952282604f820746fcd02473044022072b3f28808943c6aa588dd7a4e8f29fad7357a2814e05d6c5d767eb6b307b4e6022067bc6a8df2dbee43c87b8ce9ddd9fe678e00e0f7ae6690d5cb81eca6170c47e8012102e8fba5643e15ab70ec79528833a2c51338c1114c4eebc348a235b1a3e13ab07100000000',
      },
    ];
    // ^^ only non-segwit inputs need full transaction txhex

    let txNew = l.createTransaction(utxos, [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], 1, l.getAddress());
    let tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    const satPerVbyte = txNew.fee / tx.virtualSize();
    assert.strictEqual(satPerVbyte, 1);
    assert.strictEqual(
      txNew.tx.toHex(),
      '0200000001c4ce4282c157a7f1e4524d153d3a251669f10673ad24e49f6d2994a033e944cc000000006b48304502210091e58bd2021f2eeea8d39d7f7b053c9ccc52a747b60f1c3584ba33285e2d150602205b2d35a2536cbe157015e8c54a26f5fc350cc7c72b5ca80b9e548917993f652201210337c09b3cb889801638078fd4e6998218b28c92d338ea2602720a88847aedceb3ffffffff02905f0100000000001976a914aa381cd428a4e91327fd4434aa0a08ff131f1a5a88ac2e260000000000001976a91426e01119d265aa980390c49eece923976c218f1588ac00000000',
    );
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual(l.getAddress(), bitcoin.address.fromOutputScript(tx.outs[1].script)); // change address

    // sendMax
    txNew = l.createTransaction(utxos, [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }], 1, l.getAddress());
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 1);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address

    // batch send + send max
    txNew = l.createTransaction(
      utxos,
      [{ address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }, { address: 'bc1q3rl0mkyk0zrtxfmqn9wpcd3gnaz00yv9yp0hxe', value: 10000 }],
      1,
      l.getAddress(),
    );
    tx = bitcoin.Transaction.fromHex(txNew.tx.toHex());
    assert.strictEqual(tx.ins.length, 1);
    assert.strictEqual(tx.outs.length, 2);
    assert.strictEqual('1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB', bitcoin.address.fromOutputScript(tx.outs[0].script)); // to address
    assert.strictEqual('bc1q3rl0mkyk0zrtxfmqn9wpcd3gnaz00yv9yp0hxe', bitcoin.address.fromOutputScript(tx.outs[1].script)); // to address
  });

  it('can create transaction with better UTXO selection', async () => {
    const l = new LegacyWallet();
    l.setSecret('L4ccWrPMmFDZw4kzAKFqJNxgHANjdy6b7YKNXMwB4xac4FLF3Tov');

    const utxos = [
      {
        txid: 'cc44e933a094296d9fe424ad7306f16916253a3d154d52e4f1a757c18242cec4',
        vout: 0,
        value: 1000,
        txhex:
          '0200000000010161890cd52770c150da4d7d190920f43b9f88e7660c565a5a5ad141abb6de09de00000000000000008002a0860100000000001976a91426e01119d265aa980390c49eece923976c218f1588ac3e17000000000000160014c1af8c9dd85e0e55a532a952282604f820746fcd02473044022072b3f28808943c6aa588dd7a4e8f29fad7357a2814e05d6c5d767eb6b307b4e6022067bc6a8df2dbee43c87b8ce9ddd9fe678e00e0f7ae6690d5cb81eca6170c47e8012102e8fba5643e15ab70ec79528833a2c51338c1114c4eebc348a235b1a3e13ab07100000000',
      },
      {
        txid: 'cc44e933a094296d9fe424ad7306f16916253a3d154d52e4f1a757c18242cec4',
        vout: 1,
        value: 1000,
        txhex:
          '0200000000010161890cd52770c150da4d7d190920f43b9f88e7660c565a5a5ad141abb6de09de00000000000000008002a0860100000000001976a91426e01119d265aa980390c49eece923976c218f1588ac3e17000000000000160014c1af8c9dd85e0e55a532a952282604f820746fcd02473044022072b3f28808943c6aa588dd7a4e8f29fad7357a2814e05d6c5d767eb6b307b4e6022067bc6a8df2dbee43c87b8ce9ddd9fe678e00e0f7ae6690d5cb81eca6170c47e8012102e8fba5643e15ab70ec79528833a2c51338c1114c4eebc348a235b1a3e13ab07100000000',
      },

      {
        txid: 'cc44e933a094296d9fe424ad7306f16916253a3d154d52e4f1a757c18242cec4',
        vout: 2,
        value: 69000000,
        txhex:
          '0200000000010161890cd52770c150da4d7d190920f43b9f88e7660c565a5a5ad141abb6de09de00000000000000008002a0860100000000001976a91426e01119d265aa980390c49eece923976c218f1588ac3e17000000000000160014c1af8c9dd85e0e55a532a952282604f820746fcd02473044022072b3f28808943c6aa588dd7a4e8f29fad7357a2814e05d6c5d767eb6b307b4e6022067bc6a8df2dbee43c87b8ce9ddd9fe678e00e0f7ae6690d5cb81eca6170c47e8012102e8fba5643e15ab70ec79528833a2c51338c1114c4eebc348a235b1a3e13ab07100000000',
      },
    ];
    // ^^ only non-segwit inputs need full transaction txhex

    const { psbt } = l.createTransaction(
      utxos,
      [{ value: 60000000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }],
      1,
      l.getAddress(),
      0,
      true,
    );
    assert.strictEqual(psbt.data.inputs.length, 1);
  });

  it("throws error if you can't create wallet from this entropy", async () => {
    const l = new LegacyWallet();
    const zeroes = [...Array(32)].map(() => 0);
    await assert.rejects(async () => await l.generateFromEntropy(Buffer.from(zeroes)), {
      name: 'TypeError',
      message: 'Private key not in range [1, n)',
    });
  });

  it('can consume user generated entropy', async () => {
    const l = new LegacyWallet();
    const values = [...Array(32)].map(() => 1);
    await l.generateFromEntropy(Buffer.from(values));
    assert.strictEqual(l.getSecret(), 'KwFfNUhSDaASSAwtG7ssQM1uVX8RgX5GHWnnLfhfiQDigjioWXHH');
  });

  it('throws an error if not 32 bytes provided', async () => {
    const l = new LegacyWallet();
    const values = [...Array(31)].map(() => 1);
    await assert.rejects(async () => await l.generateFromEntropy(Buffer.from(values)), {
      message: 'Entropy should be 32 bytes',
    });
  });

  it('can sign and verify messages', async () => {
    const l = new LegacyWallet();
    l.setSecret('L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1'); // from bitcoinjs-message examples

    const signature = l.signMessage('This is an example of a signed message.', l.getAddress());
    assert.strictEqual(signature, 'H9L5yLFjti0QTHhPyFrZCT1V/MMnBtXKmoiKDZ78NDBjERki6ZTQZdSMCtkgoNmp17By9ItJr8o7ChX0XxY91nk=');
    assert.strictEqual(l.verifyMessage('This is an example of a signed message.', l.getAddress(), signature), true);
  });

  it('can sign and verify messages with uncompressed key', async () => {
    const l = new LegacyWallet();
    l.setSecret('5JqSfbkoVDrzM5i7PH7939G5fwWVDWmnFTSMbVctAmet3tYMq2S');

    const signature = l.signMessage('This is an example of a signed message.', l.getAddress());
    assert.strictEqual(signature, 'G19XLC0OYWN5ftv3N01s1PSt9Zpy0ZRKL2THZA46qGb0Jax29+SFmsdlsup0QKFeGJYN+m2HQTG1Na+YxcjU9ew=');
    assert.strictEqual(l.verifyMessage('This is an example of a signed message.', l.getAddress(), signature), true);
  });
});


================================================
FILE: ./tests/unit/transaction-status.test.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { render, waitFor } from '@testing-library/react-native';

import TransactionStatus from '../../screen/transactions/TransactionStatus';

type MockStorage = {
  wallets: any[];
  txMetadata: Record<string, any>;
  counterpartyMetadata: Record<string, any>;
  fetchAndSaveWalletTransactions: jest.Mock;
};

const mockFetchAndSaveWalletTransactions = jest.fn();
let mockStorageState: MockStorage = {
  wallets: [],
  txMetadata: {},
  counterpartyMetadata: {},
  fetchAndSaveWalletTransactions: mockFetchAndSaveWalletTransactions,
}

jest.mock('../../hooks/context/useStorage', () => ({
  useStorage: () => mockStorageState,
}));

let mockWalletSubscribe: any = null;

jest.mock('../../hooks/useWalletSubscribe', () => ({
  __esModule: true,
  default: () => mockWalletSubscribe,
}));

const routeParams = { hash: 'mock-tx', walletID: 'mock-wallet' };

jest.mock('@react-navigation/native', () => {
  const actual = jest.requireActual('@react-navigation/native');
  return {
    ...actual,
    useRoute: () => ({ params: routeParams }),
    useNavigation: () => ({
      navigate: jest.fn(),
      setOptions: jest.fn(),
      goBack: jest.fn(),
      addListener: jest.fn(),
    })
  }
})

jest.mock('../../hooks/useExtendedNavigation', () => ({
  useExtendedNavigation: () => ({
    navigate: jest.fn(),
    setOptions: jest.fn(),
    goBack: jest.fn(),
  })
}));

jest.mock('../../hooks/context/useSettings', () => ({
  useSettings: () => ({
    selectedBlockExplorer: { url: 'https://block.explorer' },
  })
}));

jest.mock('../../components/themes', () => ({
  useTheme: () => ({
    colors: {
      alternativeTextColor2: '#fff',
      success: '#0f0',
      successCheck: '#0f0',
      feeText: '#888',
      lightButton: '#222',
      buttonTextColor: '#000',
      elevated: '#111',
      buttonDisabledBackgroundColor: '#333',
      background: '#000',
      lightBorder: '#333',
      customHeader: '#000',
    },
  })
}));

jest.mock('../../MalinComponents', () => {
  const React = require('react');
  const { Text, View } = require('react-native');
  return {
    MalinCard: ({ children }: { children: React.ReactNode }) => (
      <View>{children}</View>
    ),
    MalinText: ({ children }: { children: React.ReactNode }) => (
      <Text>{children}</Text>
    )
  }
})

jest.mock('../../components/Button', () => 'Button');
jest.mock('../../components/HandOffComponent', () => 'HandOffComponent');
jest.mock('../../components/HeaderRightButton', () => 'HeaderRightButton');
jest.mock('../../components/MalinSpacing', () => ({
  MalinSpacing10: 'MalinSpacing10',
  MalinSpacing20: 'MalinSpacing20',
}));
jest.mock('../../components/MalinLoading', () => ({
  MalinLoading: 'MalinLoading',
}));
jest.mock(
  '../../components/SafeArea',
  () =>
    ({ children }: { children: React.ReactNode }) => <>{children}</>
);

jest.mock(
  '../../components/icons/TransactionIncomingIcon',
  () => 'TransactionIncomingIcon',
)
jest.mock(
  '../../components/icons/TransactionOutgoingIcon',
  () => 'TransactionOutgoingIcon',
)
jest.mock(
  '../../components/icons/TransactionPendingIcon',
  () => 'TransactionPendingIcon',
)

jest.mock('@rneui/themed', () => ({
  Icon: 'Icon',
}));

jest.mock('../../malin_modules/hapticFeedback', () => ({
  default: jest.fn(),
  HapticFeedbackTypes: {},
}));

jest.mock('../../malin_modules/MalinElectrum', () => ({
  multiGetTransactionByTxid: jest.fn(),
  getMempoolTransactionsByAddress: jest.fn(),
  estimateFees: jest.fn(),
}));

jest.mock('../../loc', () => ({
  __esModule: true,
  default: {
    formatString: (template: string, params: Record<string, any>) => {
      return Object.entries(params).reduce(
        (acc, [key, value]) => acc.replace(`{${key}}`, String(value)),
        template
      );
    },
    transactions: {
      eta_10m: '10 minutes',
      eta_3h: '3 hours',
      eta_1d: '1 day',
      status_bump: 'Bump Fee',
      status_cancel: 'Cancel',
      details_title: 'Transaction Details',
      confirmations_lowercase: 'confirmations: {confirmations}',
      transaction_loading_error: 'loading error',
      transaction_not_available: 'not available',
      copy_link: 'copy link',
      to: 'to {counterparty}',
      from: 'from {counterparty}',
      details_to: 'To',
      details_from: 'From',
      txid: 'txid',
      details_received: 'received',
      details_inputs: 'inputs',
      details_outputs: 'outputs',
      details_view_in_browser: 'view in browser',
    },
    send: {
      create_details: 'Details',
      create_fee: 'Fee',
    },
    _: {
      ok: 'OK',
      cancel: 'Cancel',
    },
  },
  formatBalanceWithoutSuffix: (value: number | string) => String(value),
}));

const mockTxBase = {
  hash: 'mock-tx',
  value: 1200,
  fee: 10,
  counterparty: undefined,
}

const setup = (confirmations: number, lastFetch: number) => {
  let currentConfirmations = confirmations;
  let currentLastFetch = lastFetch;

  const walletMock = {
    getID: () => 'mock-wallet',
    getTransactions: jest.fn(() => [
      { ...mockTxBase, confirmations: currentConfirmations }
    ]),
    getLastTxFetch: jest.fn(() => currentLastFetch),
    allowRBF: jest.fn(() => false),
    preferredBalanceUnit: 'BTC',
  } as any;

  mockStorageState = {
    ...mockStorageState,
    wallets: [walletMock],
  }

  mockWalletSubscribe = walletMock;

  const view = render(<TransactionStatus />);

  const update = async (nextConfirmations: number, nextFetch: number) => {
    currentConfirmations = nextConfirmations;
    currentLastFetch = nextFetch;

    // Create a new proxy to simulate what useWalletSubscribe does when lastTxFetch changes
    mockWalletSubscribe = new Proxy(walletMock, {});

    mockStorageState = {
      ...mockStorageState,
      wallets: [walletMock],
    }
    view.rerender(<TransactionStatus />);
    await waitFor(() => {
      expect(walletMock.getTransactions).toHaveBeenCalled();
    })
    return view;
  }

  return { walletMock, view, update };
}

describe('TransactionStatus regression', () => {
  beforeEach(() => {
    mockStorageState = {
      wallets: [],
      txMetadata: {},
      counterpartyMetadata: {},
      fetchAndSaveWalletTransactions: mockFetchAndSaveWalletTransactions,
    }
    mockWalletSubscribe = null;
  })

  afterEach(() => {
    jest.clearAllMocks();
  })

  it('re-fetches wallet transactions when lastTxFetch changes', async () => {
    const { view, update, walletMock } = setup(1, 1000);

    await waitFor(() => {
      expect(view.getByText('confirmations: 1')).toBeTruthy();
    })

    const initialCalls = walletMock.getTransactions.mock.calls.length;

    await update(4, 2000);

    await waitFor(() => {
      expect(walletMock.getTransactions).toHaveBeenCalledTimes(
        initialCalls + 1
      );
      expect(view.getByText('confirmations: 4')).toBeTruthy();
    })
  });
})


================================================
FILE: ./tests/unit/bip47.test.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP47Factory from '@spsina/bip47';
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';
import { ECPairFactory } from 'ecpair';

import ecc from '../../malin_modules/noble_ecc';
import { HDSegwitBech32Wallet, WatchOnlyWallet } from '../../class';
import { CreateTransactionUtxo } from '../../class/wallets/types';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

const ECPair = ECPairFactory(ecc);

describe('Bech32 Segwit HD (BIP84) with BIP47', () => {
  it('should work', async () => {
    const bobWallet = new HDSegwitBech32Wallet();
    // @see https://gist.github.com/SamouraiDev/6aad669604c5930864bd
    bobWallet.setSecret('reward upper indicate eight swift arch injury crystal super wrestle already dentist');

    expect(bobWallet.getBIP47PaymentCode()).toEqual(
      'PM8TJS2JxQ5ztXUpBBRnpTbcUXbUHy2T1abfrb3KkAAtMEGNbey4oumH7Hc578WgQJhPjBxteQ5GHHToTYHE3A1w6p7tU6KSoFmWBVbFGjKPisZDbP97',
    );
    assert.strictEqual(bobWallet.getBIP47NotificationAddress(), '1ChvUUvht2hUQufHBXF8NgLhW8SwE2ecGV'); // our notif address
    assert.ok(!bobWallet.weOwnAddress('1JDdmqFLhpzcUwPeinhJbUPw4Co3aWLyzW')); // alice notif address, we dont own it
  });

  it('getters, setters, flags work', async () => {
    const w = new HDSegwitBech32Wallet();
    await w.generate();

    expect(w.allowBIP47()).toEqual(true);

    expect(w.isBIP47Enabled()).toEqual(false);
    w.switchBIP47(true);
    expect(w.isBIP47Enabled()).toEqual(true);
    w.switchBIP47(false);
    expect(w.isBIP47Enabled()).toEqual(false);

    // checking that derived watch-only does not support that:
    const ww = new WatchOnlyWallet();
    ww.setSecret(w.getXpub());
    expect(ww.allowBIP47()).toEqual(false);
  });

  it('should work (samurai)', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[0]);
    w.setPassphrase('1');

    expect(w.getBIP47PaymentCode()).toEqual(
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    );

    expect(w._getExternalAddressByIndex(0)).toEqual('bc1q07l355j4yd5kyut36vjxn2u60d3dknnpt39t6y');

    const ourNotificationAddress = w.getBIP47NotificationAddress();

    const publicBip47 = BIP47Factory(ecc).fromPaymentCode(w.getBIP47PaymentCode());
    expect(ourNotificationAddress).toEqual(publicBip47.getNotificationAddress()); // same address we derived internally for ourselves and from public Payment Code
    expect(ourNotificationAddress).toEqual('1EiP2kSqxNqRhn8MPMkrtSEqaWiCWLYyTS'); // our notif address

    // since we dont do network calls in unit test we cant get counterparties payment codes from our notif address,
    // and thus, dont know collaborative addresses with our payers. lets hardcode our counterparty payment code to test
    // this functionality

    assert.deepStrictEqual(w.getBIP47SenderPaymentCodes(), []);

    w._receive_payment_codes = [
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    ];

    assert.deepStrictEqual(w.getBIP47SenderPaymentCodes(), [
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    ]);

    assert.ok(w.weOwnAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe'));
    const pubkey = w._getPubkeyByAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe');
    const path = w._getDerivationPathByAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe');
    assert.ok(pubkey);
    assert.ok(path);

    const keyPair2 = ECPair.fromWIF(w._getWIFbyAddress('bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe') || '');
    const address = bitcoin.payments.p2wpkh({
      pubkey: keyPair2.publicKey,
    }).address;

    assert.strictEqual(address, 'bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe');
  });

  it('should work (sparrow)', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[1]);

    assert.strictEqual(
      w.getXpub(),
      'zpub6r4KaQRsLuhHSGx8b9wGHh18UnawBs49jtiDzZYh9DSgKGwD72jWR3v54fkyy1UKVxt9HvCkYHmMAUe2YjKefofWzYp9YD62sUp6nNsEDMs',
    );

    expect(w.getBIP47PaymentCode()).toEqual(
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    );

    const ourNotificationAddress = w.getBIP47NotificationAddress();

    const publicBip47 = BIP47Factory(ecc).fromPaymentCode(w.getBIP47PaymentCode());
    expect(ourNotificationAddress).toEqual(publicBip47.getNotificationAddress()); // same address we derived internally for ourselves and from public Payment Code

    expect(ourNotificationAddress).toEqual('16xPugarxLzuNdhDu6XCMJBsMYrTN2fghN'); // our notif address
  });

  it('should be able to create notification transaction', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    // whom we are going to notify:
    const bip47instanceReceiver = BIP47Factory(ecc).fromBip39Seed(process.env.BIP47_HD_MNEMONIC.split(':')[0], undefined, '1');

    // notifier:
    const walletSender = new HDSegwitBech32Wallet();
    walletSender.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[1]);
    walletSender.switchBIP47(true);

    // lets produce a notification transaction and verify that receiver can actually use it

    // since we cant do network calls, we hardcode our senders so later `_getWIFbyAddress`
    // could resolve wif for address deposited by him (funds we want to use reside on addresses from BIP47)
    walletSender._receive_payment_codes = [
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    ];

    const utxos: CreateTransactionUtxo[] = [
      {
        value: 74822,
        address: 'bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt',
        txid: '73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d',
        vout: 0,
        wif: walletSender._getWIFbyAddress('bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt') + '',
      },
      {
        value: 894626,
        address: 'bc1qr60ek5gtjs04akcp9f5x25v5gyp2tmspx78jxl',
        txid: '64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f',
        vout: 0,
        wif: walletSender._getWIFbyAddress('bc1qr60ek5gtjs04akcp9f5x25v5gyp2tmspx78jxl') + '',
      },
    ];

    const changeAddress = 'bc1q7vraw79vcf7qhnefeaul578h7vjc7tr95ywfuq';

    const { tx, fee } = walletSender.createBip47NotificationTransaction(
      utxos,
      bip47instanceReceiver.getSerializedPaymentCode(),
      33,
      changeAddress,
    );
    assert(tx);

    const recoveredPaymentCode = bip47instanceReceiver.getPaymentCodeFromRawNotificationTransaction(tx.toHex());
    assert.strictEqual(walletSender.getBIP47PaymentCode(), recoveredPaymentCode); // accepted!

    assert.strictEqual(
      uint8ArrayToHex(tx.outs[1].script),
      '6a4c500100031c9282bd392ee9700a50d7161c5f76f7b89e7a6fb551bfd5660e79cc7c8d8e7f7676b25ab4db90a96fadfa1254741e09b35e27c7dc1abcd2dc93c4c32732f45400000000000000000000000000',
    );

    const actualFeerate = fee / tx.virtualSize();
    assert.strictEqual(Math.round(actualFeerate), 33);
  });

  it('should be able to pay to PC', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    // whom we are going to pay:
    const bip47instanceReceiver = BIP47Factory(ecc).fromBip39Seed(process.env.BIP47_HD_MNEMONIC.split(':')[0], undefined, '1');

    // notifier:
    const walletSender = new HDSegwitBech32Wallet();
    walletSender.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[1]);
    walletSender.switchBIP47(true);

    // since we cant do network calls, we hardcode our senders so later `_getWIFbyAddress`
    // could resolve wif for address deposited by him (funds we want to use reside on addresses from BIP47)
    walletSender._receive_payment_codes = [
      'PM8TJXuZNUtSibuXKFM6bhCxpNaSye6r4px2GXRV5v86uRdH9Raa8ZtXEkG7S4zLREf4ierjMsxLXSFTbRVUnRmvjw9qnc7zZbyXyBstSmjcb7uVcDYF',
    ];

    walletSender.addBIP47Receiver(bip47instanceReceiver.getSerializedPaymentCode());

    const utxos: CreateTransactionUtxo[] = [
      {
        value: 74822,
        address: 'bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt',
        txid: '73a2ac70858c5b306b101a861d582f40c456a692096a4e4805aa739258c4400d',
        vout: 0,
        wif: walletSender._getWIFbyAddress('bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt') + '',
      },
      {
        value: 894626,
        address: 'bc1qr60ek5gtjs04akcp9f5x25v5gyp2tmspx78jxl',
        txid: '64058a49bb75481fc0bebbb0d84a4aceebe319f9d32929e73cefb21d83342e9f',
        vout: 0,
        wif: walletSender._getWIFbyAddress('bc1qr60ek5gtjs04akcp9f5x25v5gyp2tmspx78jxl') + '',
      },
    ];

    const changeAddress = 'bc1q7vraw79vcf7qhnefeaul578h7vjc7tr95ywfuq';

    const { tx, fee } = walletSender.createTransaction(
      utxos,
      [
        { address: bip47instanceReceiver.getSerializedPaymentCode(), value: 10234 },
        { address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 22000 },
      ],
      6,
      changeAddress,
    );
    assert(tx);

    assert.strictEqual(tx.outs[0].value, 10234n);
    assert.strictEqual(
      bitcoin.address.fromOutputScript(tx.outs[0].script),
      walletSender._getBIP47AddressSend(bip47instanceReceiver.getSerializedPaymentCode(), 0),
    );

    assert.strictEqual(tx.outs[1].value, 22000n);
    assert.strictEqual(bitcoin.address.fromOutputScript(tx.outs[1].script), '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS');

    const actualFeerate = fee / tx.virtualSize();
    assert.strictEqual(Math.round(actualFeerate), 6);

    // lets retry, but pretend that a few sender's addresses were used:

    walletSender._next_free_payment_code_address_index_send[bip47instanceReceiver.getSerializedPaymentCode()] = 6;

    const { tx: tx2 } = walletSender.createTransaction(
      utxos,
      [
        { address: bip47instanceReceiver.getSerializedPaymentCode(), value: 10234 },
        { address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 22000 },
      ],
      6,
      changeAddress,
    );
    assert(tx2);

    assert.strictEqual(
      bitcoin.address.fromOutputScript(tx2.outs[0].script),
      walletSender._getBIP47AddressSend(bip47instanceReceiver.getSerializedPaymentCode(), 6),
    );
  });

  it('should be able to pay to PC (BIP-352 SilentPayments)', async () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const walletSender = new HDSegwitBech32Wallet();
    walletSender.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[1]);
    walletSender.switchBIP47(true);

    const utxos: CreateTransactionUtxo[] = [
      {
        txid: 'ff2b3dc0f16ad96e48f59232421113330781a88ca9b4518846ad9a626260abd3',
        vout: 1,
        address: 'bc1qr7trw22djl93c2vz43ftlmaexhvph8w0v4f6ap',
        value: 195928,
        wif: walletSender._getWIFbyAddress('bc1qr7trw22djl93c2vz43ftlmaexhvph8w0v4f6ap') as string,
      },
    ];
    const changeAddress = 'bc1q7vraw79vcf7qhnefeaul578h7vjc7tr95ywfuq';

    const { tx, fee } = walletSender.createTransaction(
      utxos,
      [
        { address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS', value: 22000 },
        {
          address: 'sp1qqvvnsd3xnjpmx8hnn2ua0e9sllm34t9jydf8qfesgc7nhdxgzksjwqlrxx37nfzsg6rure5vwa92fksd6f5a6rk05kr07twhd55u3ahquy2v7t6s',
          value: 10234,
        },
      ],
      6,
      changeAddress,
    );
    assert(tx);

    const legacyAddressDestination = tx.outs.find(o => bitcoin.address.fromOutputScript(o.script) === '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS');
    assert.strictEqual(legacyAddressDestination?.value, 22000n);

    const spDestinatiob = tx.outs.find(o => Number(o.value) === 10234);
    assert.strictEqual(
      bitcoin.address.fromOutputScript(spDestinatiob!.script!),
      'bc1pu7dwaehvur4lpc7cqmynnjgx5ngthk574p05mgwxf9lecv4r6j5s02nhxq',
    );

    const changeDestination = tx.outs.find(
      o => bitcoin.address.fromOutputScript(o.script) === 'bc1q7vraw79vcf7qhnefeaul578h7vjc7tr95ywfuq',
    );

    const calculatedFee =
      195928 - Number(changeDestination!.value) - Number(spDestinatiob!.value) - Number(legacyAddressDestination!.value);

    assert.strictEqual(fee, calculatedFee);

    const actualFeerate = fee / tx.virtualSize();
    assert.strictEqual(Math.round(actualFeerate), 6);
  });

  it('can unwrap addresses to send & receive', () => {
    if (!process.env.BIP47_HD_MNEMONIC) {
      console.error('process.env.BIP47_HD_MNEMONIC not set, skipped');
      return;
    }

    const w = new HDSegwitBech32Wallet();
    w.setSecret(process.env.BIP47_HD_MNEMONIC.split(':')[0]);
    w.setPassphrase('1');

    const addr = w._getBIP47AddressReceive(
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
      0,
    );
    assert.strictEqual(addr, 'bc1q57nwf9vfq2qsl80q37wq5h0tjytsk95vgjq4fe');

    const addr2 = w._getBIP47AddressSend(
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
      0,
    );

    assert.strictEqual(addr2, 'bc1qaxxc4gwx6rd6rymq08qwpxhesd4jqu93lvjsyt');

    assert.strictEqual(w.getAllExternalAddresses().length, 20); // exactly gap limit for external addresses
    assert.ok(!w.getAllExternalAddresses().includes(addr)); // joint address to _receive_ is not included

    // since we dont do network calls in unit test we cant get counterparties payment codes from our notif address,
    // and thus, dont know collaborative addresses with our payers. lets hardcode our counterparty payment code to test
    // this functionality

    assert.deepStrictEqual(w.getBIP47SenderPaymentCodes(), []);

    w.switchBIP47(true);

    w._receive_payment_codes = [
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    ];

    assert.deepStrictEqual(w.getBIP47SenderPaymentCodes(), [
      'PM8TJi1RuCrgSHTzGMoayUf8xUW6zYBGXBPSWwTiMhMMwqto7G6NA4z9pN5Kn8Pbhryo2eaHMFRRcidCGdB3VCDXJD4DdPD2ZyG3ScLMEvtStAetvPMo',
    ]);

    assert.ok(w.getAllExternalAddresses().includes(addr)); // joint address to _receive_ is included
    assert.ok(w.getAllExternalAddresses().length > 20);
  });
});


================================================
FILE: ./tests/e2e/malinwallet3.spec.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { hashIt, helperDeleteWallet, helperImportWallet, sleep, waitForId } from './helperz';

// if loglevel is set to `error`, this kind of logging will still get through
console.warn = console.log = (...args) => {
  let output = '';
  args.map(arg => (output += String(arg)));

  process.stdout.write('\n\t\t' + output + '\n');
};

beforeAll(async () => {
  // reinstalling the app just for any case to clean up app's storage
  await device.launchApp({ delete: true });
}, 300_000);

describe('MalinWallet UI Tests - import Watch-only wallet (zpub)', () => {
  /**
   * test plan:
   * 1. import wallet
   * 2. wallet -> send -> import transaction (scan QR)
   * 3. provide unsigned psbt from coldcard (UR)
   * 4. on psbtWithHardwareWallet, tap scanQr
   * 5. provide fully signed psbt (UR)
   * 6. verify that we can see broadcast button and camera backdorr button is NOT visible
   */
  it('can import zpub as watch-only, import psbt, and then scan signed psbt', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t31');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t31'), 'as it previously passed on Travis');
    }
    await device.launchApp({ newInstance: true });
    await helperImportWallet(
      // MNEMONICS_KEYSTONE
      'zpub6s2EvLxwvDpaHNVP5vfordTyi8cH1fR8usmEjz7RsSQjfTTGU2qA5VEcEyYYBxpZAyBarJoTraB4VRJKVz97Au9jRNYfLAeeHC5UnRZbz8Y',
      'watchOnly',
      'Imported Watch-only',
      '0.0001',
    );
    await sleep(15000);
    await element(by.id('ReceiveButton')).tap();
    try {
      // in case emulator has no google services and doesnt support pushes
      // we just dont show this popup
      await element(by.text(`No, and do not ask me again.`)).tap();
      await element(by.text(`No, and do not ask me again.`)).tap(); // sometimes the first click doesnt work (detox issue, not app's)
    } catch (_) {}
    await expect(element(by.id('BitcoinAddressQRCodeContainer'))).toBeVisible();
    await expect(element(by.text('bc1qgrhr5xc5774maph97d73ydrjlqqmg2v6jjlr29'))).toBeVisible();
    await element(by.id('SetCustomAmountButton')).tap();
    await element(by.id('BitcoinAmountInput')).replaceText('1');
    await element(by.id('CustomAmountDescription')).typeText('Test');
    await element(by.id('CustomAmountDescription')).tapReturnKey();
    await element(by.id('CustomAmountSaveButton')).tap();
    await expect(element(by.id('CustomAmountDescriptionText'))).toHaveText('Test');
    await expect(element(by.id('BitcoinAmountText'))).toHaveText('1 BTC');

    await expect(element(by.id('BitcoinAddressQRCodeContainer'))).toBeVisible();

    await expect(element(by.text('bitcoin:BC1QGRHR5XC5774MAPH97D73YDRJLQQMG2V6JJLR29?amount=1&label=Test'))).toBeVisible();
    await device.pressBack();
    await element(by.id('SendButton')).tap();
    await element(by.text('OK')).tap();

    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Import Transaction (QR)')).tap(); // opens camera

    // produced by real Keystone device using MNEMONICS_KEYSTONE
    const unsignedPsbt =
      'UR:CRYPTO-PSBT/HDRNJOJKIDJYZMADAEGOAOAEAEAEADLFIAYKFPTOTIHSMNDLJTLFTYPAHTFHZESOAODIBNADFDCPFZZEKSSTTOJYKPRLJOAEAEAEAEAEZMZMZMZMADNBDSAEAEAEAEAEAECFKOPTBBCFBGNTGUVAEHNDPECFUYNBHKRNPMCMJNYTBKROYKLOPSAEAEAEAEAEADADCTBEDIAEAEAEAEAEAECMAEBBFTZSECYTJZTEKGOEKECAVOGHMTVWGYIAMHCSKOSWCPAMAXENRDWMCPOTZMHKGMFPNTHLMNDMCETOHLOXTANDAMEOTSURLFHHPLTSDPCSJTWSGACSRPLEYNVEGHAEAELAAEAEAELAAEAEAELAAEAEAEAEAEAEAEAEAEAEGETNJYFN';
    const signedPsbt =
      'UR:CRYPTO-PSBT/HDWTJOJKIDJYZMADAEGOAOAEAEAEADLFIAYKFPTOTIHSMNDLJTLFTYPAHTFHZESOAODIBNADFDCPFZZEKSSTTOJYKPRLJOAEAEAEAEAEZMZMZMZMADNBDSAEAEAEAEAEAECFKOPTBBCFBGNTGUVAEHNDPECFUYNBHKRNPMCMJNYTBKROYKLOPSAEAEAEAEAEADADCTBEDIAEAEAEAEAEAECMAEBBFTZSECYTJZTEKGOEKECAVOGHMTVWGYIAMHCSKOSWADAYJEAOFLDYFYAOCXGEUTDNBDTNMKTOQDLASKMTTSCLCSHPOLGDBEHDBBZMNERLRFSFIDLTMHTLMTLYWKAOCXFRBWHGOSGYRLYKTSSSSSIEWDZOVOSTFNISKTBYCLLRLRHSHFCMSGTTVDRHURNSOLADCLAXENRDWMCPOTZMHKGMFPNTHLMNDMCETOHLOXTANDAMEOTSURLFHHPLTSDPCSJTWSGAAEAEDLFPLTSW';

    // tapping 5 times invisible button is a backdoor:
    await sleep(5000); // wait for camera screen to initialize
    for (let c = 0; c <= 5; c++) {
      await element(by.id('ScanQrBackdoorButton')).tap();
      await sleep(1000);
    }

    await element(by.id('scanQrBackdoorInput')).replaceText(unsignedPsbt);
    await element(by.id('scanQrBackdoorOkButton')).tap();

    // now lets test scanning back QR with UR PSBT. this should lead straight to broadcast dialog

    await element(by.id('PsbtWithHardwareScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await element(by.id('PsbtTxScanButton')).tap(); // opening camera

    // tapping 5 times invisible button is a backdoor:
    await sleep(5000); // wait for camera screen to initialize
    for (let c = 0; c <= 5; c++) {
      await element(by.id('ScanQrBackdoorButton')).tap();
      await sleep(1000);
    }

    await element(by.id('scanQrBackdoorInput')).replaceText(signedPsbt);
    await element(by.id('scanQrBackdoorOkButton')).tap();
    await expect(element(by.id('ScanQrBackdoorButton'))).toBeNotVisible();
    await waitForId('PsbtWithHardwareWalletBroadcastTransactionButton');

    await device.pressBack();
    await device.pressBack();
    await device.pressBack();
    await helperDeleteWallet('Imported Watch-only', '10000');

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });
});


================================================
FILE: ./tests/e2e/jest.config.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
module.exports = {
  maxWorkers: 1,
  testTimeout: 333_000,
  verbose: true,
  reporters: ['detox/runners/jest/reporter'],
  globalSetup: 'detox/runners/jest/globalSetup',
  globalTeardown: 'detox/runners/jest/globalTeardown',
  testEnvironment: 'detox/runners/jest/testEnvironment',
  rootDir: '..',
  testMatch: ['<rootDir>/e2e/**/*.spec.js'],
  transform: {
    '\\.[jt]sx?$': ['ts-jest'],
  },
};


================================================
FILE: ./tests/e2e/helperz.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { sha256 } from '@noble/hashes/sha256';
import { element } from 'detox';

export async function waitForId(id, timeout = 33000) {
  try {
    await waitFor(element(by.id(id)))
      .toBeVisible()
      .withTimeout(timeout / 2);
  } catch (_) {
    // nop
  }

  try {
    await waitFor(element(by.id(id)))
      .toBeVisible()
      .withTimeout(timeout / 2);
    return true;
  } catch (_) {
    const msg = `Assertion failed: testID ${id} is not visible`;
    throw new Error(msg);
  }
}

export async function waitForText(text, timeout = 33000) {
  try {
    await waitFor(element(by.text(text)))
      .toBeVisible()
      .withTimeout(timeout / 2);
    return true;
  } catch (_) {
    // nop
  }

  try {
    await waitFor(element(by.text(text)))
      .toBeVisible()
      .withTimeout(timeout / 2);
    return true;
  } catch (_) {
    const msg = `Assertion failed: text "${text}" is not visible`;
    throw new Error(msg);
  }
}

export async function getSwitchValue(switchId) {
  try {
    await expect(element(by.id(switchId))).toHaveToggleValue(true);
    return true;
  } catch (_) {
    return false;
  }
}

export async function helperImportWallet(importText, walletType, expectedWalletLabel, expectedBalance, passphrase) {
  await waitForId('WalletsList');

  await element(by.id('WalletsList')).swipe('left', 'fast', 1); // in case emu screen is small and it doesnt fit
  await sleep(500); // Wait until bounce animation finishes.
  // going to Import Wallet screen and importing mnemonic
  await tapAndTapAgainIfElementIsNotVisible('CreateAWallet', 'ImportWallet');
  await element(by.id('ImportWallet')).tap();
  // tapping 5 times invisible button is a backdoor:
  for (let c = 0; c < 5; c++) {
    await element(by.id('SpeedBackdoor')).tap();
    await sleep(1000);
  }
  await element(by.id('SpeedMnemonicInput')).replaceText(importText);
  await element(by.id('SpeedWalletTypeInput')).replaceText(walletType);
  if (passphrase) await element(by.id('SpeedPassphraseInput')).replaceText(passphrase);
  await element(by.id('SpeedDoImport')).tap();

  // waiting for import result
  await waitForText('OK', 3 * 61000);
  await element(by.text('OK')).tap();

  // lets go inside wallet
  await element(by.text(expectedWalletLabel)).tap();
  // label might change in the future
  await expect(element(by.id('WalletBalance'))).toHaveText(expectedBalance);
}

export async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function hashIt(s) {
  return Buffer.from(sha256(s)).toString('hex');
}

export async function helperDeleteWallet(label, remainingBalanceSat = false) {
  await element(by.text(label)).tap();
  await element(by.id('WalletDetails')).tap();
  await element(by.id('WalletDetailsScroll')).swipe('up', 'fast', 1);
  await element(by.id('HeaderMenuButton')).tap();
  await element(by.text('Delete')).tap();
  await waitForText('Yes, delete');
  await element(by.text('Yes, delete')).tap();
  if (remainingBalanceSat) {
    await element(by.type('android.widget.EditText')).typeText(remainingBalanceSat);
    await element(by.text('Delete')).tap();
  }
  await waitForId('NoTransactionsMessage');
}

/*

module.exports.helperImportWallet = helperImportWallet;
module.exports.waitForId = waitForId;
module.exports.waitForText = waitForText;
module.exports.sleep = sleep;
module.exports.hashIt = hashIt;
module.exports.helperDeleteWallet = helperDeleteWallet;

*/

/**
 * a hack to extract element text. warning, this might break in future
 * @see https://github.com/wix/detox/issues/445
 *
 * @returns {Promise<string>}
 */
export async function extractTextFromElementById(id) {
  try {
    await expect(element(by.id(id))).toHaveText('_unfoundable_text');
  } catch (error) {
    if (device.getPlatform() === 'ios') {
      const start = `accessibilityLabel was "`;
      const end = '" on ';
      const errorMessage = error.message.toString();
      const [, restMessage] = errorMessage.split(start);
      const [label] = restMessage.split(end);
      return label;
    } else {
      const start = 'Got:';
      const end = '}"';
      const errorMessage = error.message.toString();
      const [, restMessage] = errorMessage.split(start);
      const [label] = restMessage.split(end);
      const value = label.split(',');
      const combineText = value.find(i => i.includes('text=')).trim();
      const [, elementText] = combineText.split('=');
      return elementText;
    }
  }
}

export const expectToBeVisible = async id => {
  try {
    await expect(element(by.id(id))).toBeVisible();
    return true;
  } catch (e) {
    return false;
  }
};

export async function helperCreateWallet(walletName) {
  await element(by.id('WalletsList')).swipe('left', 'fast', 1); // in case emu screen is small and it doesnt fit
  await sleep(200); // Wait until bounce animation finishes.
  await tapAndTapAgainIfElementIsNotVisible('CreateAWallet', 'WalletNameInput');
  await element(by.id('WalletNameInput')).replaceText(walletName || 'cr34t3d');
  await waitForId('ActivateBitcoinButton');
  await element(by.id('ActivateBitcoinButton')).tap();
  await element(by.id('ActivateBitcoinButton')).tap();
  // why tf we need 2 taps for it to work..? mystery
  await tapAndTapAgainIfElementIsNotVisible('Create', 'PleaseBackupScrollView');

  await element(by.id('PleaseBackupScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit

  await waitForId('PleasebackupOk');
  await element(by.id('PleasebackupOk')).tap();
  await expect(element(by.id('WalletsList'))).toBeVisible();
  await element(by.id('WalletsList')).swipe('right', 'fast', 1); // in case emu screen is small and it doesnt fit
  await expect(element(by.id(walletName || 'cr34t3d'))).toBeVisible();
}

export async function tapAndTapAgainIfElementIsNotVisible(idToTap, idToCheckVisible) {
  // tap
  await element(by.id(idToTap)).tap();

  // check if visible
  try {
    await waitFor(element(by.id(idToCheckVisible)))
      .toBeVisible()
      .withTimeout(3_000);
    return; // did not throw? its visible, return
  } catch (_) {}

  // did not return so its not visible, lets tap again
  await element(by.id(idToTap)).tap();

  // check visibility again, this time no try-catch, if it fails it fails
  await waitFor(element(by.id(idToCheckVisible)))
    .toBeVisible()
    .withTimeout(3_000);
}

export async function tapAndTapAgainIfTextIsNotVisible(textToTap, textToCheckVisible) {
  // tap
  await element(by.text(textToTap)).tap();

  // check if visible
  try {
    await waitFor(element(by.text(textToCheckVisible)))
      .toBeVisible()
      .withTimeout(3_000);
    return; // did not throw? its visible, return
  } catch (_) {}

  // did not return so its not visible, lets tap again
  await element(by.text(textToTap)).tap();

  // check visibility again, this time no try-catch, if it fails it fails
  await waitFor(element(by.text(textToCheckVisible)))
    .toBeVisible()
    .withTimeout(3_000);
}

export async function tapIfPresent(id) {
  try {
    await element(by.id(id)).tap();
  } catch (_) {}
  // no need to check for visibility, just silently ignore exception if such testID is not present
}

export async function tapIfTextPresent(text) {
  try {
    await element(by.text(text)).tap();
  } catch (_) {}
  // no need to check for visibility, just silently ignore exception if such testID is not present
}

export async function countElements(testId) {
  let count = 0;
  while (true) {
    try {
      await expect(element(by.id(testId)).atIndex(count)).toExist();
      count++;
    } catch (_) {
      break;
    }
  }
  return count;
}

export async function scanText(text) {
  await sleep(5000); // wait for camera screen to initialize
  await waitForId('ScanQrBackdoorButton');
  for (let c = 0; c <= 5; c++) {
    await element(by.id('ScanQrBackdoorButton')).tap();
  }
  await element(by.id('scanQrBackdoorInput')).replaceText(text);
  await element(by.id('scanQrBackdoorOkButton')).tap();
}


================================================
FILE: ./tests/e2e/malinwallet.spec.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import {
  scanText,
  expectToBeVisible,
  extractTextFromElementById,
  hashIt,
  helperCreateWallet,
  helperDeleteWallet,
  sleep,
  waitForText,
  tapAndTapAgainIfElementIsNotVisible,
  tapIfPresent,
  tapIfTextPresent,
  waitForId,
} from './helperz';
import { element } from 'detox';

// if loglevel is set to `error`, this kind of logging will still get through
console.warn = console.log = (...args) => {
  let output = '';
  args.map(arg => (output += String(arg)));

  process.stdout.write('\n\t\t' + output + '\n');
};

/**
 * this testsuite is for test cases that require no wallets to be present
 */
describe('MalinWallet UI Tests - no wallets', () => {
  it('selftest passes', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t1');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t1'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitFor(element(by.id('WalletsList')))
      .toBeVisible()
      .withTimeout(300 * 1000);

    // go to settings, press SelfTest and wait for OK
    await element(by.id('SettingsButton')).tap();
    await element(by.id('AboutButton')).tap();
    await element(by.id('AboutScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await tapAndTapAgainIfElementIsNotVisible('RunSelfTestButton', 'SelfTestLoading');
    await waitFor(element(by.id('SelfTestOk')))
      .toBeVisible()
      .withTimeout(300 * 1000);
    await device.pressBack();
    await device.pressBack();
    await device.pressBack();
    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('all settings screens work', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t2');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t2'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');

    // go to settings, press SelfTest and wait for OK
    await element(by.id('SettingsButton')).tap();

    // general
    await element(by.id('GeneralSettings')).tap();

    // privacy
    // trigger switches
    await element(by.id('SettingsPrivacy')).tap();
    await element(by.id('ClipboardSwitch')).tap();
    await element(by.id('ClipboardSwitch')).tap();
    await element(by.id('QuickActionsSwitch')).tap();
    await element(by.id('QuickActionsSwitch')).tap();
    await device.pressBack();
    await device.pressBack();

    //
    // currency
    // change currency to ARS ($) and switch it back to USD ($)
    await element(by.id('Currency')).tap();
    await element(by.text('ARS ($)')).tap();
    await expect(element(by.text('Rate is obtained from Yadio'))).toBeVisible();
    await element(by.text('USD ($)')).tap();
    await device.pressBack();

    // language
    // change language to Chinese (ZH), test it and switch back to English
    await element(by.id('Language')).tap();
    await element(by.text('Chinese (ZH)')).tap();
    await device.pressBack();
    await expect(element(by.text(''))).toBeVisible();
    await element(by.id('Language')).tap();
    await element(by.text('English')).tap();
    await device.pressBack();

    // security
    await element(by.id('SecurityButton')).tap();
    await device.pressBack();

    // network
    await element(by.id('NetworkSettings')).tap();

    // network -> electrum server
    // change electrum server to electrum.blockstream.info and revert it back
    await element(by.id('ElectrumSettings')).tap();
    await element(by.id('ElectrumSettingsScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await element(by.id('HostInput')).replaceText('electrum.blockstream.info\n');
    await element(by.id('PortInput')).replaceText('50001\n');
    await element(by.id('ElectrumSettingsScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await element(by.id('Save')).tap();
    await waitForText('OK');
    await element(by.text('OK')).tap();
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Reset to default')).tap();
    await element(by.text('RESET TO DEFAULT')).tap();
    await waitForText('OK');
    await element(by.text('OK')).tap();
    await element(by.id('ElectrumSettingsScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await expect(element(by.id('HostInput'))).toHaveText('');
    await expect(element(by.id('PortInput'))).toHaveText('');
    await expect(element(by.id('SSLPortInput'))).toHaveToggleValue(false);
    await device.pressBack();

    // network -> lightning
    // change URI and revert it back
    /* muted since https://lndhub.herokuapp.com is down
    await element(by.id('LightningSettings')).tap();
    await element(by.id('URIInput')).replaceText('invalid\n');
    await element(by.id('Save')).tap();
    await waitForText('OK');
    await expect(element(by.text('Invalid LNDHub URI'))).toBeVisible();
    await element(by.text('OK')).tap();
    await element(by.id('URIInput')).replaceText('https://lndhub.herokuapp.com\n');
    await element(by.id('Save')).tap();
    await waitForText('OK');
    await expect(element(by.text('Your changes have been saved successfully.'))).toBeVisible();
    await element(by.text('OK')).tap();
    await element(by.id('URIInput')).replaceText('\n');
    await element(by.id('Save')).tap();
    await waitForText('OK');
    await expect(element(by.text('Your changes have been saved successfully.'))).toBeVisible();
    await element(by.text('OK')).tap();
    await device.pressBack();
    */

    // notifications
    // turn on notifications if available
    // console.warn('waitForId');
    // await sleep(300000);
    if (await expectToBeVisible('NotificationSettings')) {
      await element(by.id('NotificationSettings')).tap();
      await element(by.id('NotificationsSwitch')).tap();
      await sleep(3_000);
      await element(by.id('NotificationsSwitch')).tap();
      await device.pressBack();
      await device.pressBack();
    } else {
      await device.pressBack();
    }

    // tools
    await element(by.id('Tools')).tap();

    // tools -> broadcast
    // try to broadcast wrong tx
    await element(by.id('Broadcast')).tap();
    await element(by.id('TxHex')).replaceText('invalid\n');
    await element(by.id('BroadcastButton')).tap();
    await waitForText('OK');
    // await expect(element(by.text('the transaction was rejected by network rules....'))).toBeVisible();
    await element(by.text('OK')).tap();
    await device.pressBack();

    // IsItMyAddress
    await element(by.id('IsItMyAddress')).tap();
    await element(by.id('AddressInput')).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('CheckAddress')).tap();
    await expect(element(by.text('None of the available wallets own the provided address.'))).toBeVisible();
    await element(by.text('OK')).tap();
    await device.pressBack();
    await device.pressBack();

    // about
    await element(by.id('AboutButton')).tap();
    await device.pressBack();
    await device.pressBack();
    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can create wallet, reload app and it persists. then go to receive screen, set custom amount and label. Dismiss modal and go to WalletsList.', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t3');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t3'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');

    await helperCreateWallet();

    await device.launchApp({ newInstance: true });
    await waitForId('WalletsList');
    await expect(element(by.id('cr34t3d'))).toBeVisible();
    await tapAndTapAgainIfElementIsNotVisible('cr34t3d', 'ReceiveButton');
    await element(by.id('ReceiveButton')).tap();
    await element(by.text('Yes, I have.')).tap();
    try {
      // in case emulator has no google services and doesnt support pushes
      // we just dont show this popup
      await element(by.text(`No, and do not ask me again.`)).tap();
      await element(by.text(`No, and do not ask me again.`)).tap(); // sometimes the first click doesnt work (detox issue, not app's)
    } catch (_) {}
    await waitForId('BitcoinAddressQRCodeContainer');
    await waitForId('CopyTextToClipboard');
    await element(by.id('SetCustomAmountButton')).tap();
    await element(by.id('BitcoinAmountInput')).replaceText('1');
    await element(by.id('CustomAmountDescription')).replaceText('test');
    await element(by.id('CustomAmountDescription')).tapReturnKey();
    await tapAndTapAgainIfElementIsNotVisible('CustomAmountSaveButton', 'CustomAmountDescriptionText');
    await expect(element(by.id('CustomAmountDescriptionText'))).toHaveText('test');
    await expect(element(by.id('BitcoinAmountText'))).toHaveText('1 BTC');

    await waitForId('BitcoinAddressQRCodeContainer');
    await waitForId('CopyTextToClipboard');

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can encrypt storage, with plausible deniabilityl decrypt fake storage', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t4');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t4'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');

    // lets create a wallet
    await helperCreateWallet();

    // go to settings
    await expect(element(by.id('SettingsButton'))).toBeVisible();
    await element(by.id('SettingsButton')).tap();
    await expect(element(by.id('SecurityButton'))).toBeVisible();

    // go to Security page where we will enable encryption
    await element(by.id('SecurityButton')).tap();
    // await expect(element(by.id('EncyptedAndPasswordProtected'))).toBeVisible(); // @see https://github.com/@rneui/themed/@rneui/themed/issues/2519
    await expect(element(by.id('PlausibleDeniabilityButton'))).toBeNotVisible();

    if (device.getPlatform() === 'ios') {
      console.warn('Android only test skipped');
      return;
    }

    // lets encrypt the storage.
    // first, trying to mistype second password:
    await element(by.id('EncyptedAndPasswordProtectedSwitch')).tap();
    await element(by.id('IUnderstandButton')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash

    await element(by.id('PasswordInput')).replaceText('08902');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).replaceText('666');
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash

    // now, lets put correct passwords and encrypt the storage
    await element(by.id('PasswordInput')).clearText();
    await element(by.id('PasswordInput')).replaceText('qqq');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).clearText();
    await element(by.id('ConfirmPasswordInput')).replaceText('qqq');
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // might not always work the first time
    await sleep(3000); // propagate

    // relaunch app
    await device.launchApp({ newInstance: true });

    // trying to decrypt with incorrect password
    await waitForId('PasswordInput');
    await element(by.id('PasswordInput')).typeText('wrong\n');
    await sleep(1000); // wait for shake animation and retry

    // correct password
    await element(by.id('PasswordInput')).typeText('qqq\n');
    await waitForId('WalletsList');

    // previously created wallet should be visible
    await expect(element(by.id('cr34t3d'))).toBeVisible();

    // now lets enable plausible deniability feature

    // go to settings -> security screen -> plausible deniability screen
    await element(by.id('SettingsButton')).tap();
    await expect(element(by.id('SecurityButton'))).toBeVisible();
    await element(by.id('SecurityButton')).tap();
    // await expect(element(by.id('EncyptedAndPasswordProtected'))).toBeVisible(); // @see https://github.com/@rneui/themed/@rneui/themed/issues/2519
    await expect(element(by.id('PlausibleDeniabilityButton'))).toBeVisible();
    await element(by.id('PlausibleDeniabilityButton')).tap();

    // trying to enable plausible denability
    await element(by.id('CreateFakeStorageButton')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash

    // trying MAIN password: should fail, obviously
    await element(by.id('PasswordInput')).replaceText('qqq');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).replaceText('qqq');
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // first time might not always work
    await sleep(3000); // propagate
    await expect(element(by.text('Password is currently in use. Please try a different password.'))).toBeVisible();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash
    await element(by.text('OK')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash

    // trying new password, but will mistype
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash
    await element(by.id('PasswordInput')).clearText();
    await element(by.id('PasswordInput')).replaceText('passwordForFakeStorage');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).clearText();
    await element(by.id('ConfirmPasswordInput')).replaceText('passwordForFakeStorageWithTypo'); // retyping with typo
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash

    // trying new password
    await element(by.id('PasswordInput')).clearText();
    await element(by.id('PasswordInput')).replaceText('passwordForFakeStorage');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).clearText();
    await element(by.id('ConfirmPasswordInput')).replaceText('passwordForFakeStorage'); // retyping
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // first time might not always work
    await sleep(3_000); // propagate

    // created fake storage.
    // creating a wallet inside this fake storage
    await helperCreateWallet('fake_wallet');

    // relaunch the app, unlock with fake password, expect to see fake wallet

    // relaunch app
    await device.launchApp({ newInstance: true });
    //
    await waitForId('PasswordInput');
    await element(by.id('PasswordInput')).typeText('qqq\n');
    await waitForId('WalletsList');

    // previously created wallet IN MAIN STORAGE should be visible
    await expect(element(by.id('cr34t3d'))).toBeVisible();

    // relaunch app
    await device.launchApp({ newInstance: true });
    //
    await waitForId('PasswordInput');
    await element(by.id('PasswordInput')).typeText('passwordForFakeStorage\n');
    await waitForId('WalletsList');

    // previously created wallet in FAKE storage should be visible
    await expect(element(by.id('fake_wallet'))).toBeVisible();

    // now derypting it, to cleanup
    await element(by.id('SettingsButton')).tap();
    await element(by.id('SecurityButton')).tap();

    // correct password
    await element(by.id('EncyptedAndPasswordProtectedSwitch')).tap();
    await element(by.text('OK')).tap();
    await element(by.id('PasswordInput')).replaceText('passwordForFakeStorage');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // in case it didnt work first time
    await sleep(3000); // propagate
    await expect(element(by.text('fake_wallet'))).toBeVisible();

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can encrypt storage, and decrypt storage works', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t5');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t5'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');
    await helperCreateWallet();
    await element(by.id('SettingsButton')).tap();
    await element(by.id('SecurityButton')).tap();
    if (device.getPlatform() === 'ios') {
      console.warn('Android only test skipped');
      return;
    }

    // lets encrypt the storage.
    // lets put correct passwords and encrypt the storage
    await element(by.id('EncyptedAndPasswordProtectedSwitch')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash
    await element(by.id('IUnderstandButton')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash
    await element(by.id('PasswordInput')).replaceText('pass');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).replaceText('pass');
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // might not always work first time
    await sleep(3000); // propagate
    await element(by.id('PlausibleDeniabilityButton')).tap();

    // trying to enable plausible denability
    await element(by.id('CreateFakeStorageButton')).tap();
    if (process.env.TRAVIS) await sleep(3000); // hopefully helps prevent crash
    await element(by.id('PasswordInput')).replaceText('fake');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('ConfirmPasswordInput')).replaceText('fake'); // retyping
    await element(by.id('ConfirmPasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // might not always work first time
    await sleep(3000); // propagate
    // created fake storage.
    // creating a wallet inside this fake storage
    await helperCreateWallet('fake_wallet');

    // relaunch app
    await device.launchApp({ newInstance: true });
    //
    await waitForId('PasswordInput');
    await element(by.id('PasswordInput')).typeText('pass\n');
    await waitForId('WalletsList');

    // previously created wallet IN MAIN STORAGE should be visible
    await expect(element(by.id('cr34t3d'))).toBeVisible();

    // now go to settings, and decrypt
    await element(by.id('SettingsButton')).tap();
    await element(by.id('SecurityButton')).tap();

    // putting FAKE storage password. should not succeed
    await element(by.id('EncyptedAndPasswordProtectedSwitch')).tap();
    await element(by.text('OK')).tap();
    await element(by.id('PasswordInput')).replaceText('fake');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // might not always work first time
    await sleep(3000); // propagate
    // correct password
    await element(by.id('PasswordInput')).clearText();
    await element(by.id('PasswordInput')).replaceText('pass');
    await element(by.id('PasswordInput')).tapReturnKey();
    await element(by.id('OKButton')).tap();
    await tapIfPresent('OKButton'); // might not always work first time
    await sleep(3000); // propagate

    // relaunch app
    await device.launchApp({ newInstance: true });
    await waitForId('cr34t3d'); // success

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can import 2of2 multisig using individual cosigners (1 signer, 1 xpub)', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('can import 2of2 multisig using individual cosigners (1 signer, 1 xpub)');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');
    await element(by.id('WalletsList')).swipe('left', 'fast', 1); // in case emu screen is small and it doesnt fit
    await sleep(200); // Wait until bounce animation finishes.
    // going to Import Wallet screen and importing Vault
    await tapAndTapAgainIfElementIsNotVisible('CreateAWallet', 'ActivateVaultButton');
    await element(by.id('ActivateVaultButton')).tap();
    await element(by.id('Create')).tap();
    // vault settings:
    await element(by.id('VaultAdvancedCustomize')).tap();
    await element(by.id('DecreaseN')).tap();
    await element(by.id('ModalDoneButton')).tap();

    //

    await element(by.id('LetsStart')).tap();

    // key1 - seed:

    await element(by.id('VaultCosignerImport1')).tap();
    await element(by.id('ScanOrOpenFile')).tap();

    await sleep(5000); // wait for camera screen to initialize
    await waitForId('ScanQrBackdoorButton');
    for (let c = 0; c <= 5; c++) {
      await element(by.id('ScanQrBackdoorButton')).tap();
    }
    await element(by.id('scanQrBackdoorInput')).replaceText(
      'pipe goose bottom run seed curious thought kangaroo example family coral success',
    );
    await element(by.id('scanQrBackdoorOkButton')).tap();
    await element(by.id('DoImportKeyButton')).tap(); // when seed - need to extra tap the button

    // key2 - xpub:

    await element(by.id('VaultCosignerImport2')).tap();
    await element(by.id('ScanOrOpenFile')).tap();

    await sleep(5000); // wait for camera screen to initialize
    for (let c = 0; c <= 5; c++) {
      await element(by.id('ScanQrBackdoorButton')).tap();
    }
    await element(by.id('scanQrBackdoorInput')).replaceText(
      'ur:crypto-account/oeadcypdlouebgaolytaadmetaaddloxaxhdclaxfdyksnwkuypkfevlfzfroyiyecoeosbakbpdcldawzhtcarkwsndcphphsbsdsayaahdcxfgjyckryosmwtdptlbflonbkimlsmovolslbytonayisprvoieftgeflzcrtvesbamtaaddyotadlocsdyykaeykaeykaoykaocypdlouebgaxaaaycyttatrnolimvetsst',
    );
    await element(by.id('scanQrBackdoorOkButton')).tap();
    // when xpub - it automatically closes the modal, so no need to tap the button

    await element(by.id('CreateButton')).tap();
    await waitForText('OK');
    await tapIfTextPresent('OK');
    await waitForId('Multisig Vault');
    await element(by.id('Multisig Vault')).tap(); // go inside the wallet
    await waitForId('ReceiveButton');
    await element(by.id('ReceiveButton')).tap();
    try {
      // in case emulator has no google services and doesnt support pushes
      // we just dont show this popup
      await element(by.text(`No, and do not ask me again.`)).tap();
      await element(by.text(`No, and do not ask me again.`)).tap(); // sometimes the first click doesnt work (detox issue, not app's)
    } catch (_) {}

    await waitForText('bc1qmf06nt4jhvzz4387ak8fecs42k6jqygr2unumetfc7xkdup7ah9s8phlup');

    await device.pressBack();

    await element(by.id('WalletDetails')).tap();
    await waitForText('2 / 2 (native segwit)');

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can import multisig setup from UR, and create tx, and sign on hw devices', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t6');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t6'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');
    await element(by.id('WalletsList')).swipe('left', 'fast', 1); // in case emu screen is small and it doesnt fit
    await sleep(200); // Wait until bounce animation finishes.
    // going to Import Wallet screen and importing mnemonic
    await tapAndTapAgainIfElementIsNotVisible('CreateAWallet', 'ImportWallet');
    await element(by.id('ImportWallet')).tap();
    await element(by.id('ScanImport')).tap();

    const urs = [
      'UR:BYTES/1OF2/J8RX04F2WJ9SSY577U30R55ELM4LUCJCXJVJTD60SYV9A286Q0AQH7QXL6/TYQMJGEQGFK82E2HV9KXCET5YPXH2MR5D9EKJEEQWDJHGATSYPNXJMR9PG3JQARGD9EJQENFD3JJQCM0DE6XZ6TWWVSX7MNV0YS8QATZD35KXGRTV4UHXGRPDEJZQ6TNYPEKZEN9YP6X7Z3RYPJXJUM5WF5KYAT5V5SXZMT0DENJQCM0WD5KWMN9WFES5GC2FESK6EF6YPXH2MR5D9EKJEEQ2ESH2MR5PFGX7MRFVDUN5GPJYPHKVGPJPFZX2UNFWESHG6T0DCAZQMF0XSUZWTESYUHNQFE0XGNS53N0WFKKZAP6YPGRY46NFQ9Q53PNXAZ5Z3PC8QAZQKNSW43RWDRFDFCXV6Z92F9YU6NGGD94S5NNWP2XGNZ22C6K2M69D4F4YKNYFPC5GANS',
      'UR:BYTES/2OF2/J8RX04F2WJ9SSY577U30R55ELM4LUCJCXJVJTD60SYV9A286Q0AQH7QXL6/8944VARY2EZHJ62CDVMHQKRC2F3XVKN629M8X3ZXWPNYGJZ9FPT8G4NS0Q6YG73EG3R42468DCE9S6E40FRN2AF5X4G4GNTNT9FNYAN2DA5YU5G2PGCNVWZYGSMRQVE6YPD8QATZXU6K6S298PZK57TC2DAX772SD4RKUEP4G5MY672YXAQ5C36WDEJ8YA2HWC6NY7RS0F5K6KJ3FD6KKAMKG4N9S4ZGW9K5SWRWVF3XXDNRVDGR2APJV9XNXMTHWVEHQJ6E2DHYKUZTF4XHJARYVF8Y2KJX24UYK7N6W3V5VNFC2PHQ5ZSJDYL5T',
    ];

    await waitFor(element(by.id('UrProgressBar'))).toBeNotVisible();

    for (const ur of urs) {
      // tapping 5 times invisible button is a backdoor:
      await sleep(5000); // wait for camera screen to initialize
      for (let c = 0; c <= 5; c++) {
        await element(by.id('ScanQrBackdoorButton')).tap();
      }
      await element(by.id('scanQrBackdoorInput')).replaceText(ur);
      await element(by.id('scanQrBackdoorOkButton')).tap();
      await waitFor(element(by.id('UrProgressBar'))).toBeVisible();
    }

    if (process.env.TRAVIS) await sleep(60000);
    await waitForText('OK', 3 * 61000); // waiting for wallet import
    await element(by.text('OK')).tap();
    // ok, wallet imported

    // lets go inside wallet
    const expectedWalletLabel = 'Multisig Vault';
    await element(by.text(expectedWalletLabel)).tap();

    // sending...

    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();

    await element(by.id('AddressInput')).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('BitcoinAmountInput')).typeText('0.0005\n');
    await element(by.id('BitcoinAmountInput')).tapReturnKey();

    // setting fee rate:
    const feeRate = 3;
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText(feeRate.toString());
    await element(by.id('feeCustom')).tapReturnKey();
    await sleep(1_000); // propagate

    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}

    await waitFor(element(by.id('ItemUnsigned'))).toBeVisible();
    await waitFor(element(by.id('ItemSigned'))).toBeNotVisible(); // not a single green checkmark

    await element(by.id('ProvideSignature')).tap();
    await element(by.id('PsbtMultisigQRCodeScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await tapAndTapAgainIfElementIsNotVisible('CosignedScanOrImportFile', 'ScanQrBackdoorButton');

    const ursSignedByPassport = [
      'UR:CRYPTO-PSBT/22-4/LPCMAACFAXPLCYZTVYVOPKHDWPHKAXPYJOIHIDHNJSATRTSWEYGUHDURWYDECAGLAAHTTBHTFZFPWDRTLROXLUEHCXAHJTIHTEHDHKTEVTOTIOWFSKGEOSCFFLDRGLFTCYKELSRDNSHYGLLEVYIDGYZOEEDAAOENHGASFDHFVWNSATVYCFETATZSFROXFPMHGUJNWDSPNYMHHGPAIMGYURAYCXLEZEZSCLKBJZLFSRAOOYMSYNCEHDOSPYGTTDSODRSKLALBCAVYBNOLOEGSOYVOVLMWFDPFHGBAVDAEAEAEADADWMDTGDPTADAEADADSTENFYASFDTBCLDINBAOHFHYTPPKWYMSSNDKHKKNUOIELPDRKTOYHPCFCSWNFXPKFZNEPKVOIOCNAOAXMNPSKPLTGYFLRHLOHGUYKISWBWVEGUGMLAAYDLLDLSAAVDTDSADLIDFXYLKKFYURMTOXLKMDRSTYTERSJNHSBDPSGOGWJKJESTWLZCTKGE',
      'UR:CRYPTO-PSBT/52-4/LPCSEEAACFAXPLCYZTVYVOPKHDWPPECPWPHNLBGMLDGOMWJYMDASCFYTOEGRTDGMZOCXFGFEGOSPBDSBISPKCNNYNBIORDRLRTRTHGAAHLGDFWJTVWCEYKGLVEIODSYKKNMSBGNYSAZEZEADGHSAAEAEAECPAMAXCSPLEHGDWFSAGETNWLPRECKOSKDWURMKMYSOASBEBDBNLBFMESCHZEVSJTJKDNADCEENTDROWFVYWEPDRNMDSNYKPMRYZMRLMNRYPAAYBKTDCLGDJKIYBNTYFXECMKWFLSWFWPCPGYBKEHSETTOECANTRHKGFGCLSROLMYLKNSOLHGGDHPOXWPMWCKLYETCLMWAMIDISHKKPJTWDHFPTECMOBALNDABSPTAXAEAELAAEADAEAELSAOGDPTAEAHFLGMCLAXDWPLAHBSMTLSHFPKRLMTIYLRYATNLGPLWFLYHFTOTLRDWZHKBWLAHNFNCPWTIMRFLUVYHLBWKBCXGYNLFYDPOL',
      'UR:CRYPTO-PSBT/76-4/LPCSGSAACFAXPLCYZTVYVOPKHDWPBKEHRTTTFDCTNTRHKGFGCXSAHSRHWDMDTONBRLROWMSFCPBTHNTIAAGMPLAEAECPAOAXFXPSGMTABNWEIAJTHSCLAOSERKVLJKADWEBKTBBTRKJPTPYKMKLTMSRYRKDYPLLKCECMLGTBAXDYAEAELAAEAEAELAAEAEAELAAOAEAELAADAEAEAEAEAEAEAECPAOAXCSMYGWCMSGFWBTIENEOTRHHDFTVTLYTASNUYWZAMFSNLZSYLHGDKDWAYKBFYZTECCETEKBPMLODYAEAELAAEAEAELAAEAEAELAAOAEAELAADAEAEAEAEAEAEAEADADFLGMCLAXCSMYGWCMSGFWBTIENEOTRHHDFTVTLYTASNUYWZAMFSNLZSYLHGDKDWAYKBFYZTECCLAXFXPSGMTABNWEIAJTHSCLAOSERKVLJKADWEBKTBBTRKJPTPYKMKLTMSRYRKDYPLLKGMPLAEAEAEWLCMNTPF',
      'UR:CRYPTO-PSBT/416-4/LPCFADNBAACFAXPLCYZTVYVOPKHDWPONBWDWPACLGTAEIDWLWZBAZODNCSMSEHZELBIYDLMWCSHDIADKNYWNZSSGPKVEFLMKLRKNCELEDAMYEMBYKIJKFNDEDMIAHPLBRDPMLTROWMFNWSLTROCMIOYKWPFZDSLGLGDKWSOYPFAHMODAMYENSAIOSEGAZEEHTSLBKGOEDMWZUTRFNYJEKIPEEMIYJSOTUEZERORFPSGRPABSSKLOGOONAECAGRSFBDLRWFEMLNSALRCWZOWNLPHNPTNSLPJTKBMTEYNSISTAFTEHSEGDOTENSNMHKNFGCLFXOXMYPLCELTKOMTNEGRTOJYGURHKGPMTAFHHKWPKIOTJPGWVSKNSKSSFTOYPTKKSGSRFGIORHMDDAFHNYKTHPCPOTKEGELANNLEWEGMJEKPIYGYSFECJNCWFNRYVLTBTBWPHTKBISTLRLDEMWADCWMNKTTARKDRJSZCJPLRCNFSHGNEGAMTYLVLGOWS',
    ];

    for (const ur of ursSignedByPassport) {
      // tapping 5 times invisible button is a backdoor:
      await sleep(5000); // wait for camera screen to initialize
      for (let c = 0; c <= 5; c++) {
        await element(by.id('ScanQrBackdoorButton')).tap();
      }
      await element(by.id('scanQrBackdoorInput')).replaceText(ur);
      await element(by.id('scanQrBackdoorOkButton')).tap();
      await waitFor(element(by.id('UrProgressBar'))).toBeVisible();
    }

    await waitFor(element(by.id('ItemSigned'))).toBeVisible(); // one green checkmark visible

    await element(by.id('ProvideSignature')).tap();
    await element(by.id('PsbtMultisigQRCodeScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await tapAndTapAgainIfElementIsNotVisible('CosignedScanOrImportFile', 'ScanQrBackdoorButton');

    const urSignedByPassportAndKeystone = [
      'UR:CRYPTO-PSBT/105-2/LPCSINAOCFAXOLCYSBLUFDHSHKADTEHKAXOTJOJKIDJYZMADAEKIAOAEAEAEADSGMHIEQDIAFLKPVABAJEHLLNVLRKKPCPDAHYNSOTTSOYBTIMMUCYAASSMDAMDAMKAEAEAEAEAEZMZMZMZMAOGDSRAEAEAEAEAEAECMAEBBKBOTLPWFGMRNINIMPFYNWLGEBAVTVLSWTYPAGEGUWFVLAEAEAEAEAEAECPAECXHEJTWTTTWEPDFMMDSNYKDPRYZMRLBARSPAAYLETDCLGDJKIHBNTYFXCHNNWTRHFEAEAEAEAEAEADAEWDAOAEAEAEAEADADSTENIYASISYLVDVLGWCXRPBWVYVSDALOTLCESKTTFEJTWDTBPTECMOMNLNDABSDTADAEAEAEAEADAEAELAAOGDPTADAEAEAEAEAECPAECXCLSWSSWSCPVTGTESFWSBCTCSETNSPYNLBKJLZTUEMWSOMSNNTYGSLSFPNEPKVOIOONMOAOAEAEAEAEAECMAEBBMNAMRTRKDYGUHDURWSVOLGDRRLESMEDLOLGWLYNTAOFLDYFYAOCXDYYTJOMYYAUELEDYKIYLADUROYFNURDRGLFTCYKEKEFEIAOYGSTNCPIDGYZOEEDAAOCXHGCAENYKHNJLGOHEJOGMRLBNTDWYGWJOPFPYFMKKTISROXGMIMGYURAYCXLEUOZSADCLAOJPBGWSASPTIATTPMLECMPRIHSTMDJYLOYKTKRTHHTLSTFZKPOYWKBKROASBGBAVDAEAEAEAEADADDNGDPTADAEAEAEAEAECPAECXCLSWSSWSCPVTGTESFWSBCTCSETNSPYNLBKJLZTUEMWSOMSNNTYGSLSFPNEPKVOIOCPAOAXFTRPWPCPGYBKEHRTTTFDCTNTRHKGFGCXSAHSRHWDMDTONBRLROWMSFCPBTHNTIAAFLDYFYAOCXISRERKHDRDGAPMATEHJLFL',
      'UR:CRYPTO-PSBT/158-2/LPCSNNAOCFAXOLCYSBLUFDHSHKADTEZECFFTHDETNBADMOCLINLNOSOXZEYKGDPYTPKTRETNURTIZOPDAOCXIAAOWETTJKMDUOSBONAASWNLMERLZSGLCYCTGAKBDAFHGHWKMTRSNLAAYKFWWPRSADADAHFLGMCLAXBAPLDADMGDFLRHLOHGUYHESWEOSKMDMTJLDRTKSSRDFGDWSNTNCHZEVSJTJKDNCNCLAXFTRPWPCPGYBKEHRTTTFDCTNTRHKGFGCXSAHSRHWDMDTONBRLROWMSFCPBTHNTIAAGMPLCPAMAXBAPLDADMGDFLRHLOHGUYHESWEOSKMDMTJLDRTKSSRDFGDWSNTNCHZEVSJTJKDNCNCECMLGTBAXDYAEAELAAEAEAELAAEAEAELAAOAEAELAAEAEAEAEAXAEAEAECPAMAXFTRPWPCPGYBKEHRTTTFDCTNTRHKGFGCXSAHSRHWDMDTONBRLROWMSFCPBTHNTIAACETEKBPMLODYAEAELAAEAEAELAAEAEAELAAOAEAELAAEAEAEAEAXAEAEAEAEAEADADFLGMCLAXCSMYGWCMSGFWBTIENEOTRHHDFTVTLYTASNUYWZAMFSNLZSYLHGDKDWAYKBFYZTECCLAXFXPSGMTABNWEIAJTHSCLAOSERKVLJKADWEBKTBBTRKJPTPYKMKLTMSRYRKDYPLLKGMPLCPAOAXCSMYGWCMSGFWBTIENEOTRHHDFTVTLYTASNUYWZAMFSNLZSYLHGDKDWAYKBFYZTECCETEKBPMLODYAEAELAAEAEAELAAEAEAELAAOAEAELAADAEAEAEAEAEAEAECPAOAXFXPSGMTABNWEIAJTHSCLAOSERKVLJKADWEBKTBBTRKJPTPYKMKLTMSRYRKDYPLLKCECMLGTBAXDYAEAELAAEAEAELAAEAEAELAAOAEAELAADAEAEAEAEAEAEAEAENNHKLKUO',
    ];

    for (const ur of urSignedByPassportAndKeystone) {
      // tapping 5 times invisible button is a backdoor:
      await sleep(5000); // wait for camera screen to initialize
      for (let c = 0; c <= 5; c++) {
        await element(by.id('ScanQrBackdoorButton')).tap();
      }
      await element(by.id('scanQrBackdoorInput')).replaceText(ur);
      await element(by.id('scanQrBackdoorOkButton')).tap();
      await waitFor(element(by.id('UrProgressBar'))).toBeVisible();
    }

    await waitFor(element(by.id('ExportSignedPsbt'))).toBeVisible();

    await element(by.id('PsbtMultisigConfirmButton')).tap();

    // created. verifying:
    await waitForId('TransactionValue');
    await expect(element(by.id('TransactionValue'))).toHaveText('0.0005');
    await element(by.id('TransactionDetailsButton')).tap();

    const txhex = await extractTextFromElementById('TxhexInput');

    const transaction = bitcoin.Transaction.fromHex(txhex);
    assert.ok(transaction.ins.length === 1);
    assert.strictEqual(transaction.outs.length, 2);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl'); // to address
    assert.strictEqual(transaction.outs[0].value, 50000n);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can discover wallet account and import it', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t7');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t6'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');

    await element(by.id('WalletsList')).swipe('left', 'fast', 1); // in case emu screen is small and it doesnt fit
    await sleep(500); // Wait until bounce animation finishes.
    // going to Import Wallet screen and importing mnemonic
    await tapAndTapAgainIfElementIsNotVisible('CreateAWallet', 'ScrollView');
    await element(by.id('ScrollView')).swipe('up', 'fast', 0.9); // in case emu screen is small and it doesnt fit
    await element(by.id('ImportWallet')).tap();
    await element(by.id('MnemonicInput')).replaceText(
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
    );
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Passphrase')).tap();
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Search accounts')).tap();
    await element(by.id('DoImport')).tap();
    await sleep(1000);

    // cancel import and start over
    await element(by.text('Cancel')).tap();
    await element(by.id('DoImport')).tap();
    await sleep(1000);
    await element(by.text('OK')).tap();

    // wait for discovery to be completed
    await waitFor(element(by.text("m/84'/0'/0'")))
      .toBeVisible()
      .withTimeout(300 * 1000);
    await expect(element(by.text("m/44'/0'/1'"))).toBeVisible();
    await expect(element(by.text("m/49'/0'/0'"))).toBeVisible();
    await expect(element(by.id('Loading'))).not.toBeVisible();

    // open custom derivation path screen and import the wallet
    await element(by.id('CustomDerivationPathButton')).tap();
    await element(by.id('DerivationPathInput')).replaceText("m/44'/0'/1'");
    await waitFor(element(by.text('Found'))) // wait for discovery to be completed
      .toExist()
      .withTimeout(300 * 1000);
    await element(by.text('Found')).tap();
    await element(by.id('ImportButton')).tap();
    await element(by.text('OK')).tap();

    // go to wallet and check derivation path
    await element(by.id('Imported HD Legacy (BIP44 P2PKH)')).tap();
    await element(by.id('WalletDetails')).tap();
    await expect(element(by.id('DerivationPath'))).toHaveText("m/44'/0'/1'");

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can create wallet, and use main screen SCAN button to scan address', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t8');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t8'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');

    await helperCreateWallet();
    await tapAndTapAgainIfElementIsNotVisible('HomeScreenScanButton', 'ScanQrBackdoorButton');
    await scanText('bitcoin:bc1qzrtn3xwlunlrm0n0uu23lr00gmdx4lnlavdy75');
    await expect(element(by.id('AddressInput'))).toHaveText('bc1qzrtn3xwlunlrm0n0uu23lr00gmdx4lnlavdy75');

    // now, gona import second wallet (ln) and test bip21 with both onchain and offchain present

    await device.pressBack();
    await waitForId('WalletsList');
    await element(by.id('WalletsList')).swipe('left', 'fast', 1); // in case emu screen is small and it doesnt fit
    // going to Import Wallet screen and importing mnemonic
    await tapAndTapAgainIfElementIsNotVisible('CreateAWallet', 'ImportWallet');
    await element(by.id('ImportWallet')).tap();
    await element(by.id('ScanImport')).tap();
    await scanText('lndhub://a3b4c9109408a043d1ea:ec5a888596b2c45729d1@https://kek.lol');
    await waitForText('OK', 30_000); // waiting for wallet import
    await element(by.text('OK')).tap();

    // imported

    await tapAndTapAgainIfElementIsNotVisible('HomeScreenScanButton', 'ScanQrBackdoorButton');
    await scanText(
      'lightning:lnbc1p090vrqpp5yxpd5wjtln4r874a9grkpr772cs0uyn7ayva3ypleyut7z0a4rgsdpu235hqurfdcsx7an9wf6x7undv4h8ggpgw35hqurfdchx6eff9p6nzvfc8q5scqzpgxqyz5vqcy30v2txquuh06h6946pal4dlm4hyujqv8ec3cunetf46gfydpxswedv4sr2rlg8dwpcg3fq9gah3j42373w366e6yau37t30amp5zqqftd004',
    );
    await expect(element(by.id('AddressInput'))).toHaveText(
      'lnbc1p090vrqpp5yxpd5wjtln4r874a9grkpr772cs0uyn7ayva3ypleyut7z0a4rgsdpu235hqurfdcsx7an9wf6x7undv4h8ggpgw35hqurfdchx6eff9p6nzvfc8q5scqzpgxqyz5vqcy30v2txquuh06h6946pal4dlm4hyujqv8ec3cunetf46gfydpxswedv4sr2rlg8dwpcg3fq9gah3j42373w366e6yau37t30amp5zqqftd004',
    );

    // ok, time to test wallets selector
    await device.pressBack();
    await waitForId('WalletsList');
    await tapAndTapAgainIfElementIsNotVisible('HomeScreenScanButton', 'ScanQrBackdoorButton');
    await scanText(
      'bitcoin:1DamianM2k8WfNEeJmyqSe2YW1upB7UATx?amount=0.000001&lightning=lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4',
    );

    await waitForId('SelectWalletsList');
    await element(by.text('Imported Lightning')).tap();
    await expect(element(by.id('AddressInput'))).toHaveText(
      'lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4',
    ); // send screen, and ln invoice is prefilled!

    // now again, but chosing onchain

    await device.pressBack();
    await waitForId('WalletsList');
    await tapAndTapAgainIfElementIsNotVisible('HomeScreenScanButton', 'ScanQrBackdoorButton');
    await scanText(
      'bitcoin:1DamianM2k8WfNEeJmyqSe2YW1upB7UATx?amount=0.000001&lightning=lnbc1u1pwry044pp53xlmkghmzjzm3cljl6729cwwqz5hhnhevwfajpkln850n7clft4sdqlgfy4qv33ypmj7sj0f32rzvfqw3jhxaqcqzysxq97zvuq5zy8ge6q70prnvgwtade0g2k5h2r76ws7j2926xdjj2pjaq6q3r4awsxtm6k5prqcul73p3atveljkn6wxdkrcy69t6k5edhtc6q7lgpe4m5k4',
    );

    await waitForId('SelectWalletsList');
    await element(by.text('cr34t3d')).tap();
    await expect(element(by.id('AddressInput'))).toHaveText('1DamianM2k8WfNEeJmyqSe2YW1upB7UATx'); // send screen, and ONCHAIN invoice is prefilled!
    await expect(element(by.id('BitcoinAmountInput'))).toHaveText('0.000001');

    // let's test Azteco voucher scanning now, while we have a wallet
    await device.pressBack();
    await waitForId('WalletsList');
    await tapAndTapAgainIfElementIsNotVisible('HomeScreenScanButton', 'ScanQrBackdoorButton');
    await scanText('https://azte.co/redeem?code=1111222233334444');
    await waitForId('AztecoCode');
    await expect(element(by.id('AztecoCode'))).toBeVisible();

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can create wallet and delete wallet', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t9');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t8'), 'as it previously passed on Travis');
    }
    await device.launchApp({ delete: true }); // reinstalling the app just for any case to clean up app's storage
    await waitForId('WalletsList');
    await helperCreateWallet();
    // nop
    await helperDeleteWallet('cr34t3d');
    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });
});


================================================
FILE: ./tests/e2e/detox-build-release-apk.sh
================================================

# script thats used to build & sign release APK in preparation for Detox e2e testing.

# deleting old artifacts
find android | grep '\.apk' --color=never | xargs -l rm

# creating fresh keystore
rm detox.keystore
keytool -genkeypair -v -keystore detox.keystore -alias detox  -keyalg RSA -keysize 2048 -validity 10000 -storepass 123456 -keypass 123456 -dname  'cn=Unknown, ou=Unknown, o=Unknown, c=Unknown'

# building release APK
cd android && ./gradlew assembleRelease assembleAndroidTest -DtestBuildType=release && cd ..

# signing
echo wheres waldo?
find $ANDROID_HOME | grep apksigner | grep -v jar
mv ./android/app/build/outputs/apk/release/app-release-unsigned.apk ./android/app/build/outputs/apk/release/app-release.apk
$ANDROID_HOME/build-tools/35.0.0/apksigner sign --ks detox.keystore   --ks-pass=pass:123456 ./android/app/build/outputs/apk/release/app-release.apk
$ANDROID_HOME/build-tools/35.0.0/apksigner sign --ks detox.keystore   --ks-pass=pass:123456 ./android/app/build/outputs/apk/androidTest/release/app-release-androidTest.apk


================================================
FILE: ./tests/e2e/detox-prepare-android-emu.sh
================================================

$ANDROID_HOME/tools/bin/sdkmanager "system-images;android-28;default;x86_64"
echo no | $ANDROID_HOME/tools/bin/sdkmanager --licenses
echo no | $ANDROID_HOME/tools/bin/avdmanager create avd -n Pixel_API_29_AOSP --force --package "system-images;android-28;default;x86_64"
printf "\nhw.lcd.height=1334\nhw.lcd.width=750\nhw.lcd.density=320\nskin.name=750x1334" >> ~/.android/avd/Pixel_API_29_AOSP.avd/config.ini

================================================
FILE: ./tests/e2e/malinwallet2.spec.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import assert from 'assert';
import * as bitcoin from 'bitcoinjs-lib';

import {
  extractTextFromElementById,
  getSwitchValue,
  hashIt,
  helperImportWallet,
  sleep,
  waitForText,
  tapAndTapAgainIfElementIsNotVisible,
  tapAndTapAgainIfTextIsNotVisible,
  tapIfTextPresent,
  waitForId,
  countElements,
  scanText,
} from './helperz';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

// if loglevel is set to `error`, this kind of logging will still get through
console.warn = console.log = (...args) => {
  let output = '';
  args.map(arg => (output += String(arg)));

  process.stdout.write('\n\t\t' + output + '\n');
};

/**
 * in this suite each test requires that there is one specific wallet present, thus, we import it
 * before anything else.
 * we dont clean it up as we expect other test suites to do clean install of the app
 */
beforeAll(async () => {
  if (!process.env.HD_MNEMONIC_BIP84) {
    console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
    return;
  }
  // reinstalling the app just for any case to clean up app's storage
  await device.launchApp({ delete: true });

  console.log('before all - importing bip84...');
  await helperImportWallet(process.env.HD_MNEMONIC_BIP84, 'HDsegwitBech32', 'Imported HD SegWit (BIP84 Bech32 Native)', '0.00105526');
  console.log('...imported!');
  await device.pressBack();
  await sleep(15000);
}, 1200_000);

describe('MalinWallet UI Tests - import BIP84 wallet', () => {
  it('can create a transaction; can scanQR with bip21; can switch units', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t21');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t21'), 'as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();

    // lets create real transaction:
    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();
    await element(by.id('AddressInput')).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('BitcoinAmountInput')).typeText('0.0001\n');

    // setting fee rate:
    const feeRate = 2;
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText(feeRate.toString());
    await element(by.id('feeCustom')).tapReturnKey();

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}

    // created. verifying:
    await waitForId('TransactionValue');
    await expect(element(by.id('TransactionValue'))).toHaveText('0.0001');
    const transactionFee = await extractTextFromElementById('TransactionFee');
    assert.ok(transactionFee.startsWith('Fee: 0.00000292 BTC'), 'Unexpected tx fee: ' + transactionFee);
    await element(by.id('TransactionDetailsButton')).tap();

    let txhex = await extractTextFromElementById('TxhexInput');

    let transaction = bitcoin.Transaction.fromHex(txhex);
    assert.ok(transaction.ins.length === 1 || transaction.ins.length === 2); // depending on current fees gona use either 1 or 2 inputs
    assert.strictEqual(transaction.outs.length, 2);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl'); // to address
    assert.strictEqual(transaction.outs[0].value, 10000n);

    // checking fee rate:
    const totalIns = 69909; // we hardcode it since we know it in advance
    const totalOuts = transaction.outs.map(el => Number(el.value)).reduce((a, b) => a + b, 0);
    const tx = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(Math.round((totalIns - totalOuts) / tx.virtualSize()), feeRate);
    assert.strictEqual(transactionFee.split(' ')[1] * 100000000, totalIns - totalOuts);

    if (device.getPlatform() === 'ios') {
      console.warn('rest of the test is Android only, skipped');
      return;
    }

    // now, testing scanQR with bip21:

    await device.pressBack();
    await device.pressBack();
    await element(by.id('changeAmountUnitButton')).tap(); // switched to SATS
    await element(by.id('MalinAddressInputScanQrButton')).tap();

    await scanText('bitcoin:bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7?amount=0.00015&pj=https://btc.donate.kukks.org/BTC/pj');

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}
    // created. verifying:
    await waitForId('TransactionValue');
    await waitForId('PayjoinSwitch');
    await element(by.id('TransactionDetailsButton')).tap();
    txhex = await extractTextFromElementById('TxhexInput');
    transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    assert.strictEqual(transaction.outs[0].value, 15000n);

    // now, testing scanQR with just address after amount set to 1.1 USD. Denomination should not change after qrcode scan

    await device.pressBack();
    await device.pressBack();
    await element(by.id('changeAmountUnitButton')).tap(); // switched to SATS
    await element(by.id('changeAmountUnitButton')).tap(); // switched to FIAT
    await element(by.id('BitcoinAmountInput')).replaceText('1.1');
    await element(by.id('MalinAddressInputScanQrButton')).tap();

    await scanText('bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}
    // created. verifying:
    await waitForId('TransactionValue');
    // dont verify payjoin since we scanned different address that didnt have `&pj=xxxxxx`
    await element(by.id('TransactionDetailsButton')).tap();
    txhex = await extractTextFromElementById('TxhexInput');
    transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    assert.notEqual(transaction.outs[0].value, 110000000n); // check that it is 1.1 USD, not 1 BTC
    assert.ok(Number(transaction.outs[0].value) < 10000); // 1.1 USD ~ 0,00001964 sats in march 2021

    // now, testing units switching, and then creating tx with SATS:

    await device.pressBack();
    await device.pressBack();
    await element(by.id('changeAmountUnitButton')).tap(); // switched to BTC
    await element(by.id('BitcoinAmountInput')).replaceText('0.00015');
    await element(by.id('changeAmountUnitButton')).tap(); // switched to sats
    assert.strictEqual(await extractTextFromElementById('BitcoinAmountInput'), '15000');
    await element(by.id('changeAmountUnitButton')).tap(); // switched to FIAT
    await element(by.id('changeAmountUnitButton')).tap(); // switched to BTC
    assert.strictEqual(await extractTextFromElementById('BitcoinAmountInput'), '0.00015');
    await element(by.id('changeAmountUnitButton')).tap(); // switched to sats
    await element(by.id('BitcoinAmountInput')).replaceText('50000');

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}
    // created. verifying:
    await waitForId('TransactionValue');
    await element(by.id('TransactionDetailsButton')).tap();
    txhex = await extractTextFromElementById('TxhexInput');
    transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(transaction.outs.length, 2);
    assert.strictEqual(transaction.outs[0].value, 50000n);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can batch send', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t_batch_send');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    // Go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();

    // Add a few recipients initially
    await element(by.id('AddressInput')).replaceText('bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    await element(by.id('BitcoinAmountInput')).replaceText('0.0001\n');

    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Add Recipient')).tap();
    await waitForId('Transaction1');
    await element(by.id('AddressInput').withAncestor(by.id('Transaction1'))).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('BitcoinAmountInput').withAncestor(by.id('Transaction1'))).replaceText('0.0002\n');

    // Now remove all recipients before proceeding
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Remove All Recipients')).tap();
    await element(by.text('OK')).tap();

    // Now, let's proceed with the batch send process again
    // Let's create a real transaction again:
    await element(by.id('AddressInput')).replaceText('bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    await element(by.id('BitcoinAmountInput')).replaceText('0.0001\n');

    // Setting fee rate:
    const feeRate = 2;
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText(feeRate.toString());
    await element(by.id('feeCustom')).tapReturnKey();

    // Let's add another two outputs
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Add Recipient')).tap();
    await waitForId('Transaction1'); // Adding a recipient autoscrolls it to the last one
    await element(by.id('AddressInput').withAncestor(by.id('Transaction1'))).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('BitcoinAmountInput').withAncestor(by.id('Transaction1'))).replaceText('0.0002\n');

    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Add Recipient')).tap();
    await waitForId('Transaction2'); // Adding a recipient autoscrolls it to the last one
    await element(by.id('AddressInput').withAncestor(by.id('Transaction2'))).replaceText('bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7');
    await element(by.id('BitcoinAmountInput').withAncestor(by.id('Transaction2'))).replaceText('0.0003\n');

    // Remove last output, check if second output is shown
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Remove Recipient')).tap();
    await waitForId('Transaction1');

    // Add it again
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Add Recipient')).tap();
    await waitForId('Transaction2'); // Adding a recipient autoscrolls it to the last one
    await element(by.id('AddressInput').withAncestor(by.id('Transaction2'))).replaceText('bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7');
    await element(by.id('BitcoinAmountInput').withAncestor(by.id('Transaction2'))).replaceText('0.0003\n');

    // Remove second output
    await element(by.id('Transaction2')).swipe('right', 'fast', NaN, 0.2);
    await sleep(5000);
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Remove Recipient')).tap();

    // Creating and verifying. tx should have 3 outputs
    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}

    await element(by.id('TransactionDetailsButton')).tap();
    const txhex = await extractTextFromElementById('TxhexInput');
    const transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(transaction.outs.length, 3);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    assert.strictEqual(transaction.outs[0].value, 10000n);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[1].script), 'bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7');
    assert.strictEqual(transaction.outs[1].value, 30000n, `got txhex ${txhex}`);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can sendMAX', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t_sendMAX');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();

    // set fee rate
    const feeRate = 2;
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText(feeRate.toString());
    await element(by.id('feeCustom')).tapReturnKey();

    // first send MAX output
    await element(by.id('AddressInput')).replaceText('bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    await element(by.id('BitcoinAmountInput')).typeText('0.0001\n');
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Use Full Balance')).tap();
    await element(by.text('OK')).tap();

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}
    // created. verifying:
    await waitForId('TransactionDetailsButton');
    await element(by.id('TransactionDetailsButton')).tap();
    let txhex = await extractTextFromElementById('TxhexInput');
    let transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(transaction.outs.length, 1, 'should be single output, no change');
    assert.ok(Number(transaction.outs[0].value) > 100000);

    // add second output with amount
    await device.pressBack();
    await device.pressBack();
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Add Recipient')).tap();
    await waitForId('Transaction1');
    await element(by.id('AddressInput').withAncestor(by.id('Transaction1'))).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('BitcoinAmountInput').withAncestor(by.id('Transaction1'))).typeText('0.0001\n');

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}
    // created. verifying:
    await waitForId('TransactionDetailsButton');
    await element(by.id('TransactionDetailsButton')).tap();
    txhex = await extractTextFromElementById('TxhexInput');
    transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(transaction.outs.length, 2, 'should be single output, no change');
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1qnapskphjnwzw2w3dk4anpxntunc77v6qrua0f7');
    assert.ok(transaction.outs[0].value > 50000n);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[1].script), 'bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    assert.strictEqual(transaction.outs[1].value, 10000n);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can cosign psbt', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t_cosign');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();

    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Sign a transaction')).tap();

    // tapping 5 times invisible button is a backdoor:
    for (let c = 0; c <= 5; c++) {
      await element(by.id('ScanQrBackdoorButton')).tap();
      await sleep(1000);
    }
    // 1 input, 2 outputs. wallet can fully sign this tx
    const psbt =
      'cHNidP8BAFICAAAAAXYa7FEQBAQ2X0B48aHHKKgzkVuHfQ2yCOi3v9RR0IqlAQAAAAAAAACAAegDAAAAAAAAFgAUSnH40G+jiJfreeRb36cs641KFm8AAAAAAAEBH5YVAAAAAAAAFgAUTKHjDm4OJQSbvy9uzyLYi5i5XIoiBgMQcGrP5TIMrdvb73yB4WnZvkPzKr1EzJXJYBHWmlPJZRgAAAAAVAAAgAAAAIAAAACAAQAAAD4AAAAAAA==';
    await element(by.id('scanQrBackdoorInput')).replaceText(psbt);
    await element(by.id('scanQrBackdoorOkButton')).tap();

    // this is fully-signed tx, "this is tx hex" help text should appear
    await waitForId('DynamicCode');

    const txhex = await extractTextFromElementById('TxhexInput');
    console.warn(txhex);
    const transaction = bitcoin.Transaction.fromHex(txhex);
    assert.strictEqual(transaction.ins.length, 1);
    assert.strictEqual(transaction.outs.length, 1);
    assert.strictEqual(bitcoin.address.fromOutputScript(transaction.outs[0].script), 'bc1qffcl35r05wyf06meu3dalfevawx559n0ufrxcw'); // to address
    assert.strictEqual(transaction.outs[0].value, 1000n);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('payment codes & manage contacts', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t_manage_contacts');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await element(by.id('WalletDetails')).tap();

    // switch on BIP47 slider if its not switched
    if (!(await getSwitchValue('BIP47Switch'))) {
      await expect(element(by.text('Contacts'))).not.toBeVisible();
      await element(by.id('BIP47Switch')).tap();
      await element(by.id('WalletDetailsScroll')).swipe('up', 'fast', 1);
      await expect(element(by.text('Contacts'))).toBeVisible();
      await device.pressBack();
    } else {
      await device.pressBack();
    }

    // go to receive screen and check that payment code is there

    await waitForId('ReceiveButton');
    await element(by.id('ReceiveButton')).tap();

    try {
      await element(by.text('ASK ME LATER.')).tap();
    } catch (_) {}

    await element(by.text('Payment Code')).tap();
    await element(by.id('ReceiveDetailsScrollView')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit

    await expect(
      element(
        by.text('PM8TJbcHbQFgBL5mAYUCxJEhsz8F66abWAnVqiq6Pa8Rav8qG6XjaJQmSzNqgc1k63ipiEnobNpAoxNJVzRkdoUEANj9KyBEjLt4hL99RMoa8iJXwwwM'),
      ),
    ).toBeVisible();

    // now, testing contacts list
    await device.pressBack();
    await device.pressBack();
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await element(by.id('WalletDetails')).tap();
    await element(by.id('WalletDetailsScroll')).swipe('up', 'fast', 1); // in case emu screen is small and it doesnt fit
    await tapAndTapAgainIfTextIsNotVisible('Contacts', 'Add Contact');

    await expect(element(by.id('ContactListItem0'))).not.toBeVisible();
    await element(by.text('Add Contact')).tap();
    await element(by.type('android.widget.EditText')).replaceText('13HaCAB4jf7FYSZexJxoczyDDnutzZigjS');
    await sleep(1000);
    await element(by.text('OK')).tap();
    await element(by.text('Add Contact')).tap();
    await element(by.type('android.widget.EditText')).replaceText(
      'sp1qqgste7k9hx0qftg6qmwlkqtwuy6cycyavzmzj85c6qdfhjdpdjtdgqjuexzk6murw56suy3e0rd2cgqvycxttddwsvgxe2usfpxumr70xc9pkqwv',
    );
    await element(by.text('OK')).tap();

    await expect(element(by.id('ContactListItem0'))).toBeVisible();
    await expect(element(by.id('ContactListItem1'))).toBeVisible();

    await element(by.text('Add Contact')).tap();
    await element(by.type('android.widget.EditText')).replaceText(
      'PM8TJS2JxQ5ztXUpBBRnpTbcUXbUHy2T1abfrb3KkAAtMEGNbey4oumH7Hc578WgQJhPjBxteQ5GHHToTYHE3A1w6p7tU6KSoFmWBVbFGjKPisZDbP97',
    );
    await element(by.text('OK')).tap();

    await waitForText('On-chain transaction needed');
    await element(by.text('Cancel')).tap();

    // testing renaming contact:
    await element(by.id('ContactListItem0')).tap();
    await element(by.text('Rename contact')).tap();
    await element(by.type('android.widget.EditText')).replaceText('c0ntact');
    await element(by.text('OK')).tap();
    await expect(element(by.text('c0ntact'))).toBeVisible();

    // now, doing a real transaction with our contacts

    await device.pressBack();
    await device.pressBack();
    await device.pressBack();
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await waitForId('SendButton');

    await tapAndTapAgainIfElementIsNotVisible('SendButton', 'HeaderMenuButton');
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Insert Contact')).tap();
    await tapAndTapAgainIfElementIsNotVisible('ContactListItem0', 'BitcoinAmountInput');
    await element(by.id('BitcoinAmountInput')).typeText('0.0001\n');

    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Add Recipient')).tap();
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Insert Contact')).tap();
    await element(by.id('ContactListItem1')).tap();
    await element(by.id('BitcoinAmountInput')).atIndex(1).typeText('0.0002\n');
    await sleep(1000);
    // setting fee rate:
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText('1');
    await element(by.id('feeCustom')).tapReturnKey();
    await sleep(1000);

    await element(by.id('CreateTransactionButton')).tap();
    await element(by.id('TransactionDetailsButton')).tap();

    const txhex1 = await extractTextFromElementById('TxhexInput');
    const tx1 = bitcoin.Transaction.fromHex(txhex1);
    assert.strictEqual(tx1.outs.length, 3);
    assert.strictEqual(uint8ArrayToHex(tx1.outs[0].script), '76a91419129d53e6319baf19dba059bead166df90ab8f588ac');
    assert.strictEqual(tx1.outs[0].value, 10000n);
    assert.strictEqual(uint8ArrayToHex(tx1.outs[1].script), '5120b81959cd9a4954cd525916cd636b4ffe9466600412ccd162653a0f464489f1a8');
    assert.strictEqual(tx1.outs[1].value, 20000n);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can do basic wallet-details operations', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t_walletdetails');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();

    // let's test wallet details screens
    await element(by.id('WalletDetails')).tap();

    // rename test
    await element(by.id('WalletNameInput')).replaceText('testname');
    await element(by.id('WalletNameInput')).typeText('\n'); // newline is what triggers saving the wallet
    await device.pressBack();
    await waitForText('testname');
    await expect(element(by.id('WalletLabel'))).toHaveText('testname');
    await element(by.id('WalletDetails')).tap();

    // rename back
    await element(by.id('WalletNameInput')).replaceText('Imported HD SegWit (BIP84 Bech32 Native)');
    await element(by.id('WalletNameInput')).typeText('\n'); // newline is what triggers saving the wallet
    await device.pressBack();
    await waitForText('Imported HD SegWit (BIP84 Bech32 Native)');
    await expect(element(by.id('WalletLabel'))).toHaveText('Imported HD SegWit (BIP84 Bech32 Native)');
    await element(by.id('WalletDetails')).tap();

    // wallet export
    await element(by.id('WalletDetailsScroll')).swipe('up', 'fast', 1);
    await tapAndTapAgainIfElementIsNotVisible('WalletExport', 'WalletExportScroll');
    await element(by.id('WalletExportScroll')).swipe('up', 'fast', 1);
    await expect(element(by.id('Secret'))).toHaveText(process.env.HD_MNEMONIC_BIP84);
    await device.pressBack();

    // XPUB
    await element(by.id('WalletDetailsScroll')).swipe('up', 'fast', 1);
    await tapAndTapAgainIfElementIsNotVisible('XpubButton', 'CopyTextToClipboard');
    await device.pressBack();

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('should handle URL successfully', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t22');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t22'), 'as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });

    await device.launchApp({
      newInstance: true,
      url: 'bitcoin:BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7?amount=0.0001&label=Yo',
    });

    // setting fee rate:
    const feeRate = 2;
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText(feeRate.toString());
    await element(by.id('feeCustom')).tapReturnKey();

    if (process.env.TRAVIS) await sleep(5000);
    try {
      await element(by.id('CreateTransactionButton')).tap();
    } catch (_) {}

    // created. verifying:
    await waitForId('TransactionValue');
    await expect(element(by.id('TransactionValue'))).toHaveText('0.0001');
    await expect(element(by.id('TransactionAddress'))).toHaveText('BC1QH6TF004TY7Z7UN2V5NTU4MKF630545GVHS45U7');

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can manage UTXO', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t23');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t23'), 'as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });
    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();

    await waitFor(element(by.id('NoTxBuyBitcoin')))
      .not.toExist()
      .withTimeout(300 * 1000);

    // change note of 0.00069909 tx output
    await element(by.text('0.00069909')).atIndex(0).tap();
    await element(by.text('Details')).tap();
    await expect(element(by.text('8b0ab2c7196312e021e0d3dc73f801693826428782970763df6134457bd2ec20'))).toBeVisible();
    await element(by.type('android.widget.EditText')).replaceText('test1');
    await element(by.type('android.widget.EditText')).tapReturnKey();

    // Terminate and reopen the app to confirm the note is persisted
    await device.launchApp({ newInstance: true });
    await waitForId('WalletsList');
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Coin Control')).tap();
    await waitFor(element(by.id('Loading'))) // wait for outputs to be loaded
      .not.toExist()
      .withTimeout(300 * 1000);
    await expect(element(by.text('test1')).atIndex(0)).toBeVisible();

    // change output note and freeze it
    await element(by.text('test1')).atIndex(0).tap();
    await element(by.id('OutputMemo')).replaceText('test2');
    await element(by.type('android.widget.CompoundButton')).tap(); // freeze switch
    await element(by.id('ModalDoneButton')).tap();
    await expect(element(by.text('test2')).atIndex(0)).toBeVisible();
    await expect(element(by.text('Freeze')).atIndex(0)).toBeVisible();

    // use frozen output to create tx using "Use coin" feature
    await element(by.text('test2')).atIndex(0).tap();
    await element(by.id('UseCoin')).tap();
    await element(by.id('AddressInput')).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Use Full Balance')).tap();
    await element(by.text('OK')).tap();
    // setting fee rate:
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).replaceText('1');
    await element(by.id('feeCustom')).tapReturnKey();
    await sleep(3000);
    await element(by.id('CreateTransactionButton')).tap();
    await element(by.id('TransactionDetailsButton')).tap();

    const txhex1 = await extractTextFromElementById('TxhexInput');
    const tx1 = bitcoin.Transaction.fromHex(txhex1);
    assert.strictEqual(tx1.outs.length, 1);
    assert.strictEqual(uint8ArrayToHex(tx1.outs[0].script), '00147ea385f352be696ab0f6e94a0ee0e3c6d4b14a53');
    assert.strictEqual(tx1.outs[0].value, 69797n);
    assert.strictEqual(tx1.ins.length, 1);
    assert.strictEqual(uint8ArrayToHex(tx1.ins[0].hash), '20ecd27b453461df63079782874226386901f873dcd3e021e0126319c7b20a8b');
    assert.strictEqual(tx1.ins[0].index, 0);

    // back to wallet screen
    await device.pressBack();
    await device.pressBack();
    await device.pressBack();

    // create tx with unfrozen input
    await waitForId('SendButton');
    await element(by.id('SendButton')).tap();
    await element(by.id('AddressInput')).replaceText('bc1q063ctu6jhe5k4v8ka99qac8rcm2tzjjnuktyrl');
    await element(by.id('HeaderMenuButton')).tap();
    await element(by.text('Use Full Balance')).tap();
    await element(by.text('OK')).tap();
    // setting fee rate:
    await element(by.id('chooseFee')).tap();
    await element(by.id('feeCustomContainerButton')).tap();
    await element(by.id('feeCustom')).typeText('1');
    await element(by.id('feeCustom')).tapReturnKey();
    if (process.env.TRAVIS) await sleep(5000);
    await element(by.id('CreateTransactionButton')).tap();
    await element(by.id('TransactionDetailsButton')).tap();

    const txhex2 = await extractTextFromElementById('TxhexInput');
    const tx2 = bitcoin.Transaction.fromHex(txhex2);

    assert.strictEqual(tx2.outs.length, 1);
    assert.strictEqual(uint8ArrayToHex(tx2.outs[0].script), '00147ea385f352be696ab0f6e94a0ee0e3c6d4b14a53');
    assert.strictEqual(tx2.outs[0].value, 35369n);
    assert.strictEqual(tx2.ins.length, 3);
    assert.strictEqual(uint8ArrayToHex(tx2.ins[0].hash), 'd479264875a0f7c4a84e47141be005404531a8655f2388ae21e89a9701f14c10');
    assert.strictEqual(tx2.ins[0].index, 0);

    process.env.TRAVIS && require('fs').writeFileSync(lockFile, '1');
  });

  it('can purge txs and balance, then refetch data from tx list screen and see data on screen update', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t24');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t24'), 'as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });
    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await element(by.id('WalletDetails')).tap();

    // tapping backdoor button to purge txs and balance:
    for (let c = 0; c <= 10; c++) {
      await element(by.id('PurgeBackdoorButton')).tap();
      await sleep(500);
    }

    await waitForText('OK');
    await tapIfTextPresent('OK');

    if (device.getPlatform() === 'ios') {
      console.warn('rest of the test is Android only, skipped');
      return;
    }

    await device.pressBack();

    // asserting there are no transactions and balance is 0:

    await expect(element(by.id('WalletBalance'))).toHaveText('0');
    await waitForId('TransactionsListEmpty');
    assert.strictEqual(await countElements('TransactionListItem'), 0);

    await element(by.id('TransactionsListView')).swipe('down', 'slow'); // pul-to-refresh

    // asserting balance and txs loaded:
    await waitForText('0.00105526'); // the wait inside allows network request to propagate
    await waitFor(element(by.id('TransactionsListEmpty')))
      .not.toBeVisible()
      .withTimeout(25_000);
    await expect(element(by.id('WalletBalance'))).toHaveText('0.00105526');
    await expect(element(by.id('TransactionsListEmpty'))).not.toBeVisible();

    assert.ok((await countElements('TransactionListItem')) >= 3); // 3 is arbitrary, real txs on screen depend on screen size
  });

  it('can purge txs and balance, then restart the app and witness it to refetch tx list screen and balance', async () => {
    const lockFile = '/tmp/travislock.' + hashIt('t25');
    if (process.env.TRAVIS) {
      if (require('fs').existsSync(lockFile)) return console.warn('skipping', JSON.stringify('t25'), 'as it previously passed on Travis');
    }
    if (!process.env.HD_MNEMONIC_BIP84) {
      console.error('process.env.HD_MNEMONIC_BIP84 not set, skipped');
      return;
    }

    await device.launchApp({ newInstance: true });
    // go inside the wallet
    await element(by.text('Imported HD SegWit (BIP84 Bech32 Native)')).tap();
    await element(by.id('WalletDetails')).tap();

    // tapping backdoor button to purge txs and balance:
    for (let c = 0; c <= 10; c++) {
      await element(by.id('PurgeBackdoorButton')).tap();
      await sleep(500);
    }

    await waitForText('OK');
    await tapIfTextPresent('OK');

    if (device.getPlatform() === 'ios') {
      console.warn('rest of the test is Android only, skipped');
      return;
    }

    await device.pressBack();

    // asserting there are no transactions and balance is 0:

    await expect(element(by.id('WalletBalance'))).toHaveText('0');
    await waitForId('TransactionsListEmpty');
    assert.strictEqual(await countElements('TransactionListItem'), 0);

    // now, restarting the app:
    await device.launchApp({ newInstance: true });
    // ^^^ its supposed to refetch txs and balance

    // asserting balance and txs loaded:
    await waitForText('0.00105526 BTC '); // the wait inside allows network request to propagate. also, stupid space in the end of the string
    assert.ok((await countElements('TransactionListItem')) >= 2); // 2 is arbitrary, real txs on screen depend on screen size
  });
});


================================================
FILE: ./tests/custom-environment.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * @fileOverview see tests/custom-reporter.js for more information
 */
import NodeEnvironment from 'jest-environment-node';
class CustomEnvironment extends NodeEnvironment {
  async handleTestEvent(event) {
    if (event.name === 'test_start') {
      if (!process.env.RETRY) return;

      const fullName = (event.test.parent.name === 'ROOT_DESCRIBE_BLOCK' ? '' : event.test.parent.name + ' ') + event.test.name;
      const hash = require('crypto').createHash('md5').update(fullName).digest('hex');
      if (require('fs').existsSync(`/tmp/${hash}`)) {
        event.test.mode = 'skip';
        console.log('skipping as it previously passed on CI:', fullName);
      }
    }
  }
}

module.exports = CustomEnvironment;


================================================
FILE: ./tests/setup.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import mockClipboard from "@react-native-clipboard/clipboard/jest/clipboard-mock.js";

const consoleWarnOrig = console.warn;
console.warn = (...args) => {
  if (
    typeof args[0] === 'string' &&
    (args[0].startsWith(
      'WARNING: Sending to a future segwit version address can lead to loss of funds',
    ) ||
      args[0].startsWith('only compressed public keys are good'))
  ) {
    return;
  }
  consoleWarnOrig.apply(consoleWarnOrig, args);
}

const consoleLogOrig = console.log;
console.debug = console.log = (...args) => {
  if (
    typeof args[0] === 'string' &&
    (args[0].startsWith('updating exchange rate') ||
      args[0].startsWith('Created new currency formatter for') ||
      args[0].startsWith('begin connection') ||
      args[0].startsWith('TLS Connected to') ||
      args[0].startsWith('connected to'))
  ) {
    return;
  }
  consoleLogOrig.apply(consoleLogOrig, args);
}

global.net = require('net'); // needed by Electrum client. For RN it is proviced in shim.js
global.tls = require('tls'); // needed by Electrum client. For RN it is proviced in shim.js
global.fetch = require('node-fetch');

jest.mock('@react-native-clipboard/clipboard', () => mockClipboard);

jest.mock('react-native-watch-connectivity', () => {
  return {
    getIsWatchAppInstalled: jest.fn(() => Promise.resolve(false)),
    subscribeToMessages: jest.fn(),
    updateApplicationContext: jest.fn(),
  }
});

jest.mock('react-native-secure-key-store', () => {
  return {};
})

jest.mock('@react-native-community/push-notification-ios', () => {
  return {};
})

jest.mock('react-native-permissions', () =>
  require('react-native-permissions/mock'),
)

jest.mock('react-native-device-info', () => {
  return {
    getUniqueId: jest.fn().mockReturnValue('uniqueId'),
    getSystemName: jest.fn(),
    getDeviceType: jest.fn().mockReturnValue(false),
    hasGmsSync: jest.fn().mockReturnValue(true),
    hasHmsSync: jest.fn().mockReturnValue(false),
    isTablet: jest.fn().mockReturnValue(false),
  }
});

jest.mock('react-native-quick-actions', () => {
  return {
    clearShortcutItems: jest.fn(),
    setQuickActions: jest.fn(),
    isSupported: jest.fn(),
  }
});

jest.mock('react-native-default-preference', () => {
  let mockPreferences = {};
  let currentSuiteName = 'default';

  const getSuite = (name) => {
    if (!mockPreferences[name]) {
      mockPreferences[name] = {};
    }
    return mockPreferences[name];
  }

  return {
    setName: jest.fn((name) => {
      currentSuiteName = name;
      if (!mockPreferences[name]) {
        mockPreferences[name] = {};
      }
      return Promise.resolve();
    }),

    getName: jest.fn(() => {
      return Promise.resolve(currentSuiteName);
    }),

    get: jest.fn((key) => {
      const suite = getSuite(currentSuiteName);
      return Promise.resolve(
        Object.prototype.hasOwnProperty.call(suite, key) ? suite[key] : null
      );
    }),

    set: jest.fn((key, value) => {
      const suite = getSuite(currentSuiteName);
      suite[key] = value;
      return Promise.resolve();
    }),

    clear: jest.fn((key) => {
      const suite = getSuite(currentSuiteName);
      delete suite[key];
      return Promise.resolve();
    }),

    getMultiple: jest.fn((keys) => {
      const suite = getSuite(currentSuiteName);
      const values = keys.map((key) =>
        Object.prototype.hasOwnProperty.call(suite, key) ? suite[key] : null
      );
      return Promise.resolve(values);
    }),

    setMultiple: jest.fn((keyValuePairs) => {
      const suite = getSuite(currentSuiteName);
      Object.entries(keyValuePairs).forEach(([key, value]) => {
        suite[key] = value;
      })
      return Promise.resolve();
    }),

    clearMultiple: jest.fn((keys) => {
      const suite = getSuite(currentSuiteName);
      keys.forEach((key) => delete suite[key]);
      return Promise.resolve();
    }),

    getAll: jest.fn(() => {
      const suite = getSuite(currentSuiteName);
      return Promise.resolve({ ...suite });
    }),

    clearAll: jest.fn(() => {
      mockPreferences[currentSuiteName] = {};
      return Promise.resolve();
    }),

    reset: jest.fn(() => {
      mockPreferences = {};
      currentSuiteName = 'default'; // Reset the current suite name
      return Promise.resolve();
    })
  }
})

jest.mock('react-native-fs', () => {
  return {
    mkdir: jest.fn(),
    moveFile: jest.fn(),
    copyFile: jest.fn(),
    pathForBundle: jest.fn(),
    pathForGroup: jest.fn(),
    getFSInfo: jest.fn(),
    getAllExternalFilesDirs: jest.fn(),
    unlink: jest.fn(),
    exists: jest.fn(),
    stopDownload: jest.fn(),
    resumeDownload: jest.fn(),
    isResumable: jest.fn(),
    stopUpload: jest.fn(),
    completeHandlerIOS: jest.fn(),
    readDir: jest.fn(),
    readDirAssets: jest.fn(),
    existsAssets: jest.fn(),
    readdir: jest.fn(),
    setReadable: jest.fn(),
    stat: jest.fn(),
    readFile: jest.fn(),
    read: jest.fn(),
    readFileAssets: jest.fn(),
    hash: jest.fn(),
    copyFileAssets: jest.fn(),
    copyFileAssetsIOS: jest.fn(),
    copyAssetsVideoIOS: jest.fn(),
    writeFile: jest.fn(),
    appendFile: jest.fn(),
    write: jest.fn(),
    downloadFile: jest.fn(),
    uploadFiles: jest.fn(),
    touch: jest.fn(),
    MainBundlePath: jest.fn(),
    CachesDirectoryPath: jest.fn(),
    DocumentDirectoryPath: jest.fn(),
    ExternalDirectoryPath: jest.fn(),
    ExternalStorageDirectoryPath: jest.fn(),
    TemporaryDirectoryPath: jest.fn(),
    LibraryDirectoryPath: jest.fn(),
    PicturesDirectoryPath: jest.fn(),
  }
});

jest.mock('@react-native-documents/picker', () => ({}));

jest.mock('react-native-haptic-feedback', () => ({}));

const realmInstanceMock = {
  create: function () {},
  delete: function () {},
  close: function () {},
  write: function (transactionFn) {
    if (typeof transactionFn === 'function') {
      // to test if something is not right in Realm transactional database write
      transactionFn();
    }
  },
  objectForPrimaryKey: function () {
    return {};
  },
  objects: function () {
    const wallets = {
      filtered: function () {
        return [];
      }
    }
    return wallets;
  }
}
jest.mock('realm', () => {
  return {
    UpdateMode: { Modified: 1 },
    open: jest.fn(() => realmInstanceMock),
  }
});

jest.mock('rn-qr-generator', () => ({
  detect: jest.fn((uri) => {
    if (uri === 'invalid-image') {
      return Promise.reject(new Error('Failed to decode QR code'));
    }
    return Promise.resolve({ values: ['mocked-qr-code'] });
  })
}));

jest.mock('react-native-haptic-feedback', () => {
  return {
    trigger: jest.fn(),
  }
});

jest.mock('../malin_modules/analytics', () => {
  const ret = jest.fn();
  ret.ENUM = { CREATED_WALLET: '' };
  return ret;
})

jest.mock('react-native-share', () => {
  return {
    open: jest.fn(),
  }
});

const mockKeychain = {
  SECURITY_LEVEL_ANY: 'MOCK_SECURITY_LEVEL_ANY',
  SECURITY_LEVEL_SECURE_SOFTWARE: 'MOCK_SECURITY_LEVEL_SECURE_SOFTWARE',
  SECURITY_LEVEL_SECURE_HARDWARE: 'MOCK_SECURITY_LEVEL_SECURE_HARDWARE',
  setGenericPassword: jest.fn().mockResolvedValue(),
  getGenericPassword: jest.fn().mockResolvedValue(),
  resetGenericPassword: jest.fn().mockResolvedValue(),
}
jest.mock('react-native-keychain', () => mockKeychain);

jest.mock('react-native-tcp-socket', () => mockKeychain);

global.alert = () => {};

jest.mock('@env', () => ({
  NEXT_PUBLIC_INFURA_GAS_API_KEY: 'dummy_key',
}));


================================================
FILE: ./tests/custom-reporter.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * @fileOverview to combat flakiness of jest integration tests we implement a diy retry mechanism:
 * a custom reporter writes a lock file in /tmp for each successfull testcase.
 * then when a test suite is restarted, a custom environment checks if a testcase passed previously and
 * forcefully skips such test cases.
 */
class CustomReporter {
  constructor(globalConfig, reporterOptions, reporterContext) {
    this._globalConfig = globalConfig;
    this._options = reporterOptions;
    this._context = reporterContext;
  }

  onTestCaseResult(test, testCaseResult) {
    if (!process.env.RETRY) return;

    // since we cant distinguish several testcases in `it.each(...)`, we just ignore them so they will always run
    if (testCaseResult.fullName.includes('can fetch balance, transactions & utxo, disableBatching=')) return;
    if (testCaseResult.fullName.includes('MalinElectrum can do multiGetBalanceByAddress(), disableBatching=')) return;
    if (testCaseResult.fullName.includes('ElectrumClient can do multiGetHistoryByAddress(), disableBatching=')) return;
    if (testCaseResult.fullName.includes('ElectrumClient can do multiGetTransactionByTxid(), disableBatching=')) return;
    if (testCaseResult.fullName.includes('ElectrumClient can do multiGetHistoryByAddress() to obtain txhex, disableBatching=')) return;
    if (testCaseResult.fullName.includes('addresses for vout missing')) return;
    if (testCaseResult.fullName.includes('txdatas were coming back null from MalinElectrum because of high batchsize')) return;

    const hash = require('crypto').createHash('md5').update(testCaseResult.fullName).digest('hex');
    if (testCaseResult.status === 'passed') {
      // marking testcase as passed in /tmp
      require('fs').writeFileSync(`/tmp/${hash}`, '1');
    }
  }
}

module.exports = CustomReporter;


================================================
FILE: ./scripts/run-ln-acceptance-tests.sh
================================================

./node_modules/.bin/jest  --testNamePattern='can pay invoice'  tests/integration/lightning-custodian-wallet.test.js


================================================
FILE: ./scripts/find-unused-loc.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const fs = require('fs');
const path = require('path');

const mainLocFile = './loc/en.json';
const dirsToInterate = [
  'components',
  'screen',
  'malin_modules',
  'class',
  'hooks',
  'helpers',
  'navigation',
  'typings',
]
const addFiles = ['MalinComponents.js', 'App.tsx', 'navigation/index.tsx'];
const allowedLocPrefixes = ['loc.lnurl_auth', 'loc.units'];

const allLocKeysHashmap = {}; // loc key -> used or not

const getAllFiles = function (dirPath, arrayOfFiles) {
  const files = fs.readdirSync(dirPath);

  arrayOfFiles = arrayOfFiles || [];

  files.forEach(function (file) {
    if (fs.statSync(dirPath + '/' + file).isDirectory()) {
      arrayOfFiles = getAllFiles(dirPath + '/' + file, arrayOfFiles);
    } else {
      arrayOfFiles.push(path.resolve(path.join(dirPath, '/', file)));
    }
  });

  return arrayOfFiles;
}

const allDirFiles = [];
for (const dir of dirsToInterate) {
  allDirFiles.push(...getAllFiles(dir));
}

for (const filename of addFiles) {
  allDirFiles.push(path.resolve(filename));
}
allDirFiles.push(path.resolve('App.tsx'));

// got all source files

function objKeysRecursive(obj, depth = []) {
  for (const k in obj) {
    if (typeof obj[k] === 'object' && obj[k] !== null) {
      objKeysRecursive(obj[k], depth.concat(k));
    } else {
      allLocKeysHashmap['loc.' + depth.join('.') + '.' + k] = false; // false means unused
    }
  }
}
objKeysRecursive(JSON.parse(fs.readFileSync(mainLocFile).toString('utf8')));

// got all loc keys.
// finally, iterating all source files, readign them and looking for unused loc keys

// iterating all files
for (const filepath of allDirFiles) {
  const contents = fs.readFileSync(filepath);

  // opened a file. iterating all loc keys
  for (const key of Object.keys(allLocKeysHashmap)) {
    if (contents.includes(key)) {
      // opened file uses this loc key. marking it as used
      allLocKeysHashmap[key] = true;
    }
  }
}

// done! now printing results:

let exitCode = 0;
for (const key of Object.keys(allLocKeysHashmap)) {
  let allow = false;
  for (const allowedKey of allowedLocPrefixes) {
    if (key.startsWith(allowedKey)) allow = true;
  }

  if (allLocKeysHashmap[key] === false && !allow) {
    console.log('Unused loc key: ' + key);
    exitCode = 1;
  }
}

process.exit(exitCode);


================================================
FILE: ./scripts/edit-version-number.sh
================================================

vim ios/MalinWallet.xcodeproj/project.pbxproj
vim android/app/build.gradle
vim package.json
vim package-lock.json


================================================
FILE: ./scripts/deeplink-to-emusim.sh
================================================

#!/bin/bash

deepLinks=(
  "bitcoin:12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG"
  "bitcoin:bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7?amount=666&label=Yo"
  "BITCOIN:BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE"
  "malinwallet:bitcoin:12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG"
  "lightning:lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde"
  "malinwallet:lightning:lnbc10u1pwjqwkkpp5vlc3tttdzhpk9fwzkkue0sf2pumtza7qyw9vucxyyeh0yaqq66yqdq5f38z6mmwd3ujqar9wd6qcqzpgxq97zvuqrzjqvgptfurj3528snx6e3dtwepafxw5fpzdymw9pj20jj09sunnqmwqz9hx5qqtmgqqqqqqqlgqqqqqqgqjq5duu3fs9xq9vn89qk3ezwpygecu4p3n69wm3tnl28rpgn2gmk5hjaznemw0gy32wrslpn3g24khcgnpua9q04fttm2y8pnhmhhc2gncplz0zde"
  "https://azte.co/?c1=3062&c2=2586&c3=5053&c4=5261"
  "https://azte.co/redeem?code=1111222233334444"
  "malinwallet:setelectrumserver?server=electrum1.malinwallet.io%3A443%3As"
  "malinwallet:setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com"
  "lnaddress@zbd.gg"
  "zpub6rFDtF1nuXZ9PUL4XzKURh3vJBW6Kj6TUrYL4qPtFNtDXtcTVfiqjQDyrZNwjwzt5HS14qdqo3Co2282Lv3Re6Y5wFZxAVuMEpeygnnDwfx"
)

testOptions=("Send" "Notification")
select_test_type() {
  local ESC=$(printf "\033")
  local selected=0
  while true; do
    clear
    echo -e "\n\033[1mSelect test type (Send or Notification):\033[0m\n"
    for i in "${!testOptions[@]}"; do
      if [ $i -eq $selected ]; then
        echo "> ${testOptions[$i]}"
      else
        echo "  ${testOptions[$i]}"
      fi
    done
    read -rsn1 key
    if [[ $key == $ESC ]]; then
      read -rsn2 key
      case $key in
        '[A')
          ((selected--))
          if [ $selected -lt 0 ]; then
            selected=$((${#testOptions[@]} - 1))
          fi
          ;;
        '[B')
          ((selected++))
          if [ $selected -ge ${#testOptions[@]} ]; then
            selected=0
          fi
          ;;
      esac
    elif [[ $key == "" ]]; then
      TEST_TYPE="${testOptions[$selected]}"
      echo -e "\nSelected $TEST_TYPE test\n"
      break
    fi
  done
}
select_test_type

# For Notification mode, use only three bare bitcoin addresses
if [[ "$TEST_TYPE" == "Notification" ]]; then
  deepLinks=(
    "12eQ9m4sgAwTSQoNXkRABKhCXCsjm2jdVG"
    "bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7"
    "BC1Q3RL0MKYK0ZRTXFMQN9WPCD3GNAZ00YV9YP0HXE"
  )
fi

select_option() {
  local ESC=$(printf "\033")
  local selected=0

  while true; do
    clear
    if [[ "$TEST_TYPE" == "Notification" ]]; then
      echo -e "\n\033[1m[Category: Receive] Select a deep link for notification:\033[0m\n"
    else
      echo -e "\n\033[1m[Test: $TEST_TYPE] Select a deep link:\033[0m\n"
    fi
    for i in "${!deepLinks[@]}"; do
      if [ $i -eq $selected ]; then
        echo "> ${deepLinks[$i]}"
      else
        echo "  ${deepLinks[$i]}"
      fi
    done

    read -rsn1 key
    if [[ $key == $ESC ]]; then
      read -rsn2 key
      case $key in
        '[A') # Up arrow
          ((selected--))
          if [ $selected -lt 0 ]; then
            selected=$((${#deepLinks[@]} - 1))
          fi
          ;;
        '[B') # Down arrow
          ((selected++))
          if [ $selected -ge ${#deepLinks[@]} ]; then
            selected=0
          fi
          ;;
      esac
    elif [[ $key == "" ]]; then
      break
    fi
  done

  selectedLink="${deepLinks[$selected]}"
}

select_option

# Enumerate booted iOS simulators with OS versions
ios_sims=()
while IFS= read -r line; do
  if [[ $line =~ --\ (.*)\ -- ]]; then
    osVersion="${BASH_REMATCH[1]}"
  elif [[ $line =~ \(Booted\) ]]; then
    # trim leading whitespace
    raw=$(echo "$line" | sed 's/^[[:space:]]*//')
    # extract UDID (UUID format)
    udid=$(echo "$raw" | grep -oE '[A-F0-9-]{36}' | head -n1)
    if [[ -n "$udid" ]]; then
      name=$(echo "$raw" | sed -E "s/ \($udid\).*//")
      ios_sims+=("$name|$osVersion|$udid")
    fi
  fi
done < <(xcrun simctl list devices)

# Enumerate running Android emulators with OS versions
android_ids=($(adb devices | grep "device$" | awk '{print $1}'))
android_sims=()
for emu in "${android_ids[@]}"; do
  ver=$(adb -s "$emu" shell getprop ro.build.version.release 2>/dev/null)
  android_sims+=("$emu|$ver")
done

if [ ${#ios_sims[@]} -eq 0 ] && [ ${#android_sims[@]} -eq 0 ]; then
  echo -e "\n\033[1mNo running iOS simulators or Android emulators found.\033[0m\n"
  exit 1
fi

# Build a single list of devices for user selection
devices=()
for sim in "${ios_sims[@]}"; do
  IFS='|' read -r name os udid <<< "$sim"
  devices+=("iOS Simulator: $name ($os) [$udid]")
done
for emu in "${android_sims[@]}"; do
  IFS='|' read -r id ver <<< "$emu"
  devices+=("Android Emulator: $id (Android $ver)")
done

echo -e "\n\033[1mSelect the target device:\033[0m\n"
PS3=$'\nEnter the number corresponding to your choice: '
select device in "${devices[@]}"; do
  if [[ -z "$device" ]]; then
    echo -e "\n\033[1mInvalid selection. Please select again.\033[0m\n"
    continue
  fi
  platform="${device%%:*}"
  dev="${device#*: }"
  if [[ "$platform" == "iOS Simulator" ]]; then
    udid="${dev##*[}"
    udid="${udid%%]*}"
    if [[ "$TEST_TYPE" == "Notification" ]]; then
      echo -e "\nPreparing notification payload for address: $selectedLink\n"
      # dynamically build APNS payload with selected address
      read -r -d '' APNS_PAYLOAD << JSON
{
  "Simulator Target Bundle": "com.malinwallet.app",
  "aps": {
    "alert": {
      "title": "Transaction Received",
      "body": "You received 2000 satoshis to your address.",
      "action": "View Transaction"
    },
    "sound": "default",
    "badge": 1,
    "content-available": 1
  },
  "data": {
    "type": 2,
    "sat": 2000,
    "address": "$selectedLink",
    "txid": "sample_txid_2",
    "userInteraction": true,
    "foreground": false,
    "walletID": "wallet123",
    "chain": "ONCHAIN",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
JSON
      # write payload to temporary file
      apns_file=$(mktemp /tmp/malinwallet-apns-XXXXXX.apns)
      printf '%s' "$APNS_PAYLOAD" > "$apns_file"
      echo -e "Pushing notification to simulator $udid..."
      xcrun simctl push "$udid" "$apns_file"
      rm "$apns_file"
    else
      echo -e "\nSending deep link to iOS simulator: $selectedLink\n"
      xcrun simctl openurl "$udid" "$selectedLink"
    fi
  else
    echo -e "\nSending deep link to Android emulator: $selectedLink\n"
    # Strip version info to get the emulator device ID
    emuId="${dev%% *}"
    adb -s "$emuId" shell am start -a android.intent.action.VIEW -d "$selectedLink"
  fi
  break
done

================================================
FILE: ./scripts/remove-loc-key.sh
================================================

#!/bin/bash

# Check if a nested key path is provided
if [ -z "$1" ]; then
    echo "Usage: $0 nested_key"
    echo "Example: $0 autofill_word.error"
    exit 1
fi

NESTED_KEY=$1
IFS='.' read -r -a KEYS <<< "$NESTED_KEY"

# Define the potential directories containing JSON files
JSON_DIR1="../loc/"
JSON_DIR2="loc/"

# Check which directory exists and use it
if [ -d "$JSON_DIR1" ]; then
    JSON_DIR="$JSON_DIR1"
elif [ -d "$JSON_DIR2" ]; then
    JSON_DIR="$JSON_DIR2"
else
    echo "Neither $JSON_DIR1 nor $JSON_DIR2 exists. Exiting."
    exit 1
fi

# Function to remove the nested key from a JSON file
remove_nested_key_with_awk() {
    local file=$1

    awk -v keys="${KEYS[*]}" '
    BEGIN { 
        split(keys, k, " "); 
        key_count = length(k);
        skip = 0; 
        match_count = 0; 
        brace_count = 0; 
        delete_line = 0
    }
    {
        if (match_count < key_count && $0 ~ "\""k[match_count+1]"\" *:") {
            match_count++;
            if (match_count == key_count) {
                skip = 1;
                delete_line = NR;
                if ($0 ~ /{/) {
                    brace_count = 1;
                } else {
                    brace_count = 0;
                }
            }
        } else if (match_count < key_count && $0 ~ /{/) {
            brace_count++;
        } else if (match_count < key_count && $0 ~ /}/) {
            brace_count--;
            if (brace_count == 0) {
                match_count = 0;
            }
        }

        if (skip && $0 ~ /{/) {
            brace_count++;
        }
        if (skip && $0 ~ /}/) {
            brace_count--;
        }
        if (skip && brace_count == 0) {
            skip = 0;
            if (delete_line > 0) {
                next;
            }
        }
        if (skip == 0) {
            print $0;
        }
    }' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
}

# Iterate over all JSON files in the chosen directory
for file in "$JSON_DIR"*.json; do
    if [ -f "$file" ]; then
        echo "Processing $file..."
        remove_nested_key_with_awk "$file"
    fi
done

echo "Done."


================================================
FILE: ./scripts/current-branch.sh
================================================

#!/bin/sh

if [ -n "$GITHUB_HEAD_REF" ]; then
  echo \"$GITHUB_HEAD_REF\"
  exit
fi


BRANCH1=`git log -n 1 --pretty=%d HEAD | awk '{print $2}' | sed 's/origin\///' | sed 's/)//'`
if [ "$BRANCH1" = '->' ]
then
  BRANCH1=`git rev-parse --abbrev-ref HEAD`
fi

echo \"$BRANCH1\"


================================================
FILE: ./scripts/release-notes.sh
================================================

#!/bin/sh

# Accept a parameter to determine the filter type
FILTER_TYPE=$1

HEAD=`git rev-parse --abbrev-ref --symbolic-full-name HEAD`
if [ "$HEAD" = "master" ]
then
    TAG=`git tag | sort | tail -n 1`
else
    CURRENTTAG=`git describe --tags`
    TAG=`git describe --abbrev=0 --tags $CURRENTTAG^`
fi
HASH=`git show-ref -s $TAG`

# Define a function to apply the filter based on the parameter
apply_filter() {
    case $FILTER_TYPE in
        "apple")
            sed 's/android/other devices/Ig; s/google/other devices/Ig' | \
            sed '/Update dependency/I d' | \
            sed '/Translate loc/I d' | \
            sed '/Update /I d'
            ;;
        *)
            cat
            ;;
    esac
}

# Main log extraction command with filters applied
git log --pretty=format:'* %s %b' $HASH..HEAD | \
sed '/Merge branch '\''master'\''/I d' | \
sed '/Merge remote-tracking branch '\''origin\/master'\''/I d' | \
sed '/Merge pull request/I d' | \
awk -F 'review completed for the source file' '{print $1;}' | \
sed -E '/^on '\''[^'\'']+'\''/d' | \
awk -F 'Snyk has created this PR' '{print $1;}' | \
sed '/See this package in npm/I d; /https:\/\/www.npmjs.com\//I d; /See this project in Snyk/I d; /https:\/\/app.snyk.io/I d' | \
awk '{$1=$1};1' | \
awk 'length($0) > 5' | \
sed -E '/^\* (WIP|FIX|REF|ADD|DEL) *$/d' | \
apply_filter


================================================
FILE: ./scripts/build-release-apk.sh
================================================

#!/bin/bash

# assumes 2 env variables: KEYSTORE_FILE_HEX & KEYSTORE_PASSWORD

# PS. to turn file to hex and back:
#     $ xxd -plain test.txt > test.hex
#     $ xxd -plain -revert test.hex test2.txt

echo $KEYSTORE_FILE_HEX > malinwallet-release-key.keystore.hex
xxd -plain -revert malinwallet-release-key.keystore.hex > ./android/malinwallet-release-key.keystore
rm malinwallet-release-key.keystore.hex

cd android
# Use the BUILD_NUMBER environment variable set in the GitHub Actions workflow
sed -i'.original' "s/versionCode 1/versionCode $BUILD_NUMBER/g" app/build.gradle

# Extract versionName from build.gradle
VERSION_NAME=$(grep versionName app/build.gradle | awk '{print $2}' | tr -d '"')

./gradlew assembleRelease

# Rename the APK file to include the dynamic version and build number with parentheses
mv ./app/build/outputs/apk/release/app-release-unsigned.apk "./app/build/outputs/apk/release/MalinWallet-${VERSION_NAME}($BUILD_NUMBER).apk"

echo wheres waldo?
find $ANDROID_HOME | grep apksigner | grep -v jar

$ANDROID_HOME/build-tools/35.0.0/apksigner sign --ks ./malinwallet-release-key.keystore --ks-pass=pass:$KEYSTORE_PASSWORD "./app/build/outputs/apk/release/MalinWallet-${VERSION_NAME}($BUILD_NUMBER).apk"


================================================
FILE: ./ia.py
================================================

import os
import time
from rich.console import Console
from rich.panel import Panel
from rich.live import Live
from rich.table import Table
from langchain_ollama import OllamaLLM

console = Console()

# Initialisation des 4 Cerveaux
ia_build = OllamaLLM(model="codestral:latest")
ia_syntax = OllamaLLM(model="codellama:34b")
ia_design = OllamaLLM(model="command-r:latest")
ia_boss = OllamaLLM(model="phind-codellama:34b")

def traiter_fichier(chemin):
    with open(chemin, 'r') as f:
        code_initial = f.read()

    console.rule(f"[bold gold1]ANALYSE DE {chemin}")

    # 1. IA BUILD (DeepSeek/Codestral)
    with console.status("[bold malin]L'Ingnieur Build analyse les dpendances..."):
        diag_build = ia_build.invoke(f"Analyse ce code. Liste les erreurs de build/imports en franais. Donne ensuite le code corrig sans bla-bla inutile.\n\nCODE:\n{code_initial}")
    console.print(Panel(diag_build, title="[IA BUILD]", border_style="malin"))

    # 2. IA SYNTAXE (CodeLlama 34B)
    with console.status("[bold magenta]L'Expert Syntaxe traque les fautes de frappe..."):
        diag_syntax = ia_syntax.invoke(f"Identifie les erreurs de syntaxe TSX. Liste le nombre d'erreurs en franais et fournis le code corrig :\n\n{diag_build}")
    console.print(Panel(diag_syntax, title="[IA SYNTAXE]", border_style="magenta"))

    # 3. IA DESIGN (Command-R)
    with console.status("[bold yellow]Le Designer applique le thme Gold..."):
        diag_design = ia_design.invoke(f"Prends ce code et rends-le luxueux (Dark Gold Theme). Explique tes changements UI en franais :\n\n{diag_syntax}")
    console.print(Panel(diag_design, title="[IA DESIGN]", border_style="yellow"))

    # 4. IA BOSS (Phind 34B)
    with console.status("[bold green]Le Boss valide la scurit non-custodial..."):
        verdict = ia_boss.invoke(f"Vrifie la scurit de ce portefeuille. Fais un rapport final en franais (Erreurs restantes, Scurit, Esthtique) :\n\n{diag_design}")
    console.print(Panel(verdict, title="[VERDICT DU BOSS]", border_style="green"))

    # Sauvegarde finale
    nom_final = f"FIXED_{chemin}"
    with open(nom_final, "w") as f:
        # On essaie d'extraire uniquement le code de la rponse du Boss/Designer
        f.write(diag_design)
    
    console.print(f"\n[bold green] {chemin} termin ! Fichier cr : {nom_final}[/bold green]\n")

# Lancement sur ton dossier
fichiers_cibles = ["App.tsx", "package.json"]
for f in fichiers_cibles:
    if os.path.exists(f):
        traiter_fichier(f)


================================================
FILE: ./jest.config.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
module.exports = {
  testEnvironment: '<rootDir>/tests/custom-environment.js',
  reporters: ['default', ['<rootDir>/tests/custom-reporter.js', {}]],
  preset: 'react-native',
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
  moduleFileExtensions: ['js', 'json', 'ts', 'tsx'],
  transformIgnorePatterns: [
    'node_modules/(?!((jest-)?react-native(-.*)?|@react-native(-community)?)|@rneui|silent-payments|@arkade-os)/',
  ],
  moduleNameMapper: {
    '^expo/fetch$': '<rootDir>/util/expo-fetch-nodejs.js',
    '^@env$': '<rootDir>/tests/mocks/env.js',
  },
  setupFiles: ['./tests/setup.js'],
  watchPathIgnorePatterns: ['<rootDir>/node_modules'],
};


================================================
FILE: ./ios/MalinWalletWatch Extension/Objects/WatchDataSource.swift
================================================

// Data/WatchDataSource.swift

import Foundation
import WatchConnectivity
import Security
import ClockKit

struct NotificationName {
  static let dataUpdated = Notification.Name(rawValue: "Notification.WalletDataSource.Updated")
}
struct Notifications {
  static let dataUpdated = Notification(name: NotificationName.dataUpdated)
}

/// Handles WatchConnectivity and data synchronization between iOS and Watch apps.
class WatchDataSource: NSObject, WCSessionDelegate {
    // MARK: - Singleton Instance
  
    static func postDataUpdatedNotification() {
        NotificationCenter.default.post(Notifications.dataUpdated)
    }
    
    static let shared = WatchDataSource()
    
    // MARK: - Properties
    
    /// The list of wallets to be displayed on the Watch app.
    var wallets: [Wallet] = [] {
        didSet {
            // When wallets are updated, save to keychain and refresh complications
            saveWalletsToKeychain()
            reloadComplications()
        }
    }
    
    var isDataLoaded: Bool = false
    
    // MARK: - Private Properties
    
    private let groupUserDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)
    private let keychain = KeychainHelper.shared
    private let session: WCSession
    
    // MARK: - Initializer
    
    private override init() {
        guard WCSession.isSupported() else {
            print("WCSession is not supported on this device.")
            self.session = WCSession.default
            super.init()
            return
        }
        self.session = WCSession.default
        super.init()
        
        // Set delegate before trying to load data
        self.session.delegate = self
        
        // Load cached data from keychain to show something while waiting for fresh data
        loadKeychainData()
    }
    
    // MARK: - Public Methods
    
    /// Starts the WatchConnectivity session.
    func startSession() {
        if session.activationState != .activated {
            print("[WatchKit 2] Activating WCSession...")
            session.activate()
        } else {
            print("[WatchKit 2] WCSession is already activated: \(session.activationState.rawValue)")
            // Even if activated, attempt to request data
            if session.isReachable {
                requestDataFromiOS()
            }
        }
    }
    
    /// Deactivates the WatchConnectivity session (if needed).
    /// Note: WCSession does not provide a deactivate method, but you can handle any necessary cleanup here.
    func deactivateSession() {
        // Handle any necessary cleanup here.
    }
    
    // MARK: - Keychain Operations
    
    /// Loads wallets data from the Keychain asynchronously.
    private func loadKeychainData() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            guard let existingData = self.keychain.retrieve(service: UserDefaultsGroupKey.WatchAppBundleIdentifier.rawValue, account: UserDefaultsGroupKey.BundleIdentifier.rawValue),
                  let decodedWallets = try? JSONDecoder().decode([Wallet].self, from: existingData) else {
                print("No existing wallets data found in Keychain.")
                return
            }
            
            // Filter wallets to include only on-chain wallets.
            let onChainWallets = decodedWallets.filter { $0.chain == .onchain }
            
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                if onChainWallets != self.wallets {
                    self.wallets = onChainWallets
                    print("Loaded \(onChainWallets.count) on-chain wallets from Keychain.")
                }
                self.isDataLoaded = true
                // Post notification about data update
                WatchDataSource.postDataUpdatedNotification()
            }
        }
    }
    
    /// Saves the current wallets data to the Keychain asynchronously.
    private func saveWalletsToKeychain() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            // Save to keychain regardless of session state
            guard let encodedData = try? JSONEncoder().encode(self.wallets) else {
                print("Failed to encode wallets.")
                return
            }
            let success = self.keychain.save(encodedData, service: UserDefaultsGroupKey.WatchAppBundleIdentifier.rawValue, account: UserDefaultsGroupKey.BundleIdentifier.rawValue)
            if success {
                print("Successfully saved wallets to Keychain.")
            } else {
                print("Failed to save wallets to Keychain.")
            }
        }
    }
    
    // MARK: - WatchConnectivity Methods
    
    /// Handles the activation completion of the WCSession.
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        if let error = error {
            print("[WatchKit 2] WCSession activation failed with error: \(error.localizedDescription)")
        } else {
            print("[WatchKit 2] WCSession activated with state: \(activationState.rawValue)")
            
            if activationState == .activated {
                DispatchQueue.main.async {
                    self.requestDataFromiOS()
                }
            }
        }
    }
    
    /// Handles received messages from the iOS app.
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        processReceivedData(message)
    }
    
    /// Handles received application context updates from the iOS app.
    func session(_ session: WCSession, didReceiveApplicationContext applicationContext: [String : Any]) {
        print("[WatchKit 2] Received application context: \(applicationContext.keys)")
        if applicationContext.isEmpty { return }
        
        DispatchQueue.main.async {
            self.processReceivedData(applicationContext)
            // Post notification that data was updated
            WatchDataSource.postDataUpdatedNotification()
        }
    }
    
    /// Requests current data from the iOS app
    func requestDataFromiOS() {
        guard session.activationState == .activated else {
            print("[WatchKit 2] Cannot request data: WCSession not activated (state: \(session.activationState.rawValue))")
            startSession() // Try to activate the session
            return
        }
        
        let message = ["message": "sendApplicationContext"]
        
        // First check if we can use direct messaging
        if session.isReachable {
            print("[WatchKit 2] iOS app is reachable, sending direct message")
            session.sendMessage(message, replyHandler: { [weak self] _ in
                print("[WatchKit 2] Successfully requested application context from iOS app")
                // Notify that we might have received data
                DispatchQueue.main.async {
                    WatchDataSource.postDataUpdatedNotification()
                }
            }, errorHandler: { error in
                print("[WatchKit 2] Error requesting application context: \(error.localizedDescription)")
                
                // Fallback to application context as a backup
                self.sendApplicationContextRequest()
            })
        } else {
            print("[WatchKit 2] iOS app is not reachable, using application context")
            sendApplicationContextRequest()
        }
    }
    
    private func sendApplicationContextRequest() {
        do {
            try session.updateApplicationContext(["message": "sendApplicationContext"])
            print("[WatchKit 2] Sent context update request to iOS app")
        } catch {
            print("[WatchKit 2] Failed to send context update request: \(error.localizedDescription)")
        }
    }
    
    // Enhance session reachability notification
    func sessionReachabilityDidChange(_ session: WCSession) {
        print("[WatchKit 2] Session reachability changed: \(session.isReachable)")
        
        if session.isReachable {
            // If iOS app becomes reachable, request fresh data
            requestDataFromiOS()
        }
    }
    
    // MARK: - Data Processing
    
    /// Processes received data from the iOS app.
    /// - Parameter data: The data received either as a message or application context.
    private func processReceivedData(_ data: [String: Any]) {
        if let preferredFiatCurrency = data["preferredFiatCurrency"] as? String {
            // Handle preferred fiat currency update.
            groupUserDefaults?.set(preferredFiatCurrency, forKey: "preferredCurrency")
            
            // Fetch and update market data based on the new preferred currency.
            updateMarketData(for: preferredFiatCurrency)
        } else {
            // Assume the data contains wallets information.
            processWalletsData(walletsInfo: data)
        }
    }
    
    /// Processes wallets data received from the iOS app.
    /// - Parameter walletsInfo: The wallets data received as a dictionary.
    private func processWalletsData(walletsInfo: [String: Any]) {
        guard let walletsToProcess = walletsInfo["wallets"] as? [[String: Any]] else {
            print("No wallets data found in received context.")
            return
        }
        
        var processedWallets: [Wallet] = []
        
        for entry in walletsToProcess {
            guard let label = entry["label"] as? String,
                  let balance = entry["balance"] as? Double,
                  let typeString = entry["type"] as? String,
                  let preferredBalanceUnitString = entry["preferredBalanceUnit"] as? String,
                  let chainString = entry["chain"] as? String,
                  let transactions = entry["transactions"] as? [[String: Any]] else {
                print("Incomplete wallet entry found. Skipping.")
                continue
            }
            
            var transactionsProcessed: [Transaction] = []
            for transactionEntry in transactions {
                guard let timeString = transactionEntry["time"] as? String,
                      let memo = transactionEntry["memo"] as? String,
                      let amountDouble = transactionEntry["amount"] as? Double,
                      let type = transactionEntry["type"] as? String else {
                    print("Incomplete transaction entry found. Skipping.")
                    continue
                }
                
                guard let time = ISO8601DateFormatter().date(from: timeString) else {
                    print("Invalid date format for transaction. Skipping.")
                    continue
                }
                
                let amount = Decimal(amountDouble)
                
                let transactionType = TransactionType.fromRawString(type)
                
                let transaction = Transaction(time: time, memo: memo, type: transactionType, amount: amount)
                transactionsProcessed.append(transaction)
            }
            
            let receiveAddress = entry["receiveAddress"] as? String ?? ""
            let xpub = entry["xpub"] as? String ?? ""
            let hideBalance = entry["hideBalance"] as? Bool ?? false
            let paymentCode = entry["paymentCode"] as? String
            let chain = Chain(rawString: chainString)
            
            let wallet = Wallet(
                label: label,
                balance: "\(balance) BTC",
                type: WalletType(rawString: typeString),
                chain: chain,
                preferredBalanceUnit: BitcoinUnit(rawString: preferredBalanceUnitString),
                receiveAddress: receiveAddress,
                transactions: transactionsProcessed,
                xpub: xpub,
                hideBalance: hideBalance,
                paymentCode: paymentCode
            )
            processedWallets.append(wallet)
        }
        
        // Update the `wallets` property on the main thread.
        DispatchQueue.main.async { [weak self] in
            self?.wallets = processedWallets
            print("Updated wallets from received context.")
            WatchDataSource.postDataUpdatedNotification()
        }
    }
    
    /// Fetches market data based on the preferred fiat currency.
    /// - Parameter fiatCurrency: The preferred fiat currency string.
    private func updateMarketData(for fiatCurrency: String) {
        guard !fiatCurrency.isEmpty else {
            print("Invalid fiat currency provided")
            return
        }

        MarketAPI.fetchPrice(currency: fiatCurrency) { [weak self] (marketData, error) in
            guard let self = self else { return }
            if let error = error {
                print("Failed to fetch market data: \(error.localizedDescription)")
                // Consider implementing retry logic or fallback mechanism
                return
            }
            
            guard let marketData = marketData as? MarketData else {
                print("Invalid market data format received")
                return
            }
            
            do {
                let widgetData = WidgetDataStore(rate: "\(marketData.rate)", lastUpdate: marketData.dateString, rateDouble: marketData.rate)
                if let encodedData = try? JSONEncoder().encode(widgetData) {
                    self.groupUserDefaults?.set(encodedData, forKey: MarketData.string)
                    print("Market data updated for currency: \(fiatCurrency)")
                } else {
                  throw NSError(domain: "WatchDataSource", code: 1, userInfo: [NSLocalizedDescriptionKey: "Failed to encode market data"])
                }
            } catch {
                print("Failed to process market data: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - Wallet Actions
    
    /// Requests a Lightning Invoice from the iOS app.
    /// - Parameters:
    ///   - walletIdentifier: The index of the wallet in the `wallets` array.
    ///   - amount: The amount for the invoice.
    ///   - description: An optional description for the invoice.
    ///   - responseHandler: A closure to handle the invoice string received from the iOS app.
    func requestLightningInvoice(walletIdentifier: Int, amount: Double, description: String?, responseHandler: @escaping (_ invoice: String) -> Void) {
        let timeoutSeconds = 30.0
        let timeoutTimer = Timer.scheduledTimer(withTimeInterval: timeoutSeconds, repeats: false) { _ in
            print("Lightning invoice request timed out")
            responseHandler("")
        }

        guard wallets.indices.contains(walletIdentifier) else {
            timeoutTimer.invalidate()
            responseHandler("")
            return
        }
        let message: [String: Any] = [
            "request": "createInvoice",
            "walletIndex": walletIdentifier,
            "amount": amount,
            "description": description ?? ""
        ]
        session.sendMessage(message, replyHandler: { reply in
            timeoutTimer.invalidate()
            if let invoicePaymentRequest = reply["invoicePaymentRequest"] as? String, !invoicePaymentRequest.isEmpty {
                responseHandler(invoicePaymentRequest)
            } else {
                responseHandler("")
            }
        }, errorHandler: { error in
            timeoutTimer.invalidate()
            print("Error requesting Lightning Invoice: \(error.localizedDescription)")
            responseHandler("")
        })
    }
    
    /// Toggles the visibility of the wallet's balance.
    /// - Parameters:
    ///   - walletIdentifier: The index of the wallet in the `wallets` array.
    ///   - hideBalance: A boolean indicating whether to hide the balance.
    func toggleWalletHideBalance(walletIdentifier: UUID, hideBalance: Bool, responseHandler: @escaping (_ success: Bool) -> Void) {
        guard wallets.indices.contains(walletIdentifier.hashValue) else {
            responseHandler(false)
            return
        }
        let message: [String: Any] = [
            "message": "hideBalance",
            "walletIndex": walletIdentifier,
            "hideBalance": hideBalance
        ]
        session.sendMessage(message, replyHandler: { reply in
            responseHandler(true)
        }, errorHandler: { error in
            print("Error toggling hide balance: \(error.localizedDescription)")
            responseHandler(false)
        })
    }
    
    // MARK: - Complications Reload
    
    /// Reloads all active complications on the Watch face.
    private func reloadComplications() {
        let server = CLKComplicationServer.sharedInstance()
        server.activeComplications?.forEach { complication in
            server.reloadTimeline(for: complication)
            print("[Complication] Reloaded timeline for \(complication.family.rawValue)")
        }
    }

}

extension WatchDataSource {
    static var mock: WatchDataSource {
        let mockDataSource = WatchDataSource()
        mockDataSource.wallets = [Wallet.mock]
        return mockDataSource
    }
}


================================================
FILE: ./ios/MalinWalletWatch Extension/ExtensionDelegate.swift
================================================

//
//  ExtensionDelegate.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/6/19.
//

import WatchKit
import ClockKit
import Bugsnag
import WatchConnectivity

// WatchKit 2 uses WKExtensionDelegate, not WKApplicationDelegate
class ExtensionDelegate: NSObject, WKExtensionDelegate {
  
  let groupUserDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)

  func applicationDidFinishLaunching() {
    // Initialize WatchDataSource in the application lifecycle
    initializeWCSession()
    
    scheduleNextReload()
    updatePreferredFiatCurrency()
    if let isDoNotTrackEnabled = groupUserDefaults?.bool(forKey: "donottrack"), !isDoNotTrackEnabled {
      Bugsnag.start()
    }
  }
  
  private func initializeWCSession() {
    // Ensure WatchDataSource is initialized and session is started
    WatchDataSource.shared.startSession()
    
    // Log session state for debugging
    if WCSession.isSupported() {
      let session = WCSession.default
      print("WCSession initialized with state: \(session.activationState.rawValue)")
      print("Is WCSession reachable: \(session.isReachable)")
    } else {
      print("WCSession is not supported on this device")
    }
  }
  
  func applicationDidBecomeActive() {
    // Request data when app becomes active
    WatchDataSource.shared.requestDataFromiOS()
  }
  
  func applicationWillResignActive() {
    // Perform any cleanup before app goes inactive
    print("Watch app will resign active")
  }
  
  func updatePreferredFiatCurrency() {
    guard let fiatUnitUserDefaults = fetchPreferredFiatUnit() else { return }
    updateMarketData(for: fiatUnitUserDefaults)
  }
  
  private func fetchPreferredFiatUnit() -> FiatUnit? {
    if let preferredFiatCurrency = groupUserDefaults?.string(forKey: "preferredCurrency"), let preferredFiatUnit = fiatUnit(currency: preferredFiatCurrency) {
      return preferredFiatUnit
    } else {
      return fiatUnit(currency: "USD")
    }
  }
  
  private func updateMarketData(for fiatUnit: FiatUnit) {
    MarketAPI.fetchPrice(currency: fiatUnit.endPointKey) { (data, error) in
      guard let data = data, let encodedData = try? PropertyListEncoder().encode(data) else { return }
      let groupUserDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)
      groupUserDefaults?.set(encodedData, forKey: MarketData.string)
      groupUserDefaults?.synchronize()
      ExtensionDelegate.reloadActiveComplications()
    }
  }
  
  private static func reloadActiveComplications() {
    let server = CLKComplicationServer.sharedInstance()
    for complication in server.activeComplications ?? [] {
      server.reloadTimeline(for: complication)
    }
  }
  
  func nextReloadTime(after date: Date) -> Date {
    let calendar = Calendar(identifier: .gregorian)
    return calendar.date(byAdding: .minute, value: 10, to: date)!
  }
  
  // Update to use the correct API for scheduling background tasks in WatchKit 2
  func scheduleNextReload() {
    let targetDate = nextReloadTime(after: Date())
    // Use scheduleBackgroundRefresh instead of newer API
    WKExtension.shared().scheduleBackgroundRefresh(
      withPreferredDate: targetDate,
      userInfo: nil,
      scheduledCompletion: { _ in }
    )
  }
  
  func handle(_ backgroundTasks: Set<WKRefreshBackgroundTask>) {
    for task in backgroundTasks {
      switch task {
        case let backgroundTask as WKApplicationRefreshBackgroundTask:
          handleApplicationRefreshBackgroundTask(backgroundTask)
        case let snapshotTask as WKSnapshotRefreshBackgroundTask:
          // Handle snapshot generation
          snapshotTask.setTaskCompleted(restoredDefaultState: true, estimatedSnapshotExpiration: Date.distantFuture, userInfo: nil)
        default:
          task.setTaskCompletedWithSnapshot(false)
      }
    }
  }
  
  private func handleApplicationRefreshBackgroundTask(_ backgroundTask: WKApplicationRefreshBackgroundTask) {
      scheduleNextReload()
      guard let fiatUnitUserDefaults = fetchPreferredFiatUnit() else {
          backgroundTask.setTaskCompletedWithSnapshot(false)
          return
      }
      updateMarketData(for: fiatUnitUserDefaults)
      
      // Request updated wallet data during background refresh
      WatchDataSource.shared.requestDataFromiOS()
      
      backgroundTask.setTaskCompletedWithSnapshot(false)
  }
  
}


================================================
FILE: ./ios/MalinWalletWatch Extension/InterfaceController.swift
================================================

//
//  InterfaceController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/6/19.
//

import WatchKit
import WatchConnectivity
import Foundation

class InterfaceController: WKInterfaceController {
  
  @IBOutlet weak var walletsTable: WKInterfaceTable!
  @IBOutlet weak var noWalletsAvailableLabel: WKInterfaceLabel!
  
  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    print("InterfaceController: awake")
  }
  
  override func willActivate() {
    super.willActivate()
    print("InterfaceController: willActivate (WatchKit 2)")
    
    // Request fresh data when controller becomes active
    WatchDataSource.shared.requestDataFromiOS()
    
    // Update UI with any existing data
    updateUI()
    
    // Register for notifications
    NotificationCenter.default.addObserver(
      self, 
      selector: #selector(updateUI), 
      name: Notifications.dataUpdated.name, 
      object: nil
    )
  }
  
  override func didDeactivate() {
    super.didDeactivate()
    // Clean up observers when controller is no longer active
    NotificationCenter.default.removeObserver(self)
  }
  
  @objc private func updateUI() {
    let wallets = WatchDataSource.shared.wallets
    let isEmpty = wallets.isEmpty
    noWalletsAvailableLabel.setHidden(!isEmpty)
    walletsTable.setHidden(isEmpty)
    
    if isEmpty { return }
    
    walletsTable.setNumberOfRows(wallets.count, withRowType: WalletInformation.identifier)
    for index in 0..<wallets.count {
      updateRow(at: index, with: wallets[index])
    }
  }
  
  private func updateRow(at index: Int, with wallet: Wallet) {
    guard let controller = walletsTable.rowController(at: index) as? WalletInformation else { return }
    controller.configure(with: wallet)
  }
  
  override func contextForSegue(withIdentifier segueIdentifier: String, in table: WKInterfaceTable, rowIndex: Int) -> Any? {
    return rowIndex
  }
}


================================================
FILE: ./ios/MalinWalletWatch Extension/main.swift
================================================

import WatchKit
import Foundation

// For WatchKit 2, we use the NSExtensionMain function
NSExtensionMain()


================================================
FILE: ./ios/WalletInformationWidget/WalletInformationWidget.swift
================================================

//
//  WalletInformationWidget.swift
//  WalletInformationWidget
//
//  Created by Marcos Rodriguez on 10/29/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import WidgetKit
import SwiftUI

struct WalletInformationWidgetProvider: TimelineProvider {
    typealias Entry = WalletInformationWidgetEntry
    static var lastSuccessfulEntries: [WalletInformationWidgetEntry] = []

    func placeholder(in context: Context) -> WalletInformationWidgetEntry {
        return WalletInformationWidgetEntry.placeholder
    }

    func getSnapshot(in context: Context, completion: @escaping (WalletInformationWidgetEntry) -> ()) {
        let entry: WalletInformationWidgetEntry
        if (context.isPreview) {
            entry = WalletInformationWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 10000), allWalletsBalance: WalletData(balance: 1000000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000)))
        } else {
            entry = WalletInformationWidgetEntry(date: Date(), marketData: emptyMarketData)
        }
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {
        var entries: [WalletInformationWidgetEntry] = []
        let userPreferredCurrency = Currency.getUserPreferredCurrency()
        let allwalletsBalance = WalletData(balance: UserDefaultsGroup.getAllWalletsBalance(), latestTransactionTime: UserDefaultsGroup.getAllWalletsLatestTransactionTime())

        MarketAPI.fetchPrice(currency: userPreferredCurrency) { (result, error) in
            let entry: WalletInformationWidgetEntry

            if let result = result {
                entry = WalletInformationWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "", sats: "", price: result.formattedRate ?? "!", rate: result.rateDouble), allWalletsBalance: allwalletsBalance)
                WalletInformationWidgetProvider.lastSuccessfulEntries.append(entry)
                if WalletInformationWidgetProvider.lastSuccessfulEntries.count > 5 {
                    WalletInformationWidgetProvider.lastSuccessfulEntries.removeFirst()
                }
            } else {
                if let lastEntry = WalletInformationWidgetProvider.lastSuccessfulEntries.last {
                    entry = lastEntry
                } else {
                    entry = WalletInformationWidgetEntry.placeholder
                }
            }
            entries.append(entry)
            let timeline = Timeline(entries: entries, policy: .atEnd)
            completion(timeline)
        }
    }
}

struct WalletInformationWidgetEntry: TimelineEntry {
    let date: Date
    let marketData: MarketData
    var allWalletsBalance: WalletData = WalletData(balance: 0)
}

extension WalletInformationWidgetEntry {
    static var placeholder: WalletInformationWidgetEntry {
        WalletInformationWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 10000), allWalletsBalance: WalletData(balance: 1000000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000)))
    }
}

struct WalletInformationWidgetEntryView: View {
    let entry: WalletInformationWidgetEntry

    var WalletBalance: some View {
        WalletInformationView(allWalletsBalance: entry.allWalletsBalance, marketData: entry.marketData)
    }

    var body: some View {
        VStack(content: {
            WalletBalance
        }).padding().background(Color.widgetBackground)
    }
}

struct WalletInformationWidget: Widget {
    let kind: String = "WalletInformationWidget"

    var body: some WidgetConfiguration {
        if #available(iOSApplicationExtension 16.0, *) {
            return StaticConfiguration(kind: kind, provider: WalletInformationWidgetProvider()) { entry in
                WalletInformationWidgetEntryView(entry: entry)
            }
            .configurationDisplayName("Balance")
            .description("View your accumulated balance.").supportedFamilies([.systemSmall])
            .contentMarginsDisabledIfAvailable()
        } else {
            return StaticConfiguration(kind: kind, provider: WalletInformationWidgetProvider()) { entry in
                WalletInformationWidgetEntryView(entry: entry)
            }
            .configurationDisplayName("Balance")
            .description("View your accumulated balance.").supportedFamilies([.systemSmall])
            .contentMarginsDisabledIfAvailable()
        }
    }
}

struct WalletInformationWidget_Previews: PreviewProvider {
    static var previews: some View {
        WalletInformationWidgetEntryView(entry: WalletInformationWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: Double(0)), allWalletsBalance: WalletData(balance: 0, latestTransactionTime: LatestTransaction(isUnconfirmed: nil, epochValue: nil))))
            .previewContext(WidgetPreviewContext(family: .systemSmall))
    }
}


================================================
FILE: ./ios/Shared/BitcoinUnit.swift
================================================

//
//  BitcoinUnit.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//
import Foundation

/// Represents the various balance units used in the application.
/// Conforms to `String`, `Codable`, `Equatable`, and `CustomStringConvertible` for easy encoding/decoding, comparisons, and descriptions.
enum BitcoinUnit: String, Codable, Equatable, CustomStringConvertible {
    case btc = "BTC"
    case sats = "sats"
    case localCurrency = "local_currency"
    case max = "MAX"

    /// Provides a user-friendly description of the `BitcoinUnit`.
    var description: String {
        switch self {
        case .btc:
            return "BTC"
        case .sats:
            return "sats"
        case .localCurrency:
            return "Local Currency"
        case .max:
            return "MAX"
        }
    }

    /// Initializes a `BitcoinUnit` from a raw string.
    /// - Parameter rawString: The raw string representing the balance unit.
    init(rawString: String) {
        switch rawString.lowercased() {
        case "btc":
            self = .sats
        case "sats":
            self = .sats
        case "local_currency":
            self = .localCurrency
        case "max":
            self = .max
        default:
            // Handle unknown balance units if necessary
            // For now, defaulting to .max
            self = .max
        }
    }
}

extension BitcoinUnit {
    static var mockUnit: BitcoinUnit {
        return .sats
    }
}


================================================
FILE: ./ios/Shared/LatestTransaction.swift
================================================

//
//  LatestTransaction.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

struct LatestTransaction {
  let isUnconfirmed: Bool?
  let epochValue: Int?
}


================================================
FILE: ./ios/Shared/Utilities/Utilities.swift
================================================

//
//  Utilities.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 6/4/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

func percentile(_ arr: [Double], p: Double) -> Double {
    guard !arr.isEmpty else { return 0 }
    guard p >= 0, p <= 1 else { fatalError("Percentile must be between 0 and 1") }

    if p == 0 { return arr.first! }
    if p == 1 { return arr.last! }

    let index = Double(arr.count - 1) * p
    let lower = Int(floor(index))
    let upper = lower + 1
    let weight = index - Double(lower)

    if upper >= arr.count { return arr[lower] }
    return arr[lower] * (1 - weight) + arr[upper] * weight
}

func calcEstimateFeeFromFeeHistogram(numberOfBlocks: Int, feeHistogram: [[Double]]) -> Double {
    var totalVsize = 0.0
    var histogramToUse: [(fee: Double, vsize: Double)] = []

    for h in feeHistogram {
        var (fee, vsize) = (h[0], h[1])
        var timeToStop = false

        if totalVsize + vsize >= 1000000.0 * Double(numberOfBlocks) {
            vsize = 1000000.0 * Double(numberOfBlocks) - totalVsize
            timeToStop = true
        }

        histogramToUse.append((fee, vsize))
        totalVsize += vsize
        if timeToStop { break }
    }

    var histogramFlat: [Double] = []
    for hh in histogramToUse {
        histogramFlat += Array(repeating: hh.fee, count: Int(hh.vsize / 25000))
    }

    histogramFlat.sort()

    return max(2, percentile(histogramFlat, p: 0.5))
}


var numberFormatter: NumberFormatter {
    let formatter = NumberFormatter()
    formatter.numberStyle = .decimal
    formatter.maximumFractionDigits = 0
    formatter.locale = Locale.current
    return formatter
}

extension Double {
    func formattedPriceString() -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 0
        return formatter.string(from: NSNumber(value: self)) ?? "--"
    }

    func formattedCurrencyString() -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.maximumFractionDigits = 0
        formatter.currencySymbol = fiatUnit(currency: Currency.getUserPreferredCurrency())?.symbol
        return formatter.string(from: NSNumber(value: self)) ?? "--"
    }
}

extension Date {
    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: self)
    }
}


================================================
FILE: ./ios/Shared/Utilities/KeychainHelper.swift
================================================

//
//  KeychainHelper.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/20/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//


import Foundation
import Security

class KeychainHelper {
    
    static let shared = KeychainHelper()
    
    private init() {}
    
    /// Save data to Keychain
    func save(_ data: Data, service: String, account: String) -> Bool {
        // Create query
        let query: [String: Any] = [
            kSecClass as String       : kSecClassGenericPassword,
            kSecAttrService as String : service,
            kSecAttrAccount as String : account,
            kSecValueData as String   : data
        ]
        
        // Delete any existing item
        SecItemDelete(query as CFDictionary)
        
        // Add new item
        let status = SecItemAdd(query as CFDictionary, nil)
        return status == errSecSuccess
    }
    
    /// Retrieve data from Keychain
    func retrieve(service: String, account: String) -> Data? {
        // Create query
        let query: [String: Any] = [
            kSecClass as String       : kSecClassGenericPassword,
            kSecAttrService as String : service,
            kSecAttrAccount as String : account,
            kSecReturnData as String  : true,
            kSecMatchLimit as String  : kSecMatchLimitOne
        ]
        
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        
        if status == errSecSuccess {
            return dataTypeRef as? Data
        } else {
            return nil
        }
    }
    
    /// Delete data from Keychain
    func delete(service: String, account: String) -> Bool {
        // Create query
        let query: [String: Any] = [
            kSecClass as String       : kSecClassGenericPassword,
            kSecAttrService as String : service,
            kSecAttrAccount as String : account
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        return status == errSecSuccess
    }
}


================================================
FILE: ./ios/Shared/MarketAPI+Electrum.swift
================================================

//
//  MarketAPI+Electrum.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/8/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import Foundation

struct APIError: LocalizedError {
  var errorDescription: String = "Failed to fetch Electrum data..."
}

extension MarketAPI {

    static func fetchNextBlockFee() async throws -> MarketData {
        let client = SwiftTCPClient(hosts: hardcodedPeers)
        defer {
            client.close()
            print("Closed SwiftTCPClient connection.") 
        }

        guard await client.connectToNextAvailable(validateCertificates: false) else {
            print("Failed to connect to any Electrum peer.") 
            throw APIError()
        }

        let message = "{\"id\": 1, \"method\": \"mempool.get_fee_histogram\", \"params\": []}\n"
        guard let data = message.data(using: .utf8) else {
            print("Failed to encode message to data.") 
            throw APIError()
        }

        print("Sending fee histogram request: \(message)") 

        guard await client.send(data: data) else {
            print("Failed to send fee histogram request.") 
            throw APIError()
        }

        do {
            let receivedData = try await client.receive()
            print("Received data: \(receivedData)") 

            guard let json = try JSONSerialization.jsonObject(with: receivedData, options: .allowFragments) as? [String: AnyObject],
                  let feeHistogram = json["result"] as? [[Double]] else {
                print("Invalid JSON structure in response.") 
                throw APIError()
            }

            let fastestFee = calcEstimateFeeFromFeeHistogram(numberOfBlocks: 1, feeHistogram: feeHistogram)
            print("Calculated fastest fee: \(fastestFee)") 
            return MarketData(nextBlock: String(format: "%.0f", fastestFee), sats: "0", price: "0", rate: 0, dateString: "")
        } catch {
            print("Error during fetchNextBlockFee: \(error.localizedDescription)") 
            throw APIError()
        }
    }

    static func fetchMarketData(currency: String) async throws -> MarketData {
        var marketDataEntry = MarketData(nextBlock: "...", sats: "...", price: "...", rate: 0)
        
        do {
            if let priceResult = try await fetchPrice(currency: currency) {
                marketDataEntry.rate = priceResult.rateDouble
                marketDataEntry.price = priceResult.formattedRate ?? "!"
                print("Fetched price data: rateDouble=\(priceResult.rateDouble), formattedRate=\(priceResult.formattedRate ?? "nil")") 
            }
        } catch {
            print("Error fetching price: \(error.localizedDescription)")
        }

        do {
            let nextBlockData = try await fetchNextBlockFee()
            marketDataEntry.nextBlock = nextBlockData.nextBlock
            print("Fetched next block fee data: nextBlock=\(nextBlockData.nextBlock)")
        } catch {
            print("Error fetching next block fee: \(error.localizedDescription)") 
            marketDataEntry.nextBlock = "!"
        }

        marketDataEntry.sats = numberFormatter.string(from: NSNumber(value: Double(10 / marketDataEntry.rate) * 10000000)) ?? "!"
        print("Calculated sats: \(marketDataEntry.sats)") 
        
        return marketDataEntry
    }

    static func fetchMarketData(currency: String, completion: @escaping (Result<MarketData, Error>) -> ()) {
        Task {
            do {
                let marketData = try await fetchMarketData(currency: currency)
                completion(.success(marketData))
            } catch {
                completion(.failure(error))
            }
        }
    }
}



================================================
FILE: ./ios/Shared/UserDefaultsGroup.swift
================================================

//
//  UserDefaultsGroup.swift
//  MarketWidgetExtension
//
//  Created by Marcos Rodriguez on 10/31/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import Foundation

struct UserDefaultsElectrumSettings {
    var host: String?
    var port: UInt16?
    var sslPort: UInt16?
}

let hardcodedPeers = DefaultElectrumPeers.map { settings in
    (
        host: settings.host ?? "", 
        port: settings.sslPort ?? settings.port ?? 50001, 
        useSSL: settings.sslPort != nil
    )
}

let DefaultElectrumPeers = [
 UserDefaultsElectrumSettings(host: "mainnet.foundationdevices.com", port: 50001, sslPort: 50002),
    // UserDefaultsElectrumSettings(host: "electrum.jochen-hoenicke.de", port: 50001, sslPort: 50006),
    UserDefaultsElectrumSettings(host: "electrum1.malinwallet.io", port: 50001, sslPort: 443),
    UserDefaultsElectrumSettings(host: "electrum.acinq.co", port: 50001, sslPort: 50002),
    UserDefaultsElectrumSettings(host: "electrum.bitaroo.net", port: 50001, sslPort: 50002),
]

class UserDefaultsGroup {
    static private let suite = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)

    static func getElectrumSettings() -> UserDefaultsElectrumSettings {
        guard let electrumSettingsHost = suite?.string(forKey: UserDefaultsGroupKey.ElectrumSettingsHost.rawValue) else {
            return DefaultElectrumPeers.randomElement() ?? UserDefaultsElectrumSettings()
        }

        let electrumSettingsTCPPort = suite?.integer(forKey: UserDefaultsGroupKey.ElectrumSettingsTCPPort.rawValue) ?? 50001
        let electrumSettingsSSLPort = suite?.integer(forKey: UserDefaultsGroupKey.ElectrumSettingsSSLPort.rawValue) ?? 443

        let host = electrumSettingsHost
        let sslPort = UInt16(electrumSettingsSSLPort)
        let port = UInt16(electrumSettingsTCPPort)

        return UserDefaultsElectrumSettings(host: host, port: port, sslPort: sslPort)
    }

    static func getAllWalletsBalance() -> Double {
        guard let allWalletsBalance = suite?.string(forKey: UserDefaultsGroupKey.AllWalletsBalance.rawValue) else {
            return 0
        }

        return Double(allWalletsBalance) ?? 0
    }

    // Int: EPOCH value, Bool: Latest transaction is unconfirmed
    static func getAllWalletsLatestTransactionTime() -> LatestTransaction {
        guard let allWalletsTransactionTime = suite?.string(forKey: UserDefaultsGroupKey.AllWalletsLatestTransactionTime.rawValue) else {
            return LatestTransaction(isUnconfirmed: false, epochValue: 0)
        }

        if allWalletsTransactionTime == UserDefaultsGroupKey.LatestTransactionIsUnconfirmed.rawValue {
            return LatestTransaction(isUnconfirmed: true, epochValue: 0)
        } else {
            return LatestTransaction(isUnconfirmed: false, epochValue: Int(allWalletsTransactionTime) ?? 0)
        }
    }
}


================================================
FILE: ./ios/Shared/WidgetData.swift
================================================

//
//  WidgetData.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

class WidgetData {
  
  static let WidgetDataStoreKey = "WidgetDataStoreKey"
  static let WidgetCachedDataStoreKey = "WidgetCachedDataStoreKey"
  
  static func savePriceRateAndLastUpdate(rate: String, lastUpdate: String) {
    guard let userDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue) else { return }
    userDefaults.setValue(["rate": rate, "lastUpdate": lastUpdate], forKey: WidgetDataStoreKey)
    userDefaults.synchronize()
  }
  
}


================================================
FILE: ./ios/Shared/Currency.swift
================================================

//
//  Currency.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

struct CurrencyError: LocalizedError {
  var errorDescription: String = "Failed to parse response"
}

class Currency {
  
  static func getUserPreferredCurrency() -> String {

    guard let userDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue),
          let preferredCurrency = userDefaults.string(forKey: "preferredCurrency")
    else {
      return "USD"
    }

    if preferredCurrency != Currency.getLastSelectedCurrency() {
      UserDefaults.standard.removeObject(forKey: WidgetData.WidgetCachedDataStoreKey)
      UserDefaults.standard.removeObject(forKey: WidgetData.WidgetDataStoreKey)
      UserDefaults.standard.synchronize()
    }

    return preferredCurrency
  }

  static func getUserPreferredCurrencyLocale() -> String {
    guard let userDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue),
          let preferredCurrency = userDefaults.string(forKey: "preferredCurrencyLocale")
    else {
      return "en_US"
    }
    return preferredCurrency
  }

  static func getLastSelectedCurrency() -> String {
    guard let userDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue), let dataStore = userDefaults.string(forKey: "currency") else {
      return "USD"
    }

    return dataStore
  }

  static func saveNewSelectedCurrency() {
    UserDefaults.standard.setValue(Currency.getUserPreferredCurrency(), forKey: "currency")
  }

  
}



================================================
FILE: ./ios/Shared/Balance.swift
================================================

import Foundation

class Balance {
    static func formatBalance(_ balance: Decimal, toUnit: BitcoinUnit, withFormatting: Bool = false, completion: @escaping (String) -> Void) {
      switch toUnit {
      case .sats:
        if withFormatting {
          completion(NumberFormatter.localizedString(from: balance as NSNumber, number: .decimal) + " SATS")
        } else {
          completion("\(balance) SATS")
        }
      case .localCurrency:
        fetchLocalCurrencyEquivalent(satoshi: balance, completion: completion)
        
      default:
        let value = balance / Decimal(100_000_000)
        completion("\(value) BTC") // Localize unit names as needed.
      }
    }

    private static func fetchLocalCurrencyEquivalent(satoshi: Decimal, completion: @escaping (String) -> Void) {
      
        let currency = Currency.getUserPreferredCurrency() // Ensure this method retrieves the correct currency code.
        MarketAPI.fetchPrice(currency: currency) { dataStore, error in
            DispatchQueue.main.async {
                guard let dataStore = dataStore, error == nil else {
                    completion("Error: \(error?.localizedDescription ?? "Unknown error")")
                    return
                }
                let rate = Decimal(string: dataStore.rate) ?? Decimal(0)
                let convertedAmount = (satoshi / Decimal(100_000_000)) * rate
                completion("\(convertedAmount) \(currency)")
            }
        }
    }
}

extension Decimal {
  func formatted(as unit: BitcoinUnit, withFormatting: Bool = false) -> String {
        switch unit {
        case .sats:
            return withFormatting ? NumberFormatter.localizedString(from: self as NSNumber, number: .decimal) + " SATS" : "\(self) SATS"
        case .localCurrency:
            let userDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)
            if let widgetData = userDefaults?.object(forKey: MarketData.string) as? Data,
               let marketData = try? JSONDecoder().decode(MarketData.self, from: widgetData) {
                let rate = Decimal(marketData.rate)
                let convertedAmount = (self / Decimal(100_000_000)) * rate
                return "\(convertedAmount) \(Currency.getUserPreferredCurrency())"
            } else {
                return "N/A"
            }
        default:
            let value = self / Decimal(100_000_000)
            return "\(value) BTC"
        }
    }
}


================================================
FILE: ./ios/Shared/WalletData.swift
================================================

//
//  WalletData.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

struct WalletData {
  var balance: Double
  var latestTransactionTime: LatestTransaction = LatestTransaction(isUnconfirmed: false, epochValue: 0)
  var formattedBalanceBTC: String {
    let formatter = NumberFormatter()
    formatter.numberStyle = .none
    formatter.usesSignificantDigits = true
    formatter.maximumSignificantDigits = 9
    formatter.roundingMode = .up
    let value = NSNumber(value: balance / 100000000);
    if let valueString = formatter.string(from: value) {
      return "\(String(describing: valueString)) \(BitcoinUnit.btc.rawValue)"
    } else {
      return "0 \(BitcoinUnit.btc.rawValue)"
    }
  }
}


================================================
FILE: ./ios/Shared/MarketData.swift
================================================

//
//  MarketData.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

public struct MarketData:Codable  {
  public var nextBlock: String
  public var sats: String
  public var price: String
  public var rate: Double

  var formattedNextBlock: String {
    if nextBlock == "..." {
      return "..."
    } else {
      if let nextBlockInt = Int(nextBlock) {
        let numberFormatter = NumberFormatter()
        numberFormatter.numberStyle = .decimal
        if let formattedNumber = numberFormatter.string(from: NSNumber(value: nextBlockInt)) {
          return "\(formattedNumber) sat/vb"
        }
      }
      return "\(nextBlock) sat/vb"  // Fallback in case the nextBlock cannot be converted to an Int
    }
  }
  var dateString: String = ""
  var formattedDate: String? {
    let isoDateFormatter = ISO8601DateFormatter()
    let dateFormatter = DateFormatter()
    dateFormatter.locale = Locale.current
    dateFormatter.timeStyle = .short
    
    if let date = isoDateFormatter.date(from: dateString) {
      return dateFormatter.string(from: date)
    }
    return nil
  }
  static let string = "MarketData"
}

enum MarketDataTimeline: String {
  case Previous = "previous"
  case Current = "current"
}


================================================
FILE: ./ios/Shared/MarketAPI.swift
================================================

//
//  MarketAPI.swift
//
//  Created by Marcos Rodriguez on 11/2/19.
//

//

import Foundation

class MarketAPI {
    
    private static func buildURLString(source: String, endPointKey: String) -> String {
        switch source {
        case "Yadio":
            return "https://api.yadio.io/json/\(endPointKey)"
        case "YadioConvert":
            return "https://api.yadio.io/convert/1/BTC/\(endPointKey)"
        case "Exir":
            return "https://api.exir.io/v1/ticker?symbol=btc-irt"
        case "coinpaprika":
            return "https://api.coinpaprika.com/v1/tickers/btc-bitcoin?quotes=INR"
        case "Bitstamp":
            return "https://www.bitstamp.net/api/v2/ticker/btc\(endPointKey.lowercased())"
        case "Coinbase":
            return "https://api.coinbase.com/v2/prices/BTC-\(endPointKey.uppercased())/buy"
        case "CoinGecko":
            return "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=\(endPointKey.lowercased())"
        case "BNR":
            return "https://www.bnr.ro/nbrfxrates.xml"
        case "Kraken":
            return "https://api.kraken.com/0/public/Ticker?pair=XXBTZ\(endPointKey.uppercased())"
        default: // CoinDesk
            return "https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=\(endPointKey)"
        }
    }
    
    private static func handleDefaultData(data: Data, source: String, endPointKey: String) throws -> WidgetDataStore? {
        guard let json = (try? JSONSerialization.jsonObject(with: data, options: [])) as? [String: Any] else {
            throw CurrencyError(errorDescription: "JSON parsing error.")
        }
        
        return try parseJSONBasedOnSource(json: json, source: source, endPointKey: endPointKey)
    }
    
    private static func parseJSONBasedOnSource(json: [String: Any], source: String, endPointKey: String) throws -> WidgetDataStore? {
        var latestRateDataStore: WidgetDataStore?
        
        switch source {
        case "Yadio":
            if let rateDict = json[endPointKey] as? [String: Any],
               let rateDouble = rateDict["price"] as? Double,
               let lastUpdated = rateDict["timestamp"] as? Int {
                let unix = Double(lastUpdated / 1_000)
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: unix))
                latestRateDataStore = WidgetDataStore(rate: String(rateDouble), lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        case "YadioConvert":
            guard let rateDouble = json["rate"] as? Double,
                  let lastUpdated = json["timestamp"] as? Int else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
            let unix = Double(lastUpdated / 1_000)
            let lastUpdatedString = ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: unix))
            latestRateDataStore = WidgetDataStore(rate: String(rateDouble), lastUpdate: lastUpdatedString, rateDouble: rateDouble)
            return latestRateDataStore
        case "CoinGecko":
            if let bitcoinDict = json["bitcoin"] as? [String: Any],
               let rateDouble = bitcoinDict[endPointKey.lowercased()] as? Double {
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: String(rateDouble), lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        case "Exir":
            if let rateDouble = json["last"] as? Double {
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: String(rateDouble), lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        case "Bitstamp":
            if let rateString = json["last"] as? String, let rateDouble = Double(rateString) {
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: rateString, lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        case "coinpaprika":
            if let quotesDict = json["quotes"] as? [String: Any],
               let currencyDict = quotesDict[endPointKey.uppercased()] as? [String: Any],
               let rateDouble = currencyDict["price"] as? Double {
                let rateString = String(rateDouble)
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: rateString, lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        case "Coinbase":
            if let data = json["data"] as? [String: Any],
               let rateString = data["amount"] as? String,
               let rateDouble = Double(rateString) {
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: rateString, lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        case "BNR":
            throw CurrencyError(errorDescription: "BNR data source is not yet implemented")
        case "Kraken":
            if let result = json["result"] as? [String: Any],
               let tickerData = result["XXBTZ\(endPointKey.uppercased())"] as? [String: Any],
               let c = tickerData["c"] as? [String],
               let rateString = c.first,
               let rateDouble = Double(rateString) {
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: rateString, lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                if let errorMessage = json["error"] as? [String] {
                    throw CurrencyError(errorDescription: "Kraken API error: \(errorMessage.joined(separator: ", "))")
                } else {
                    throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
                }
            }
        default: // CoinDesk
            if let rateDouble = json[endPointKey] as? Double {
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                latestRateDataStore = WidgetDataStore(rate: String(rateDouble), lastUpdate: lastUpdatedString, rateDouble: rateDouble)
                return latestRateDataStore
            } else {
                throw CurrencyError(errorDescription: "Data formatting error for source: \(source)")
            }
        }
    }
    
    private static func handleBNRData(data: Data) async throws -> WidgetDataStore? {
        let parser = XMLParser(data: data)
        let delegate = BNRXMLParserDelegate()
        parser.delegate = delegate
        if parser.parse(), let usdToRonRate = delegate.usdRate {
            let coinGeckoUrl = URL(string: "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd")!
            let (data, _) = try await URLSession.shared.data(from: coinGeckoUrl)
            if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
               let bitcoinDict = json["bitcoin"] as? [String: Double],
               let btcToUsdRate = bitcoinDict["usd"] {
                let btcToRonRate = btcToUsdRate * usdToRonRate
                let lastUpdatedString = ISO8601DateFormatter().string(from: Date())
                let latestRateDataStore = WidgetDataStore(rate: String(btcToRonRate), lastUpdate: lastUpdatedString, rateDouble: btcToRonRate)
                return latestRateDataStore
            } else {
                throw CurrencyError()
            }
        } else {
            throw CurrencyError(errorDescription: "XML parsing error.")
        }
    }

     
  static func fetchPrice(currency: String) async throws -> WidgetDataStore? {
         let currencyToFiatUnit = fiatUnit(currency: currency)
         guard let source = currencyToFiatUnit?.source, let endPointKey = currencyToFiatUnit?.endPointKey else {
             throw CurrencyError(errorDescription: "Invalid currency unit or endpoint.")
         }

         let urlString = buildURLString(source: source, endPointKey: endPointKey)
         guard let url = URL(string: urlString) else {
             throw CurrencyError(errorDescription: "Invalid URL.")
         }

         return try await fetchData(url: url, source: source, endPointKey: endPointKey)
     }

     private static func fetchData(url: URL, source: String, endPointKey: String, retries: Int = 3) async throws -> WidgetDataStore? {
         do {
             let (data, _) = try await URLSession.shared.data(from: url)
             if source == "BNR" {
                 return try await handleBNRData(data: data)
             } else {
                 return try handleDefaultData(data: data, source: source, endPointKey: endPointKey)
             }
         } catch {
             if retries > 0 {
                 return try await fetchData(url: url, source: source, endPointKey: endPointKey, retries: retries - 1)
             } else {
                 throw error
             }
         }
     }
    
    static func fetchPrice(currency: String, completion: @escaping ((WidgetDataStore?, Error?) -> Void)) {
        Task {
            do {
                if let dataStore = try await fetchPrice(currency: currency) {
                    completion(dataStore, nil)
                } else {
                    completion(nil, CurrencyError(errorDescription: "No data received."))
                }
            } catch {
                completion(nil, error)
            }
        }
    }
}


================================================
FILE: ./ios/Shared/UserDefaultsExtension.swift
================================================

//
//  UserDefaultsExtension.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 2/8/21.
//  Copyright  2021 MalinWallet. All rights reserved.
//

import Foundation

extension UserDefaults {

func codable<Element: Codable>(forKey key: String) -> Element? {
  guard let userDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue), let data = userDefaults.data(forKey: key) else { return nil }
        let element = try? PropertyListDecoder().decode(Element.self, from: data)
        return element
    }
}


================================================
FILE: ./ios/Shared/UserDefaultsGroupKey.swift
================================================

//
//  UserDefaultsGroupKeys.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

enum UserDefaultsGroupKey: String {
  case GroupName = "group.com.malinwallet.app"
  case PreferredCurrency = "preferredCurrency"
  case WatchAppBundleIdentifier = "com.malinwallet.app.watch"
  case BundleIdentifier = "com.malinwallet.app"
  case ElectrumSettingsHost = "electrum_host"
  case ElectrumSettingsTCPPort = "electrum_tcp_port"
  case ElectrumSettingsSSLPort = "electrum_ssl_port"
  case AllWalletsBalance = "WidgetCommunicationAllWalletsSatoshiBalance"
  case AllWalletsLatestTransactionTime = "WidgetCommunicationAllWalletsLatestTransactionTime"
  case LatestTransactionIsUnconfirmed = "\"WidgetCommunicationLatestTransactionIsUnconfirmed\""
}


================================================
FILE: ./ios/Shared/Numeric+abbreviated.swift
================================================

//
//  Numeric+abbreviated.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

extension Numeric {
    
    var abbreviated: String {
      let bytecountFormatter = ByteCountFormatter()
      bytecountFormatter.zeroPadsFractionDigits = true
      bytecountFormatter.countStyle = .decimal
      bytecountFormatter.isAdaptive = false
      let bytesString = bytecountFormatter.string(fromByteCount: (self as! NSNumber).int64Value)
      
        let numericString = bytesString
            .replacingOccurrences(of: "bytes", with: "")
            .replacingOccurrences(of: "B", with: "") // removes B (bytes) in 'KB'/'MB'/'GB'
            .replacingOccurrences(of: "G", with: "B") // replace G (Giga) to just B (billions)
        return numericString.replacingOccurrences(of: " ", with: "")
    }
  
}


================================================
FILE: ./ios/Shared/Fiat/FiatUnit.swift
================================================

//
//  FiatUnit.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/20/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//
import Foundation

struct FiatUnit: Codable {
  let endPointKey: String
  let symbol: String
  let locale: String
  let source: String
  
}

func fiatUnit(currency: String) -> FiatUnit? {
  return Bundle.main.decode([String: FiatUnit].self, from: "fiatUnits.json").first(where: {$1.endPointKey == currency})?.value
}


================================================
FILE: ./ios/Shared/Fiat/XMLParserDelegate.swift
================================================

//
//  XMLParserDelegate.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/13/23.
//  Copyright  2023 MalinWallet. All rights reserved.
//

import Foundation

class BNRXMLParserDelegate: NSObject, XMLParserDelegate {
    var usdRate: Double?
    var currentElement = ""
    var foundRate = false

    func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) {
        currentElement = elementName
        if elementName == "Rate" && attributeDict["currency"] == "USD" {
            foundRate = true
        }
    }

    func parser(_ parser: XMLParser, foundCharacters string: String) {
        if foundRate {
            usdRate = Double(string)
            foundRate = false
        }
    }
}


================================================
FILE: ./ios/Shared/Bundle+decode.swift
================================================

//
//  Bundle+decode.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

extension Bundle {
    func decode<T: Decodable>(_ type: T.Type, from file: String, dateDecodingStrategy: JSONDecoder.DateDecodingStrategy = .deferredToDate, keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy = .useDefaultKeys) -> T {
        guard let url = self.url(forResource: file, withExtension: nil) else {
            fatalError("Failed to locate \(file) in bundle.")
        }

        guard let data = try? Data(contentsOf: url) else {
            fatalError("Failed to load \(file) from bundle.")
        }

        let decoder = JSONDecoder()
      
        decoder.dateDecodingStrategy = dateDecodingStrategy
        decoder.keyDecodingStrategy = keyDecodingStrategy

        do {
            return try decoder.decode(T.self, from: data)
        } catch DecodingError.keyNotFound(let key, let context) {
            fatalError("Failed to decode \(file) from bundle due to missing key '\(key.stringValue)' not found  \(context.debugDescription)")
        } catch DecodingError.typeMismatch(_, let context) {
            fatalError("Failed to decode \(file) from bundle due to type mismatch  \(context.debugDescription)")
        } catch DecodingError.valueNotFound(let type, let context) {
            fatalError("Failed to decode \(file) from bundle due to missing \(type) value  \(context.debugDescription)")
        } catch DecodingError.dataCorrupted(_) {
            fatalError("Failed to decode \(file) from bundle because it appears to be invalid JSON")
        } catch {
            fatalError("Failed to decode \(file) from bundle: \(error.localizedDescription)")
        }
    }
}


================================================
FILE: ./ios/Shared/Placeholders.swift
================================================

//
//  Models.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/1/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import Foundation



let emptyMarketData = MarketData(nextBlock: "...", sats: "...", price: "...", rate: 0)
let emptyWalletData = WalletData(balance: 0, latestTransactionTime:  LatestTransaction(isUnconfirmed: false, epochValue: Int(Date().timeIntervalSince1970)))




================================================
FILE: ./ios/Shared/WidgetDataStore.swift
================================================

//
//  WidgetDataStore.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/14/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

struct WidgetDataStore: Codable {
  let rate: String
  let lastUpdate: String
  let rateDouble: Double
  var formattedRate: String? {
    let numberFormatter = NumberFormatter()
    numberFormatter.locale = Locale(identifier: Currency.getUserPreferredCurrencyLocale())
    numberFormatter.numberStyle = .currency
    numberFormatter.maximumFractionDigits = 0
    numberFormatter.minimumFractionDigits = 0
    if let rateString = numberFormatter.string(from: NSNumber(value: rateDouble)) {
      return rateString
    }
    return rate
  }
  var formattedRateForSmallComplication: String? {
    return rateDouble.abbreviated
  }
  
  var formattedRateForComplication: String? {
    let numberFormatter = NumberFormatter()
    numberFormatter.locale = Locale(identifier: Currency.getUserPreferredCurrencyLocale())
    numberFormatter.numberStyle = .currency
    numberFormatter.currencySymbol = ""
    if let rateString = numberFormatter.string(from: NSNumber(value: rateDouble)) {
      return rateString
    }
    return rate
  }
  
  var date: Date? {
    let isoDateFormatter = ISO8601DateFormatter()
    let dateFormatter = DateFormatter()
    dateFormatter.locale = Locale.current
    dateFormatter.timeStyle = .short
    
    return isoDateFormatter.date(from: lastUpdate)
  }
  var formattedDate: String? {
    let isoDateFormatter = ISO8601DateFormatter()
    let dateFormatter = DateFormatter()
    dateFormatter.locale = Locale.current
    dateFormatter.timeStyle = .short
    
    if let date = isoDateFormatter.date(from: lastUpdate) {
      return dateFormatter.string(from: date)
    }
    return nil
  }
}




================================================
FILE: ./ios/Shared/Colors.swift
================================================

//
//  Colors.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/1/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import SwiftUI


extension Color {
  static let textColor = Color("TextColor")
  static let textColorLightGray = Color(red: 0.6, green: 0.63, blue: 0.67)
  static let widgetBackground = Color("WidgetBackground")
  static let containerGreen = Color("ContainerGreen")
  static let containerRed = Color("ContainerRed")
}


================================================
FILE: ./ios/Shared/Chain.swift
================================================

//
//  Chain.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/16/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

/// Represents the chain type for a wallet.
/// Conforms to `String`, `Codable`, `Equatable`, and `CustomStringConvertible` for easy encoding/decoding, comparisons, and descriptions.
enum Chain: String, Codable, Equatable, CustomStringConvertible {
    case onchain = "ONCHAIN"
    case offchain = "OFFCHAIN"

    /// Provides a user-friendly description of the `Chain`.
    var description: String {
        switch self {
        case .onchain:
            return "On-chain"
        case .offchain:
            return "Off-chain"
        }
    }

    /// Initializes a `Chain` from a raw string.
    /// - Parameter rawString: The raw string representing the chain type.
    init(rawString: String) {
        switch rawString.uppercased() {
        case "ONCHAIN":
            self = .onchain
        case "OFFCHAIN":
            self = .offchain
        default:
            // Handle unknown chain types if necessary
            // For now, defaulting to .onchain
            self = .onchain
        }
    }
}

extension Chain {
    static var mockChain: Chain {
        return .onchain
    }
}

================================================
FILE: ./ios/MenuElementsEmitter/MenuElementsEmitter.swift
================================================

import Foundation
import React

@objc(MenuElementsEmitter)
class MenuElementsEmitter: RCTEventEmitter {
    
    private static var instance: MenuElementsEmitter?
    private var hasListeners = false
    
    override init() {
        super.init()
        MenuElementsEmitter.instance = self
    }
    
    @objc
    class func sharedInstance() -> MenuElementsEmitter {
        if instance == nil {
            instance = MenuElementsEmitter()
        }
        return instance!
    }
    
    override func supportedEvents() -> [String]! {
        return ["openSettings", "addWalletMenuAction", "importWalletMenuAction", "reloadTransactionsMenuAction"]
    }
    
    override class func requiresMainQueueSetup() -> Bool {
        return true
    }
    
    override func startObserving() {
        hasListeners = true
    }
    
    override func stopObserving() {
        hasListeners = false
    }
    
    @objc
    func openSettings() {
        if hasListeners {
            sendEvent(withName: "openSettings", body: nil)
        }
    }
    
    @objc
    func addWalletMenuAction() {
        if hasListeners {
            sendEvent(withName: "addWalletMenuAction", body: nil)
        }
    }
    
    @objc
    func importWalletMenuAction() {
        if hasListeners {
            sendEvent(withName: "importWalletMenuAction", body: nil)
        }
    }
    
    @objc
    func reloadTransactionsMenuAction() {
        if hasListeners {
            sendEvent(withName: "reloadTransactionsMenuAction", body: nil)
        }
    }
}


================================================
FILE: ./ios/MalinWalletTests/MockData.swift
================================================

//
//  MockData.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 7/10/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

struct MockData {
    static let currentMarketData = MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2023-01-01T00:00:00+00:00")
    static let previousMarketData = MarketData(nextBlock: "", sats: "", price: "$9,000", rate: 9000, dateString: "2022-12-31T00:00:00+00:00")
    static let noChangeMarketData = MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2023-01-01T00:00:00+00:00")
}


================================================
FILE: ./ios/MalinWalletTests/MalinWalletUITest.swift
================================================

//
//  MalinWalletUITest.swift
//  MalinWalletUITests
//
//  Created by Marcos Rodriguez on 2/28/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import XCTest

final class MalinWalletUITest: XCTestCase {
  
  override func setUpWithError() throws {
        continueAfterFailure = false
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    func testAppLaunchesAndShowsSettingsButton() throws {
        let app = XCUIApplication()
        app.launch()

        let settingsButton = app.buttons["SettingsButton"]

        // Wait for the settings button to appear to make sure the app has finished launching and is displaying its initial UI.
        let exists = NSPredicate(format: "exists == true")
        expectation(for: exists, evaluatedWith: settingsButton, handler: nil)
        
        // Wait for a maximum of 10 seconds for the settings button to appear
        waitForExpectations(timeout: 10, handler: nil)

        // Assert that the settings button is not only present but also hittable (visible and interactable)
        XCTAssertTrue(settingsButton.isHittable, "The settings button should be visible and interactable")
    }
}


================================================
FILE: ./ios/WidgetHelper.swift
================================================

import Foundation
import WidgetKit

class WidgetHelper {
    static func reloadAllWidgets() {
        #if arch(arm64) || arch(i386) || arch(x86_64)
        if #available(iOS 14.0, *) {
            WidgetCenter.shared.reloadAllTimelines()
        }
        #endif
    }
    
    static func getSharedUserDefaults() -> UserDefaults? {
        let suiteName = "group.com.malinwallet.app"
        let defaults = UserDefaults(suiteName: suiteName)
        if defaults == nil {
            NSLog("[WidgetHelper] Warning: Could not access shared UserDefaults")
        }
        return defaults
    }
}


================================================
FILE: ./ios/Bridge.swift
================================================

//
//  Bridge.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 9/19/19.
//

import Foundation


================================================
FILE: ./ios/Widgets/Shared/SwiftTCPClient.swift
================================================

import Foundation
import Network
import Dispatch

enum SwiftTCPClientError: Error, LocalizedError {
    case connectionNil
    case connectionCancelled
    case readTimedOut
    case noDataReceived
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .connectionNil:
            return "Connection is nil."
        case .connectionCancelled:
            return "Connection was cancelled."
        case .readTimedOut:
            return "Read timed out."
        case .noDataReceived:
            return "No data received."
        case .unknown(let error):
            return error.localizedDescription
        }
    }
}

struct TimeoutError: Error {}

actor HostManager {
    var availableHosts: [(host: String, port: UInt16, useSSL: Bool)]
    var hostFailureCounts: [String: Int] = [:]
    let maxRetriesPerHost: Int

    init(hosts: [(host: String, port: UInt16, useSSL: Bool)], maxRetriesPerHost: Int) {
        self.availableHosts = hosts
        self.maxRetriesPerHost = maxRetriesPerHost
    }

    func getNextHost() -> (host: String, port: UInt16, useSSL: Bool)? {
        guard !availableHosts.isEmpty else {
            return nil
        }
        // Rotate the first host to the end
        let currentHost = availableHosts.removeFirst()
        availableHosts.append(currentHost)
        return currentHost
    }

    func shouldSkipHost(_ host: String) -> Bool {
        if let failureCount = hostFailureCounts[host], failureCount >= maxRetriesPerHost {
            return true
        }
        return false
    }

    func resetFailureCount(for host: String) {
        hostFailureCounts[host] = 0
    }

    func incrementFailureCount(for host: String) {
        hostFailureCounts[host, default: 0] += 1
    }
}

class SwiftTCPClient {
    private var connection: NWConnection?
    private let queue = DispatchQueue(label: "SwiftTCPClientQueue", qos: .userInitiated)
    private let readTimeout: TimeInterval = 5.0
    let maxRetries = 3
    private let hostManager: HostManager
    
    private enum ConnectionState: CustomStringConvertible {
        case disconnected
        case connecting
        case connected(NWConnection.State)
        case failed(Error)
        case cancelled
        
        var description: String {
            switch self {
            case .disconnected:
                return "Disconnected"
            case .connecting:
                return "Connecting"
            case .connected(let state):
                return "Connected (\(state))"
            case .failed(let error):
                return "Failed: \(error.localizedDescription)"
            case .cancelled:
                return "Cancelled"
            }
        }
    }
    
    private var connectionState: ConnectionState = .disconnected
    
    // Add a path monitor to detect network changes
    private var pathMonitor: NWPathMonitor?
    private var currentPath: NWPath?
    
    init(hosts: [(host: String, port: UInt16, useSSL: Bool)] = [], maxRetriesPerHost: Int = 3) {
        self.hostManager = HostManager(hosts: hosts, maxRetriesPerHost: maxRetriesPerHost)
        setupPathMonitor()
    }
    
    deinit {
        stopPathMonitor()
        close()
    }
    
    private func setupPathMonitor() {
        pathMonitor = NWPathMonitor()
        pathMonitor?.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            let previousPath = self.currentPath
            self.currentPath = path
            
            if let previousPath = previousPath, previousPath.status != path.status {
                print("Network path changed: \(path.status), available interfaces: \(path.availableInterfaces.map { $0.name })")
                
                // If we're connected and the network changed to unsatisfied, we might need to reconnect
                if path.status == .unsatisfied, case .connected = self.connectionState {
                    print("Network became unavailable, connection may be affected")
                }
            }
        }
        pathMonitor?.start(queue: queue)
    }
    
    private func stopPathMonitor() {
        pathMonitor?.cancel()
        pathMonitor = nil
    }

    func connect(to host: String, port: UInt16, useSSL: Bool = false, validateCertificates: Bool = true, retries: Int = 0) async -> Bool {
        // Skip host if it has failed too many times
        if await hostManager.shouldSkipHost(host) {
            print("Skipping host \(host) after \(hostManager.maxRetriesPerHost) retries.")
            return false
        }

        // Reset connection state and close any existing connection
        connectionState = .disconnected
        close()

        // Check network availability before attempting to connect
        if let currentPath = currentPath, currentPath.status == .unsatisfied {
            print("Network is currently unavailable, can't connect to \(host):\(port)")
            await hostManager.incrementFailureCount(for: host)
            return false
        }

        let parameters: NWParameters
        if useSSL {
            parameters = NWParameters(tls: createTLSOptions(validateCertificates: validateCertificates), tcp: .init())
        } else {
            parameters = NWParameters.tcp
        }

        parameters.prohibitExpensivePaths = false
        parameters.expiredDNSBehavior = .allow
        parameters.multipathServiceType = .handover
        
        let tcpOptions = parameters.defaultProtocolStack.internetProtocol as? NWProtocolTCP.Options
        tcpOptions?.enableFastOpen = false  
        tcpOptions?.noDelay = true     
        
        tcpOptions?.enableKeepalive = true
        tcpOptions?.keepaliveCount = 5
        tcpOptions?.keepaliveIdle = 60 
        tcpOptions?.keepaliveInterval = 5
        
        tcpOptions?.connectionTimeout = 10  

        guard let nwPort = NWEndpoint.Port(rawValue: port) else {
            print("Invalid port number: \(port)")
            return false
        }
        
        let isLocalhost = host == "localhost" || host == "127.0.0.1" || host == "::1"
        if isLocalhost {
            print("Connecting to localhost, checking if service is available on port \(port)...")
        }
        
        connectionState = .connecting
        let endpoint = NWEndpoint.Host(host)
        connection = NWConnection(host: endpoint, port: nwPort, using: parameters)
        connection?.start(queue: queue)
        
        print("Attempting to connect to \(host):\(port) (SSL: \(useSSL))")
        
        guard let connection = connection else {
            print("Connection object creation failed")
            connectionState = .failed(SwiftTCPClientError.connectionNil)
            return false
        }

        do {
            try await withCheckedThrowingContinuation { [self] (continuation: CheckedContinuation<Void, Error>) in
                let syncQueue = DispatchQueue(label: "com.malinwallet.continuationSync")
                var isContinuationResolved = false
                
                // Safe completion function to avoid multiple resolutions
                let completeOnce: (Result<Void, Error>) -> Void = { result in
                    syncQueue.sync {
                        if !isContinuationResolved {
                            isContinuationResolved = true
                            switch result {
                            case .success:
                                continuation.resume()
                            case .failure(let error):
                                continuation.resume(throwing: error)
                            }
                        }
                    }
                }
                
                connection.stateUpdateHandler = { state in
                    switch state {
                    case .ready:
                        print("Successfully connected to \(host):\(port)")
                        
                        if let localEndpointDesc = connection.currentPath?.localEndpoint?.debugDescription {
                            print("Local endpoint: \(localEndpointDesc)")
                        }
                        if let remoteEndpointDesc = connection.currentPath?.remoteEndpoint?.debugDescription {
                            print("Remote endpoint: \(remoteEndpointDesc)")
                        }
                        
                        self.connectionState = .connected(state)
                        completeOnce(.success(()))
                        
                    case .failed(let error):
                        let nsError = error as NSError
                        print("Connection to \(host):\(port) failed with error: \(error.localizedDescription) (Code: \(nsError.code))")
                        
                        if self.isTLSError(error) {
                            print("SSL Error while connecting to \(host):\(port) - \(error.localizedDescription)")
                        } else if nsError.code == 61 {
                            print("Connection refused by \(host):\(port) - Server may not be listening on this port")
                            if isLocalhost {
                                print("For localhost connections, ensure the server is running and listening on port \(port)")
                            }
                        } else if nsError.code == 60 {
                            print("Operation timed out connecting to \(host):\(port) - Server might be unreachable")
                        } else if nsError.code == 65 {
                            print("No route to host \(host):\(port) - Network route unavailable")
                        }
                        
                        self.connectionState = .failed(error)
                        completeOnce(.failure(SwiftTCPClientError.unknown(error)))
                        
                    case .cancelled:
                        print("Connection to \(host):\(port) was cancelled.")
                        self.connectionState = .cancelled
                        completeOnce(.failure(SwiftTCPClientError.connectionCancelled))
                        
                    case .preparing:
                        print("Preparing connection to \(host):\(port)...")
                        
                    case .waiting(let error):
                        print("Waiting to connect to \(host):\(port) - \(error.localizedDescription)")
                        
                    case .setup:
                        print("Setting up connection to \(host):\(port)...")
                        
                    @unknown default:
                        print("Unknown connection state for \(host):\(port)")
                    }
                }
                
                let timeoutWorkItem = DispatchWorkItem { [weak self] in
                    guard let self = self else { return }
                    
                    syncQueue.sync {
                        if !isContinuationResolved {
                            self.connectionState = .failed(SwiftTCPClientError.readTimedOut)
                            print("Connection to \(host):\(port) timed out after \(self.readTimeout) seconds")
                            completeOnce(.failure(SwiftTCPClientError.readTimedOut))
                        }
                    }
                }
                
                self.queue.asyncAfter(deadline: .now() + self.readTimeout, execute: timeoutWorkItem)
            }
            
            await hostManager.resetFailureCount(for: host)
            return true
            
        } catch {
            print("Connection to \(host) failed with error: \(error.localizedDescription)")
            await hostManager.incrementFailureCount(for: host)
            
            if let nsError = error as NSError?, nsError.code == 61 {
                print("Connection refused by \(host):\(port) - skipping retries as server is not listening")
                return false
            }
            
            if retries < maxRetries - 1 {
                print("Retrying connection to \(host) (\(retries + 1)/\(maxRetries))...")
                try? await Task.sleep(nanoseconds: 500_000_000) // 500ms delay
                return await connect(to: host, port: port, useSSL: useSSL, validateCertificates: validateCertificates, retries: retries + 1)
            } else {
                print("Host \(host) failed after \(maxRetries) retries. Skipping.")
                return false
            }
        }
    }

    func connectToNextAvailable(validateCertificates: Bool = true) async -> Bool {
        while true {
            guard let currentHost = await hostManager.getNextHost() else {
                print("No available hosts to connect.")
                return false
            }

            if await hostManager.shouldSkipHost(currentHost.host) {
                print("Skipping host \(currentHost.host) after \(hostManager.maxRetriesPerHost) retries.")
                continue
            }

            print("Attempting to connect to next available host: \(currentHost.host):\(currentHost.port) (SSL: \(currentHost.useSSL))")

            if await connect(to: currentHost.host, port: currentHost.port, useSSL: currentHost.useSSL, validateCertificates: validateCertificates) {
                print("Connected to host \(currentHost.host):\(currentHost.port)")
                await hostManager.resetFailureCount(for: currentHost.host)
                return true
            } else {
                print("Failed to connect to host \(currentHost.host):\(currentHost.port)")
                await hostManager.incrementFailureCount(for: currentHost.host)
            }
        }
    }

    func isConnectionReady() -> Bool {
      guard connection != nil else { 
            return false 
        }
        
        if case .connected(let state) = connectionState, state == .ready {
            return true
        }
        return false
    }

    func send(data: Data) async -> Bool {
        if !isConnectionReady() {
            print("Send failed: Connection is not ready. Current state: \(connectionState)")
            return false
        }
        
        guard let connection = connection else {
            print("Send failed: No active connection.")
            return false
        }
        
        guard let _ = connection.currentPath?.remoteEndpoint else {
            print("Send failed: No remote endpoint available")
            return false
        }
        
        do {
            print("Sending data (\(data.count) bytes)")
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                let connectionCopy = connection
                
                let workItem = DispatchWorkItem {
                    connectionCopy.send(content: data, completion: .contentProcessed { error in
                        if let error = error {
                            print("Send error: \(error.localizedDescription)")
                            continuation.resume(throwing: error)
                        } else {
                            print("Data sent successfully")
                            continuation.resume()
                        }
                    })
                }
                
                self.queue.async(execute: workItem)
            }
            return true
        } catch {
            print("Send failed with error: \(error.localizedDescription)")
            
            // Update connection state if we detect it's failed
            if let nsError = error as NSError?, nsError.code == 57 || nsError.code == 54 {
                connectionState = .failed(error)
                print("Connection appears to be closed or reset")
            }
            
            return false
        }
    }

    func receive() async throws -> Data {
        guard case .connected = connectionState else {
            print("Receive failed: Connection is not in connected state. Current state: \(connectionState)")
            throw SwiftTCPClientError.connectionNil
        }
        
        guard let connection = connection else {
            throw SwiftTCPClientError.connectionNil
        }

        print("Attempting to receive data...")
        
        // Extract the timeout value to avoid capturing self in the task closures
        let timeout = self.readTimeout
        let closeConnection = { [weak self] in self?.close() }

        return try await withThrowingTaskGroup(of: Data.self) { group in
            // Create a task for receiving data
            group.addTask { @Sendable in
                return try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Data, Error>) in
                    // We'll use a dedicated flag with a lock for thread safety
                    let syncQueue = DispatchQueue(label: "com.malinwallet.receiveSync")
                    var isCompleted = false
                    
                    connection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { data, _, isComplete, error in
                        syncQueue.sync {
                            guard !isCompleted else { return }
                            isCompleted = true
                            
                            if let error = error {
                                let nsError = error as NSError
                                print("Receive error: \(error.localizedDescription) (Code: \(nsError.code))")
                                continuation.resume(throwing: SwiftTCPClientError.unknown(error))
                                return
                            }

                            if let data = data, !data.isEmpty {
                                print("Received data: \(data)")
                                continuation.resume(returning: data)
                            } else if isComplete {
                                print("Connection closed by peer.")
                                closeConnection()
                                continuation.resume(throwing: SwiftTCPClientError.noDataReceived)
                            } else {
                                print("Read timed out.")
                                continuation.resume(throwing: SwiftTCPClientError.readTimedOut)
                            }
                        }
                    }
                }
            }
            
            group.addTask { @Sendable in
                try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
                print("Receive operation timed out after \(timeout) seconds.")
                throw SwiftTCPClientError.readTimedOut
            }
            
            if let firstResult = try await group.next() {
                group.cancelAll()
                print("Receive operation completed successfully.")
                return firstResult
            } else {
                print("Receive operation timed out.")
                throw SwiftTCPClientError.readTimedOut
            }
        }
    }

    func close() {
        print("Closing connection")
        connection?.stateUpdateHandler = nil
        connectionState = .disconnected
        connection?.cancel()
        connection = nil
    }

    private func createTLSOptions(validateCertificates: Bool = true) -> NWProtocolTLS.Options {
        let tlsOptions = NWProtocolTLS.Options()
        if (!validateCertificates) {
            sec_protocol_options_set_verify_block(tlsOptions.securityProtocolOptions, { _, _, completion in
                completion(true)
            }, DispatchQueue.global())
            print("SSL certificate validation is disabled.")
        }
        return tlsOptions
    }

    private func isTLSError(_ error: NWError) -> Bool {
        let nsError = error as NSError
        let code = nsError.code
        if #available(iOS 16.4, *) {
            switch code {
            case 20, 21, 22:
                return true
            case 1, 2, 3, 4:
                return false
            default:
                return false
            }
        } else {
            switch code {
            case 20, 21, 22:
                return true
            default:
                return false
            }
        }
    }

    private func withTimeout<T>(seconds: TimeInterval, operation: @escaping @Sendable () async throws -> T) async throws -> T {
        // Extract the value to avoid capturing self
        let timeoutSeconds = seconds
        
        return try await withThrowingTaskGroup(of: T.self) { group in
            // Add the main operation task
            group.addTask { @Sendable in
                return try await operation()
            }
            
            // Add the timeout task
            group.addTask { @Sendable in
                try await Task.sleep(nanoseconds: UInt64(timeoutSeconds * 1_000_000_000))
                throw TimeoutError()
            }
            
            let result = try await group.next()!
            group.cancelAll()
            return result
        }
    }
}


================================================
FILE: ./ios/Widgets/Shared/FiatUnitEnum.swift
================================================


// Hardcoding values for simplicity; AppIntents are unnecessarily complex

import AppIntents

@available(iOS 16.0, *)
enum FiatUnitEnum: String, AppEnum, CaseIterable, Identifiable, Codable {
  
  var id: String { self.rawValue }

    case AED
    case ARS
    case AUD
    case AWG
    case BHD
    case BRL
    case CAD
    case CHF
    case CLP
    case CNY
    case COP
    case CZK
    case DKK
    case EGP
    case EUR
    case GBP
    case HRK
    case HUF
    case IDR
    case ILS
    case INR
    case IRR
    case IRT
    case ISK
    case JPY
    case KES
    case KRW
    case KWD
    case LBP
    case LKR
    case MXN
    case MYR
    case MZN
    case NGN
    case NOK
    case NZD
    case OMR
    case PHP
    case PLN
    case QAR
    case RON
    case RUB
    case SAR
    case SEK
    case SGD
    case THB
    case TRY
    case TWD
    case TZS
    case UAH
    case UGX
    case USD
    case UYU
    case VEF
    case VES
    case XAF
    case ZAR
    case GHS

    var code: String {
        return self.rawValue
    }

    var source: String {
        switch self {
        case .AED:
            return "CoinGecko"
        case .ARS:
            return "Yadio"
        case .AUD:
            return "CoinGecko"
        case .AWG:
            return "CoinDesk"
        case .BHD:
            return "CoinGecko"
        case .BRL:
            return "CoinGecko"
        case .CAD:
            return "CoinGecko"
        case .CHF:
            return "CoinGecko"
        case .CLP:
            return "Yadio"
        case .CNY:
            return "Coinbase"
        case .COP:
            return "CoinDesk"
        case .CZK:
            return "CoinGecko"
        case .DKK:
            return "CoinGecko"
        case .EGP:
            return "YadioConvert"
        case .EUR:
            return "Kraken"
        case .GBP:
            return "Kraken"
        case .HRK:
            return "CoinDesk"
        case .HUF:
            return "CoinGecko"
        case .IDR:
            return "CoinGecko"
        case .ILS:
            return "CoinGecko"
        case .INR:
            return "coinpaprika"
        case .IRR:
            return "Exir"
        case .IRT:
            return "Exir"
        case .ISK:
            return "CoinDesk"
        case .JPY:
            return "CoinGecko"
        case .KES:
            return "CoinDesk"
        case .KRW:
            return "CoinGecko"
        case .KWD:
            return "CoinGecko"
        case .LBP:
            return "YadioConvert"
        case .LKR:
            return "CoinGecko"
        case .MXN:
            return "CoinGecko"
        case .MYR:
            return "CoinGecko"
        case .MZN:
            return "CoinDesk"
        case .NGN:
            return "CoinGecko"
        case .NOK:
            return "CoinGecko"
        case .NZD:
            return "CoinGecko"
        case .OMR:
            return "CoinDesk"
        case .PHP:
            return "CoinGecko"
        case .PLN:
            return "CoinGecko"
        case .QAR:
            return "CoinDesk"
        case .RON:
            return "BNR"
        case .RUB:
            return "CoinGecko"
        case .SAR:
            return "CoinGecko"
        case .SEK:
            return "CoinGecko"
        case .SGD:
            return "CoinGecko"
        case .THB:
            return "CoinGecko"
        case .TRY:
            return "CoinGecko"
        case .TWD:
            return "CoinGecko"
        case .TZS:
            return "CoinDesk"
        case .UAH:
            return "CoinGecko"
        case .UGX:
            return "CoinDesk"
        case .USD:
            return "Kraken"
        case .UYU:
            return "CoinDesk"
        case .VEF:
            return "CoinGecko"
        case .VES:
            return "Yadio"
        case .XAF:
            return "CoinDesk"
        case .ZAR:
            return "CoinGecko"
        case .GHS:
            return "CoinDesk"
        }
    }

    static var typeDisplayRepresentation: TypeDisplayRepresentation {
        TypeDisplayRepresentation(stringLiteral: "Currency")
    }

    static var caseDisplayRepresentations: [FiatUnitEnum: DisplayRepresentation] {
        return [
          .AED: DisplayRepresentation(stringLiteral: "United Arab Emirates (UAE Dirham)"),
            .ARS: DisplayRepresentation(stringLiteral: "Argentina (Argentine Peso)"),
            .AUD: DisplayRepresentation(stringLiteral: "Australia (Australian Dollar)"),
            .AWG: DisplayRepresentation(stringLiteral: "Aruba (Aruban Florin)"),
            .BHD: DisplayRepresentation(stringLiteral: "Bahrain (Bahraini Dinar)"),
            .BRL: DisplayRepresentation(stringLiteral: "Brazil (Brazilian Real)"),
            .CAD: DisplayRepresentation(stringLiteral: "Canada (Canadian Dollar)"),
            .CHF: DisplayRepresentation(stringLiteral: "Switzerland (Swiss Franc)"),
            .CLP: DisplayRepresentation(stringLiteral: "Chile (Chilean Peso)"),
            .CNY: DisplayRepresentation(stringLiteral: "China (Chinese Yuan)"),
            .COP: DisplayRepresentation(stringLiteral: "Colombia (Colombian Peso)"),
            .CZK: DisplayRepresentation(stringLiteral: "Czech Republic (Czech Koruna)"),
            .DKK: DisplayRepresentation(stringLiteral: "Denmark (Danish Krone)"),
            .EGP: DisplayRepresentation(stringLiteral: "Egypt (Egyptian Pound)"),
            .EUR: DisplayRepresentation(stringLiteral: "European Union (Euro)"),
            .GBP: DisplayRepresentation(stringLiteral: "United Kingdom (British Pound)"),
            .HRK: DisplayRepresentation(stringLiteral: "Croatia (Croatian Kuna)"),
            .HUF: DisplayRepresentation(stringLiteral: "Hungary (Hungarian Forint)"),
            .IDR: DisplayRepresentation(stringLiteral: "Indonesia (Indonesian Rupiah)"),
            .ILS: DisplayRepresentation(stringLiteral: "Israel (Israeli New Shekel)"),
            .INR: DisplayRepresentation(stringLiteral: "India (Indian Rupee)"),
            .IRR: DisplayRepresentation(stringLiteral: "Iran (Iranian Rial)"),
            .IRT: DisplayRepresentation(stringLiteral: "Iran (Iranian Toman)"),
            .ISK: DisplayRepresentation(stringLiteral: "Iceland (Icelandic Krna)"),
            .JPY: DisplayRepresentation(stringLiteral: "Japan (Japanese Yen)"),
            .KES: DisplayRepresentation(stringLiteral: "Kenya (Kenyan Shilling)"),
            .KRW: DisplayRepresentation(stringLiteral: "South Korea (South Korean Won)"),
            .KWD: DisplayRepresentation(stringLiteral: "Kuwait (Kuwaiti Dinar)"),
            .LBP: DisplayRepresentation(stringLiteral: "Lebanon (Lebanese Pound)"),
            .LKR: DisplayRepresentation(stringLiteral: "Sri Lanka (Sri Lankan Rupee)"),
            .MXN: DisplayRepresentation(stringLiteral: "Mexico (Mexican Peso)"),
            .MYR: DisplayRepresentation(stringLiteral: "Malaysia (Malaysian Ringgit)"),
            .MZN: DisplayRepresentation(stringLiteral: "Mozambique (Mozambican Metical)"),
            .NGN: DisplayRepresentation(stringLiteral: "Nigeria (Nigerian Naira)"),
            .NOK: DisplayRepresentation(stringLiteral: "Norway (Norwegian Krone)"),
            .NZD: DisplayRepresentation(stringLiteral: "New Zealand (New Zealand Dollar)"),
            .OMR: DisplayRepresentation(stringLiteral: "Oman (Omani Rial)"),
            .PHP: DisplayRepresentation(stringLiteral: "Philippines (Philippine Peso)"),
            .PLN: DisplayRepresentation(stringLiteral: "Poland (Polish Zloty)"),
            .QAR: DisplayRepresentation(stringLiteral: "Qatar (Qatari Riyal)"),
            .RON: DisplayRepresentation(stringLiteral: "Romania (Romanian Leu)"),
            .RUB: DisplayRepresentation(stringLiteral: "Russia (Russian Ruble)"),
            .SAR: DisplayRepresentation(stringLiteral: "Saudi Arabia (Saudi Riyal)"),
            .SEK: DisplayRepresentation(stringLiteral: "Sweden (Swedish Krona)"),
            .SGD: DisplayRepresentation(stringLiteral: "Singapore (Singapore Dollar)"),
            .THB: DisplayRepresentation(stringLiteral: "Thailand (Thai Baht)"),
            .TRY: DisplayRepresentation(stringLiteral: "Turkey (Turkish Lira)"),
            .TWD: DisplayRepresentation(stringLiteral: "Taiwan (New Taiwan Dollar)"),
            .TZS: DisplayRepresentation(stringLiteral: "Tanzania (Tanzanian Shilling)"),
            .UAH: DisplayRepresentation(stringLiteral: "Ukraine (Ukrainian Hryvnia)"),
            .UGX: DisplayRepresentation(stringLiteral: "Uganda (Ugandan Shilling)"),
            .USD: DisplayRepresentation(stringLiteral: "United States of America (US Dollar)"),
            .UYU: DisplayRepresentation(stringLiteral: "Uruguay (Uruguayan Peso)"),
            .VEF: DisplayRepresentation(stringLiteral: "Venezuela (Venezuelan Bolvar Fuerte)"),
            .VES: DisplayRepresentation(stringLiteral: "Venezuela (Venezuelan Bolvar Soberano)"),
            .XAF: DisplayRepresentation(stringLiteral: "Central African Republic (Central African Franc)"),
            .ZAR: DisplayRepresentation(stringLiteral: "South Africa (South African Rand)"),
            .GHS: DisplayRepresentation(stringLiteral: "Ghana (Ghanaian Cedi)"),
        ]
    }
}



================================================
FILE: ./ios/Widgets/Shared/Views/MarketView.swift
================================================

//
//  MarketView.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/3/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import SwiftUI
import WidgetKit

struct MarketView: View {

  var marketData: MarketData = emptyMarketData

    var body: some View {
      VStack(alignment: .leading, spacing:23 , content: {
        VStack(alignment: .leading, spacing: /*@START_MENU_TOKEN@*/nil/*@END_MENU_TOKEN@*/, content: {
          Text("Market").font(.headline).foregroundColor(.textColor).bold()
          Spacer()
          HStack(alignment: .center, spacing: 0, content: {
            Text("Next Block").bold().lineLimit(1).font(Font.system(size:11, weight: .medium, design: .default)).foregroundColor(.textColor)
            Spacer()
            Text(marketData.formattedNextBlock).padding(EdgeInsets(top: 2, leading: 4, bottom: 2, trailing: 4)).lineLimit(1).minimumScaleFactor(0.1).foregroundColor(.widgetBackground).font(Font.system(size:11, weight: .semibold, design: .default)).background(Color(red: 0.29, green: 0.86, blue: 0.73)).overlay(
              RoundedRectangle(cornerRadius: 4.0)
                .stroke(Color.containerGreen, lineWidth: 4.0))
          })

          Spacer()
          HStack(alignment: .center, spacing: 0, content: {
            Text("Sats/\(Currency.getUserPreferredCurrency())").bold().lineLimit(1).font(Font.system(size:11, weight: .medium, design: .default)).foregroundColor(.textColor)
            Spacer()
            Text( marketData.sats).padding(EdgeInsets(top: 2, leading: 4, bottom: 2, trailing: 4)).lineLimit(1).minimumScaleFactor(0.1).foregroundColor(.widgetBackground).font(Font.system(size:11, weight: .semibold, design: .default)).background(Color(red: 0.97, green: 0.21, blue: 0.38)).overlay(
              RoundedRectangle(cornerRadius: 4.0)
                .stroke(Color.containerRed, lineWidth: 4.0))
          })
          Spacer()
          HStack(alignment: .center, spacing: 0, content: {
            Text("Price").bold().lineLimit(1).font(Font.system(size:11, weight: . medium, design: .default)).foregroundColor(.textColor)
            Spacer()
            Text( marketData.price).padding(EdgeInsets(top: 2, leading: 4, bottom: 2, trailing: 4)).lineLimit(1).minimumScaleFactor(0.1).foregroundColor(.widgetBackground).font(Font.system(size:11, weight: .semibold, design: .default)).background(Color(red: 0.29, green: 0.86, blue: 0.73)).overlay(
              RoundedRectangle(cornerRadius:4.0)
                .stroke(Color.containerGreen, lineWidth: 4.0))
          })
        })
      })
    }
}



struct MarketView_Previews: PreviewProvider {
    static var previews: some View {
      MarketView(marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 0))
        .previewContext(WidgetPreviewContext(family: .systemSmall))
    }
}


================================================
FILE: ./ios/Widgets/Shared/Views/PriceView.swift
================================================

//
//  PriceView.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/8/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import SwiftUI
import WidgetKit

@available(iOS 16.0, *)
struct PriceView: View {
  var entry: PriceWidgetEntry
  
  var body: some View {
    switch entry.family {
    case .accessoryInline, .accessoryCircular, .accessoryRectangular:
      if #available(iOSApplicationExtension 16.0, *) {
        wrappedView(for: getView(for: entry.family), family: entry.family)
      } else {
        getView(for: entry.family)
      }
    default:
      defaultView.background(Color(UIColor.systemBackground))
    }
  }
  
  private func getView(for family: WidgetFamily) -> some View {
    switch family {
    case .accessoryCircular:
      return AnyView(accessoryCircularView)
    case .accessoryInline:
      return AnyView(accessoryInlineView)
    case .accessoryRectangular:
      return AnyView(accessoryRectangularView)
    default:
      return AnyView(defaultView)
    }
  }
  
  @ViewBuilder
  private func wrappedView<Content: View>(for content: Content, family: WidgetFamily) -> some View {
    if #available(iOSApplicationExtension 16.0, *) {
      ZStack {
        if family == .accessoryRectangular {
          AccessoryWidgetBackground()
            .background(Color(UIColor.systemBackground))
            .clipShape(RoundedRectangle(cornerRadius: 10))
        } else {
          AccessoryWidgetBackground()
        }
        content
      }
    } else {
      content
    }
  }
  
  private var accessoryCircularView: some View {
    let priceString = formattedPriceString(from: entry.currentMarketData?.rate)
    let priceChangePercentage = formattedPriceChangePercentage(currentRate: entry.currentMarketData?.rate, previousRate: entry.previousMarketData?.rate)
    
    return VStack(alignment: .center, spacing: 4) {
      Text("BTC")
        .font(.caption)
        .minimumScaleFactor(0.1)
      Text(priceString)
        .font(.body)
        .minimumScaleFactor(0.1)
        .lineLimit(1)
      if let priceChangePercentage = priceChangePercentage {
        Text(priceChangePercentage)
          .font(.caption2)
          .foregroundColor(priceChangePercentage.contains("-") ? .red : .green)
      }
    }
    .widgetURL(URL(string: "malinwallet://marketprice"))
  }
  
  private var accessoryInlineView: some View {
    let priceString = formattedCurrencyString(from: entry.currentMarketData?.rate)
    let priceChangePercentage = formattedPriceChangePercentage(currentRate: entry.currentMarketData?.rate, previousRate: entry.previousMarketData?.rate)
    
    return HStack {
      Text(priceString)
        .font(.body)
        .minimumScaleFactor(0.1)
      if let priceChangePercentage = priceChangePercentage {
        Image(systemName: priceChangePercentage.contains("-") ? "arrow.down" : "arrow.up")
          .foregroundColor(priceChangePercentage.contains("-") ? .red : .green)
      }
    }
  }
  
  private var accessoryRectangularView: some View {
    let currentPrice = formattedCurrencyString(from: entry.currentMarketData?.rate)
    
    return VStack(alignment: .leading, spacing: 4) {
      Text("Bitcoin (\(Currency.getUserPreferredCurrency()))")
        .font(.caption)
        .foregroundColor(.secondary)
      HStack {
        Text(currentPrice)
          .font(.caption)
          .fontWeight(.bold)
        if let currentMarketDataRate = entry.currentMarketData?.rate,
           let previousMarketDataRate = entry.previousMarketData?.rate,
           currentMarketDataRate != previousMarketDataRate {
          Image(systemName: currentMarketDataRate > previousMarketDataRate ? "arrow.up" : "arrow.down")
        }
      }
      
      if let previousMarketDataPrice = entry.previousMarketData?.price, Int(entry.currentMarketData?.rate ?? 0) != Int(entry.previousMarketData?.rate ?? 0) {
        Text("From \(previousMarketDataPrice)")
          .font(.caption)
          .foregroundColor(.secondary)
      }
      
      Text("at \(entry.currentMarketData?.formattedDate ?? "--")")
        .font(.caption2)
        .foregroundColor(.secondary)
    }
    .padding(.all, 8)
    .frame(maxWidth: .infinity, alignment: .leading)
    .background(Color(UIColor.systemBackground))
    .clipShape(RoundedRectangle(cornerRadius: 10))
  }
  
  private var defaultView: some View {
    VStack(alignment: .trailing, spacing: nil, content: {
      Text("Last Updated").font(Font.system(size: 11, weight: .regular)).foregroundColor(Color(UIColor.lightGray))
      HStack(alignment: .lastTextBaseline, spacing: nil, content: {
        Text(entry.currentMarketData?.formattedDate ?? "").lineLimit(1).foregroundColor(.primary).font(Font.system(size: 13, weight: .regular)).minimumScaleFactor(0.01).transition(.opacity)
      })
      Spacer()
      VStack(alignment: .trailing, spacing: 16, content: {
        HStack(alignment: .lastTextBaseline, spacing: nil, content: {
          Text(entry.currentMarketData?.price ?? "").lineLimit(1).foregroundColor(.primary).font(Font.system(size: 28, weight: .bold)).minimumScaleFactor(0.01).transition(.opacity)
        })
        if let previousMarketDataPrice = entry.previousMarketData?.price, let currentMarketDataRate = entry.currentMarketData?.rate, let previousMarketDataRate = entry.previousMarketData?.rate, previousMarketDataRate > 0, currentMarketDataRate != previousMarketDataRate {
          HStack(alignment: .lastTextBaseline, spacing: nil, content: {
            Image(systemName: currentMarketDataRate > previousMarketDataRate ? "arrow.up" : "arrow.down")
            Text("from").lineLimit(1).foregroundColor(.primary).font(Font.system(size: 13, weight: .regular)).minimumScaleFactor(0.01)
            Text(previousMarketDataPrice).lineLimit(1).foregroundColor(.primary).font(Font.system(size: 13, weight: .regular)).minimumScaleFactor(0.01)
          }).transition(.slide)
        }
      })
    }).frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .trailing).padding()
  }
  
  private func formattedPriceString(from rate: Double?) -> String {
    let numberFormatter = NumberFormatter()
    numberFormatter.numberStyle = .decimal
    numberFormatter.maximumFractionDigits = 0
    return numberFormatter.string(from: NSNumber(value: rate ?? 0)) ?? "--"
  }
  
  private func formattedCurrencyString(from rate: Double?) -> String {
    let numberFormatter = NumberFormatter()
    numberFormatter.maximumFractionDigits = 0
    numberFormatter.numberStyle = .currency
    numberFormatter.currencySymbol = fiatUnit(currency: Currency.getUserPreferredCurrency())?.symbol
    return numberFormatter.string(from: NSNumber(value: rate ?? 0)) ?? "--"
  }
  
  private func formattedPriceChangePercentage(currentRate: Double?, previousRate: Double?) -> String? {
    guard let currentRate = currentRate, let previousRate = previousRate, previousRate > 0 else { return nil }
    let change = ((currentRate - previousRate) / previousRate) * 100
    return change == 0 ? nil : String(format: "%+.1f%%", change)
  }
}

@available(iOS 16.0, *)
struct PriceView_Previews: PreviewProvider {
  static var previews: some View {
    Group {
      PriceView(entry: PriceWidgetEntry(date: Date(), family: .systemSmall, currentMarketData: MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2019-09-18T17:27:00+00:00"), previousMarketData: emptyMarketData))
        .previewContext(WidgetPreviewContext(family: .systemSmall)).padding()
      if #available(iOSApplicationExtension 16.0, *) {
        PriceView(entry: PriceWidgetEntry(date: Date(), family: .accessoryCircular, currentMarketData: MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2019-09-18T17:27:00+00:00"), previousMarketData: emptyMarketData))
          .previewContext(WidgetPreviewContext(family: .accessoryCircular))
        PriceView(entry: PriceWidgetEntry(date: Date(), family: .accessoryInline, currentMarketData: MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2019-09-18T17:27:00+00:00"), previousMarketData: emptyMarketData))
          .previewContext(WidgetPreviewContext(family: .accessoryInline))
        PriceView(entry: PriceWidgetEntry(date: Date(), family: .accessoryRectangular, currentMarketData: MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2019-09-18T17:27:00+00:00"), previousMarketData: emptyMarketData))
          .previewContext(WidgetPreviewContext(family: .accessoryRectangular))
      }
    }
  }
}


================================================
FILE: ./ios/Widgets/Shared/Views/SendReceiveButtons.swift
================================================

//
//  SendReceiveButtons.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/3/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import SwiftUI
import WidgetKit

struct SendReceiveButtons: View {
    var body: some View {
      VStack(alignment: .center, spacing: nil, content: {
        HStack(alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/, spacing: 16, content: {
          Link("receive", destination: URL(string: "malinwallet://widget?action=openReceive")!).frame(minWidth: 144, maxWidth: /*@START_MENU_TOKEN@*/.infinity/*@END_MENU_TOKEN@*/, minHeight: 32, maxHeight: 32, alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/).lineLimit(1).foregroundColor(.textColor).font(Font.system(size:11, weight: .semibold, design: .default)).background(Color.widgetBackground).overlay(
            RoundedRectangle(cornerRadius: 4.0)
              .stroke(Color.widgetBackground, lineWidth: 4.0))
          Link("send", destination: URL(string: "malinwallet://widget?action=openSend")!).frame(minWidth: 144, maxWidth: /*@START_MENU_TOKEN@*/.infinity/*@END_MENU_TOKEN@*/, minHeight: 32, maxHeight: 32, alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/).lineLimit(1).foregroundColor(.textColor).font(Font.system(size:11, weight: .semibold, design: .default)).background(Color.widgetBackground).overlay(
            RoundedRectangle(cornerRadius: 4.0)
              .stroke(Color.widgetBackground, lineWidth: 4.0))
        })
      })
    }
}

struct SendReceiveButtons_Previews: PreviewProvider {
    static var previews: some View {
        SendReceiveButtons().previewContext(WidgetPreviewContext(family: .systemLarge))
    }
}


================================================
FILE: ./ios/Widgets/Shared/Views/WalletInformationView.swift
================================================

//
//  WalletInformationView.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/3/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import SwiftUI
import WidgetKit

struct WalletInformationView: View {
  
  var allWalletsBalance: WalletData = emptyWalletData
  var marketData: MarketData = emptyMarketData
  
  var formattedBalance: String {
    let numberFormatter = NumberFormatter()
    numberFormatter.locale = Locale(identifier: Currency.getUserPreferredCurrencyLocale())
    numberFormatter.numberStyle = .currency
    let amount = numberFormatter.string(from:  NSNumber(value: ((allWalletsBalance.balance / 100000000) * marketData.rate))) ?? ""
    return amount
  }
  var formattedLatestTransactionTime: String {
    if allWalletsBalance.latestTransactionTime.isUnconfirmed == true {
      return "Pending..."
    } else if allWalletsBalance.latestTransactionTime.epochValue == 0 {
      return "Never"
    }
    guard let epochValue = allWalletsBalance.latestTransactionTime.epochValue else {
      return "Never"
    }
    let forDate = Date(timeIntervalSince1970: TimeInterval(epochValue / 1000))
    let dateFormatter = RelativeDateTimeFormatter()
    dateFormatter.locale = Locale(identifier: Locale.current.identifier)
    dateFormatter.dateTimeStyle = .numeric
    return dateFormatter.localizedString(for: forDate, relativeTo: Date())
  }
  
    var body: some View {
        VStack(alignment: .leading, spacing:nil , content: {
            Text(allWalletsBalance.formattedBalanceBTC).font(Font.system(size: 15, weight: .medium, design: .default)).foregroundColor(.textColorLightGray).lineLimit(1).minimumScaleFactor(0.01)
          
  
          Text(formattedBalance).lineLimit(1).foregroundColor(.textColor).font(Font.system(size:28, weight: .bold, design: .default)).minimumScaleFactor(0.01)
      Spacer()
        
              Text("Latest transaction").font(Font.system(size: 11, weight: .regular, design: .default)).foregroundColor(.textColorLightGray)
              Text(formattedLatestTransactionTime).lineLimit(1).foregroundColor(.textColor).font(Font.system(size:13, weight: .regular, design: .default)).minimumScaleFactor(0.01)
        
      }).frame(minWidth: 0,
               maxWidth: .infinity,
               minHeight: 0,
               maxHeight: .infinity,
               alignment: .topLeading)
    }
}

struct WalletInformationView_Previews: PreviewProvider {
  static var previews: some View {
    WalletInformationView(allWalletsBalance: WalletData(balance: 10000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000)), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: Double(13000)))
      .previewContext(WidgetPreviewContext(family: .systemSmall))
  }
}


================================================
FILE: ./ios/Widgets/Shared/HostManager.swift
================================================

import Foundation

actor HostManager {
    var availableHosts: [(host: String, port: UInt16, useSSL: Bool)]
    var hostFailureCounts: [String: Int] = [:]
    let maxRetriesPerHost: Int

    init(hosts: [(host: String, port: UInt16, useSSL: Bool)], maxRetriesPerHost: Int) {
        self.availableHosts = hosts
        self.maxRetriesPerHost = maxRetriesPerHost
        print("Initialized HostManager with \(hosts.count) hosts.")
    }

    func getNextHost() -> (host: String, port: UInt16, useSSL: Bool)? {
        guard !availableHosts.isEmpty else {
            print("No available hosts to retrieve.")
            return nil
        }
        
        var attempts = availableHosts.count
        while attempts > 0 {
            let currentHost = availableHosts.removeFirst()
            if !shouldSkipHost(currentHost.host) {
                availableHosts.append(currentHost)
                print("Selected host: \(currentHost.host):\(currentHost.port) (SSL: \(currentHost.useSSL))")
                return currentHost
            } else {
                availableHosts.append(currentHost)
                attempts -= 1
                print("Host \(currentHost.host) is skipped due to max retries.")
            }
        }

        print("All hosts have been exhausted after max retries.")
        return nil
    }

    func shouldSkipHost(_ host: String) -> Bool {
        if let failureCount = hostFailureCounts[host], failureCount >= maxRetriesPerHost {
            print("Host \(host) has reached max retries (\(failureCount)). It will be skipped.") 
            return true
        }
        return false
    }

    func resetFailureCount(for host: String) {
        hostFailureCounts[host] = 0
        print("Reset failure count for host \(host).") 
    }

    func incrementFailureCount(for host: String) {
        hostFailureCounts[host, default: 0] += 1
        let newCount = hostFailureCounts[host]!
        print("Incremented failure count for host \(host). New count: \(newCount)") 
    }
}

================================================
FILE: ./ios/Widgets/Widgets.swift
================================================

//
//  Widgets.swift
//  Widgets
//
//  Created by Marcos Rodriguez on 6/6/21.
//  Copyright  2021 MalinWallet. All rights reserved.
//

import WidgetKit
import SwiftUI

@main
struct Widgets: WidgetBundle {
    @WidgetBundleBuilder
    var body: some Widget {
        PriceWidget()
        WalletInformationWidget()
        MarketWidget()
        WalletInformationAndMarketWidget()
    }
}


================================================
FILE: ./ios/Widgets/PriceWidget/PriceWidgetEntry.swift
================================================

//
//  PriceWidgetEntry.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 10/27/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import AppIntents
import WidgetKit

@available(iOS 14.0, *)
public struct PriceWidgetEntry: TimelineEntry {
    public let date: Date
    public let family: WidgetFamily
    public let currentMarketData: MarketData?
    public let previousMarketData: MarketData?

    public init(date: Date, family: WidgetFamily, currentMarketData: MarketData?, previousMarketData: MarketData?) {
        self.date = date
        self.family = family
        self.currentMarketData = currentMarketData
        self.previousMarketData = previousMarketData
    }
}


================================================
FILE: ./ios/Widgets/PriceWidget/PriceWidgetEntryView.swift
================================================

//
//  PriceWidgetEntryView.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 10/27/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import SwiftUI


@available(iOS 16.0, *)
struct PriceWidgetEntryView: View {
    let entry: PriceWidgetEntry

    var body: some View {
        PriceView(entry: entry)
    }
}


================================================
FILE: ./ios/Widgets/PriceWidget/PriceWidgetProvider.swift
================================================

//
//  PriceWidgetProvider.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 10/27/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//


import WidgetKit
import SwiftUI

@available(iOS 16.0, *)
struct PriceWidgetProvider: TimelineProvider {
    typealias Entry = PriceWidgetEntry
    static var lastSuccessfulEntry: PriceWidgetEntry?

    func placeholder(in context: Context) -> PriceWidgetEntry {
        createEntry(date: Date(), family: context.family, currentMarketData: previewMarketData)
    }

    func getSnapshot(in context: Context, completion: @escaping (PriceWidgetEntry) -> Void) {
        let entry: PriceWidgetEntry
        if context.isPreview {
            entry = createEntry(date: Date(), family: context.family, currentMarketData: previewMarketData)
        } else {
            entry = createEntry(date: Date(), family: context.family, currentMarketData: emptyMarketData)
        }
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<PriceWidgetEntry>) -> Void) {
        var entries: [PriceWidgetEntry] = []

        let userPreferredCurrency = Currency.getUserPreferredCurrency()
        if userPreferredCurrency != Currency.getLastSelectedCurrency() {
            Currency.saveNewSelectedCurrency()
        }

        Task {
            do {
                if let data = try await MarketAPI.fetchPrice(currency: userPreferredCurrency), let formattedRate = data.formattedRate {
                    let currentMarketData = MarketData(nextBlock: "", sats: "", price: formattedRate, rate: data.rateDouble, dateString: data.lastUpdate)
                    let previousMarketData = PriceWidgetProvider.lastSuccessfulEntry?.currentMarketData

                    let entry = createEntry(
                        date: Date(),
                        family: context.family,
                        currentMarketData: currentMarketData,
                        previousMarketData: previousMarketData ?? emptyMarketData
                    )
                    PriceWidgetProvider.lastSuccessfulEntry = entry
                    entries.append(entry)
                } else {
                    if let lastEntry = PriceWidgetProvider.lastSuccessfulEntry {
                        entries.append(lastEntry)
                    } else {
                        let entry = createEntry(date: Date(), family: context.family, currentMarketData: emptyMarketData)
                        entries.append(entry)
                    }
                }
            } catch {
                if let lastEntry = PriceWidgetProvider.lastSuccessfulEntry {
                    entries.append(lastEntry)
                } else {
                    let entry = createEntry(date: Date(), family: context.family, currentMarketData: emptyMarketData)
                    entries.append(entry)
                }
            }

            let timeline = Timeline(entries: entries, policy: .atEnd)
            completion(timeline)
        }
    }

    private func createEntry(date: Date, family: WidgetFamily, currentMarketData: MarketData, previousMarketData: MarketData = emptyMarketData) -> PriceWidgetEntry {
        PriceWidgetEntry(date: date, family: family, currentMarketData: currentMarketData, previousMarketData: previousMarketData)
    }
}


================================================
FILE: ./ios/Widgets/PriceWidget/PriceIntent.swift
================================================

//
//  PriceIntent.swift
//  MalinWallet
//

import AppIntents
import SwiftUI
import Foundation

// MARK: - Error Types

enum PriceIntentError: LocalizedError {
    case fetchFailed
    case invalidData
    case networkUnavailable
    
    var errorDescription: String? {
        switch self {
        case .fetchFailed:
            return "Failed to fetch Bitcoin price data"
        case .invalidData:
            return "Received invalid price data"
        case .networkUnavailable:
            return "Network is unavailable"
        }
    }
}

// MARK: - Price Data Model

struct PriceData {
    let rate: Double
    let lastUpdate: String
    let formattedPrice: String
    let currencyCode: String
    let dataSource: String
}

@available(iOS 16.0, *)
struct PriceIntent: AppIntent {
    // MARK: - Intent Metadata
    
    static var title: LocalizedStringResource = "Market Rate"
    static var description = IntentDescription("View the current Bitcoin market rate in your preferred currency.")
    static var openAppWhenRun: Bool { false }

    // MARK: - Parameters
    
    @Parameter(
        title: "Currency",
        description: "Choose your preferred currency."
    )
    var fiatCurrency: FiatUnitEnum?

    @MainActor
    func perform() async throws -> some IntentResult & ReturnsValue<Double> & ProvidesDialog & ShowsSnippetView {
        let selectedCurrency = resolveCurrency()
        
        do {
            let priceData = try await fetchPriceData(for: selectedCurrency)
            let successView = CompactPriceView(
                price: priceData.formattedPrice,
                lastUpdated: priceData.lastUpdate,
                code: priceData.currencyCode,
                dataSource: priceData.dataSource
            )
            
            return .result(
                value: priceData.rate,
                dialog: "Current Bitcoin Market Rate",
                view: successView
            )
        } catch {
            let errorView = CompactPriceView(
                price: "N/A",
                lastUpdated: "--",
                code: selectedCurrency.rawValue,
                dataSource: "Error fetching data"
            )
            
            return .result(
                value: 0.0,
                dialog: "Failed to retrieve the Bitcoin market rate.",
                view: errorView
            )
        }
    }

    // MARK: - Currency Resolution
    
    private func resolveCurrency() -> FiatUnitEnum {
        // Priority order: parameter -> shared defaults -> device locale -> USD fallback
        if let providedCurrency = fiatCurrency {
            return providedCurrency
        }
        
        if let sharedCurrency = getSharedCurrency() {
            return sharedCurrency
        }
        
        if let deviceCurrency = getDeviceCurrency() {
            return deviceCurrency
        }
        
        return .USD
    }
    
    private func getSharedCurrency() -> FiatUnitEnum? {
        guard let sharedDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue),
              let currencyCode = sharedDefaults.string(forKey: UserDefaultsGroupKey.PreferredCurrency.rawValue),
              let currency = FiatUnitEnum(rawValue: currencyCode.uppercased()) else {
            return nil
        }
        return currency
    }
    
    private func getDeviceCurrency() -> FiatUnitEnum? {
        guard let deviceCurrencyCode = Locale.current.currency?.identifier,
              let currency = FiatUnitEnum(rawValue: deviceCurrencyCode.uppercased()) else {
            return nil
        }
        return currency
    }

    // MARK: - Data Fetching
    
    private func fetchPriceData(for currency: FiatUnitEnum) async throws -> PriceData {
        guard let fetchedData = try await MarketAPI.fetchPrice(currency: currency.rawValue) else {
            throw PriceIntentError.fetchFailed
        }
        
        let formattedPrice = formatPrice(fetchedData.rateDouble, currencyCode: currency.rawValue)
        let formattedDate = formatDate(from: fetchedData.lastUpdate)
        
        return PriceData(
            rate: fetchedData.rateDouble,
            lastUpdate: formattedDate,
            formattedPrice: formattedPrice,
            currencyCode: currency.rawValue,
            dataSource: currency.source
        )    }

    // MARK: - Formatting Methods

    private func formatDate(from isoString: String?) -> String {
        guard let isoString = isoString,
              let date = ISO8601DateFormatter().date(from: isoString) else {
            return "--"
        }

        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }

    private func formatPrice(_ price: Double, currencyCode: String) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale.current
        formatter.currencyCode = currencyCode

        if price >= 1000 {
            formatter.maximumFractionDigits = 0
            formatter.minimumFractionDigits = 0
        } else {
            formatter.maximumFractionDigits = 2
            formatter.minimumFractionDigits = 2
        }

        return formatter.string(from: NSNumber(value: price)) ?? "\(price)"
    }
}


================================================
FILE: ./ios/Widgets/PriceWidget/PriceWidget.swift
================================================

//
//  PriceWidget.swift
//  PriceWidget
//
//  Created by Marcos Rodriguez on 11/8/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import WidgetKit
import SwiftUI

@available(iOS 16.0, *)
struct PriceWidget: Widget {
    let kind: String = "PriceWidget"

  var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: PriceWidgetProvider()) { entry in
            PriceWidgetEntryView(entry: entry)
        }
        .configurationDisplayName("Price")
        .description("View the current price of Bitcoin.")
        .supportedFamilies(supportedFamilies)
        .contentMarginsDisabledIfAvailable() 
    }

  @available(iOS 16.0, *)
  private var supportedFamilies: [WidgetFamily] {
        if #available(iOSApplicationExtension 16.0, *) {
            return [.systemSmall, .accessoryCircular, .accessoryInline, .accessoryRectangular]
        } else {
            return [.systemSmall]
        }
    }
}

@available(iOS 16.0, *)
struct PriceWidget_Previews: PreviewProvider {
  static var previews: some View {
        Group {
            PriceWidgetEntryView(entry: PreviewData.entry)
                .previewContext(WidgetPreviewContext(family: .systemSmall))
            if #available(iOSApplicationExtension 16.0, *) {
                PriceWidgetEntryView(entry: PreviewData.entry)
                    .previewContext(WidgetPreviewContext(family: .accessoryCircular))
                PriceWidgetEntryView(entry: PreviewData.entry)
                    .previewContext(WidgetPreviewContext(family: .accessoryInline))
                PriceWidgetEntryView(entry: PreviewData.entry)
                    .previewContext(WidgetPreviewContext(family: .accessoryRectangular))
            }
        }
    }
}

let previewMarketData = MarketData(nextBlock: "", sats: "", price: "$10,000", rate: 10000, dateString: "2019-09-18T17:27:00+00:00")

@available(iOS 14.0, *)
struct PreviewData {
    static let entry = PriceWidgetEntry(
        date: Date(),
        family: .systemSmall,
        currentMarketData: previewMarketData,
        previousMarketData: emptyMarketData
    )
}

@available(iOS 14.0, *)
extension WidgetConfiguration
{
  @available(iOS 15.0, *)
  func contentMarginsDisabledIfAvailable() -> some WidgetConfiguration
    {
        if #available(iOSApplicationExtension 17.0, *)
        {
            return self.contentMarginsDisabled()
        }
        else
        {
            return self
        }
    }
}


================================================
FILE: ./ios/Widgets/PriceWidget/CompactPriceView.swift
================================================

import SwiftUI

@available(iOS 15.0, *)
struct CompactPriceView: View {
    @Environment(\.colorScheme) var colorScheme

    let price: String
    let lastUpdated: String
    let code: String
    let dataSource: String

    var body: some View {
        VStack(alignment: .center, spacing: 16) {
            Text(price)
                .font(.title)
                .bold()
                .multilineTextAlignment(.center)
                .dynamicTypeSize(.large ... .accessibility5)
                .foregroundColor(textColor)
                .accessibilityLabel("Bitcoin price: \(price)")

            VStack(alignment: .center, spacing: 8) {
                Text(code)
                    .shadow(color: shadowColor, radius: 1, x: 0, y: 1)
                Text(lastUpdated)
                    .shadow(color: shadowColor, radius: 1, x: 0, y: 1)
                Text(dataSource)
                    .shadow(color: shadowColor, radius: 1, x: 0, y: 1)
            }
            .font(.subheadline)
            .foregroundColor(textColor)
            .multilineTextAlignment(.center)
            .accessibilityElement(children: .combine)
        }
        .padding()
        .frame(maxWidth: .infinity)
    }

    private var textColor: Color {
        colorScheme == .dark ? .white : .black
    }

    private var shadowColor: Color {
        textColor.opacity(0.2)
    }
}

@available(iOS 15.0, *)
struct CompactPriceView_Previews: PreviewProvider {
    static var previews: some View {
        ZStack {
            LinearGradient(
                gradient: Gradient(colors: [.blue, .purple]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()

            CompactPriceView(
                price: "$50,000",
                lastUpdated: "Last updated: Oct 10, 2023",
                code: "BTC",
                dataSource: "Data source: CoinDesk"
            )
        }
    }
}


================================================
FILE: ./ios/Widgets/WalletInformationAndMarketWidget/WalletInformationAndMarketWidget.swift
================================================

//
//  WalletInformationAndMarketWidget.swift
//  WalletInformationAndMarketWidget
//
//  Created by Marcos Rodriguez on 10/29/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import WidgetKit
import SwiftUI

struct WalletInformationAndMarketWidgetProvider: TimelineProvider {
    typealias Entry = WalletInformationAndMarketWidgetEntry

    actor LastSuccessfulEntryStore {
        private var lastSuccessfulEntry: WalletInformationAndMarketWidgetEntry?

        func getLastSuccessfulEntry() -> WalletInformationAndMarketWidgetEntry? {
            return lastSuccessfulEntry
        }

        func setLastSuccessfulEntry(_ entry: WalletInformationAndMarketWidgetEntry) {
            lastSuccessfulEntry = entry
        }
    }

    let entryStore = LastSuccessfulEntryStore()

    func placeholder(in context: Context) -> WalletInformationAndMarketWidgetEntry {
        return WalletInformationAndMarketWidgetEntry.placeholder
    }

    func getSnapshot(in context: Context, completion: @escaping (WalletInformationAndMarketWidgetEntry) -> ()) {
        let entry: WalletInformationAndMarketWidgetEntry
        if (context.isPreview) {
            entry = WalletInformationAndMarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 10000), allWalletsBalance: WalletData(balance: 1000000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000)))
        } else {
            entry = WalletInformationAndMarketWidgetEntry(date: Date(), marketData: emptyMarketData)
        }
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {
        var entries: [WalletInformationAndMarketWidgetEntry] = []
        if (context.isPreview) {
            let entry = WalletInformationAndMarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 10000), allWalletsBalance: WalletData(balance: 1000000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000)))
            entries.append(entry)
            let timeline = Timeline(entries: entries, policy: .atEnd)
            completion(timeline)
        } else {
            let userPreferredCurrency = Currency.getUserPreferredCurrency()
            let allWalletsBalance = WalletData(balance: UserDefaultsGroup.getAllWalletsBalance(), latestTransactionTime: UserDefaultsGroup.getAllWalletsLatestTransactionTime())

            fetchMarketDataWithRetry(currency: userPreferredCurrency, retries: 3) { marketData in
                let entry = WalletInformationAndMarketWidgetEntry(date: Date(), marketData: marketData, allWalletsBalance: allWalletsBalance)
                Task {
                    await entryStore.setLastSuccessfulEntry(entry)
                    entries.append(entry)
                    let timeline = Timeline(entries: entries, policy: .atEnd)
                    completion(timeline)
                }
            }
        }
    }

    private func fetchMarketDataWithRetry(currency: String, retries: Int, completion: @escaping (MarketData) -> ()) {
        var attempt = 0

        func attemptFetch() {
            attempt += 1
            print("Attempt \(attempt) to fetch market data.")

          MarketAPI.fetchMarketData(currency: currency) { result in
                switch result {
                case .success(let marketData):
                    print("Successfully fetched market data on attempt \(attempt).")
                    completion(marketData)
                case .failure(let error):
                    print("Error fetching market data: \(error.localizedDescription). Retry \(attempt)/\(retries)")
                    if attempt < retries {
                        DispatchQueue.global().asyncAfter(deadline: .now() + 2) {
                            attemptFetch()
                        }
                    } else {
                        print("Max retries reached.")
                        Task {
                            if let lastEntry = await entryStore.getLastSuccessfulEntry() {
                                completion(lastEntry.marketData)
                            } else {
                                completion(WalletInformationAndMarketWidgetEntry.placeholder.marketData)
                            }
                        }
                    }
                }
            }
        }

        attemptFetch()
    }
}

struct WalletInformationAndMarketWidgetEntry: TimelineEntry {
    let date: Date
    let marketData: MarketData
    var allWalletsBalance: WalletData = WalletData(balance: 0)
    static var placeholder = WalletInformationAndMarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "...", sats: "...", price: "...", rate: 0), allWalletsBalance: WalletData(balance: 0, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000)))
}

struct WalletInformationAndMarketWidgetEntryView: View {
    @Environment(\.widgetFamily) var family
    let entry: WalletInformationAndMarketWidgetEntry

    var WalletBalance: some View {
        WalletInformationView(allWalletsBalance: entry.allWalletsBalance, marketData: entry.marketData).background(Color.widgetBackground)
    }

    var MarketStack: some View {
        MarketView(marketData: entry.marketData)
    }

    var SendReceiveButtonsView: some View {
        SendReceiveButtons().padding(.all, 10)
    }

    var body: some View {
        if family == .systemLarge {
            HStack(alignment: .center, spacing: nil, content: {
                VStack(alignment: .leading, spacing: nil, content: {
                    HStack(content: {
                        WalletBalance.padding()
                    }).background(Color.widgetBackground)
                    HStack(content: {
                        MarketStack
                    }).padding()
                    SendReceiveButtonsView
                }).background(Color(.lightGray).opacity(0.77))
            })
        } else {
            HStack(content: {
                WalletBalance.padding()
                HStack(content: {
                    MarketStack.padding()
                }).background(Color(.lightGray).opacity(0.77))
            }).background(Color.widgetBackground)
        }
    }
}

struct WalletInformationAndMarketWidget: Widget {
    let kind: String = "WalletInformationAndMarketWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: WalletInformationAndMarketWidgetProvider()) { entry in
            WalletInformationAndMarketWidgetEntryView(entry: entry)
        }
        .configurationDisplayName("Wallet and Market")
        .description("View your total wallet balance and network prices.").supportedFamilies([.systemMedium, .systemLarge])
        .contentMarginsDisabledIfAvailable()
    }
}

struct WalletInformationAndMarketWidget_Previews: PreviewProvider {
    static var previews: some View {
        WalletInformationAndMarketWidgetEntryView(entry: WalletInformationAndMarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 0), allWalletsBalance: WalletData(balance: 10000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000))))
            .previewContext(WidgetPreviewContext(family: .systemMedium))
        WalletInformationAndMarketWidgetEntryView(entry: WalletInformationAndMarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10,000", rate: 0), allWalletsBalance: WalletData(balance: 10000, latestTransactionTime: LatestTransaction(isUnconfirmed: false, epochValue: 1568804029000))))
            .previewContext(WidgetPreviewContext(family: .systemLarge))
    }
}


================================================
FILE: ./ios/Widgets/WalletAppShortcuts.swift
================================================

//
//  WalletAppShortcuts.swift
//  MalinWallet


import AppIntents

@available(iOS 16.4, *)
struct WalletAppShortcuts: AppShortcutsProvider {
    
    @AppShortcutsBuilder
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: PriceIntent(),
            phrases: [
                AppShortcutPhrase<PriceIntent>("Market rate for Bitcoin in \(\.$fiatCurrency) using ${applicationName}"),
                AppShortcutPhrase<PriceIntent>("Get the current Bitcoin market rate in \(\.$fiatCurrency) with ${applicationName}"),
                AppShortcutPhrase<PriceIntent>("What's the current Bitcoin rate in \(\.$fiatCurrency) using ${applicationName}?"),
                AppShortcutPhrase<PriceIntent>("Show me the current Bitcoin price in \(\.$fiatCurrency) via ${applicationName}"),
                AppShortcutPhrase<PriceIntent>("Retrieve Bitcoin rate in \(\.$fiatCurrency) from ${applicationName}")
            ],
            shortTitle: "Market Rate",
            systemImageName: "bitcoinsign.circle"
        )
        
    }
}


================================================
FILE: ./ios/Widgets/MarketWidget/MarketWidget.swift
================================================

//
//  MarketWidget.swift
//  MarketWidget
//
//  Created by Marcos Rodriguez on 11/6/20.
//  Copyright  2020 MalinWallet. All rights reserved.
//

import WidgetKit
import SwiftUI

struct MarketWidgetProvider: TimelineProvider {
    static var lastSuccessfulEntry: MarketWidgetEntry?

    func placeholder(in context: Context) -> MarketWidgetEntry {
        return MarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10 000", rate: 10000))
    }

    func getSnapshot(in context: Context, completion: @escaping (MarketWidgetEntry) -> ()) {
        let entry: MarketWidgetEntry
        if context.isPreview {
            entry = MarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9 134", price: "$10 000", rate: 10000))
        } else {
            entry = MarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "...", sats: "...", price: "...", rate: 0))
        }
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {
        let currentDate = Date()
        var entries: [MarketWidgetEntry] = []

        let marketDataEntry = MarketWidgetEntry(date: currentDate, marketData: MarketData(nextBlock: "...", sats: "...", price: "...", rate: 0))
        entries.append(marketDataEntry) // Initial placeholder entry

        let userPreferredCurrency = Currency.getUserPreferredCurrency()
        fetchMarketDataWithRetry(currency: userPreferredCurrency, retries: 3) { marketData in
            let entry = MarketWidgetEntry(date: Date(), marketData: marketData)
            entries.append(entry)
            let timeline = Timeline(entries: entries, policy: .atEnd)
            completion(timeline)
        }
    }

    private func fetchMarketDataWithRetry(currency: String, retries: Int, completion: @escaping (MarketData) -> ()) {
        var attempt = 0

        func attemptFetch() {
            attempt += 1
            print("Attempt \(attempt) to fetch market data.")

            MarketAPI.fetchMarketData(currency: currency) { result in
                switch result {
                case .success(let marketData):
                    print("Successfully fetched market data on attempt \(attempt).")
                    completion(marketData)
                case .failure(let error):
                    print("Fetch market data failed (attempt \(attempt)): \(error.localizedDescription)")
                    if attempt < retries {
                        DispatchQueue.global().asyncAfter(deadline: .now() + 2) {
                            attemptFetch()
                        }
                    } else {
                        print("Failed to fetch market data after \(retries) attempts.")
                        let fallbackData = MarketData(nextBlock: "...", sats: "...", price: "...", rate: 0)
                        completion(fallbackData)
                    }
                }
            }
        }

        attemptFetch()
    }
}

struct MarketWidgetEntry: TimelineEntry {
    let date: Date
    var marketData: MarketData
}

struct MarketWidgetEntryView: View {
    var entry: MarketWidgetEntry

 var MarketStack: some View {
    MarketView(marketData: entry.marketData)
  }
  
  var body: some View {
    VStack(content: {
      MarketStack.containerBackground(Color.widgetBackground, for: .widget)
    })
  }
}

struct MarketWidget: Widget {
    let kind: String = "MarketWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: MarketWidgetProvider()) { entry in
            MarketWidgetEntryView(entry: entry)
        }
        .configurationDisplayName("Market")
        .description("View the current market information.").supportedFamilies([.systemSmall])
    }
}

struct MarketWidget_Previews: PreviewProvider {
    static var previews: some View {
        MarketWidgetEntryView(entry: MarketWidgetEntry(date: Date(), marketData: MarketData(nextBlock: "26", sats: "9,134", price: "$10,000", rate: 0)))
            .previewContext(WidgetPreviewContext(family: .systemSmall))
    }
}


================================================
FILE: ./ios/MalinWallet-Bridging-Header.h
================================================

//
//  MalinWallet-Bridging-Header.h
//  MalinWallet
//
//  Created by Marcos Rodriguez on 4/4/25.
//  Copyright  2026 MalinWallet. All rights reserved.
//

#import <RNCPushNotificationIOS.h>
#import "RNQuickActionManager.h"


================================================
FILE: ./ios/MalinWallet/AppDelegate.swift
================================================

import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import UserNotifications
import Bugsnag


@main
class AppDelegate: RCTAppDelegate, UNUserNotificationCenterDelegate {

    private var userDefaultsGroup: UserDefaults?

    override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
        clearFilesIfNeeded()
        
        // Fix app group UserDefaults initialization
        userDefaultsGroup = UserDefaults.standard
        
        // Set up device UID observers early
        setupDeviceUIDObservers()
        
        let doNotTrackValue = userDefaultsGroup?.string(forKey: "donottrack") ?? "0"
        NSLog("[AppDelegate] Initial Do Not Track value: '\(doNotTrackValue)'")

        if let isDoNotTrackEnabled = userDefaultsGroup?.string(forKey: "donottrack"), isDoNotTrackEnabled == "1" {
            let isEnabled = userDefaultsGroup?.string(forKey: "donottrack") ?? "0"
            NSLog("[AppDelegate] Do Not Track setting: \(isEnabled), expected to be '1'")
          
            userDefaultsGroup?.set("Disabled", forKey: "deviceUIDCopy")
            userDefaultsGroup?.synchronize()
          
            NSLog("[AppDelegate] Do Not Track enabled: set deviceUIDCopy to 'Disabled'")
          
        } else {
      #if targetEnvironment(macCatalyst)
      let config = BugsnagConfiguration.loadConfig()
      config.appType = "macOS"
      Bugsnag.start(with: config)
      copyDeviceUID()
      #else
      Bugsnag.start()
      copyDeviceUID()
      #endif
        }

        self.moduleName = "MalinWallet"
        self.dependencyProvider = RCTAppDependencyProvider()
        self.initialProps = [:]

        RCTI18nUtil.sharedInstance().allowRTL(true)

        let center = UNUserNotificationCenter.current()
        center.delegate = self

        setupUserDefaultsListener()
        registerNotificationCategories()
        
        // Access the singleton via the class method
        _ = MenuElementsEmitter.sharedInstance()
        NSLog("[MenuElements] AppDelegate: Initialized emitter singleton")
        
        return super.application(application, didFinishLaunchingWithOptions: launchOptions)
    }

    override func sourceURL(for bridge: RCTBridge) -> URL? {
        return bundleURL()
    }

    override func bundleURL() -> URL? {
        #if DEBUG
        return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
        #else
        return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
        #endif
    }

    private func registerNotificationCategories() {
        let viewAddressTransactionsAction = UNNotificationAction(
            identifier: "VIEW_ADDRESS_TRANSACTIONS",
            title: NSLocalizedString("VIEW_ADDRESS_TRANSACTIONS_TITLE", comment: ""),
            options: .foreground
        )

        let viewTransactionDetailsAction = UNNotificationAction(
            identifier: "VIEW_TRANSACTION_DETAILS",
            title: NSLocalizedString("VIEW_TRANSACTION_DETAILS_TITLE", comment: ""),
            options: .foreground
        )

        let transactionCategory = UNNotificationCategory(
            identifier: "TRANSACTION_CATEGORY",
            actions: [viewAddressTransactionsAction, viewTransactionDetailsAction],
            intentIdentifiers: [],
            options: .customDismissAction
        )

        UNUserNotificationCenter.current().setNotificationCategories([transactionCategory])
    }

    private func setupUserDefaultsListener() {
        guard let defaults = userDefaultsGroup else {
            NSLog("[AppDelegate] Cannot setup UserDefaults listeners: group defaults not available")
            return
        }
        
        let keys = [
            "WidgetCommunicationAllWalletsSatoshiBalance",
            "WidgetCommunicationAllWalletsLatestTransactionTime",
            "WidgetCommunicationDisplayBalanceAllowed",
            "WidgetCommunicationLatestTransactionIsUnconfirmed",
            "preferredCurrency",
            "preferredCurrencyLocale",
            "electrum_host",
            "electrum_tcp_port",
            "electrum_ssl_port"
        ]

        for key in keys {
            defaults.addObserver(self, forKeyPath: key, options: .new, context: nil)
        }
    }

    private func copyDeviceUID() {
        let isDoNotTrackEnabled = userDefaultsGroup?.string(forKey: "donottrack") == "1"
        
        let deviceUID = UserDefaults.standard.string(forKey: "deviceUID") ?? ""
        let currentCopy = userDefaultsGroup?.string(forKey: "deviceUIDCopy") ?? ""
        
        if isDoNotTrackEnabled {
            if currentCopy != "Disabled" {
                userDefaultsGroup?.set("Disabled", forKey: "deviceUIDCopy")
                userDefaultsGroup?.synchronize()
                NSLog("[AppDelegate] Do Not Track enabled - set deviceUIDCopy to 'Disabled'")
            }
            return
        }
        
        let hasCorrectFormat = deviceUID.count == 36 && deviceUID.components(separatedBy: "-").count == 5
        if deviceUID.isEmpty || !hasCorrectFormat {
            let uuid = UUID().uuidString
            UserDefaults.standard.setValue(uuid, forKey: "deviceUID")
            copyDeviceUID()
            return
        }
        if deviceUID != currentCopy {
            userDefaultsGroup?.set(deviceUID, forKey: "deviceUIDCopy")
            userDefaultsGroup?.synchronize()
            
            NSLog("[AppDelegate] Synced deviceUID to shared group: \(deviceUID)")
            
            let updatedCopy = userDefaultsGroup?.string(forKey: "deviceUIDCopy") ?? ""
            NSLog("[AppDelegate] Verification - deviceUIDCopy is now: \(updatedCopy)")
        }
    }


    private func setupDeviceUIDObservers() {
        UserDefaults.standard.addObserver(self, forKeyPath: "deviceUID", options: .new, context: nil)
        
        if userDefaultsGroup != nil {
            userDefaultsGroup?.addObserver(self, forKeyPath: "donottrack", options: .new, context: nil)
            NSLog("[AppDelegate] Registered observer for donottrack changes")
        }
        
        // Check if Do Not Track is enabled
        let isDoNotTrackEnabled = userDefaultsGroup?.string(forKey: "donottrack") == "1"
        NSLog("[AppDelegate] Do Not Track enabled: \(isDoNotTrackEnabled)")
        
        let currentDeviceUID = UserDefaults.standard.string(forKey: "deviceUID")
        
        if !isDoNotTrackEnabled {
            var shouldSetUUID = false
            
            if currentDeviceUID == nil {
                shouldSetUUID = true
                NSLog("[AppDelegate] No deviceUID exists, will create a new one")
            } else if let currentUID = currentDeviceUID {
                let hasCorrectFormat = currentUID.count == 36 && currentUID.components(separatedBy: "-").count == 5
                if !hasCorrectFormat {
                    shouldSetUUID = true
                    NSLog("[AppDelegate] Current deviceUID doesn't match UUID format, will replace it")
                }
            }
            
            if shouldSetUUID {
                let uuid = UUID().uuidString
                UserDefaults.standard.setValue(uuid, forKey: "deviceUID")
                NSLog("[AppDelegate] Set deviceUID to: \(uuid)")
            }
        } else {
            NSLog("[AppDelegate] Do Not Track enabled - not setting UUID")
        }
        
        if userDefaultsGroup != nil {
            UserDefaults.standard.addSuite(named: UserDefaultsGroupKey.GroupName.rawValue)
            NSLog("[AppDelegate] Registered app group UserDefaults with standard UserDefaults")
        }
        
        copyDeviceUID()
    }

    private func clearFilesIfNeeded() {
        let defaults = UserDefaults.standard
        if defaults.bool(forKey: "clearFilesOnLaunch") {
            clearDirectory(.documentDirectory)
            clearDirectory(.cachesDirectory)
            clearTempDirectory()

            defaults.set(false, forKey: "clearFilesOnLaunch")
            defaults.synchronize()

            DispatchQueue.main.async {
                let alert = UIAlertController(
                    title: "Cache Cleared",
                    message: "The document, cache, and temp directories have been cleared.",
                    preferredStyle: .alert
                )
                alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
              self.window.rootViewController?.present(alert, animated: true, completion: nil)
            }
        }
    }

    private func clearDirectory(_ directory: FileManager.SearchPathDirectory) {
        if let directoryURL = FileManager.default.urls(for: directory, in: .userDomainMask).last {
            clearDirectory(at: directoryURL)
        }
    }

    private func clearTempDirectory() {
        let tempDirectory = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        clearDirectory(at: tempDirectory)
    }

    private func clearDirectory(at url: URL) {
        do {
            let contents = try FileManager.default.contentsOfDirectory(at: url, includingPropertiesForKeys: nil, options: [])
            for fileURL in contents {
                try FileManager.default.removeItem(at: fileURL)
            }
        } catch {
            print("Error clearing directory: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Key-Value Observing
  override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey: Any]?, context: UnsafeMutableRawPointer?) {
        guard let keyPath = keyPath else { return }

        // Handle deviceUID change
        if keyPath == "deviceUID" {
            NSLog("[AppDelegate] deviceUID changed, calling copyDeviceUID")
            copyDeviceUID()
        }
        
        // Handle donottrack changes
        if keyPath == "donottrack" {
            let newValue = userDefaultsGroup?.string(forKey: "donottrack") ?? "0"
            NSLog("[AppDelegate] donottrack changed to: \(newValue)")
            
            if newValue != "1" {
                let deviceUID = UserDefaults.standard.string(forKey: "deviceUID") ?? ""
                let hasCorrectFormat = deviceUID.count == 36 && deviceUID.components(separatedBy: "-").count == 5
                
                if deviceUID.isEmpty || !hasCorrectFormat {
                    let uuid = UUID().uuidString
                    UserDefaults.standard.setValue(uuid, forKey: "deviceUID")
                    NSLog("[AppDelegate] Do Not Track disabled - setting new deviceUID: \(uuid)")
                }
            }
            
            copyDeviceUID()
        }

        let keys = [
            "WidgetCommunicationAllWalletsSatoshiBalance",
            "WidgetCommunicationAllWalletsLatestTransactionTime",
            "WidgetCommunicationDisplayBalanceAllowed",
            "WidgetCommunicationLatestTransactionIsUnconfirmed",
            "preferredCurrency",
            "preferredCurrencyLocale",
            "electrum_host",
            "electrum_tcp_port",
            "electrum_ssl_port"
        ]

        if keys.contains(keyPath) {
            WidgetHelper.reloadAllWidgets()
        }
    }

    override func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
      let activityType = userActivity.activityType
      guard !activityType.isEmpty else {
            print("[Handoff] Invalid or missing userActivity")
            return false
        }

        let userActivityData: [String: Any] = [
            "activityType": activityType,
            "userInfo": userActivity.userInfo ?? [:]
        ]

        userDefaultsGroup?.setValue(userActivityData, forKey: "onUserActivityOpen")

        if ["com.malinwallet.app.receiveonchain", "com.malinwallet.app.xpub", "com.malinwallet.app.blockexplorer"].contains(activityType) {
          EventEmitter.shared().sendUserActivity(userActivityData)
            return true
        }

        if activityType == NSUserActivityTypeBrowsingWeb {
            return RCTLinkingManager.application(application, continue: userActivity, restorationHandler: restorationHandler)
        }

        print("[Handoff] Unhandled user activity type: \(activityType)")
        return false
    }

    override func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
        return RCTLinkingManager.application(app, open: url, options: options)
    }

    override func applicationWillTerminate(_ application: UIApplication) {
        userDefaultsGroup?.removeObject(forKey: "onUserActivityOpen")
        
        UserDefaults.standard.removeObserver(self, forKeyPath: "deviceUID")
    }

    override func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
        RNQuickActionManager.onQuickActionPress(shortcutItem, completionHandler: completionHandler)
    }

    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler([.sound, .list, .banner, .badge])
    }

    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        let userInfo = response.notification.request.content.userInfo
        let blockExplorer = userDefaultsGroup?.string(forKey: "blockExplorer") ?? "https://www.mempool.space"

        if let data = userInfo["data"] as? [String: Any] {
            if response.actionIdentifier == "VIEW_ADDRESS_TRANSACTIONS", let address = data["address"] as? String {
                if let url = URL(string: "\(blockExplorer)/address/\(address)") {
                    UIApplication.shared.open(url)
                }
            } else if response.actionIdentifier == "VIEW_TRANSACTION_DETAILS", let txid = data["txid"] as? String {
                if let url = URL(string: "\(blockExplorer)/tx/\(txid)") {
                    UIApplication.shared.open(url)
                }
            }
        }

        RNCPushNotificationIOS.didReceive(response)
        completionHandler()
    }
    
    // MARK: - Menu Building (macOS Catalyst)
    
    override func buildMenu(with builder: UIMenuBuilder) {
        super.buildMenu(with: builder)
        
        // Remove unnecessary menus
        builder.remove(menu: .services)
        builder.remove(menu: .format)
        builder.remove(menu: .toolbar)
        
        // Remove the original Settings menu item
        builder.remove(menu: .preferences)
        
        // File -> Add Wallet (Command + Shift + A)
        let addWalletCommand = UIKeyCommand(
            title: "Add Wallet",
            action: #selector(addWalletAction),
            input: "A",
            modifierFlags: [.command, .shift]
        )
        
        // All menu items enabled by default
        
        // File -> Import Wallet (Command + I)
        let importWalletCommand = UIKeyCommand(
            title: "Import Wallet",
            action: #selector(importWalletAction),
            input: "I",
            modifierFlags: .command
        )
        
        // Group Add Wallet and Import Wallet in a displayInline menu
        let walletOperationsMenu = UIMenu(
            title: "",
            image: nil,
            identifier: nil,
            options: .displayInline,
            children: [addWalletCommand, importWalletCommand]
        )
        
        // Modify the existing File menu to include Wallet Operations
        if let fileMenu = builder.menu(for: .file) {
            // Add "Reload Transactions" (Command + R)
            let reloadTransactionsCommand = UIKeyCommand(
                title: "Reload Transactions",
                action: #selector(reloadTransactionsAction),
                input: "R",
                modifierFlags: .command
            )
            
            // Combine wallet operations and Reload Transactions into the new File menu
            let newFileMenu = UIMenu(
                title: fileMenu.title,
                image: fileMenu.image,
                identifier: fileMenu.identifier,
                options: fileMenu.options,
                children: [walletOperationsMenu, reloadTransactionsCommand]
            )
            
            builder.replace(menu: .file, with: newFileMenu)
        }
        
        // MalinWallet -> Settings (Command + ,)
        let settingsCommand = UIKeyCommand(
            title: "Settings...",
            action: #selector(openSettings),
            input: ",",
            modifierFlags: .command
        )
        
        let settingsMenu = UIMenu(
            title: "",
            image: nil,
            identifier: nil,
            options: .displayInline,
            children: [settingsCommand]
        )
        
        // Insert the new Settings menu after the About menu
        builder.insertSibling(settingsMenu, afterMenu: .about)
    }
    
    @objc func openSettings(_ keyCommand: UIKeyCommand) {
        DispatchQueue.main.async {
            MenuElementsEmitter.sharedInstance().openSettings()
        }
    }
    
    @objc func addWalletAction(_ keyCommand: UIKeyCommand) {
        DispatchQueue.main.async {
            MenuElementsEmitter.sharedInstance().addWalletMenuAction()
        }
    }
    
    @objc func importWalletAction(_ keyCommand: UIKeyCommand) {
        DispatchQueue.main.async {
            MenuElementsEmitter.sharedInstance().importWalletMenuAction()
        }
    }
    
    @objc func reloadTransactionsAction(_ keyCommand: UIKeyCommand) {
        DispatchQueue.main.async {
            MenuElementsEmitter.sharedInstance().reloadTransactionsMenuAction()
        }
    }
    
    @objc func showHelp(_ sender: Any) {
        if let url = URL(string: "https://gitlab.com/amsss900-group/amsss900-project/-/blob/main/README.md") {
            UIApplication.shared.open(url, options: [:], completionHandler: nil)
        }
    }
    
    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
        if action == #selector(showHelp(_:)) {
            return true
        } else {
            return super.canPerformAction(action, withSender: sender)
        }
    }
}


================================================
FILE: ./ios/Components/EventEmitter.swift
================================================

import Foundation
import React

@objc(EventEmitter)
class EventEmitter: RCTEventEmitter {
    static let sharedInstance = EventEmitter()
    
    override class func requiresMainQueueSetup() -> Bool {
        return true
    }
    
    @objc static func shared() -> EventEmitter {
        return sharedInstance
    }
    
    override func supportedEvents() -> [String]! {
        return ["onUserActivityOpen"]
    }
    
    @objc func sendUserActivity(_ userInfo: [String: Any]) {
        sendEvent(withName: "onUserActivityOpen", body: userInfo)
    }
    
    @objc func getMostRecentUserActivity(_ resolve: @escaping RCTPromiseResolveBlock,
                                           rejecter reject: RCTPromiseRejectBlock) {
        if let defaults = UserDefaults(suiteName: "group.com.malinwallet.app") {
            resolve(defaults.value(forKey: "onUserActivityOpen"))
        } else {
            resolve(nil)
        }
    }
}


================================================
FILE: ./ios/Components/WidgetHelper.swift
================================================

import WidgetKit

@objc class WidgetHelper: NSObject {
    @objc static func reloadAllWidgets() {
      if #available(iOS 14.0, *) {
        WidgetCenter.shared.reloadAllTimelines()
      } else {
        // Fallback on earlier versions
      }
    }
}


================================================
FILE: ./ios/Components/SegmentedControl/CustomSegmentedControl.swift
================================================

import UIKit
import React

@objc(CustomSegmentedControl)
class CustomSegmentedControl: UISegmentedControl {
    @objc var onChangeEvent: RCTDirectEventBlock?

    @objc var values: [String] = [] {
        didSet {
            removeAllSegments()
            for (index, title) in values.enumerated() {
                insertSegment(withTitle: title, at: index, animated: false)
            }
        }
    }

    @objc var selectedIndex: NSNumber = 0 {
        didSet {
            self.selectedSegmentIndex = selectedIndex.intValue
        }
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        addTarget(self, action: #selector(onChange(_:)), for: .valueChanged)
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        addTarget(self, action: #selector(onChange(_:)), for: .valueChanged)
    }

    @objc func onChange(_ sender: UISegmentedControl) {
        onChangeEvent?(["selectedIndex": sender.selectedSegmentIndex])
    }
}

@objc(CustomSegmentedControlManager)
class CustomSegmentedControlManager: RCTViewManager {
    override func view() -> UIView! {
        return CustomSegmentedControl(frame: .zero)
    }

    override class func requiresMainQueueSetup() -> Bool {
        return true
    }
}


================================================
FILE: ./ios/ci_scripts/ci_post_clone.sh
================================================

#!/bin/zsh

echo "===== Installing CocoaPods ====="
export HOMEBREW_NO_INSTALL_CLEANUP=TRUE
brew install cocoapods
echo "CocoaPods installation complete."

echo "===== Installing Node.js ====="
brew install node@20
echo "Node.js installation complete."

# Configure environment to use node@20
echo "Configuring environment to use node@20..."
echo 'export PATH="/usr/local/opt/node@20/bin:$PATH"' >> ~/.zshrc
export PATH="/usr/local/opt/node@20/bin:$PATH"

echo 'export LDFLAGS="-L/usr/local/opt/node@20/lib"' >> ~/.zshrc
export LDFLAGS="-L/usr/local/opt/node@20/lib"

echo 'export CPPFLAGS="-I/usr/local/opt/node@20/include"' >> ~/.zshrc
export CPPFLAGS="-I/usr/local/opt/node@20/include"
echo "Configuration complete."

# Install dependencies using npm
echo "===== Running npm ci ====="
npm ci | tee npm-ci-log.txt
npm prune --production | tee npm-prune-log.txt
echo "npm ci complete. Full log output in npm-ci-log.txt and npm-prune-log.txt"

echo "===== Running pod install ====="
cd ios
pod install | tee pod-install-log.txt
echo "pod install complete. Full log output in pod-install-log.txt"
cd ..

echo "===== Installation and Setup Complete ====="


================================================
FILE: ./ios/MalinWalletWatch/ComplicationController.swift
================================================

//
//  ComplicationController.swift
//  T WatchKit Extension
//
//  Created by Marcos Rodriguez on 8/24/19.
//  Copyright  2019 Marcos Rodriguez. All rights reserved.
//

import ClockKit


class ComplicationController: NSObject, CLKComplicationDataSource {
  
  private let groupUserDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)
  // MARK: - Timeline Configuration
  
  func getSupportedTimeTravelDirections(for complication: CLKComplication, withHandler handler: @escaping (CLKComplicationTimeTravelDirections) -> Void) {
    handler([])
  }
  
  func getTimelineStartDate(for complication: CLKComplication, withHandler handler: @escaping (Date?) -> Void) {
    handler(nil)
  }
  
  @available(watchOSApplicationExtension 7.0, *)
  func complicationDescriptors() async -> [CLKComplicationDescriptor] {
    return  [CLKComplicationDescriptor(
      identifier: "com.malinwallet.app",
      displayName: "Market Price",
      supportedFamilies: CLKComplicationFamily.allCases)]
  }
  
  func getTimelineEndDate(for complication: CLKComplication, withHandler handler: @escaping (Date?) -> Void) {
    handler(nil)
  }
  
  func getPrivacyBehavior(for complication: CLKComplication, withHandler handler: @escaping (CLKComplicationPrivacyBehavior) -> Void) {
    handler(.showOnLockScreen)
  }
  
  // MARK: - Timeline Population
  
  func getCurrentTimelineEntry(
    for complication: CLKComplication,
    withHandler handler: @escaping (CLKComplicationTimelineEntry?) -> Void)
  {
    let marketData: WidgetDataStore? = groupUserDefaults?.codable(forKey: MarketData.string)
    let entry: CLKComplicationTimelineEntry
    let date: Date
    let valueLabel: String
    let valueSmallLabel: String
    let currencySymbol: String
    let timeLabel: String
    if let price = marketData?.formattedRateForComplication, let priceAbbreviated = marketData?.formattedRateForSmallComplication, let marketDatadata = marketData?.date, let lastUpdated = marketData?.formattedDate {
      date = marketDatadata
      valueLabel = price
      timeLabel = lastUpdated
      valueSmallLabel = priceAbbreviated
      if let preferredFiatCurrency = groupUserDefaults?.string(forKey: "preferredCurrency"), let preferredFiatUnit = fiatUnit(currency: preferredFiatCurrency) {
        currencySymbol = preferredFiatUnit.symbol
      } else {
        currencySymbol = fiatUnit(currency: "USD")!.symbol
      }
    } else {
      valueLabel = "--"
      timeLabel = "--"
      valueSmallLabel = "--"
      currencySymbol = fiatUnit(currency: "USD")!.symbol
      date = Date()
    }
    
    let line2Text = CLKSimpleTextProvider(text:currencySymbol)
    let line1SmallText = CLKSimpleTextProvider(text: valueSmallLabel)
    
    switch complication.family {
    case .circularSmall:
      let template = CLKComplicationTemplateCircularSmallStackText()
      template.line1TextProvider = line1SmallText
      template.line2TextProvider = line2Text
      entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
      handler(entry)
    case .utilitarianSmallFlat:
      let template = CLKComplicationTemplateUtilitarianSmallFlat()
      if #available(watchOSApplicationExtension 6.0, *) {
        template.textProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueSmallLabel)
      } else {
        handler(nil)
      }
      entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
      handler(entry)
      
    case .utilitarianSmall:
      let template = CLKComplicationTemplateUtilitarianSmallRingImage()
      template.imageProvider = CLKImageProvider(onePieceImage: UIImage(named: "Complication/Utilitarian")!)
      entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
      handler(entry)
    case .graphicCircular:
      if #available(watchOSApplicationExtension 6.0, *) {
        let template = CLKComplicationTemplateGraphicCircularStackText()
        template.line1TextProvider = line1SmallText
        template.line2TextProvider = line2Text
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    case .modularSmall:
      let template = CLKComplicationTemplateModularSmallStackText()
      template.line1TextProvider = line1SmallText
      template.line2TextProvider = line2Text
      entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
      handler(entry)
    case .graphicCorner:
      let template = CLKComplicationTemplateGraphicCornerStackText()
      if #available(watchOSApplicationExtension 6.0, *) {
        template.outerTextProvider = CLKTextProvider(format: "%@", valueSmallLabel)
        template.innerTextProvider = CLKTextProvider(format: "%@", currencySymbol)
      } else {
        handler(nil)
      }
      entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
      handler(entry)
    case .graphicBezel:
      let template = CLKComplicationTemplateGraphicBezelCircularText()
      if #available(watchOSApplicationExtension 6.0, *) {
        template.textProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueSmallLabel)
        let imageProvider = CLKFullColorImageProvider(fullColorImage: UIImage(named: "Complication/Graphic Bezel")!)
        let circularTemplate = CLKComplicationTemplateGraphicCircularImage()
        circularTemplate.imageProvider = imageProvider
        template.circularTemplate = circularTemplate
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    case .utilitarianLarge:
      if #available(watchOSApplicationExtension 7.0, *) {
        let textProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueLabel)
        let template = CLKComplicationTemplateUtilitarianLargeFlat(textProvider: textProvider)
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    case .modularLarge:
      let template = CLKComplicationTemplateModularLargeStandardBody()
      if #available(watchOSApplicationExtension 6.0, *) {
        template.headerTextProvider =  CLKTextProvider(format: "Bitcoin Price")
        template.body1TextProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueLabel)
        template.body2TextProvider = CLKTextProvider(format: "at %@", timeLabel)
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    case .extraLarge:
      let template = CLKComplicationTemplateExtraLargeStackText()
      if #available(watchOSApplicationExtension 6.0, *) {
        template.line1TextProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueLabel)
        template.line2TextProvider = CLKTextProvider(format: "at %@", timeLabel)
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    case .graphicRectangular:
      let template = CLKComplicationTemplateGraphicRectangularStandardBody()
      if #available(watchOSApplicationExtension 6.0, *) {
        template.headerTextProvider =  CLKTextProvider(format: "Bitcoin Price")
        template.body1TextProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueLabel)
        template.body2TextProvider = CLKTextProvider(format: "at %@", timeLabel)
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    case .graphicExtraLarge:
      if #available(watchOSApplicationExtension 7.0, *) {
        let template = CLKComplicationTemplateGraphicExtraLargeCircularStackText()
        template.line1TextProvider = CLKTextProvider(format: "%@%@", currencySymbol, valueLabel)
        template.line1TextProvider = CLKTextProvider(format: "at %@", timeLabel)
        entry = CLKComplicationTimelineEntry(date: date, complicationTemplate: template)
        handler(entry)
      } else {
        handler(nil)
      }
    @unknown default:
      fatalError()
    }
  }
  
}

func getTimelineEntries(for complication: CLKComplication, before date: Date, limit: Int, withHandler handler: @escaping ([CLKComplicationTimelineEntry]?) -> Void) {
  // Call the handler with the timeline entries prior to the given date
  handler(nil)
}

func getTimelineEntries(for complication: CLKComplication, after date: Date, limit: Int, withHandler handler: @escaping ([CLKComplicationTimelineEntry]?) -> Void) {
  // Call the handler with the timeline entries after to the given date
  handler(nil)
}

// MARK: - Placeholder Templates

func getLocalizableSampleTemplate(for complication: CLKComplication, withHandler handler: @escaping (CLKComplicationTemplate?) -> Void) {
  // This method will be called once per supported complication, and the results will be cached
  let line1Text = CLKSimpleTextProvider(text:"46 K")
  let line2Text = CLKSimpleTextProvider(text:"$")
  let lineTimeText = CLKSimpleTextProvider(text:"3:40 PM")

  switch complication.family {
  case .circularSmall:
    let template = CLKComplicationTemplateCircularSmallStackText()
    template.line1TextProvider = line1Text
    template.line2TextProvider = line2Text
    handler(template)
  case .utilitarianSmallFlat:
    let template = CLKComplicationTemplateUtilitarianSmallFlat()
    if #available(watchOSApplicationExtension 6.0, *) {
      template.textProvider = CLKTextProvider(format: "%@", "$46,134")
    } else {
      handler(nil)
    }
    handler(template)
  case .utilitarianSmall:
    let template = CLKComplicationTemplateUtilitarianSmallRingImage()
    template.imageProvider = CLKImageProvider(onePieceImage: UIImage(named: "Complication/Utilitarian")!)
    handler(template)
  case .graphicCircular:
    if #available(watchOSApplicationExtension 6.0, *) {
      let template = CLKComplicationTemplateGraphicCircularStackText()
      template.line1TextProvider = line1Text
      template.line2TextProvider = line2Text
      handler(template)
    } else {
      handler(nil)
    }
  case .graphicCorner:
    let template = CLKComplicationTemplateGraphicCornerStackText()
    if #available(watchOSApplicationExtension 6.0, *) {
      template.outerTextProvider = CLKTextProvider(format: "46,134")
      template.innerTextProvider = CLKTextProvider(format: "$")
    } else {
      handler(nil)
    }
    handler(template)
  case .modularSmall:
    let template = CLKComplicationTemplateModularSmallStackText()
    template.line1TextProvider = line1Text
    template.line2TextProvider = line2Text
    handler(template)
  case .utilitarianLarge:
    if #available(watchOSApplicationExtension 7.0, *) {
      let textProvider = CLKTextProvider(format: "%@%@", "$", "46,000")
      let template = CLKComplicationTemplateUtilitarianLargeFlat(textProvider: textProvider)
      handler(template)
    } else {
      handler(nil)
    }
  case .graphicBezel:
    let template = CLKComplicationTemplateGraphicBezelCircularText()
    if #available(watchOSApplicationExtension 6.0, *) {
      template.textProvider = CLKTextProvider(format: "%@%@", "$S", "46,000")
      let imageProvider = CLKFullColorImageProvider(fullColorImage: UIImage(named: "Complication/Graphic Bezel")!)
      let circularTemplate = CLKComplicationTemplateGraphicCircularImage()
      circularTemplate.imageProvider = imageProvider
      template.circularTemplate = circularTemplate
      handler(template)
    } else {
      handler(nil)
    }
  case .modularLarge:
    let template = CLKComplicationTemplateModularLargeStandardBody()
    if #available(watchOSApplicationExtension 6.0, *) {
      template.headerTextProvider =  CLKTextProvider(format: "Bitcoin Price")
      template.body1TextProvider = CLKTextProvider(format: "%@%@", "$S", "46,000")
      template.body2TextProvider = lineTimeText
      handler(template)
    } else {
      handler(nil)
    }
  case .extraLarge:
    let template = CLKComplicationTemplateExtraLargeStackText()
    template.line1TextProvider = line1Text
    template.line2TextProvider = lineTimeText
    handler(template)
  case .graphicRectangular:
    let template = CLKComplicationTemplateGraphicRectangularStandardBody()
    if #available(watchOSApplicationExtension 6.0, *) {
      template.headerTextProvider =  CLKTextProvider(format: "Bitcoin Price")
      template.body1TextProvider = CLKTextProvider(format: "%@%@", "$S", "46,000")
      template.body2TextProvider = CLKTextProvider(format: "%@", Date().description)
      handler(template)
    } else {
      handler(nil)
    }
  case .graphicExtraLarge:
    if #available(watchOSApplicationExtension 7.0, *) {
      let template = CLKComplicationTemplateGraphicExtraLargeCircularStackText()
      template.line1TextProvider = line1Text
      template.line2TextProvider = line2Text
      handler(template)
    } else {
      handler(nil)
    }
  @unknown default:
    fatalError()
  }
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/TransactionTableRow.swift
================================================

//
//  TransactionTableRow.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/10/19.

//

import WatchKit

class TransactionTableRow: NSObject {
  
  @IBOutlet private weak var transactionAmountLabel: WKInterfaceLabel!
  @IBOutlet private weak var transactionMemoLabel: WKInterfaceLabel!
  @IBOutlet private weak var transactionTimeLabel: WKInterfaceLabel!
  @IBOutlet private weak var transactionTypeImage: WKInterfaceImage!

  static let identifier: String = "TransactionTableRow"
  
  var amount: String = "" {
    willSet {
      transactionAmountLabel.setText(newValue)
    }
  }
  
  var memo: String = "" {
    willSet {
      transactionMemoLabel.setText(newValue)
    }
  }
  
  var time: String = "" {
    willSet {
      if type == .pending {
        transactionTimeLabel.setText("Pending...")
      } else {
        transactionTimeLabel.setText(newValue)
      }
    }
  }
  
  var type: TransactionType = .pending {
    willSet {
      if newValue == .pending {
        transactionTypeImage.setImage(UIImage(named: "pendingConfirmation"))
      } else if newValue == .received {
        transactionTypeImage.setImage(UIImage(named: "receivedArrow"))
      } else if newValue == .sent {
        transactionTypeImage.setImage(UIImage(named: "sentArrow"))
      } else {
        transactionTypeImage.setImage(nil)
      }
    }
  }
  
}

// TransactionTableRow extension for configuration
 extension TransactionTableRow {
   func configure(with transaction: Transaction) {
     amount = "\(transaction.amount)"
     
     type = transaction.type
     
     memo = transaction.memo
     
     let formatter = DateFormatter()
     formatter.dateStyle = .short
     formatter.timeStyle = .short
     time = formatter.string(from: transaction.time)
   }
 }


================================================
FILE: ./ios/MalinWalletWatch/Objects/Transaction.swift
================================================

import Foundation

/// Represents a transaction with various properties including its type.
/// Conforms to `Codable` and `Identifiable` for encoding/decoding and unique identification.
struct Transaction: Codable, Identifiable, Equatable {
    let id: UUID
    let time: Date
    let memo: String
    let type: TransactionType
    let amount: Decimal
    
    /// Initializes a new Transaction instance.
    /// - Parameters:
    ///   - id: Unique identifier for the transaction. Defaults to a new UUID.
    ///   - time: Timestamp of the transaction.
    ///   - memo: A memo or note associated with the transaction.
    ///   - type: The type of the transaction, defined by `TransactionType`.
    ///   - amount: The amount involved in the transaction as a string.
    init(id: UUID = UUID(), time: Date, memo: String, type: TransactionType, amount: Decimal) {
        self.id = id
        self.time = time
        self.memo = memo
        self.type = type
        self.amount = amount
    }
}

extension Transaction {
    static var mock: Transaction {
        Transaction(
            time: Date(timeIntervalSince1970: 1714398896), // 2024-04-27T12:34:56Z
            memo: "Mock Transaction",
            type: .sent,
            amount: Decimal(string: "-0.001")!
        )
    }

    static var mockTransactions: [Transaction] {
        [
            .mock,
            Transaction(
                time: Date(timeIntervalSince1970: 1714308153), // 2024-04-26T11:22:33Z
                memo: "Another Mock Transaction",
                type: .received,
                amount: Decimal(string: "0.002")!
            ),
            Transaction(
                time: Date(timeIntervalSince1970: 1714217482), // 2024-04-25T10:11:22Z
                memo: "Third Mock Transaction",
                type: .pending,
                amount: Decimal.zero
            )
        ]
    }
    
func formattedAmount(for unit: BitcoinUnit) -> String {
        return amount.formatted(as: unit)
    }
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/ReceiveInterfaceMode.swift
================================================

//
//  ReceiveInterfaceMode.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 6/15/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

enum ReceiveInterfaceMode {
  case Address, QRCode
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/TransactionType.swift
================================================

//
//  TransactionType.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/20/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//


// Models/TransactionType.swift

import Foundation

/// Represents the various types of transactions available in the application.
/// Conforms to `String`, `Codable`, `Equatable`, and `CustomStringConvertible` for easy encoding/decoding, comparisons, and descriptions.
enum TransactionType: Codable, Equatable {
    // Transaction state
    case pending
    case expired
    
    // Transaction type
    case onchain
    case offchain
    
    // Fallback
    case unknown(String) // For any unknown or future transaction types
    
    case sent
    case received

    // MARK: - Coding Keys
    enum CodingKeys: String, CodingKey {
        case rawValue = "type"
    }

    // MARK: - Decodable Conformance
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let typeString = try container.decode(String.self, forKey: .rawValue)
        self = TransactionType.fromRawString(typeString)
    }

    // MARK: - Encodable Conformance
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.rawString, forKey: .rawValue)
    }

    static func fromRawString(_ typeString: String) -> TransactionType {
        switch typeString.lowercased() {
        case "sent":
            return .sent
        case "received":
            return .received
        case "pending":
            return .pending
        case "bitcoind_tx":
            return .onchain
        case "paid_invoice":
            return .offchain
        default:
            return .unknown(typeString)
        }
    }

    // MARK: - Computed Property for Raw String
    /// Returns the raw string associated with the `TransactionType`.
    var rawString: String {
        switch self {
        case .sent:
            return "sent"
        case .received:
            return "received"
        case .pending:
            return "pending"
        case .onchain:
            return "bitcoind_tx"
        case .offchain:
            return "paid_invoice"
        case .unknown(let typeString):
            return typeString
        case .expired:
          return "expired"
        }
    }
}

// MARK: - CustomStringConvertible Conformance
extension TransactionType: CustomStringConvertible {
    /// Provides a user-friendly description of the `TransactionType`.
    var description: String {
        switch self {
        case .sent:
            return "Sent"
        case .received:
            return "Received"
        case .pending:
            return "pending"
        case .onchain:
            return "Onchain"
        case .offchain:
            return "Offchain"
        case .unknown(let typeString):
            return typeString
        case .expired:
            return "Expired"
        }
    }
}

// MARK: - Computed Properties for Categorizing Transaction Types
extension TransactionType {
    var isIncoming: Bool {
        switch self {
        case .received:
            return true
        default:
            return false
        }
    }

    var isOutgoing: Bool {
        switch self {
        case .sent:
            return true
        default:
            return false
        }
    }

    var isPending: Bool {
        switch self {
        case .pending:
            return true
        default:
            return false
        }
    }
    
    static var mockSent: TransactionType {
      return .sent
    }

    static var mockReceived: TransactionType {
      return .received
    }
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/WalletType.swift
================================================

//
//  WalletType.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 11/20/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//


import Foundation

/// Represents the various types of wallets available in the application.
/// Conforms to `Codable` and `Equatable`, handling encoding and decoding for known and unknown types.
enum WalletType: Codable, Equatable {
    case hdSegwitP2SHWallet
    case hdSegwitBech32Wallet
    case segwitBech32Wallet
    case watchOnlyWallet
    case legacyWallet
    case hdLegacyP2PKHWallet
    case hdLegacyBreadWallet
    case multisigHdWallet
    case lightningCustodianWallet
    case aezeedWallet
    case defaultGradients

    // MARK: - Coding Keys
    enum CodingKeys: String, CodingKey {
        case rawValue = "type"
    }

    // MARK: - Decodable Conformance
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let typeString = try container.decode(String.self, forKey: .rawValue)

        switch typeString {
        case "HDsegwitP2SH":
            self = .hdSegwitP2SHWallet
        case "HDsegwitBech32":
            self = .hdSegwitBech32Wallet
        case "segwitBech32":
            self = .segwitBech32Wallet
        case "watchOnly":
            self = .watchOnlyWallet
        case "legacy":
            self = .legacyWallet
        case "HDLegacyP2PKH":
            self = .hdLegacyP2PKHWallet
        case "HDLegacyBreadwallet":
            self = .hdLegacyBreadWallet
        case "HDmultisig":
            self = .multisigHdWallet
        case "LightningCustodianWallet":
            self = .lightningCustodianWallet
        case "HDAezeedWallet":
            self = .aezeedWallet
        default:
            self = .defaultGradients
        }
    }

    // MARK: - Encodable Conformance
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .hdSegwitP2SHWallet:
            try container.encode("HDsegwitP2SH", forKey: .rawValue)
        case .hdSegwitBech32Wallet:
            try container.encode("HDsegwitBech32", forKey: .rawValue)
        case .segwitBech32Wallet:
            try container.encode("segwitBech32", forKey: .rawValue)
        case .watchOnlyWallet:
            try container.encode("watchOnly", forKey: .rawValue)
        case .legacyWallet:
            try container.encode("legacy", forKey: .rawValue)
        case .hdLegacyP2PKHWallet:
            try container.encode("HDLegacyP2PKH", forKey: .rawValue)
        case .hdLegacyBreadWallet:
            try container.encode("HDLegacyBreadwallet", forKey: .rawValue)
        case .multisigHdWallet:
            try container.encode("HDmultisig", forKey: .rawValue)
        case .lightningCustodianWallet:
            try container.encode("LightningCustodianWallet", forKey: .rawValue)
        case .aezeedWallet:
            try container.encode("HDAezeedWallet", forKey: .rawValue)
        case .defaultGradients:
            try container.encode("DefaultGradients", forKey: .rawValue)
        }
    }

    // MARK: - Custom Initializer from Raw String
    /// Initializes a `WalletType` from a raw string.
    /// - Parameter rawString: The raw string representing the wallet type.
    init(rawString: String) {
        self = WalletType.fromRawString(rawString)
    }

    static func fromRawString(_ typeString: String) -> WalletType {
        switch typeString {
        case "HDsegwitP2SH":
            return .hdSegwitP2SHWallet
        case "HDsegwitBech32":
            return .hdSegwitBech32Wallet
        case "segwitBech32":
            return .segwitBech32Wallet
        case "watchOnly":
            return .watchOnlyWallet
        case "legacy":
            return .legacyWallet
        case "HDLegacyP2PKH":
            return .hdLegacyP2PKHWallet
        case "HDLegacyBreadwallet":
            return .hdLegacyBreadWallet
        case "HDmultisig":
            return .multisigHdWallet
        case "LightningCustodianWallet":
            return .lightningCustodianWallet
        case "HDAezeedWallet":
            return .aezeedWallet
        case "DefaultGradients":
            return .defaultGradients
        default:
            return .defaultGradients
        }
    }

    // MARK: - Computed Property for Raw String
    /// Returns the raw string associated with the `WalletType`.
    var rawString: String {
        switch self {
        case .hdSegwitP2SHWallet:
            return "HDsegwitP2SH"
        case .hdSegwitBech32Wallet:
            return "HDsegwitBech32"
        case .segwitBech32Wallet:
            return "segwitBech32"
        case .watchOnlyWallet:
            return "watchOnly"
        case .legacyWallet:
            return "legacy"
        case .hdLegacyP2PKHWallet:
            return "HDLegacyP2PKH"
        case .hdLegacyBreadWallet:
            return "HDLegacyBreadwallet"
        case .multisigHdWallet:
            return "HDmultisig"
        case .lightningCustodianWallet:
            return "LightningCustodianWallet"
        case .aezeedWallet:
            return "HDAezeedWallet"
        case .defaultGradients:
            return "DefaultGradients"
        }
    }
}

// MARK: - CustomStringConvertible Conformance
extension WalletType: CustomStringConvertible {
    /// Provides a user-friendly description of the `WalletType`.
    var description: String {
        switch self {
        case .hdSegwitP2SHWallet:
            return "HD Segwit P2SH Wallet"
        case .hdSegwitBech32Wallet:
            return "HD Segwit Bech32 Wallet"
        case .segwitBech32Wallet:
            return "Segwit Bech32 Wallet"
        case .watchOnlyWallet:
            return "Watch Only Wallet"
        case .legacyWallet:
            return "Legacy Wallet"
        case .hdLegacyP2PKHWallet:
            return "HD Legacy P2PKH Wallet"
        case .hdLegacyBreadWallet:
            return "HD Legacy Bread Wallet"
        case .multisigHdWallet:
            return "Multisig HD Wallet"
        case .lightningCustodianWallet:
            return "Lightning Custodian Wallet"
        case .aezeedWallet:
            return "Aezeed Wallet"
        case .defaultGradients:
            return "Default Gradients"
        }
    }
}

extension WalletType {
    static var mockType: WalletType {
        return .hdSegwitBech32Wallet
    }
}

================================================
FILE: ./ios/MalinWalletWatch/Objects/WalletInformation.swift
================================================

//
//  WalletInformation.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/10/19.

//

import WatchKit

class WalletInformation: NSObject {
  
  @IBOutlet weak var walletBalanceLabel: WKInterfaceLabel!
  @IBOutlet private weak var walletNameLabel: WKInterfaceLabel!
  @IBOutlet private weak var walletGroup: WKInterfaceGroup!
  static let identifier: String = "WalletInformation"
  let type: Wallet? = nil
  
  var name: String = "" {
    willSet {
      walletNameLabel.setText(newValue)
    }
  }
  
  var balance: String = "" {
    willSet {
      walletBalanceLabel.setText(newValue)
    }
  }
  
  
  
}

// WalletInformation extension for configuration
extension WalletInformation {
  func configure(with wallet: Wallet) {
    walletBalanceLabel.setHidden(wallet.hideBalance)
    name = wallet.label
    balance = wallet.hideBalance ? "" : wallet.balance
  }
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/WalletGradient.swift
================================================

import WatchKit

// Extension to support hex color initialization for watchOS
extension UIColor {
    convenience init(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        Scanner(string: hexSanitized).scanHexInt64(&rgb)
        
        let red = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
        let green = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
        let blue = CGFloat(rgb & 0x0000FF) / 255.0
        
        self.init(red: red, green: green, blue: blue, alpha: 1.0)
    }
}

struct WalletGradient {
  
  static let hdSegwitP2SHWallet: [UIColor] = [
    UIColor(hex: "#007AFF"),
    UIColor(hex: "#0040FF")
  ]
  
  static let hdSegwitBech32Wallet: [UIColor] = [
    UIColor(hex: "#6CD9FC"),
    UIColor(hex: "#44BEE5")
  ]
  
  static let segwitBech32Wallet: [UIColor] = [
    UIColor(hex: "#6CD9FC"),
    UIColor(hex: "#44BEE5")
  ]
  
  static let watchOnlyWallet: [UIColor] = [
    UIColor(hex: "#474646"),
    UIColor(hex: "#282828")
  ]
  
  static let legacyWallet: [UIColor] = [
    UIColor(hex: "#37E8C0"),
    UIColor(hex: "#15BE98")
  ]
  
  static let hdLegacyP2PKHWallet: [UIColor] = [
    UIColor(hex: "#FD7478"),
    UIColor(hex: "#E73B40")
  ]
  
  static let hdLegacyBreadWallet: [UIColor] = [
    UIColor(hex: "#FE6381"),
    UIColor(hex: "#F99C42")
  ]
  
  static let multisigHdWallet: [UIColor] = [
    UIColor(hex: "#1CE6EB"),
    UIColor(hex: "#296FC5"),
    UIColor(hex: "#3500A2")
  ]
  
  static let defaultGradients: [UIColor] = [
    UIColor(hex: "#B770F6"),
    UIColor(hex: "#9013FE")
  ]
  
  static let lightningCustodianWallet: [UIColor] = [
    UIColor(hex: "#F1AA07"),
    UIColor(hex: "#FD7E37")
  ]
  
  static let aezeedWallet: [UIColor] = [
    UIColor(hex: "#8584FF"),
    UIColor(hex: "#5351FB")
  ]
  
  // MARK: - Gradient Layer Creation for WatchKit
  
  /// Creates gradient colors suitable for WatchKit interface
  /// - Parameters:
  ///   - type: The wallet type
  /// - Returns: An array of UIColors for the gradient
  static func gradientColorsFor(type: WalletType) -> [UIColor] {
    return gradientsFor(type: type)
  }
  
  /// Gets the colors for a WKInterfaceGroup gradient
  /// - Parameter type: The wallet type
  /// - Returns: Colors array suitable for setting on WKInterfaceGroup
  static func getWatchKitGroupColors(for type: WalletType) -> [Any] {
    return gradientsFor(type: type).map { $0.cgColor as Any }
  }
  
  // MARK: - Gradient Selection
  
  static func gradientsFor(type: WalletType) -> [UIColor] {
    switch type {
    case .watchOnlyWallet:
      return WalletGradient.watchOnlyWallet
    case .legacyWallet:
      return WalletGradient.legacyWallet
    case .hdLegacyP2PKHWallet:
      return WalletGradient.hdLegacyP2PKHWallet
    case .hdLegacyBreadWallet:
      return WalletGradient.hdLegacyBreadWallet
    case .hdSegwitP2SHWallet:
      return WalletGradient.hdSegwitP2SHWallet
    case .hdSegwitBech32Wallet:
      return WalletGradient.hdSegwitBech32Wallet
    case .segwitBech32Wallet:
      return WalletGradient.segwitBech32Wallet
    case .multisigHdWallet:
      return WalletGradient.multisigHdWallet
    case .aezeedWallet:
      return WalletGradient.aezeedWallet
    case .lightningCustodianWallet:
      return WalletGradient.lightningCustodianWallet
    default:
      return WalletGradient.defaultGradients
    }
  }
  
  // MARK: - Header Color Selection
  
  /// Returns the primary color for headers based on the wallet type.
  /// Typically, the first color of the gradient is used for headers.
  /// - Parameter type: The type of the wallet.
  /// - Returns: A `UIColor` representing the header color.
  static func headerColorFor(type: WalletType) -> UIColor {
    let gradient = gradientsFor(type: type)
    return gradient.first ?? UIColor.black // Defaults to black if gradient is empty
  }
  
  static func imageStringFor(type: WalletType) -> String {
    switch type {
    case .hdSegwitP2SHWallet:
      return "wallet"
    case .segwitBech32Wallet:
      return "walletHDSegwitNative"
    case .hdSegwitBech32Wallet:
      return "walletHD"
    case .watchOnlyWallet:
      return "walletWatchOnly"
    case .lightningCustodianWallet:
      return "walletLightningCustodial"
    case .multisigHdWallet:
      return "watchMultisig"
    case .legacyWallet:
      return "walletLegacy"
    case .hdLegacyP2PKHWallet:
      return "walletHDLegacyP2PKH"
    case .hdLegacyBreadWallet:
      return "walletHDLegacyBread"
    case .aezeedWallet:
      return "walletAezeed"
    case .defaultGradients:
      return "walletLegacy"
    }
  }
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/WatchDataSource.swift
================================================

// Data/WatchDataSource.swift

import Foundation
import WatchConnectivity
import Security
import Combine
import ClockKit

struct NotificationName {
  static let dataUpdated = Notification.Name(rawValue: "Notification.WalletDataSource.Updated")
}
struct Notifications {
  static let dataUpdated = Notification(name: NotificationName.dataUpdated)
}

/// Represents the group user defaults keys.
/// Ensure these match the keys used in your iOS app for sharing data.

/// Handles WatchConnectivity and data synchronization between iOS and Watch apps.
class WatchDataSource: NSObject, ObservableObject, WCSessionDelegate {
    // MARK: - Singleton Instance
  
  static func postDataUpdatedNotification() {
      NotificationCenter.default.post(Notifications.dataUpdated)
    }

    
    static let shared = WatchDataSource()
    
    // MARK: - Published Properties
    
    /// The list of wallets to be displayed on the Watch app.
    @Published var wallets: [Wallet] = []
    
    @Published var isDataLoaded: Bool = false
    
    // MARK: - Private Properties
    
    private let groupUserDefaults = UserDefaults(suiteName: UserDefaultsGroupKey.GroupName.rawValue)
    private let keychain = KeychainHelper.shared
    private let session: WCSession
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Initializer
    
    private override init() {
        guard WCSession.isSupported() else {
            print("WCSession is not supported on this device.")
            self.session = WCSession.default
            super.init()
            return
        }
        self.session = WCSession.default
        super.init()
        
        // Set delegate and setup bindings before trying to load data
        self.session.delegate = self
        setupBindings()
        
        // Load cached data from keychain to show something while waiting for fresh data
        loadKeychainData()
    }
    
    // MARK: - Public Methods
    
    /// Starts the WatchConnectivity session.
    func startSession() {
        if session.activationState != .activated {
            print("[WatchKit 2] Activating WCSession...")
            session.activate()
        } else {
            print("[WatchKit 2] WCSession is already activated: \(session.activationState.rawValue)")
            // Even if activated, attempt to request data
            if session.isReachable {
                requestDataFromiOS()
            }
        }
    }
    
    /// Deactivates the WatchConnectivity session (if needed).
    /// Note: WCSession does not provide a deactivate method, but you can handle any necessary cleanup here.
    func deactivateSession() {
        // Handle any necessary cleanup here.
    }
    
    // MARK: - Data Binding
    
    /// Sets up bindings to observe changes to `wallets` and perform actions accordingly.
    private func setupBindings() {
        // Observe changes to wallets and perform actions if needed.
        $wallets
            .sink { [weak self] updatedWallets in
                self?.saveWalletsToKeychain()
                self?.reloadComplications()
            }
            .store(in: &cancellables)
    }
    
    // MARK: - Keychain Operations
    
    /// Loads wallets data from the Keychain asynchronously.
    private func loadKeychainData() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            guard let existingData = self.keychain.retrieve(service: UserDefaultsGroupKey.WatchAppBundleIdentifier.rawValue, account: UserDefaultsGroupKey.BundleIdentifier.rawValue),
                  let decodedWallets = try? JSONDecoder().decode([Wallet].self, from: existingData) else {
                print("No existing wallets data found in Keychain.")
                return
            }
            
            // Filter wallets to include only on-chain wallets.
            let onChainWallets = decodedWallets.filter { $0.chain == .onchain }
            
            DispatchQueue.main.async {
                if onChainWallets != self.wallets {
                    self.wallets = onChainWallets
                    print("Loaded \(onChainWallets.count) on-chain wallets from Keychain.")
                }
                self.isDataLoaded = true
            }
        }
    }
    
    /// Saves the current wallets data to the Keychain asynchronously.
    private func saveWalletsToKeychain() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            // Save to keychain regardless of session state
            guard let encodedData = try? JSONEncoder().encode(self.wallets) else {
                print("Failed to encode wallets.")
                return
            }
            let success = self.keychain.save(encodedData, service: UserDefaultsGroupKey.WatchAppBundleIdentifier.rawValue, account: UserDefaultsGroupKey.BundleIdentifier.rawValue)
            if success {
                print("Successfully saved wallets to Keychain.")
            } else {
                print("Failed to save wallets to Keychain.")
            }
        }
    }
    
    // MARK: - WatchConnectivity Methods
    
    /// Handles the activation completion of the WCSession.
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        if let error = error {
            print("[WatchKit 2] WCSession activation failed with error: \(error.localizedDescription)")
        } else {
            print("[WatchKit 2] WCSession activated with state: \(activationState.rawValue)")
            
            if activationState == .activated {
                DispatchQueue.main.async {
                    self.requestDataFromiOS()
                }
            }
        }
    }
    
    /// Handles received messages from the iOS app.
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        processReceivedData(message)
    }
    
    /// Handles received application context updates from the iOS app.
    func session(_ session: WCSession, didReceiveApplicationContext applicationContext: [String : Any]) {
        print("[WatchKit 2] Received application context: \(applicationContext.keys)")
        if applicationContext.isEmpty { return }
        
        DispatchQueue.main.async {
            self.processReceivedData(applicationContext)
            // Post notification that data was updated
            WatchDataSource.postDataUpdatedNotification()
        }
    }
    
    /// Requests current data from the iOS app
    func requestDataFromiOS() {
        guard session.activationState == .activated else {
            print("[WatchKit 2] Cannot request data: WCSession not activated (state: \(session.activationState.rawValue))")
            startSession() // Try to activate the session
            return
        }
        
        let message = ["message": "sendApplicationContext"]
        
        // First check if we can use direct messaging
        if session.isReachable {
            print("[WatchKit 2] iOS app is reachable, sending direct message")
            session.sendMessage(message, replyHandler: { [weak self] _ in
                print("[WatchKit 2] Successfully requested application context from iOS app")
                // Notify that we might have received data
                DispatchQueue.main.async {
                    WatchDataSource.postDataUpdatedNotification()
                }
            }, errorHandler: { error in
                print("[WatchKit 2] Error requesting application context: \(error.localizedDescription)")
                
                // Fallback to application context as a backup
                self.sendApplicationContextRequest()
            })
        } else {
            print("[WatchKit 2] iOS app is not reachable, using application context")
            sendApplicationContextRequest()
        }
    }
    
    private func sendApplicationContextRequest() {
        do {
            try session.updateApplicationContext(["message": "sendApplicationContext"])
            print("[WatchKit 2] Sent context update request to iOS app")
        } catch {
            print("[WatchKit 2] Failed to send context update request: \(error.localizedDescription)")
        }
    }
    
    // Enhance session reachability notification
    func sessionReachabilityDidChange(_ session: WCSession) {
        print("[WatchKit 2] Session reachability changed: \(session.isReachable)")
        
        if session.isReachable {
            // If iOS app becomes reachable, request fresh data
            requestDataFromiOS()
        }
    }
    
    // MARK: - Data Processing
    
    /// Processes received data from the iOS app.
    /// - Parameter data: The data received either as a message or application context.
    private func processReceivedData(_ data: [String: Any]) {
        if let preferredFiatCurrency = data["preferredFiatCurrency"] as? String {
            // Handle preferred fiat currency update.
            groupUserDefaults?.set(preferredFiatCurrency, forKey: "preferredCurrency")
            
            // Fetch and update market data based on the new preferred currency.
            updateMarketData(for: preferredFiatCurrency)
        } else {
            // Assume the data contains wallets information.
            processWalletsData(walletsInfo: data)
        }
    }
    
    /// Processes wallets data received from the iOS app.
    /// - Parameter walletsInfo: The wallets data received as a dictionary.
    private func processWalletsData(walletsInfo: [String: Any]) {
        guard let walletsToProcess = walletsInfo["wallets"] as? [[String: Any]] else {
            print("No wallets data found in received context.")
            return
        }
        
        var processedWallets: [Wallet] = []
        
        for entry in walletsToProcess {
            guard let label = entry["label"] as? String,
                  let balance = entry["balance"] as? Double,
                  let typeString = entry["type"] as? String,
                  let preferredBalanceUnitString = entry["preferredBalanceUnit"] as? String,
                  let chainString = entry["chain"] as? String,
                  let transactions = entry["transactions"] as? [[String: Any]] else {
                print("Incomplete wallet entry found. Skipping.")
                continue
            }
            
            var transactionsProcessed: [Transaction] = []
            for transactionEntry in transactions {
                guard let timeString = transactionEntry["time"] as? String,
                      let memo = transactionEntry["memo"] as? String,
                      let amountDouble = transactionEntry["amount"] as? Double,
                      let type = transactionEntry["type"] as? String else {
                    print("Incomplete transaction entry found. Skipping.")
                    continue
                }
                
                guard let time = ISO8601DateFormatter().date(from: timeString) else {
                    print("Invalid date format for transaction. Skipping.")
                    continue
                }
                
                let amount = Decimal(amountDouble)
                
                let transactionType = TransactionType.fromRawString(type)
                
                let transaction = Transaction(time: time, memo: memo, type: transactionType, amount: amount)
                transactionsProcessed.append(transaction)
            }
            
            let receiveAddress = entry["receiveAddress"] as? String ?? ""
            let xpub = entry["xpub"] as? String ?? ""
            let hideBalance = entry["hideBalance"] as? Bool ?? false
            let paymentCode = entry["paymentCode"] as? String
            let chain = Chain(rawString: chainString)
            
            let wallet = Wallet(
                label: label,
                balance: "\(balance) BTC",
                type: WalletType(rawString: typeString),
                chain: chain,
                preferredBalanceUnit: BitcoinUnit(rawString: preferredBalanceUnitString),
                receiveAddress: receiveAddress,
                transactions: transactionsProcessed,
                xpub: xpub,
                hideBalance: hideBalance,
                paymentCode: paymentCode
            )
            processedWallets.append(wallet)
        }
        
        // Update the published `wallets` property on the main thread.
        DispatchQueue.main.async { [weak self] in
            self?.wallets = processedWallets
            print("Updated wallets from received context.")
            WatchDataSource.postDataUpdatedNotification()
        }
    }
    
    /// Fetches market data based on the preferred fiat currency.
    /// - Parameter fiatCurrency: The preferred fiat currency string.
    private func updateMarketData(for fiatCurrency: String) {
        guard !fiatCurrency.isEmpty else {
            print("Invalid fiat currency provided")
            return
        }

        MarketAPI.fetchPrice(currency: fiatCurrency) { [weak self] (marketData, error) in
            guard let self = self else { return }
            if let error = error {
                print("Failed to fetch market data: \(error.localizedDescription)")
                // Consider implementing retry logic or fallback mechanism
                return
            }
            
            guard let marketData = marketData as? MarketData else {
                print("Invalid market data format received")
                return
            }
            
            do {
                let widgetData = WidgetDataStore(rate: "\(marketData.rate)", lastUpdate: marketData.dateString, rateDouble: marketData.rate)
                if let encodedData = try? JSONEncoder().encode(widgetData) {
                    self.groupUserDefaults?.set(encodedData, forKey: MarketData.string)
                    print("Market data updated for currency: \(fiatCurrency)")
                } else {
                  throw NSError(domain: "WatchDataSource", code: 1, userInfo: [NSLocalizedDescriptionKey: "Failed to encode market data"])
                }
            } catch {
                print("Failed to process market data: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - Wallet Actions
    
    /// Requests a Lightning Invoice from the iOS app.
    /// - Parameters:
    ///   - walletIdentifier: The index of the wallet in the `wallets` array.
    ///   - amount: The amount for the invoice.
    ///   - description: An optional description for the invoice.
    ///   - responseHandler: A closure to handle the invoice string received from the iOS app.
    func requestLightningInvoice(walletIdentifier: Int, amount: Double, description: String?, responseHandler: @escaping (_ invoice: String) -> Void) {
        let timeoutSeconds = 30.0
        let timeoutTimer = Timer.scheduledTimer(withTimeInterval: timeoutSeconds, repeats: false) { _ in
            print("Lightning invoice request timed out")
            responseHandler("")
        }

        guard wallets.indices.contains(walletIdentifier) else {
            timeoutTimer.invalidate()
            responseHandler("")
            return
        }
        let message: [String: Any] = [
            "request": "createInvoice",
            "walletIndex": walletIdentifier,
            "amount": amount,
            "description": description ?? ""
        ]
        session.sendMessage(message, replyHandler: { reply in
            timeoutTimer.invalidate()
            if let invoicePaymentRequest = reply["invoicePaymentRequest"] as? String, !invoicePaymentRequest.isEmpty {
                responseHandler(invoicePaymentRequest)
            } else {
                responseHandler("")
            }
        }, errorHandler: { error in
            timeoutTimer.invalidate()
            print("Error requesting Lightning Invoice: \(error.localizedDescription)")
            responseHandler("")
        })
    }
    
    /// Toggles the visibility of the wallet's balance.
    /// - Parameters:
    ///   - walletIdentifier: The index of the wallet in the `wallets` array.
    ///   - hideBalance: A boolean indicating whether to hide the balance.
  func toggleWalletHideBalance(walletIdentifier: UUID, hideBalance: Bool, responseHandler: @escaping (_ success: Bool) -> Void) {
    guard wallets.indices.contains(walletIdentifier.hashValue) else {
            responseHandler(false)
            return
        }
        let message: [String: Any] = [
            "message": "hideBalance",
            "walletIndex": walletIdentifier,
            "hideBalance": hideBalance
        ]
        session.sendMessage(message, replyHandler: { reply in
            responseHandler(true)
        }, errorHandler: { error in
            print("Error toggling hide balance: \(error.localizedDescription)")
            responseHandler(false)
        })
    }
    
    // MARK: - Complications Reload
    
    /// Reloads all active complications on the Watch face.
    private func reloadComplications() {
        let server = CLKComplicationServer.sharedInstance()
        server.activeComplications?.forEach { complication in
            server.reloadTimeline(for: complication)
            print("[Complication] Reloaded timeline for \(complication.family.rawValue)")
        }
    }

}

extension WatchDataSource {
    static var mock: WatchDataSource {
        let mockDataSource = WatchDataSource()
        mockDataSource.wallets = [Wallet.mock]
        return mockDataSource
    }
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/ReceiveMethod.swift
================================================

//
//  ReceiveMethod.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 6/15/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

enum ReceiveMethod {
  case Onchain, CreateInvoice
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/ReceiveType.swift
================================================

//
//  ReceiveType.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 6/15/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation

enum ReceiveType {
  case Address, PaymentCode
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/Handoff.swift
================================================

//
//  Handoff.swift
//  MalinWalletWatch Extension
//
//  Created by Admin on 9/27/21.
//  Copyright  2021 MalinWallet. All rights reserved.
//

import Foundation

enum HandoffIdentifier: String {
  case ReceiveOnchain = "com.malinwallet.app.receiveonchain"
  case Xpub = "com.malinwallet.app.xpub"
  case ViewInBlockExplorer = "com.malinwallet.app.blockexplorer"
}

enum HandOffUserInfoKey: String {
  case ReceiveOnchain = "address"
  case Xpub = "xpub"
}

enum HandOffTitle: String {
  case ReceiveOnchain = "View Address"
  case Xpub = "View XPUB"
}


================================================
FILE: ./ios/MalinWalletWatch/Objects/Wallet.swift
================================================

import Foundation

/// Represents a wallet with various properties including its type.
/// Conforms to `Codable` and `Identifiable` for encoding/decoding and unique identification.
struct Wallet: Codable, Identifiable, Equatable {
    let id: UUID
    let label: String
    let balance: String
    let type: WalletType
    let chain: Chain
  let preferredBalanceUnit:  BitcoinUnit
    let receiveAddress: String
    let transactions: [Transaction]
    let xpub: String
    let hideBalance: Bool
    let paymentCode: String?
        
    /// Initializes a new Wallet instance.
    /// - Parameters:
    ///   - id: Unique identifier for the wallet. Defaults to a new UUID.
    ///   - label: Display label for the wallet.
    ///   - balance: Current balance of the wallet as a string.
    ///   - type: The type of the wallet, defined by `WalletType`.
    ///   - preferredBalanceUnit: The preferred unit for displaying balance (e.g., BTC).
    ///   - receiveAddress: The address to receive funds.
    ///   - transactions: An array of transactions associated with the wallet.
    ///   - xpub: Extended public key for HD wallets.
    ///   - hideBalance: Indicates whether the balance should be hidden.
    ///   - paymentCode: Optional payment code associated with the wallet.
  init(id: UUID = UUID(), label: String, balance: String, type: WalletType, chain: Chain = .onchain, preferredBalanceUnit: BitcoinUnit = .sats, receiveAddress: String, transactions: [Transaction], xpub: String, hideBalance: Bool, paymentCode: String? = nil) {
        self.id = id
        self.label = label
        self.balance = balance
        self.type = type
      self.chain = chain
        self.preferredBalanceUnit = preferredBalanceUnit
        self.receiveAddress = receiveAddress
        self.transactions = transactions
        self.xpub = xpub
        self.hideBalance = hideBalance
        self.paymentCode = paymentCode
    }
}

extension Wallet {
    static var mock: Wallet {
        Wallet(
            label: "Mock Wallet",
            balance: "1.2345 BTC",
            type: .hdSegwitBech32Wallet,
            preferredBalanceUnit: .sats,
            receiveAddress: "bc1qmockaddressxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            transactions: Transaction.mockTransactions, // Includes multiple transactions
            xpub: "xpub6CUGRUonZSQ4TWtTMmzXdrXDtypWKiKp...",
            hideBalance: false,
            paymentCode: "p2pkh_mock_payment_code"
        )
    }
}

extension Wallet {
    var formattedBalance: String {
        guard let balanceDecimal = Decimal(string: balance) else { return balance }
        return balanceDecimal.formatted(as: preferredBalanceUnit)
    }
}


================================================
FILE: ./ios/MalinWalletWatch/ViewQRCodefaceController.swift
================================================

//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/11/19.

import WatchKit
import Foundation
import EFQRCode

class ViewQRCodefaceController: WKInterfaceController {
  
  static let identifier = "ViewQRCodefaceController"
  @IBOutlet weak var imageInterface: WKInterfaceImage!
  @IBOutlet weak var addressLabel: WKInterfaceLabel!
  
  var address: String? {
    didSet {
      updateQRCode()
      updateUserActivity()
    }
  }

  private var interfaceMode = ReceiveInterfaceMode.Address
  private let userActivity: NSUserActivity = NSUserActivity(activityType: HandoffIdentifier.Xpub.rawValue)
    
  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    configureUserActivity()
    guard let passedContext = context as? String  else {
      pop()
      return
    }
    address = passedContext
    addressLabel.setText(passedContext)
    toggleViewButtonPressed()
  }

  private func configureUserActivity() {
    userActivity.title = HandOffTitle.Xpub.rawValue
    userActivity.requiredUserInfoKeys = [HandOffUserInfoKey.Xpub.rawValue]
    userActivity.isEligibleForHandoff = true
  }
  
  private func updateUserActivity() {
    if let address = address, !address.isEmpty {
      userActivity.userInfo = [HandOffUserInfoKey.Xpub.rawValue: address]
      userActivity.becomeCurrent()
    } else {
      userActivity.invalidate()
    }
  }

  private func updateQRCode() {
    guard let address = address, !address.isEmpty else {
      imageInterface.setImage(nil)
      return
    }
    DispatchQueue.global(qos: .userInteractive).async {
      guard let cgImage = EFQRCode.generate(for: address) else {
        return
      }
      DispatchQueue.main.async {
        let image = UIImage(cgImage: cgImage)
        self.imageInterface.setImage(image)
      }
    }
  }

  @IBAction @objc func toggleViewButtonPressed() {
    clearAllMenuItems()
    interfaceMode = interfaceMode == .QRCode ? .Address : .QRCode

    let menuItemTitle = interfaceMode == .QRCode ? "QR Code" : "Address"
    let systemImageName = interfaceMode == .QRCode ? "textformat.subscript" : "qrcode"
    let defaultMenuItemIcon = interfaceMode == .QRCode ? WKMenuItemIcon.shuffle : WKMenuItemIcon.shuffle

    addressLabel.setHidden(interfaceMode != .Address)
    imageInterface.setHidden(interfaceMode != .QRCode)

    if #available(watchOSApplicationExtension 6.0, *), let image = UIImage(systemName: systemImageName) {
      addMenuItem(with: image, title: menuItemTitle, action: #selector(toggleViewButtonPressed))
    } else {
      addMenuItem(with: defaultMenuItemIcon, title: menuItemTitle, action: #selector(toggleViewButtonPressed))
    }
  }
  
  override func willActivate() {
    super.willActivate()
    updateUserActivity()
  }

  override func didDeactivate() {
    super.didDeactivate()
    userActivity.invalidate()
  }
}


================================================
FILE: ./ios/MalinWalletWatch/WalletDetailsInterfaceController.swift
================================================

//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/11/19.

import WatchKit
import Foundation
import WatchConnectivity

class WalletDetailsInterfaceController: WKInterfaceController {
  
  var wallet: Wallet?
  static let identifier = "WalletDetailsInterfaceController"
  @IBOutlet weak var walletBasicsGroup: WKInterfaceGroup!
  @IBOutlet weak var walletBalanceLabel: WKInterfaceLabel!
  @IBOutlet weak var createInvoiceButton: WKInterfaceButton!
  @IBOutlet weak var walletNameLabel: WKInterfaceLabel!
  @IBOutlet weak var receiveButton: WKInterfaceButton!
  @IBOutlet weak var viewXPubButton: WKInterfaceButton!
  @IBOutlet weak var noTransactionsLabel: WKInterfaceLabel!
  @IBOutlet weak var transactionsTable: WKInterfaceTable!
  
  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    guard let identifier = context as? UUID else {
      pop()
      return
    }
    loadWalletDetails(identifier: identifier)
  }
  
  private func loadWalletDetails(identifier: UUID) {
    let index = WatchDataSource.shared.wallets.firstIndex(where: { $0.id == identifier }) ?? 0
    let wallet = WatchDataSource.shared.wallets[index]
    self.wallet = wallet
    updateWalletUI(wallet: wallet)
    updateTransactionsTable(forWallet: wallet)
  }
  
  private func updateWalletUI(wallet: Wallet) {
    walletBalanceLabel.setHidden(wallet.hideBalance)
    walletBalanceLabel.setText(wallet.hideBalance ? "" : wallet.balance)
    walletNameLabel.setText(wallet.label)
//    walletBasicsGroup.setBackgroundImageNamed(WalletGradient(rawValue: wallet.type)?)
    
    let isLightningWallet = wallet.type == .lightningCustodianWallet
    createInvoiceButton.setHidden(!isLightningWallet)
    receiveButton.setHidden(wallet.receiveAddress.isEmpty)
    viewXPubButton.setHidden(!isXPubAvailable(wallet: wallet))
  }
  
  private func isXPubAvailable(wallet: Wallet) -> Bool {
    return (wallet.type != .lightningCustodianWallet) && !(wallet.xpub).isEmpty
  }
  
  private func updateTransactionsTable(forWallet wallet: Wallet) {
    let transactions = wallet.transactions
    transactionsTable.setNumberOfRows(transactions.count, withRowType: TransactionTableRow.identifier)
    
    for index in 0..<transactions.count {
      guard let controller = transactionsTable.rowController(at: index) as? TransactionTableRow else { continue }
      let transaction = transactions[index]
      controller.configure(with: transaction)
    }
    transactionsTable.setHidden(transactions.isEmpty)
    noTransactionsLabel.setHidden(!transactions.isEmpty)
  }
  
  @IBAction func toggleBalanceVisibility(_ sender: Any) {
    guard let wallet = wallet else {
      return
    }
    
    if wallet.hideBalance {
      showBalanceMenuItemTapped()
    } else {
      hideBalanceMenuItemTapped()
    }
  }
  
  @objc func showBalanceMenuItemTapped() {
    guard let identifier = wallet?.id else { return }
    WatchDataSource.shared.toggleWalletHideBalance(walletIdentifier: identifier, hideBalance: false) { [weak self] _ in
      DispatchQueue.main.async {
        WatchDataSource.postDataUpdatedNotification()
        self?.loadWalletDetails(identifier: identifier)
      }
    }
  }
  
  @objc func hideBalanceMenuItemTapped() {
    guard let identifier = wallet?.id else { return }
    WatchDataSource.shared.toggleWalletHideBalance(walletIdentifier: identifier, hideBalance: true) { [weak self] _ in
      DispatchQueue.main.async {
        WatchDataSource.postDataUpdatedNotification()
        self?.loadWalletDetails(identifier: identifier)
      }
    }
  }
  
  @IBAction func viewXPubMenuItemTapped() {
    guard let xpub = wallet?.xpub else {
      return
    }
    presentController(withName: ViewQRCodefaceController.identifier, context: xpub)
  }
  
  override func willActivate() {
    super.willActivate()
    guard let wallet = wallet else { return }
    updateTransactionsTable(forWallet: wallet)
  }
  
  @IBAction func receiveMenuItemTapped() {
    guard let wallet = wallet else { return }
    presentController(withName: ReceivePageInterfaceController.identifier, context: (wallet, ReceiveMethod.Onchain))
  }
  
  @IBAction func createInvoiceTapped() {
    guard let wallet = wallet else { return }
    pushController(withName: ReceiveInterfaceController.identifier, context: (wallet.id, ReceiveMethod.CreateInvoice))
  }
  
  override func contextForSegue(withIdentifier segueIdentifier: String) -> Any? {
    guard let wallet = wallet else { return nil }
    return (wallet.id, ReceiveMethod.Onchain)
  }
  
}


================================================
FILE: ./ios/MalinWalletWatch/NotificationController.swift
================================================

//
//  NotificationController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/6/19.

//

import WatchKit
import Foundation
import UserNotifications


class NotificationController: WKUserNotificationInterfaceController {

    override init() {
        // Initialize variables here.
        super.init()
        
        // Configure interface objects here.
    }

    override func willActivate() {
        // This method is called when watch view controller is about to be visible to user
        super.willActivate()
    }

    override func didDeactivate() {
        // This method is called when watch view controller is no longer visible
        super.didDeactivate()
    }

    override func didReceive(_ notification: UNNotification) {
        // This method is called when a notification needs to be presented.
        // Implement it if you use a dynamic notification interface.
        // Populate your dynamic notification interface as quickly as possible.
    }
}


================================================
FILE: ./ios/MalinWalletWatch/InterfaceController.swift
================================================

//
//  InterfaceController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/6/19.
//

import WatchKit
import WatchConnectivity
import Foundation

class InterfaceController: WKInterfaceController {
  
  @IBOutlet weak var walletsTable: WKInterfaceTable!
  @IBOutlet weak var noWalletsAvailableLabel: WKInterfaceLabel!
    
  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    // Ensure WatchDataSource is initialized early in the lifecycle
    _ = WatchDataSource.shared
  }
  
  override func willActivate() {
    super.willActivate()
    
    // Request fresh data when controller becomes active
    WatchDataSource.shared.requestDataFromiOS()
    
    // Update UI with any existing data
    updateUI()
    
    // Register for notifications
    NotificationCenter.default.addObserver(self, selector: #selector(updateUI), name: Notifications.dataUpdated.name, object: nil)
  }
  
  override func didDeactivate() {
    super.didDeactivate()
    // Clean up observers when controller is no longer active
    NotificationCenter.default.removeObserver(self)
  }
  
  @objc private func updateUI() {
    let wallets = WatchDataSource.shared.wallets
    let isEmpty = wallets.isEmpty
    noWalletsAvailableLabel.setHidden(!isEmpty)
    walletsTable.setHidden(isEmpty)
    
    if isEmpty { return }
    
    walletsTable.setNumberOfRows(wallets.count, withRowType: WalletInformation.identifier)
    for index in 0..<wallets.count {
      updateRow(at: index, with: wallets[index])
    }
  }
  
  private func updateRow(at index: Int, with wallet: Wallet) {
    guard let controller = walletsTable.rowController(at: index) as? WalletInformation else { return }
    controller.configure(with: wallet)
  }
  
  override func contextForSegue(withIdentifier segueIdentifier: String, in table: WKInterfaceTable, rowIndex: Int) -> Any? {
    return rowIndex
  }
}


================================================
FILE: ./ios/MalinWalletWatch/ReceiveInterfaceController.swift
================================================

//
//  ReceiveInterfaceController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/12/19.

import WatchKit
import WatchConnectivity
import Foundation
import EFQRCode

class ReceiveInterfaceController: WKInterfaceController {

    static let identifier = "ReceiveInterfaceController"
    private var wallet: Wallet?
    private var receiveMethod: ReceiveMethod = .Onchain
    private var interfaceMode: ReceiveInterfaceMode = .Address
    var receiveType: ReceiveType = .Address
    @IBOutlet weak var addressLabel: WKInterfaceLabel!
    @IBOutlet weak var loadingIndicator: WKInterfaceGroup!
    @IBOutlet weak var imageInterface: WKInterfaceImage!
    private let userActivity: NSUserActivity = NSUserActivity(activityType: HandoffIdentifier.ReceiveOnchain.rawValue)

    override func willActivate() {
        super.willActivate()
        userActivity.title = HandOffTitle.ReceiveOnchain.rawValue
        userActivity.requiredUserInfoKeys = [HandOffUserInfoKey.ReceiveOnchain.rawValue]
        userActivity.isEligibleForHandoff = true
        update(userActivity)
    }

    override func awake(withContext context: Any?) {
        super.awake(withContext: context)
        guard let passedContext = context as? (Int, ReceiveMethod, ReceiveType) else {
            pop()
            return
        }
        let wallet = WatchDataSource.shared.wallets[passedContext.0]
        self.wallet = wallet
        receiveMethod = passedContext.1
        receiveType = passedContext.2
        setupView()
    }

    private func setupView() {
      if receiveMethod == .CreateInvoice && (wallet?.type == .lightningCustodianWallet) {
        presentController(withName: SpecifyInterfaceController.identifier, context: wallet?.id)
        } else {
            setupQRCode()
            setupMenuItems()
        }
    }

    private func setupQRCode() {
      guard let address = receiveType == .Address ? wallet?.receiveAddress : wallet?.paymentCode else { return }
        addressLabel.setText(address)
        generateQRCode(from: address)
    }

    private func generateQRCode(from content: String) {
        DispatchQueue.global(qos: .userInteractive).async {
          guard let cgImage = EFQRCode.generate(for: content) else { return }
            DispatchQueue.main.async {
                let image = UIImage(cgImage: cgImage)
                self.imageInterface.setImage(image)
                self.loadingIndicator.setHidden(true)
                self.imageInterface.setHidden(false)
            }
        }
    }

    private func setupMenuItems() {
        clearAllMenuItems()
        addMenuItem(with: .shuffle, title: "Toggle View", action: #selector(toggleViewButtonPressed))
    }

    @IBAction @objc func toggleViewButtonPressed() {
        interfaceMode = interfaceMode == .QRCode ? .Address : .QRCode
        updateView()
    }

    private func updateView() {
        addressLabel.setHidden(interfaceMode != .Address)
        imageInterface.setHidden(interfaceMode != .QRCode)
    }

    override func didAppear() {
        super.didAppear()
        if isCreatingInvoice() {
            presentController(withName: SpecifyInterfaceController.identifier, context: wallet?.id)
        }
    }

    private func isCreatingInvoice() -> Bool {
      return receiveMethod == .CreateInvoice && (wallet?.type == .lightningCustodianWallet)
    }

    override func didDeactivate() {
        super.didDeactivate()
        NotificationCenter.default.removeObserver(self)
        userActivity.invalidate()
    }
}



================================================
FILE: ./ios/MalinWalletWatch/NumericKeypadInterfaceController.swift
================================================

//
//  NumericKeypadInterfaceController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/23/19.

//

import WatchKit
import Foundation


class NumericKeypadInterfaceController: WKInterfaceController {
  
  static let identifier = "NumericKeypadInterfaceController"
  private var amount: [String] = ["0"]
  var keyPadType: NumericKeypadType = .BTC
  struct NotificationName {
    static let keypadDataChanged = Notification.Name(rawValue: "Notification.NumericKeypadInterfaceController.keypadDataChanged")
  }
  struct Notifications {
    static let keypadDataChanged = Notification(name: NotificationName.keypadDataChanged)
  }
  enum NumericKeypadType: String {
    case BTC = "BTC"
    case SATS = "sats"
  }
  
  @IBOutlet weak var periodButton: WKInterfaceButton!
  
  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    if let context = context as? SpecifyInterfaceController.SpecificQRCodeContent {
      amount = context.amountStringArray
      keyPadType = context.bitcoinUnit
    }
    periodButton.setEnabled(keyPadType == .SATS)
  }
  
  override func willActivate() {
    // This method is called when watch view controller is about to be visible to user
    super.willActivate()
    updateTitle()
  }
  
  private func updateTitle() {
    var title = ""
    for amount in self.amount {
      let isValid = Double(amount)
      if amount == "." || isValid != nil {
        title.append(String(amount))
      }
    }
    if title.isEmpty {
      title = "0"
    }
    setTitle("< \(title) \(keyPadType)")
    NotificationCenter.default.post(name: NotificationName.keypadDataChanged, object: amount)
  }
  
  private func append(value: String) {
    guard amount.filter({$0 != "."}).count <= 9 && !(amount.contains(".") && value == ".") else {
      return
    }
    switch keyPadType {
    case .SATS:
      if amount.first == "0" {
        if value == "0" {
          return
        }
        amount[0] = value
      } else {
        amount.append(value)
      }
    case .BTC:
      if amount.isEmpty {
        if (value == "0") {
          amount.append("0")
        } else if value == "." && !amount.contains(".") {
          amount.append("0")
          amount.append(".")
        } else {
          amount.append(value)
        }
      } else if let first = amount.first, first == "0" {
        if amount.count > 1, amount[1] != "." {
          amount.insert(".", at: 1)
        } else if amount.count == 1, amount.first == "0" && value != "." {
          amount.append(".")
          amount.append(value)
        } else {
          amount.append(value)
        }
      } else {
        amount.append(value)
      }
    }
    updateTitle()
  }
  
  @IBAction func keypadNumberOneTapped() {
    append(value: "1")
  }
  
  @IBAction func keypadNumberTwoTapped() {
    append(value: "2")
  }
  
  @IBAction func keypadNumberThreeTapped() {
    append(value: "3")
  }
  
  @IBAction func keypadNumberFourTapped() {
    append(value: "4")
  }
  
  @IBAction func keypadNumberFiveTapped() {
    append(value: "5")
  }
  
  @IBAction func keypadNumberSixTapped() {
    append(value: "6")
  }
  
  @IBAction func keypadNumberSevenTapped() {
    append(value: "7")
  }
  
  @IBAction func keypadNumberEightTapped() {
    append(value: "8")
  }
  
  @IBAction func keypadNumberNineTapped() {
    append(value: "9")
  }
  
  @IBAction func keypadNumberZeroTapped() {
    append(value: "0")
  }
  
  @IBAction func keypadNumberDotTapped() {
    guard !amount.contains("."), keyPadType == .BTC else { return }
    append(value: ".")
  }
  
  @IBAction func keypadNumberRemoveTapped() {
    guard !amount.isEmpty else {
      setTitle("< 0 \(keyPadType)")
      return
    }
    amount.removeLast()
    updateTitle()
  }
  
}


================================================
FILE: ./ios/MalinWalletWatch/File.swift
================================================

//
//  File.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 3/19/25.
//  Copyright  2025 MalinWallet. All rights reserved.
//



================================================
FILE: ./ios/MalinWalletWatch/SpecifyInterfaceController.swift
================================================

//
//  SpecifyInterfaceController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 3/23/19.

//

import WatchKit
import WatchConnectivity
import Foundation

class SpecifyInterfaceController: WKInterfaceController {

  static let identifier = "SpecifyInterfaceController"
  @IBOutlet weak var descriptionButton: WKInterfaceButton!
  @IBOutlet weak var amountButton: WKInterfaceButton!
  @IBOutlet weak var createButton: WKInterfaceButton!
  
  struct SpecificQRCodeContent {
    var amount: Double?
    var description: String?
    var amountStringArray: [String] = ["0"]
    var bitcoinUnit: NumericKeypadInterfaceController.NumericKeypadType = .BTC
  }
  var specifiedQRContent: SpecificQRCodeContent = SpecificQRCodeContent(amount: nil, description: nil, amountStringArray: ["0"], bitcoinUnit: .BTC)
  var wallet: Wallet?
  struct NotificationName {
    static let createQRCode = Notification.Name(rawValue: "Notification.SpecifyInterfaceController.createQRCode")
  }
  struct Notifications {
    static let createQRCode = Notification(name: NotificationName.createQRCode)
  }

  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    guard let identifier = context as? Int, WatchDataSource.shared.wallets.count > identifier else {
     return
    }
    let wallet = WatchDataSource.shared.wallets[identifier]
    self.wallet = wallet
    self.createButton.setAlpha(0.5)
    self.specifiedQRContent.bitcoinUnit = (wallet.type == .lightningCustodianWallet) ? .SATS : .BTC
    NotificationCenter.default.addObserver(forName: NumericKeypadInterfaceController.NotificationName.keypadDataChanged, object: nil, queue: nil) { [weak self] (notification) in
      guard let amountObject = notification.object as? [String], !amountObject.isEmpty else { return }
      if amountObject.count == 1 && (amountObject.first == "." || amountObject.first == "0") {
        return
      }
      var title = ""
      for amount in amountObject {
        let isValid = Double(amount)
        if amount == "." || isValid != nil {
          title.append(String(amount))
        }
      }
      self?.specifiedQRContent.amountStringArray = amountObject
      if let amountDouble = Double(title), let keyPadType = self?.specifiedQRContent.bitcoinUnit {
        self?.specifiedQRContent.amount = amountDouble
        self?.amountButton.setTitle("\(title) \(keyPadType)")
        
        var isShouldCreateButtonBeEnabled = amountDouble > 0 && !title.isEmpty
        
        if (wallet.type == .lightningCustodianWallet) && !WCSession.default.isReachable {
          isShouldCreateButtonBeEnabled = false
        }
        
        self?.createButton.setEnabled(isShouldCreateButtonBeEnabled)
        self?.createButton.setAlpha(isShouldCreateButtonBeEnabled ? 1.0 : 0.5)
        }
      }
    }

    override func didDeactivate() {
        // This method is called when watch view controller is no longer visible
      super.didDeactivate()
      NotificationCenter.default.removeObserver(self, name: NumericKeypadInterfaceController.NotificationName.keypadDataChanged, object: nil)
    }

  @IBAction func descriptionButtonTapped() {
    presentTextInputController(withSuggestions: nil, allowedInputMode: .allowEmoji) { [weak self]  (result: [Any]?) in
      DispatchQueue.main.async {
        if let result = result, let text = result.first as? String   {
          self?.specifiedQRContent.description = text
          self?.descriptionButton.setTitle(nil)
          self?.descriptionButton.setTitle(text)
        }
      }
    }
  }
  
  @IBAction func createButtonTapped() {
    NotificationCenter.default.post(name: NotificationName.createQRCode, object: specifiedQRContent)
    dismiss()
  }
  
  override func contextForSegue(withIdentifier segueIdentifier: String) -> Any? {
    if segueIdentifier == NumericKeypadInterfaceController.identifier {
      return specifiedQRContent
    }
    return nil
  }
  
}


================================================
FILE: ./ios/MalinWalletWatch/MalinWalletWatch-Bridging-Header.h
================================================

//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//



================================================
FILE: ./ios/MalinWalletWatch/main.swift
================================================

//
//  main.swift
//  MalinWallet
//
//  Created by Marcos Rodriguez on 3/20/25.
//  Copyright  2025 MalinWallet. All rights reserved.
//



================================================
FILE: ./ios/MalinWalletWatch/ReceivePageInterfaceController.swift
================================================

//
//  ReceivePageViewController.swift
//  MalinWalletWatch Extension
//
//  Created by Marcos Rodriguez on 6/15/24.
//  Copyright  2024 MalinWallet. All rights reserved.
//

import Foundation
import WatchKit

class ReceivePageInterfaceController: WKInterfaceController {
  static let identifier = "ReceivePageInterfaceController"
    var pageNames = ["Address", "Payment Code"]
    var pageControllers = ["ReceiveInterfaceController", "ReceiveInterfaceController"]

    override func awake(withContext context: Any?) {
        super.awake(withContext: context)
      
      let wallet = context as? Wallet

        WKInterfaceController.reloadRootPageControllers(
            withNames: pageControllers,
            contexts: [(wallet,ReceiveMethod.Onchain ,  ReceiveType.Address), (wallet, ReceiveMethod.Onchain, ReceiveType.PaymentCode)],
            orientation: .horizontal,
            pageIndex: 0
        )
    }
}


================================================
FILE: ./ios/MalinWalletUITests/MalinWalletUITests.swift
================================================

//
//  MalinWalletUITests.swift
//  MalinWalletUITests
//
//  Created by Marcos Rodriguez on 12/6/23.
//  Copyright  2023 MalinWallet. All rights reserved.
//

import XCTest

class MalinWalletUITests: XCTestCase {

    var app: XCUIApplication!

    override func setUp() {
        super.setUp()
        continueAfterFailure = false

        // Initialize the XCUIApplication instance
        app = XCUIApplication()
        
        // Add a launch argument to differentiate between Mac Catalyst and iOS
        #if targetEnvironment(macCatalyst)
        app.launchArguments.append("--macCatalyst")
        #else
        app.launchArguments.append("--iOS")
        #endif

        app.launch()
    }

    func testAppLaunchesSuccessfully() {
        XCTAssertEqual(app.state, .runningForeground, "App should be running in the foreground")

        #if targetEnvironment(macCatalyst)
        XCTAssertTrue(app.windows.count > 0, "There should be at least one window in Mac Catalyst")
        #else
        XCTAssertTrue(app.buttons.count > 0, "There should be at least one button on iOS")
        #endif
    }
}


================================================
FILE: ./shim.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/* global __DEV__, localStorage */
import 'text-encoding';
if (typeof Buffer === 'undefined') global.Buffer = require('buffer').Buffer;
if (typeof __dirname === 'undefined') global.__dirname = '/';
if (typeof __filename === 'undefined') global.__filename = '';
if (typeof process === 'undefined') {
  global.process = {};
}

process.browser = false;
process.version = '0.0.0';

// Minimalistic process.nextTick implementation
process.nextTick = function (callback, ...args) {
  if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }

  // Use setImmediate if available (better than setTimeout), otherwise fallback to setTimeout
  if (typeof setImmediate !== 'undefined') {
    setImmediate(() => callback(...args));
  } else {
    setTimeout(() => callback(...args), 0);
  }
};

// global.location = global.location || { port: 80 }
const isDev = typeof __DEV__ === 'boolean' && __DEV__;
process.env.NODE_ENV = isDev ? 'development' : 'production';
if (typeof localStorage !== 'undefined') {
  localStorage.debug = isDev ? '*' : '';
}

// If using the crypto shim, uncomment the following line to ensure
// crypto is loaded first, so it can populate global.crypto
require('crypto');


================================================
FILE: ./.eslintrc.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint', 'jest', 'react', 'react-native', 'prettier'],
  extends: [
    '@react-native/eslint-config',
    'plugin:@typescript-eslint/recommended',
    'prettier',
    'standard',
    'standard-jsx',
    'standard-react',
  ],
  rules: {
    'prettier/prettier': 'error',
  },
}


================================================
FILE: ./cleaner.py
================================================

import os

# Liste des fichiers critiques
targets = ['App.tsx', 'shim.js', 'index.js']

print("--- [IA SYNTAXE] : Nettoyage des imports et des points-virgules ---")
for target in targets:
    if os.path.exists(target):
        with open(target, 'r') as f:
            content = f.read()
        # Simulation de correction (on pourrait ici appeler une API)
        new_content = content.replace(';;', ';') 
        with open(target, 'w') as f:
            f.write(new_content)
        print(f"[OK] {target} analys.")


================================================
FILE: ./MalinComponents.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/* eslint react/prop-types: "off", react-native/no-inline-styles: "off" */
import React, { forwardRef } from 'react';
import { Dimensions, Platform, Pressable, StyleSheet, TextInput, View } from 'react-native';
import { Icon, Text } from '@rneui/themed';
import { useTheme } from './components/themes';
import { useLocale } from '@react-navigation/native';

const { height, width } = Dimensions.get('window');
const aspectRatio = height / width;
let isIpad;
if (aspectRatio > 1.6) {
  isIpad = false;
} else {
  isIpad = true;
}

/**
 * TODO: remove this comment once this file gets properly converted to typescript.
 *
 * @type {React.FC<any>}
 */
export const MalinButtonLink = forwardRef((props, ref) => {
  const { colors } = useTheme();
  return (
    <Pressable accessibilityRole="button" style={({ pressed }) => [styles.malinButtonLink, pressed && styles.pressed]} {...props} ref={ref}>
      <Text style={{ color: colors.foregroundColor, textAlign: 'center', fontSize: 16 }}>{props.title}</Text>
    </Pressable>
  );
});

export const MalinCard = props => {
  return <View {...props} style={{ padding: 20 }} />;
};

export const MalinText = ({ bold = false, ...props }) => {
  const { colors } = useTheme();
  const { direction } = useLocale();
  const style = StyleSheet.compose(
    {
      color: colors.foregroundColor,
      writingDirection: direction,
      fontWeight: bold ? 'bold' : 'normal',
    },
    props.style,
  );
  return <Text {...props} style={style} />;
};

export const MalinTextCentered = props => {
  const { colors } = useTheme();
  return <Text {...props} style={{ color: colors.foregroundColor, textAlign: 'center' }} />;
};

export const MalinFormLabel = props => {
  const { colors } = useTheme();
  const { direction } = useLocale();

  return (
    <Text
      {...props}
      style={{
        color: colors.foregroundColor,
        fontWeight: '400',
        marginHorizontal: 20,
        writingDirection: direction,
      }}
    />
  );
};

export const MalinFormMultiInput = props => {
  const { colors } = useTheme();

  return (
    <TextInput
      multiline
      underlineColorAndroid="transparent"
      numberOfLines={4}
      editable={!props.editable}
      style={{
        paddingHorizontal: 8,
        paddingVertical: 16,
        flex: 1,
        marginTop: 5,
        marginHorizontal: 20,
        borderColor: colors.formBorder,
        borderBottomColor: colors.formBorder,
        borderWidth: 1,
        borderBottomWidth: 0.5,
        borderRadius: 4,
        backgroundColor: colors.inputBackgroundColor,
        color: colors.foregroundColor,
        textAlignVertical: 'top',
      }}
      autoCorrect={false}
      autoCapitalize="none"
      spellCheck={false}
      {...props}
      selectTextOnFocus={false}
      keyboardType={Platform.OS === 'android' ? 'visible-password' : 'default'}
    />
  );
};

export class is {
  static ipad() {
    return isIpad;
  }
}

export function MalinBigCheckmark({ style = {} }) {
  const defaultStyles = {
    backgroundColor: '#ccddf9',
    width: 120,
    height: 120,
    borderRadius: 60,
    alignSelf: 'center',
    justifyContent: 'center',
    marginTop: 0,
    marginBottom: 0,
  };
  const mergedStyles = { ...defaultStyles, ...style };
  return (
    <View style={mergedStyles}>
      <Icon name="check" size={50} type="font-awesome" color="#0f5cc0" />
    </View>
  );
}

const styles = StyleSheet.create({
  malinButtonLink: {
    minWidth: 100,
    minHeight: 36,
    justifyContent: 'center',
  },
  pressed: {
    opacity: 0.6,
  },
});


================================================
FILE: ./gesture-handler.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// Don't import react-native-gesture-handler on web


================================================
FILE: ./miniapp/index.html
================================================

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MalinWallet Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================
FILE: ./miniapp/src/main.jsx
================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


================================================
FILE: ./miniapp/src/App.jsx
================================================

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';

// Theme Colors
const COLORS = {
  background: '#000000',
  primary: '#D4AF37', // Gold
  text: '#FFFFFF',
  secondary: '#1A1A1A'
};

function App() {
  const [wallet, setWallet] = useState(null);
  const [balance, setBalance] = useState('0.00');

  useEffect(() => {
    // Check if Telegram WebApp is available
    if (window.Telegram?.WebApp) {
      window.Telegram.WebApp.ready();
      window.Telegram.WebApp.expand();
    }

    // Load or Create local wallet (simplified for demo)
    const storedKey = localStorage.getItem('mw_private_key');
    if (storedKey) {
        const w = new ethers.Wallet(storedKey);
        setWallet(w);
        fetchBalance(w.address);
    }
  }, []);

  const createWallet = () => {
      const w = ethers.Wallet.createRandom();
      localStorage.setItem('mw_private_key', w.privateKey);
      setWallet(w);
      setBalance('0.00');
  };

  const fetchBalance = async (address) => {
      // Use public RPC or the Infura key via env (if Vite configured)
      // Simulating fetch
      setBalance('0.00');
  };

  return (
    <div style={{ backgroundColor: COLORS.background, minHeight: '100vh', color: COLORS.text, fontFamily: 'sans-serif', padding: '20px' }}>
      <header style={{ textAlign: 'center', marginBottom: '40px' }}>
        <h1 style={{ color: COLORS.primary, margin: 0 }}>MalinWallet</h1>
        <p style={{ opacity: 0.7, fontSize: '14px' }}>Mini App</p>
      </header>

      {!wallet ? (
        <div style={{ textAlign: 'center' }}>
          <p>Bienvenue ! Crez un wallet pour commencer.</p>
          <button
            onClick={createWallet}
            style={{
                backgroundColor: COLORS.primary,
                color: '#000',
                border: 'none',
                padding: '15px 30px',
                borderRadius: '12px',
                fontSize: '16px',
                fontWeight: 'bold',
                cursor: 'pointer',
                width: '100%'
            }}
          >
            Crer un Wallet
          </button>
        </div>
      ) : (
        <div>
            <div style={{ backgroundColor: COLORS.secondary, padding: '20px', borderRadius: '16px', marginBottom: '20px' }}>
                <p style={{ margin: 0, opacity: 0.6, fontSize: '12px' }}>Solde Total</p>
                <h2 style={{ margin: '10px 0', fontSize: '32px' }}>{balance} ETH</h2>
                <p style={{ margin: 0, fontSize: '10px', opacity: 0.5, wordBreak: 'break-all' }}>{wallet.address}</p>
            </div>

            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }}>
                <button style={btnStyle}>Acheter</button>
                <button style={btnStyle}>Vendre</button>
                <button style={btnStyle}>Swap</button>
                <button style={btnStyle}>DApps</button>
            </div>
        </div>
      )}
    </div>
  );
}

const btnStyle = {
    backgroundColor: '#333',
    color: COLORS.primary,
    border: `1px solid ${COLORS.primary}`,
    padding: '12px',
    borderRadius: '8px',
    fontSize: '14px',
    fontWeight: 'bold',
    cursor: 'pointer'
};

export default App;


================================================
FILE: ./miniapp/src/index.css
================================================

body {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}


================================================
FILE: ./bot/index.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
require('dotenv').config();
const { Telegraf, Markup } = require('telegraf');
const { ethers } = require('ethers');
const { Connection, PublicKey, clusterApiUrl } = require('@solana/web3.js');
const axios = require('axios');

// Load environment variables (User needs to create .env in bot/ directory or pass them)
const TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const WEB_APP_URL = process.env.WEB_APP_URL || 'https://malinwallet.app'; // Placeholder
const INFURA_KEY = process.env.INFURA_API_KEY || '97ecdb3bd46649e5b03d041dafad5661'; // From user previous input
const ZEROX_KEY = process.env.ZEROX_API_KEY || '50d0ce66-7c28-4c4e-ba23-2f41e1561ef4';
const FEE_RECIPIENT = '0xeeafb3f49fe1a7156a580877346b347c4709e8e6';
const AFFILIATE_ID = '9817a72d5f2caf';

if (!TOKEN) {
    console.error('Error: TELEGRAM_BOT_TOKEN is missing in .env');
    // We don't exit here to allow testing structure, but in prod it should exit.
}

const bot = new Telegraf(TOKEN);

// --- HELPERS ---

async function getEthBalance(address) {
    try {
        const provider = new ethers.JsonRpcProvider(`https://mainnet.infura.io/v3/${INFURA_KEY}`);
        const balance = await provider.getBalance(address);
        return ethers.formatEther(balance);
    } catch (e) {
        console.error('ETH Balance Error:', e.message);
        return 'Error';
    }
}

async function getSolBalance(address) {
    try {
        const connection = new Connection(clusterApiUrl('mainnet-beta'));
        const publicKey = new PublicKey(address);
        const balance = await connection.getBalance(publicKey);
        return balance / 1e9;
    } catch (e) {
        console.error('SOL Balance Error:', e.message);
        return 'Error';
    }
}

// --- COMMANDS ---

bot.start((ctx) => {
    ctx.reply(
        "Bienvenue sur MalinWallet Bot ! \n\nJe suis votre assistant crypto personnel. Je peux grer vos transactions, swap, et achats directement ici.\n\nLancez la Mini App pour une exprience visuelle complte ou utilisez les commandes ci-dessous.",
        Markup.keyboard([
            [Markup.button.webApp(" Ouvrir MalinWallet Mini App", WEB_APP_URL)],
            [" Solde", " Envoyer", " Recevoir"],
            [" Swap", " Acheter Crypto", " Vendre"]
        ]).resize()
    );
});

bot.hears(' Solde', async (ctx) => {
    // In a real bot, we would map the Telegram User ID to a stored wallet address in a database.
    // For this demo, we'll ask the user or simulate.
    ctx.reply("Pour quel wallet voulez-vous voir le solde ? Envoyez votre adresse ETH ou SOL.", Markup.forceReply());
});

bot.hears(' Recevoir', (ctx) => {
    ctx.reply(
        "Pour recevoir des cryptos, ouvrez la Mini App pour afficher votre QR Code et votre adresse en toute scurit.",
        Markup.inlineKeyboard([
            [Markup.button.webApp(" Ouvrir QR Code", WEB_APP_URL)]
        ])
    );
});

bot.hears(' Envoyer', (ctx) => {
    ctx.reply(
        "Pour envoyer des cryptos, veuillez utiliser la Mini App pour signer la transaction de manire scurise.",
        Markup.inlineKeyboard([
            [Markup.button.webApp(" Envoyer via Mini App", WEB_APP_URL)]
        ])
    );
});

bot.on('text', async (ctx) => {
    const text = ctx.message.text.trim();

    // Simple address detection
    if (ethers.isAddress(text)) {
        const loading = await ctx.reply(" Vrification du solde ETH...");
        const bal = await getEthBalance(text);
        ctx.telegram.editMessageText(ctx.chat.id, loading.message_id, null, ` Solde ETH: ${bal} ETH`);
    } else if (text.length > 30 && !text.includes(' ')) {
        // Assume SOL address length check roughly
        try {
            new PublicKey(text); // Check validity
            const loading = await ctx.reply(" Vrification du solde SOL...");
            const bal = await getSolBalance(text);
            ctx.telegram.editMessageText(ctx.chat.id, loading.message_id, null, ` Solde SOL: ${bal} SOL`);
        } catch {
            // Not an address, maybe chat
            // ctx.reply("Je n'ai pas reconnu cette adresse.");
        }
    }
});

bot.hears(' Swap', (ctx) => {
    ctx.reply("Quel swap voulez-vous effectuer ? (Ex: ETH -> USDC)", Markup.inlineKeyboard([
        [Markup.button.callback("ETH -> USDC", "swap_eth_usdc")],
        [Markup.button.callback("SOL -> USDC", "swap_sol_usdc")]
    ]));
});

bot.action('swap_eth_usdc', (ctx) => {
    // Here we would ideally ask for amount, then fetch 0x quote
    ctx.reply("Combien d'ETH voulez-vous changer ?");
    // State management would be needed here (e.g., telegraf-session) to capture the next message as amount.
});

bot.hears(' Acheter Crypto', (ctx) => {
    // ChangeNOW Logic
    // We need an address. If stored, use it. Else ask.
    const url = `https://changenow.io/exchange?from=eur&to=eth&amount=50&link_id=${AFFILIATE_ID}`;
    ctx.reply(`Achetez vos cryptos facilement et en toute scurit ici : ${url}`,
        Markup.inlineKeyboard([
            Markup.button.url("Acheter maintenant", url)
        ])
    );
});

// --- LAUNCH ---

// Enable graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

if (TOKEN) {
    bot.launch().then(() => console.log('MalinWallet Bot started'));
} else {
    console.log('Bot not started: No Token provided in .env');
}


================================================
FILE: ./screen/ActionSheet.common.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// ActionSheet.common.ts
export interface ActionSheetOptions {
  title?: string;
  message?: string;
  options: string[]; // Array of button labels.
  destructiveButtonIndex?: number;
  cancelButtonIndex?: number;
  confirmButtonIndex?: number;
  anchor?: number;
}

export type CompletionCallback = (buttonIndex: number) => void;


================================================
FILE: ./screen/wallets/WalletDetails.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  ActivityIndicator,
  InteractionManager,
  LayoutAnimation,
  StyleSheet,
  Switch,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from 'react-native';
import { writeFileAndExport } from '../../malin_modules/fs';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import {
  HDAezeedWallet,
  HDSegwitBech32Wallet,
  LegacyWallet,
  LightningArkWallet,
  MultisigHDWallet,
  SegwitBech32Wallet,
  SegwitP2SHWallet,
  WatchOnlyWallet,
} from '../../class';
import { AbstractHDElectrumWallet } from '../../class/wallets/abstract-hd-electrum-wallet';
import { LightningCustodianWallet } from '../../class/wallets/lightning-custodian-wallet';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import ListItem from '../../components/ListItem';
import { SecondButton } from '../../components/SecondButton';
import { useTheme } from '../../components/themes';
import prompt from '../../helpers/prompt';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc, { formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import { useFocusEffect, useRoute, RouteProp, usePreventRemove, useLocale } from '@react-navigation/native';
import { LightningTransaction, Transaction, TWallet } from '../../class/wallets/types';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import { Action } from '../../components/types';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';

type RouteProps = RouteProp<DetailViewStackParamList, 'WalletDetails'>;
const WalletDetails: React.FC = () => {
  const { saveToDisk, wallets, txMetadata, handleWalletDeletion } = useStorage();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const { walletID } = useRoute<RouteProps>().params;
  const { direction } = useLocale();
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [backdoorPressed, setBackdoorPressed] = useState<number>(0);
  const walletRef = useRef<TWallet | undefined>(wallets.find(w => w.getID() === walletID));
  const wallet = walletRef.current as TWallet;
  const [walletUseWithHardwareWallet, setWalletUseWithHardwareWallet] = useState<boolean>(
    wallet.useWithHardwareWalletEnabled ? wallet.useWithHardwareWalletEnabled() : false,
  );
  const [isBIP47Enabled, setIsBIP47Enabled] = useState<boolean>(wallet.isBIP47Enabled ? wallet.isBIP47Enabled() : false);

  const [isContactsVisible, setIsContactsVisible] = useState<boolean>(
    (wallet.allowBIP47 && wallet.allowBIP47() && wallet.isBIP47Enabled && wallet.isBIP47Enabled()) || false,
  );

  const [hideTransactionsInWalletsList, setHideTransactionsInWalletsList] = useState<boolean>(
    wallet.getHideTransactionsInWalletsList ? !wallet.getHideTransactionsInWalletsList() : true,
  );
  const { setOptions, navigate, navigateToWalletsList } = useExtendedNavigation();
  const { colors } = useTheme();
  const [walletName, setWalletName] = useState<string>(wallet.getLabel());

  const [masterFingerprint, setMasterFingerprint] = useState<string | undefined>();
  const [arkAddress, setArkAddress] = useState<string>('');
  const walletTransactionsLength = useMemo<number>(() => wallet.getTransactions().length, [wallet]);
  const derivationPath = useMemo<string | null>(() => {
    try {
      // @ts-expect-error: Need to fix later
      if (wallet.getDerivationPath) {
        // @ts-expect-error: Need to fix later
        const path = wallet.getDerivationPath();
        return path.length > 0 ? path : null;
      }
      return null;
    } catch (e) {
      return null;
    }
  }, [wallet]);
  const [isMasterFingerPrintVisible, setIsMasterFingerPrintVisible] = useState<boolean>(false);

  // Fetch ark address when wallet is a LightningArkWallet
  useEffect(() => {
    const fetchArkAddress = async () => {
      if (wallet.type === LightningArkWallet.type && wallet.getArkAddress) {
        try {
          const address = await wallet.getArkAddress();
          console.log('ark address:', address);
          setArkAddress(address);
        } catch (error: any) {
          setArkAddress(error.message);
        }
      }
    };

    fetchArkAddress();
  }, [wallet]);

  const navigateToOverviewAndDeleteWallet = useCallback(async () => {
    setIsLoading(true);
    const deletionSucceeded = await handleWalletDeletion(wallet.getID());
    if (deletionSucceeded) {
      navigateToWalletsList();
    } else {
      setIsLoading(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const presentWalletHasBalanceAlert = useCallback(async () => {
    triggerHapticFeedback(HapticFeedbackTypes.NotificationWarning);
    try {
      const balance = formatBalanceWithoutSuffix(wallet.getBalance(), BitcoinUnit.SATS, true);
      const walletBalanceConfirmation = await prompt(
        loc.wallets.details_delete_wallet,
        loc.formatString(loc.wallets.details_del_wb_q, { balance }),
        true,
        'numeric',
        true,
        loc.wallets.details_delete,
      );
      // Remove any non-numeric characters before comparison
      const cleanedConfirmation = (walletBalanceConfirmation || '').replace(/[^0-9]/g, '');

      if (Number(cleanedConfirmation) === wallet.getBalance()) {
        navigateToOverviewAndDeleteWallet();
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      } else {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        setIsLoading(false);
        presentAlert({ message: loc.wallets.details_del_wb_err });
      }
    } catch (_) {}
  }, [navigateToOverviewAndDeleteWallet, wallet]);

  const handleDeleteButtonTapped = useCallback(() => {
    triggerHapticFeedback(HapticFeedbackTypes.NotificationWarning);
    presentAlert({
      title: loc.wallets.details_delete_wallet,
      message: loc.wallets.details_are_you_sure,
      buttons: [
        {
          text: loc.wallets.details_yes_delete,
          onPress: async () => {
            const isBiometricsEnabled = await isBiometricUseCapableAndEnabled();
            if (isBiometricsEnabled) {
              if (!(await unlockWithBiometrics())) {
                setIsLoading(false);
                return false;
              }
            }
            if (wallet.getBalance && wallet.getBalance() > 0 && wallet.allowSend && wallet.allowSend()) {
              presentWalletHasBalanceAlert();
            } else {
              navigateToOverviewAndDeleteWallet();
            }
          },
          style: 'destructive',
        },
        {
          text: loc._.cancel,
          onPress: () => {
            setIsLoading(false);
            return false;
          },
          style: 'cancel',
        },
      ],
      options: { cancelable: false },
    });
  }, [isBiometricUseCapableAndEnabled, navigateToOverviewAndDeleteWallet, presentWalletHasBalanceAlert, wallet]);

  const exportHistoryContent = useCallback(() => {
    const headers = [loc.transactions.date, loc.transactions.txid, `${loc.send.create_amount} (${BitcoinUnit.BTC})`, loc.send.create_memo];
    if (wallet.chain === Chain.OFFCHAIN) {
      headers.push(loc.lnd.payment);
    }

    const rows = [headers.join(',')];
    const transactions = wallet.getTransactions();

    transactions.forEach((transaction: Transaction & LightningTransaction) => {
      const value = formatBalanceWithoutSuffix(transaction.value || 0, BitcoinUnit.BTC, true);
      let hash: string = transaction.hash || '';
      let memo = (transaction.hash && txMetadata[transaction.hash]?.memo?.trim()) || '';
      let status = '';

      if (wallet.chain === Chain.OFFCHAIN) {
        hash = transaction.payment_hash ? transaction.payment_hash.toString() : '';
        memo = transaction.memo || '';
        status = transaction.ispaid ? loc._.success : loc.lnd.expired;
        if (typeof hash !== 'string' && (hash as any)?.type === 'Buffer' && (hash as any)?.data) {
          hash = Buffer.from((hash as any).data).toString('hex');
        }
      }

      const date = transaction.timestamp ? new Date(transaction.timestamp * 1000).toString() : '';
      const data = [date, hash, value, memo];

      if (wallet.chain === Chain.OFFCHAIN) {
        data.push(status);
      }

      rows.push(data.join(','));
    });

    return rows.join('\n');
  }, [wallet, txMetadata]);

  const fileName = useMemo(() => {
    const label = wallet.getLabel().replace(' ', '-');
    return `${label}-history.csv`;
  }, [wallet]);

  const toolTipOnPressMenuItem = useCallback(
    async (id: string) => {
      if (id === CommonToolTipActions.Delete.id) {
        handleDeleteButtonTapped();
      } else if (id === CommonToolTipActions.Share.id) {
        await writeFileAndExport(fileName, exportHistoryContent(), true);
      } else if (id === CommonToolTipActions.SaveFile.id) {
        await writeFileAndExport(fileName, exportHistoryContent(), false);
      }
    },
    [exportHistoryContent, fileName, handleDeleteButtonTapped],
  );

  const toolTipActions = useMemo(() => {
    const actions: Action[] = [
      {
        id: loc.wallets.details_export_history,
        text: loc.wallets.details_export_history,
        displayInline: true,
        hidden: walletTransactionsLength === 0,
        subactions: [CommonToolTipActions.Share, CommonToolTipActions.SaveFile],
      },
      CommonToolTipActions.Delete,
    ];

    return actions;
  }, [walletTransactionsLength]);

  const HeaderRight = useMemo(
    () => <HeaderMenuButton disabled={isLoading} onPressMenuItem={toolTipOnPressMenuItem} actions={toolTipActions} />,
    [toolTipOnPressMenuItem, toolTipActions, isLoading],
  );

  useEffect(() => {
    setOptions({
      headerRight: () => HeaderRight,
    });
  }, [HeaderRight, setOptions]);

  useEffect(() => {
    setIsContactsVisible(wallet.allowBIP47 && wallet.allowBIP47() && isBIP47Enabled);
  }, [isBIP47Enabled, wallet]);

  useFocusEffect(
    useCallback(() => {
      const task = InteractionManager.runAfterInteractions(() => {
        if (isMasterFingerPrintVisible && wallet.allowMasterFingerprint && wallet.allowMasterFingerprint()) {
          // @ts-expect-error: Need to fix later
          if (wallet.getMasterFingerprintHex) {
            // @ts-expect-error: Need to fix later
            setMasterFingerprint(wallet.getMasterFingerprintHex());
          }
        } else {
          setMasterFingerprint(undefined);
        }
      });

      return () => task.cancel();
    }, [isMasterFingerPrintVisible, wallet]),
  );

  const stylesHook = StyleSheet.create({
    textLabel1: {
      color: colors.feeText,
      writingDirection: direction,
    },
    textLabel2: {
      color: colors.feeText,
      writingDirection: direction,
    },
    textValue: {
      color: colors.outputValue,
    },
    input: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const navigateToWalletExport = () => {
    navigate('WalletExport', {
      walletID,
    });
  };

  const navigateToMultisigCoordinationSetup = () => {
    navigate('ExportMultisigCoordinationSetupRoot', {
      screen: 'ExportMultisigCoordinationSetup',
      params: {
        walletID,
      },
    });
  };
  const navigateToViewEditCosigners = () => {
    navigate('ViewEditMultisigCosigners', {
      walletID,
    });
  };
  const navigateToXPub = () =>
    navigate('WalletXpub', {
      walletID,
      xpub: wallet.getXpub(),
    });

  const navigateToSignVerify = () =>
    navigate('SignVerifyRoot', {
      screen: 'SignVerify',
      params: {
        walletID,
        address: wallet.getAllExternalAddresses()[0], // works for both single address and HD wallets
      },
    });

  const navigateToAddresses = () =>
    navigate('WalletAddresses', {
      walletID,
    });

  const navigateToContacts = () => navigate('PaymentCodeList', { walletID });

  const exportInternals = async () => {
    if (backdoorPressed < 10) return setBackdoorPressed(backdoorPressed + 1);
    setBackdoorPressed(0);
    if (wallet.type !== HDSegwitBech32Wallet.type) return;
    const fileNameExternals = 'wallet-externals.json';
    const contents = JSON.stringify(
      {
        _balances_by_external_index: wallet._balances_by_external_index,
        _balances_by_internal_index: wallet._balances_by_internal_index,
        _txs_by_external_index: wallet._txs_by_external_index,
        _txs_by_internal_index: wallet._txs_by_internal_index,
        _utxo: wallet._utxo,
        next_free_address_index: wallet.next_free_address_index,
        next_free_change_address_index: wallet.next_free_change_address_index,
        internal_addresses_cache: wallet.internal_addresses_cache,
        external_addresses_cache: wallet.external_addresses_cache,
        _xpub: wallet._xpub,
        gap_limit: wallet.gap_limit,
        label: wallet.label,
        _lastTxFetch: wallet._lastTxFetch,
        _lastBalanceFetch: wallet._lastBalanceFetch,
      },
      null,
      2,
    );

    await writeFileAndExport(fileNameExternals, contents, false);
  };

  const purgeTransactions = async () => {
    if (backdoorPressed < 10) return setBackdoorPressed(backdoorPressed + 1);
    setBackdoorPressed(0);
    const msg = 'Transactions & balances purged. Pls go to main screen and back to rerender screen';

    if (wallet.type === HDSegwitBech32Wallet.type) {
      wallet._txs_by_external_index = {};
      wallet._txs_by_internal_index = {};
      presentAlert({ message: msg });

      wallet._balances_by_external_index = {};
      wallet._balances_by_internal_index = {};
      wallet._lastTxFetch = 0;
      wallet._lastBalanceFetch = 0;
    }

    // @ts-expect-error: Need to fix later
    if (wallet._hdWalletInstance) {
      // @ts-expect-error: Need to fix later
      wallet._hdWalletInstance._txs_by_external_index = {};
      // @ts-expect-error: Need to fix later
      wallet._hdWalletInstance._txs_by_internal_index = {};

      // @ts-expect-error: Need to fix later
      wallet._hdWalletInstance._balances_by_external_index = {};
      // @ts-expect-error: Need to fix later
      wallet._hdWalletInstance._balances_by_internal_index = {};
      // @ts-expect-error: Need to fix later
      wallet._hdWalletInstance._lastTxFetch = 0;
      // @ts-expect-error: Need to fix later
      wallet._hdWalletInstance._lastBalanceFetch = 0;
      presentAlert({ message: msg });
    }
  };

  const walletNameTextInputOnBlur = useCallback(async () => {
    const trimmedWalletName = walletName.trim();
    if (trimmedWalletName.length === 0) {
      const walletLabel = wallet.getLabel();
      setWalletName(walletLabel);
    } else if (wallet.getLabel() !== trimmedWalletName) {
      // Only save if the name has changed
      wallet.setLabel(trimmedWalletName);
      try {
        console.warn('saving wallet name:', trimmedWalletName);
        await saveToDisk();
      } catch (error) {
        console.error((error as Error).message);
      }
    }
  }, [wallet, walletName, saveToDisk]);

  usePreventRemove(false, () => {
    walletNameTextInputOnBlur();
  });

  const onViewMasterFingerPrintPress = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setIsMasterFingerPrintVisible(true);
  };

  return (
    <SafeAreaScrollView centerContent={isLoading} testID="WalletDetailsScroll">
      <>
        {isLoading ? (
          <MalinLoading />
        ) : (
          <>
            <MalinCard style={styles.address}>
              {(() => {
                if (
                  [LegacyWallet.type, SegwitBech32Wallet.type, SegwitP2SHWallet.type].includes(wallet.type) ||
                  (wallet.type === WatchOnlyWallet.type && !wallet.isHd())
                ) {
                  return (
                    <>
                      <Text style={[styles.textLabel1, stylesHook.textLabel1]}>{loc.wallets.details_address.toLowerCase()}</Text>
                      <Text style={[styles.textValue, stylesHook.textValue]} selectable>
                        {(() => {
                          // gracefully handling faulty wallets, so at least user has an option to delete the wallet
                          try {
                            return wallet.getAddress ? wallet.getAddress() : '';
                          } catch (error: any) {
                            return error.message;
                          }
                        })()}
                      </Text>
                    </>
                  );
                }
              })()}
              <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.wallets.add_wallet_name.toLowerCase()}</Text>
              <View style={[styles.input, stylesHook.input]}>
                <TextInput
                  value={walletName}
                  onChangeText={(text: string) => {
                    setWalletName(text);
                  }}
                  onChange={event => {
                    const text = event.nativeEvent.text;
                    setWalletName(text);
                  }}
                  onBlur={walletNameTextInputOnBlur}
                  numberOfLines={1}
                  placeholderTextColor="#81868e"
                  style={[styles.inputText, { writingDirection: direction }]}
                  editable={!isLoading}
                  underlineColorAndroid="transparent"
                  testID="WalletNameInput"
                />
              </View>
              <MalinSpacing20 />
              <Text style={[styles.textLabel1, stylesHook.textLabel1]}>{loc.wallets.details_type.toLowerCase()}</Text>
              <Text style={[styles.textValue, stylesHook.textValue]} selectable>
                {wallet.typeReadable}
              </Text>
              {wallet.type === LightningArkWallet.type && (
                <>
                  <Text style={[styles.textLabel1, stylesHook.textLabel1]}>Ark {loc.wallets.details_address.toLowerCase()}</Text>
                  <Text style={[styles.textValue, stylesHook.textValue]} selectable>
                    {arkAddress}
                  </Text>
                </>
              )}

              {wallet.type === MultisigHDWallet.type && (
                <>
                  <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.wallets.details_multisig_type}</Text>
                  <MalinText>
                    {`${wallet.getM()} / ${wallet.getN()} (${
                      wallet.isNativeSegwit() ? 'native segwit' : wallet.isWrappedSegwit() ? 'wrapped segwit' : 'legacy'
                    })`}
                  </MalinText>
                </>
              )}
              {wallet.type === MultisigHDWallet.type && (
                <>
                  <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.multisig.how_many_signatures_can_malinwallet_make}</Text>
                  <MalinText>{wallet.howManySignaturesCanWeMake()}</MalinText>
                </>
              )}

              {wallet.type === LightningCustodianWallet.type && (
                <>
                  <Text style={[styles.textLabel1, stylesHook.textLabel1]}>{loc.wallets.details_connected_to.toLowerCase()}</Text>
                  <MalinText>{wallet.getBaseURI()}</MalinText>
                </>
              )}

              {wallet.type === HDAezeedWallet.type && (
                <>
                  <Text style={[styles.textLabel1, stylesHook.textLabel1]}>{loc.wallets.identity_pubkey.toLowerCase()}</Text>
                  <MalinText>{wallet.getIdentityPubkey()}</MalinText>
                </>
              )}
              <MalinSpacing20 />
              <>
                <Text onPress={exportInternals} style={[styles.textLabel2, stylesHook.textLabel2]}>
                  {loc.transactions.list_title.toLowerCase()}
                </Text>
                <View style={styles.hardware}>
                  <MalinText>{loc.wallets.details_display}</MalinText>
                  <Switch
                    value={hideTransactionsInWalletsList}
                    onValueChange={async (value: boolean) => {
                      if (wallet.setHideTransactionsInWalletsList) {
                        wallet.setHideTransactionsInWalletsList(!value);
                        triggerHapticFeedback(HapticFeedbackTypes.ImpactLight);
                        setHideTransactionsInWalletsList(!wallet.getHideTransactionsInWalletsList());
                      }
                      try {
                        await saveToDisk();
                      } catch (error: any) {
                        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
                        console.error(error.message);
                      }
                    }}
                  />
                </View>
              </>
              <>
                <Text onPress={purgeTransactions} style={[styles.textLabel2, stylesHook.textLabel2]} testID="PurgeBackdoorButton">
                  {loc.transactions.transactions_count.toLowerCase()}
                </Text>
                <MalinText>{wallet.getTransactions().length}</MalinText>
              </>

              {wallet.allowBIP47 && wallet.allowBIP47() ? (
                <>
                  <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.bip47.payment_code}</Text>
                  <View style={styles.hardware}>
                    <MalinText>{loc.bip47.purpose}</MalinText>
                    <Switch
                      value={isBIP47Enabled}
                      onValueChange={async (value: boolean) => {
                        setIsBIP47Enabled(value);
                        if (wallet.switchBIP47) {
                          wallet.switchBIP47(value);
                          triggerHapticFeedback(HapticFeedbackTypes.ImpactLight);
                        }
                        try {
                          await saveToDisk();
                        } catch (error: unknown) {
                          triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
                          console.error((error as Error).message);
                        }
                      }}
                      testID="BIP47Switch"
                    />
                  </View>
                </>
              ) : null}

              <View>
                {wallet.type === WatchOnlyWallet.type && wallet.isHd && wallet.isHd() && (
                  <>
                    <MalinSpacing10 />
                    <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.wallets.details_advanced.toLowerCase()}</Text>
                    <View style={styles.hardware}>
                      <MalinText>{loc.wallets.details_use_with_hardware_wallet}</MalinText>
                      <Switch
                        value={walletUseWithHardwareWallet}
                        onValueChange={async (value: boolean) => {
                          setWalletUseWithHardwareWallet(value);
                          if (wallet.setUseWithHardwareWalletEnabled) {
                            wallet.setUseWithHardwareWalletEnabled(value);
                            triggerHapticFeedback(HapticFeedbackTypes.ImpactLight);
                          }
                          try {
                            await saveToDisk();
                          } catch (error: unknown) {
                            triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
                            console.error((error as Error).message);
                          }
                        }}
                      />
                    </View>
                  </>
                )}
                <View style={styles.row}>
                  {wallet.allowMasterFingerprint && wallet.allowMasterFingerprint() && (
                    <View style={styles.marginRight16}>
                      <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.wallets.details_master_fingerprint.toLowerCase()}</Text>
                      {isMasterFingerPrintVisible ? (
                        <MalinText selectable>{masterFingerprint ?? <ActivityIndicator />}</MalinText>
                      ) : (
                        <TouchableOpacity onPress={onViewMasterFingerPrintPress}>
                          <MalinText>{loc.multisig.view}</MalinText>
                        </TouchableOpacity>
                      )}
                    </View>
                  )}

                  {derivationPath && (
                    <View>
                      <Text style={[styles.textLabel2, stylesHook.textLabel2]}>{loc.wallets.details_derivation_path}</Text>
                      <MalinText selectable testID="DerivationPath">
                        {derivationPath}
                      </MalinText>
                    </View>
                  )}
                </View>
              </View>
            </MalinCard>
            {(wallet instanceof AbstractHDElectrumWallet || (wallet.type === WatchOnlyWallet.type && wallet.isHd && wallet.isHd())) && (
              <ListItem onPress={navigateToAddresses} title={loc.wallets.details_show_addresses} chevron />
            )}
            {isContactsVisible ? <ListItem onPress={navigateToContacts} title={loc.bip47.contacts} chevron /> : null}
            <MalinCard style={styles.address}>
              <View>
                <MalinSpacing20 />
                <Button onPress={navigateToWalletExport} testID="WalletExport" title={loc.wallets.details_export_backup} />
                {wallet.type === MultisigHDWallet.type && (
                  <>
                    <MalinSpacing20 />
                    <SecondButton
                      onPress={navigateToMultisigCoordinationSetup}
                      testID="MultisigCoordinationSetup"
                      title={loc.multisig.export_coordination_setup.replace(/^\w/, (c: string) => c.toUpperCase())}
                    />
                  </>
                )}

                {wallet.type === MultisigHDWallet.type && (
                  <>
                    <MalinSpacing20 />
                    <SecondButton
                      onPress={navigateToViewEditCosigners}
                      testID="ViewEditCosigners"
                      title={loc.multisig.view_edit_cosigners}
                    />
                  </>
                )}

                {wallet.allowXpub && wallet.allowXpub() && (
                  <>
                    <MalinSpacing20 />
                    <SecondButton onPress={navigateToXPub} testID="XpubButton" title={loc.wallets.details_show_xpub} />
                  </>
                )}
                {wallet.allowSignVerifyMessage && wallet.allowSignVerifyMessage() && (
                  <>
                    <MalinSpacing20 />
                    <SecondButton onPress={navigateToSignVerify} testID="SignVerify" title={loc.addresses.sign_title} />
                  </>
                )}
                <MalinSpacing20 />
                <MalinSpacing20 />
              </View>
            </MalinCard>
          </>
        )}
      </>
    </SafeAreaScrollView>
  );
};

const styles = StyleSheet.create({
  address: {
    alignItems: 'center',
    flex: 1,
  },
  textLabel1: {
    fontWeight: '500',
    fontSize: 14,
    marginVertical: 12,
  },
  textLabel2: {
    fontWeight: '500',
    fontSize: 14,
    marginVertical: 16,
  },
  textValue: {
    fontWeight: '500',
    fontSize: 14,
  },
  input: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    borderRadius: 4,
  },
  inputText: {
    flex: 1,
    marginHorizontal: 8,
    minHeight: 33,
    color: '#81868e',
  },
  hardware: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  row: {
    flexDirection: 'row',
  },
  marginRight16: {
    marginRight: 16,
  },
});

export default WalletDetails;


================================================
FILE: ./screen/wallets/WalletAddresses.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useLayoutEffect, useRef, useReducer, useMemo } from 'react';
import { useRoute, RouteProp, useFocusEffect } from '@react-navigation/native';
import { ActivityIndicator, FlatList, StyleSheet, View, Platform, UIManager } from 'react-native';
import { WatchOnlyWallet } from '../../class';
import { AddressItem } from '../../components/addresses/AddressItem';
import { useTheme } from '../../components/themes';
import { useStorage } from '../../hooks/context/useStorage';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import SegmentedControl from '../../components/SegmentControl';
import loc from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { useSettings } from '../../hooks/context/useSettings';
import { useScreenProtect } from '../../hooks/useScreenProtect';

export const TABS = {
  EXTERNAL: 'receive',
  INTERNAL: 'change',
} as const;

type TabKey = keyof typeof TABS;

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

interface Address {
  key: string;
  index: number;
  address: string;
  isInternal: boolean;
  balance: number;
  transactions: number;
}

interface WalletAddressesState {
  showAddresses: boolean;
  addresses: Address[];
  currentTab: (typeof TABS)[keyof typeof TABS];
  search: string;
}

const SET_SHOW_ADDRESSES = 'SET_SHOW_ADDRESSES' as const;
const SET_ADDRESSES = 'SET_ADDRESSES' as const;
const SET_CURRENT_TAB = 'SET_CURRENT_TAB' as const;
const SET_SEARCH = 'SET_SEARCH' as const;

type WalletAddressesAction =
  | { type: typeof SET_SHOW_ADDRESSES; payload: boolean }
  | { type: typeof SET_ADDRESSES; payload: Address[] }
  | { type: typeof SET_CURRENT_TAB; payload: (typeof TABS)[keyof typeof TABS] }
  | { type: typeof SET_SEARCH; payload: string };

const initialState: WalletAddressesState = {
  showAddresses: false,
  addresses: [],
  currentTab: TABS.EXTERNAL,
  search: '',
};

const reducer = (state: WalletAddressesState, action: WalletAddressesAction): WalletAddressesState => {
  switch (action.type) {
    case SET_SHOW_ADDRESSES:
      return { ...state, showAddresses: action.payload };
    case SET_ADDRESSES:
      return { ...state, addresses: action.payload };
    case SET_CURRENT_TAB:
      return { ...state, currentTab: action.payload };
    case SET_SEARCH:
      return { ...state, search: action.payload };
    default:
      return state;
  }
};

export const totalBalance = ({ c, u } = { c: 0, u: 0 }) => c + u;

export const getAddress = (wallet: any, index: number, isInternal: boolean): Address => {
  let address: string;
  let balance = 0;
  let transactions = 0;

  if (isInternal) {
    address = wallet._getInternalAddressByIndex(index);
    balance = totalBalance(wallet._balances_by_internal_index[index]);
    transactions = wallet._txs_by_internal_index[index]?.length;
  } else {
    address = wallet._getExternalAddressByIndex(index);
    balance = totalBalance(wallet._balances_by_external_index[index]);
    transactions = wallet._txs_by_external_index[index]?.length;
  }

  return {
    key: address,
    index,
    address,
    isInternal,
    balance,
    transactions,
  };
};

export const sortByAddressIndex = (a: Address, b: Address) => {
  return a.index > b.index ? 1 : -1;
};

export const filterByAddressType = (
  type: (typeof TABS)[keyof typeof TABS],
  isInternal: boolean,
  currentType: (typeof TABS)[keyof typeof TABS],
) => {
  return currentType === type ? isInternal === true : isInternal === false;
};

type NavigationProps = NativeStackNavigationProp<DetailViewStackParamList, 'WalletAddresses'>;
type RouteProps = RouteProp<DetailViewStackParamList, 'WalletAddresses'>;

const WalletAddresses: React.FC = () => {
  const [{ showAddresses, addresses, currentTab, search }, dispatch] = useReducer(reducer, initialState);

  const { wallets } = useStorage();
  const { walletID } = useRoute<RouteProps>().params;

  const addressList = useRef<FlatList<Address>>(null);
  const wallet = wallets.find((w: any) => w.getID() === walletID);

  const balanceUnit = wallet?.getPreferredBalanceUnit() ?? BitcoinUnit.BTC;
  const isWatchOnly = wallet?.type === WatchOnlyWallet.type;
  const walletInstance = isWatchOnly ? wallet._hdWalletInstance : wallet;
  const allowSignVerifyMessage = (wallet && 'allowSignVerifyMessage' in wallet && wallet.allowSignVerifyMessage()) ?? false;

  const { colors } = useTheme();
  const { isPrivacyBlurEnabled } = useSettings();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const { setOptions } = useExtendedNavigation<NavigationProps>();

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
  });

  useFocusEffect(
    useCallback(() => {
      if (isPrivacyBlurEnabled) enableScreenProtect();
      return () => {
        disableScreenProtect();
      };
    }, [disableScreenProtect, enableScreenProtect, isPrivacyBlurEnabled]),
  );

  const getAddresses = useMemo(() => {
    if (!walletInstance) return [];
    const newAddresses: Address[] = [];
    const changeMaxIndex = 'next_free_change_address_index' in walletInstance ? walletInstance.next_free_change_address_index : 0;
    for (let index = 0; index <= changeMaxIndex; index++) {
      try {
        newAddresses.push(getAddress(walletInstance, index, true));
      } catch (error: any) {
        console.error('error', error);
      }
    }

    const gapLimit = 'gap_limit' in walletInstance ? walletInstance.gap_limit : 0;
    const addressMaxIndex = 'next_free_address_index' in walletInstance ? walletInstance.next_free_address_index : 0;
    for (let index = 0; index < addressMaxIndex + gapLimit; index++) {
      try {
        newAddresses.push(getAddress(walletInstance, index, false));
      } catch (error: any) {
        console.error('error', error);
      }
    }
    return newAddresses;
  }, [walletInstance]);

  useEffect(() => {
    dispatch({ type: SET_ADDRESSES, payload: getAddresses });
    dispatch({ type: SET_SHOW_ADDRESSES, payload: true });
  }, [getAddresses]);

  const filteredAddresses = useMemo(
    () => addresses.filter(address => filterByAddressType(TABS.INTERNAL, address.isInternal, currentTab)).sort(sortByAddressIndex),
    [addresses, currentTab],
  );

  useEffect(() => {
    if (showAddresses && addressList.current) {
      addressList.current.scrollToIndex({ animated: false, index: 0 });
    }
  }, [showAddresses]);

  useLayoutEffect(() => {
    setOptions({
      headerSearchBarOptions: {
        onChangeText: (event: { nativeEvent: { text: string } }) => dispatch({ type: SET_SEARCH, payload: event.nativeEvent.text }),
      },
    });
  }, [setOptions]);

  const data =
    search.length > 0 ? filteredAddresses.filter(item => item.address.toLowerCase().includes(search.toLowerCase())) : filteredAddresses;

  const keyExtractor = useCallback((item: Address) => item.key, []);

  const renderRow = useCallback(
    ({ item }: { item: Address }) => {
      return (
        <AddressItem item={item} {...item} balanceUnit={balanceUnit} walletID={walletID} allowSignVerifyMessage={allowSignVerifyMessage} />
      );
    },
    [balanceUnit, walletID, allowSignVerifyMessage],
  );

  if (!wallet) {
    return (
      <View>
        <ActivityIndicator />
      </View>
    );
  }

  return (
    <FlatList
      contentContainerStyle={stylesHook.root}
      ref={addressList}
      data={data}
      extraData={data}
      style={styles.root}
      keyExtractor={keyExtractor}
      initialNumToRender={20}
      renderItem={renderRow}
      ListEmptyComponent={search.length > 0 ? null : <ActivityIndicator />}
      centerContent={!showAddresses}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
      automaticallyAdjustsScrollIndicatorInsets
      automaticallyAdjustKeyboardInsets
      ListHeaderComponent={
        <SegmentedControl
          values={Object.values(TABS).map(tab => loc.addresses[`type_${tab}`])}
          selectedIndex={Object.values(TABS).findIndex(tab => tab === currentTab)}
          onChange={index => {
            const tabKey = Object.keys(TABS)[index] as TabKey;
            dispatch({ type: SET_CURRENT_TAB, payload: TABS[tabKey] });
          }}
        />
      }
    />
  );
};

export default WalletAddresses;

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
});


================================================
FILE: ./screen/wallets/WalletTransactions.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp, useFocusEffect, useRoute, useLocale } from '@react-navigation/native';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Dimensions,
  findNodeHandle,
  FlatList,
  LayoutAnimation,
  PixelRatio,
  ScrollView,
  StyleSheet,
  Text,
  View,
  RefreshControl,
} from 'react-native';
import { Icon } from '@rneui/themed';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { isDesktop } from '../../malin_modules/environment';
import * as fs from '../../malin_modules/fs';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { LightningArkWallet, LightningCustodianWallet, MultisigHDWallet, WatchOnlyWallet } from '../../class';
import presentAlert, { AlertType } from '../../components/Alert';
import { FButton, FContainer } from '../../components/FloatButtons';
import { useTheme } from '../../components/themes';
import { TransactionListItem } from '../../components/TransactionListItem';
import TransactionsNavigationHeader, { actionKeys } from '../../components/TransactionsNavigationHeader';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc, { formatBalance } from '../../loc';
import { Chain } from '../../models/bitcoinUnits';
import ActionSheet from '../ActionSheet';
import { useStorage } from '../../hooks/context/useStorage';
import WatchOnlyWarning from '../../components/WatchOnlyWarning';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { Transaction, TWallet } from '../../class/wallets/types';
import getWalletTransactionsOptions, { WalletTransactionsRouteProps } from '../../navigation/helpers/getWalletTransactionsOptions';
import { presentWalletExportReminder } from '../../helpers/presentWalletExportReminder';
import selectWallet from '../../helpers/select-wallet';
import assert from 'assert';
import useMenuElements from '../../hooks/useMenuElements';
import { useSettings } from '../../hooks/context/useSettings';
import useWalletSubscribe from '../../hooks/useWalletSubscribe';
import { getClipboardContent } from '../../malin_modules/clipboard';
import HandOffComponent from '../../components/HandOffComponent';
import { HandOffActivityType } from '../../components/types';
import WalletGradient from '../../class/wallet-gradient';

const buttonFontSize =
  PixelRatio.roundToNearestPixel(Dimensions.get('window').width / 26) > 22
    ? 22
    : PixelRatio.roundToNearestPixel(Dimensions.get('window').width / 26);

type RouteProps = RouteProp<DetailViewStackParamList, 'WalletTransactions'>;

type WalletTransactionsProps = NativeStackScreenProps<DetailViewStackParamList, 'WalletTransactions'>;

type TransactionListItem = Transaction & { type: 'transaction' | 'header' };
const WalletTransactions: React.FC<WalletTransactionsProps> = ({ route }: { route: WalletTransactionsRouteProps }) => {
  const { wallets, saveToDisk } = useStorage();
  const { registerTransactionsHandler, unregisterTransactionsHandler } = useMenuElements();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const { direction } = useLocale();
  const [isLoading, setIsLoading] = useState(false);
  const { params, name } = useRoute<RouteProps>();
  const { walletID } = params;
  const wallet = useWalletSubscribe(walletID);
  const [limit, setLimit] = useState(15);
  const [pageSize] = useState(20);
  const navigation = useExtendedNavigation();
  const { setOptions, navigate } = navigation;
  const { colors } = useTheme();
  const { isElectrumDisabled } = useSettings();
  const walletActionButtonsRef = useRef<View>(null);
  const [lastFetchTimestamp, setLastFetchTimestamp] = useState(() => wallet._lastTxFetch || 0);
  const [fetchFailures, setFetchFailures] = useState(0);
  const [balance, setBalance] = useState(wallet.getBalance());
  const MAX_FAILURES = 3;
  const flatListRef = useRef<FlatList<Transaction>>(null);
  const headerRef = useRef<View>(null);
  const [headerHeight, setHeaderHeight] = useState(0);

  const stylesHook = StyleSheet.create({
    listHeaderText: {
      color: colors.foregroundColor,
    },
    listFooterStyle: {
      height: '100%',
      backgroundColor: colors.background,
    },
    backgroundContainer: {
      backgroundColor: colors.background,
    },
    gradientBackground: {
      backgroundColor: headerHeight > 0 ? WalletGradient.headerColorFor(wallet.type) : colors.background,
      height: headerHeight > 0 ? headerHeight : '30%',
    },
    activityIndicatorStyle: {
      backgroundColor: colors.background,
    },
    sendIcon: { transform: [{ rotate: direction === 'rtl' ? '-225deg' : '225deg' }] },
    receiveIcon: { transform: [{ rotate: direction === 'rtl' ? '-45deg' : '45deg' }] },
  });

  useFocusEffect(
    useCallback(() => {
      setOptions(getWalletTransactionsOptions({ route }));
    }, [route, setOptions]),
  );

  const onBarCodeRead = useCallback(
    (ret?: { data?: any }) => {
      if (!isLoading) {
        setIsLoading(true);
        const parameters = {
          walletID,
          uri: ret?.data ? ret.data : ret,
        };
        if (wallet.chain === Chain.ONCHAIN) {
          navigate('SendDetailsRoot', { screen: 'SendDetails', params: parameters });
        } else {
          navigate('ScanLNDInvoiceRoot', { screen: 'ScanLNDInvoice', params: parameters });
        }
        setIsLoading(false);
      }
    },
    [isLoading, walletID, wallet.chain, navigate],
  );

  useEffect(() => {
    const data = route.params?.onBarScanned;
    if (data) {
      onBarCodeRead({ data });
      navigation.setParams({ onBarScanned: undefined });
    }
  }, [navigation, onBarCodeRead, route.params]);

  const sortedTransactions = useMemo(() => {
    const txs = wallet.getTransactions();
    txs.sort((a, b) => b.timestamp - a.timestamp);
    return txs;
  }, [wallet]);

  const getTransactions = useCallback((lmt = Infinity): Transaction[] => sortedTransactions.slice(0, lmt), [sortedTransactions]);

  const loadMoreTransactions = useCallback(() => {
    if (getTransactions(Infinity).length > limit) {
      setLimit(prev => prev + pageSize);
    }
  }, [getTransactions, limit, pageSize]);

  const refreshTransactions = useCallback(
    async (isManualRefresh = false) => {
      console.debug('refreshTransactions, ', wallet.getLabel());
      if (isElectrumDisabled || isLoading) return;

      const MIN_REFRESH_INTERVAL = 5000; // 5 seconds
      if (!isManualRefresh && lastFetchTimestamp !== 0 && Date.now() - lastFetchTimestamp < MIN_REFRESH_INTERVAL) {
        return; // Prevent auto-refreshing if last fetch was too recent
      }

      if (fetchFailures >= MAX_FAILURES && !isManualRefresh) {
        return; // Silently stop auto-retrying, but allow manual refresh
      }

      // Only show loading indicator on manual refresh or after first successful fetch
      if (isManualRefresh || lastFetchTimestamp !== 0) {
        setIsLoading(true);
      }

      let smthChanged = false;
      try {
        await MalinElectrum.waitTillConnected();
        if (wallet.allowBIP47() && wallet.isBIP47Enabled() && 'fetchBIP47SenderPaymentCodes' in wallet) {
          await wallet.fetchBIP47SenderPaymentCodes();
        }
        const oldBalance = wallet.getBalance();
        await wallet.fetchBalance();
        if (oldBalance !== wallet.getBalance()) smthChanged = true;
        const oldTxLen = wallet.getTransactions().length;
        await wallet.fetchTransactions();
        if ('fetchPendingTransactions' in wallet) {
          await wallet.fetchPendingTransactions();
        }
        if ('fetchUserInvoices' in wallet) {
          await wallet.fetchUserInvoices();
        }
        if (oldTxLen !== wallet.getTransactions().length) smthChanged = true;

        // Success - reset failure counter and update timestamps
        setFetchFailures(0);
        const newTimestamp = Date.now();
        setLastFetchTimestamp(newTimestamp);
      } catch (err: any) {
        const errorMessage: string = err.message;
        setFetchFailures(prev => {
          const newFailures = prev + 1;
          // Only show error on final attempt for automatic refresh
          if ((isManualRefresh || newFailures === MAX_FAILURES) && newFailures >= MAX_FAILURES) {
            if (errorMessage) {
              presentAlert({ message: errorMessage, type: AlertType.Toast });
            }
          }
          setIsLoading(true);
          return newFailures;
        });
      } finally {
        if (smthChanged) {
          await saveToDisk();
          setLimit(prev => prev + pageSize);
        }
        setIsLoading(false);
      }
    },
    [wallet, isElectrumDisabled, isLoading, saveToDisk, pageSize, lastFetchTimestamp, fetchFailures],
  );

  useEffect(() => {
    if (lastFetchTimestamp === 0 && !isLoading && !isElectrumDisabled) {
      refreshTransactions(false).catch(console.error);
    }
  }, [wallet, isElectrumDisabled, isLoading, refreshTransactions, lastFetchTimestamp]);

  const isLightning = useCallback((): boolean => wallet.chain === Chain.OFFCHAIN || false, [wallet]);
  const renderListFooterComponent = () => {
    // if not all txs rendered - display indicator
    return wallet.getTransactions().length > limit ? (
      <ActivityIndicator style={[styles.activityIndicator, stylesHook.activityIndicatorStyle]} />
    ) : (
      <View style={stylesHook.listFooterStyle} />
    );
  };

  const navigateToSendScreen = () => {
    navigate('SendDetailsRoot', {
      screen: 'SendDetails',
      params: {
        walletID,
      },
    });
  };

  const onWalletSelect = useCallback(
    async (selectedWallet: TWallet) => {
      assert(
        wallet.type === LightningCustodianWallet.type || wallet.type === LightningArkWallet.type,
        `internal error, wallet is not ${LightningCustodianWallet.type} or ${LightningArkWallet.type}`,
      );

      // getting refill address, either cached or from the server:
      let toAddress;
      if (wallet.refill_addressess.length > 0) {
        toAddress = wallet.refill_addressess[0];
      } else {
        try {
          await wallet.fetchBtcAddress();
          toAddress = wallet.refill_addressess[0];
        } catch (Err) {
          return presentAlert({ message: (Err as Error).message, type: AlertType.Toast });
        }
      }

      // navigating to pay screen where user can pay to refill address:
      navigate('SendDetailsRoot', {
        screen: 'SendDetails',
        params: {
          transactionMemo: loc.lnd.refill_lnd_balance,
          address: toAddress,
          walletID: selectedWallet.getID(),
        },
      });
    },
    [navigate, wallet],
  );

  const navigateToViewEditCosigners = useCallback(() => {
    navigate('ViewEditMultisigCosigners', {
      walletID,
    });
  }, [navigate, walletID]);

  const onManageFundsPressed = useCallback(
    (id?: string) => {
      if (id === actionKeys.Refill) {
        const availableWallets = wallets.filter(item => item.chain === Chain.ONCHAIN && item.allowSend());
        if (availableWallets.length === 0) {
          presentAlert({ message: loc.lnd.refill_create });
        } else {
          selectWallet(navigation, name, Chain.ONCHAIN).then(onWalletSelect);
        }
      } else if (id === actionKeys.RefillWithExternalWallet) {
        navigate('ReceiveDetails', { walletID });
      }
    },
    [name, navigate, navigation, onWalletSelect, walletID, wallets],
  );

  const getItemLayout = (_: any, index: number) => ({
    length: 64,
    offset: 64 * index,
    index,
  });

  const renderItem = useCallback(
    // eslint-disable-next-line react/no-unused-prop-types
    ({ item }: { item: Transaction }) => (
      <TransactionListItem key={item.hash} item={item} itemPriceUnit={wallet.preferredBalanceUnit} walletID={walletID} />
    ),
    [wallet.preferredBalanceUnit, walletID],
  );

  const choosePhoto = () => {
    fs.showImagePickerAndReadImage()
      .then(data => {
        if (data) {
          onBarCodeRead({ data });
        }
      })
      .catch(error => {
        console.log(error);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ title: loc.errors.error, message: error.message });
      });
  };

  const _keyExtractor = useCallback((_item: any, index: number) => index.toString(), []);

  const pasteFromClipboard = async () => {
    onBarCodeRead({ data: await getClipboardContent() });
  };

  const sendButtonPress = () => {
    if (wallet.chain === Chain.OFFCHAIN) {
      return navigate('ScanLNDInvoiceRoot', { screen: 'ScanLNDInvoice', params: { walletID } });
    }

    if (wallet.type === WatchOnlyWallet.type && wallet.isHd() && !wallet.useWithHardwareWalletEnabled()) {
      return Alert.alert(
        loc.wallets.details_title,
        loc.transactions.enable_offline_signing,
        [
          {
            text: loc._.ok,
            onPress: async () => {
              wallet.setUseWithHardwareWalletEnabled(true);
              await saveToDisk();
              navigateToSendScreen();
            },
            style: 'default',
          },
          { text: loc._.cancel, onPress: () => {}, style: 'cancel' },
        ],
        { cancelable: false },
      );
    }

    navigateToSendScreen();
  };

  const sendButtonLongPress = async () => {
    const isClipboardEmpty = (await getClipboardContent())?.trim().length === 0;
    const options = [loc._.cancel, loc.wallets.list_long_choose, loc.wallets.list_long_scan];
    const cancelButtonIndex = 0;

    if (!isClipboardEmpty) {
      options.push(loc.wallets.paste_from_clipboard);
    }

    ActionSheet.showActionSheetWithOptions(
      {
        title: loc.send.header,
        options,
        cancelButtonIndex,
        anchor: findNodeHandle(walletActionButtonsRef.current) ?? undefined,
      },
      async buttonIndex => {
        switch (buttonIndex) {
          case 0:
            break;
          case 1: {
            choosePhoto();
            break;
          }
          case 2: {
            navigate('ScanQRCode', {
              showImportFileButton: true,
            });
            break;
          }
          case 3:
            if (!isClipboardEmpty) {
              pasteFromClipboard();
            }
            break;
        }
      },
    );
  };

  useEffect(() => {
    const screenKey = `WalletTransactions-${walletID}`;
    registerTransactionsHandler(() => refreshTransactions(true), screenKey);

    return () => {
      unregisterTransactionsHandler(screenKey);
    };
  }, [walletID, refreshTransactions, registerTransactionsHandler, unregisterTransactionsHandler]);

  useFocusEffect(
    useCallback(() => {
      const screenKey = `WalletTransactions-${walletID}`;

      return () => {
        unregisterTransactionsHandler(screenKey);
      };
    }, [walletID, unregisterTransactionsHandler]),
  );

  useEffect(() => {
    const interval = setInterval(() => setBalance(wallet.getBalance()), 1000);
    return () => clearInterval(interval);
  }, [wallet]);

  const walletBalance = useMemo(() => {
    if (wallet.hideBalance) return '';
    if (isNaN(balance) || balance === 0) return '';
    return formatBalance(balance, wallet.preferredBalanceUnit, true);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [wallet, wallet.hideBalance, wallet.preferredBalanceUnit, balance]);

  const handleScroll = useCallback(
    (event: any) => {
      const offsetY = event.nativeEvent.contentOffset.y;
      const combinedHeight = 180;
      if (offsetY < combinedHeight) {
        setOptions({ ...getWalletTransactionsOptions({ route }), headerTitle: undefined });
      } else {
        navigation.setOptions({
          headerTitle: `${wallet.getLabel()} ${walletBalance}`,
        });
      }
    },
    [navigation, wallet, walletBalance, setOptions, route],
  );

  const measureHeaderHeight = useCallback(() => {
    if (!headerRef.current) {
      // If header ref is not available, use default background
      setHeaderHeight(0);
      return;
    }

    headerRef.current.measure((x, y, width, height, pageX, pageY) => {
      // Check if the header is actually visible
      if (height === 0 || pageY < 0) {
        // Header is not visible, use default background
        setHeaderHeight(0);
        return;
      }

      const fullHeight = pageY + height;
      if (fullHeight > 0) {
        setHeaderHeight(fullHeight);
      }
    });
  }, []);

  useEffect(() => {
    const timer = setTimeout(measureHeaderHeight, 100);
    return () => clearTimeout(timer);
  }, [walletID, measureHeaderHeight]);

  const ListHeaderComponent = useCallback(
    () => (
      <View ref={headerRef} onLayout={measureHeaderHeight}>
        <TransactionsNavigationHeader
          wallet={wallet}
          onWalletUnitChange={async selectedUnit => {
            wallet.preferredBalanceUnit = selectedUnit;
            await saveToDisk();
          }}
          unit={wallet.preferredBalanceUnit}
          onWalletBalanceVisibilityChange={async isShouldBeVisible => {
            const isBiometricsEnabled = await isBiometricUseCapableAndEnabled();
            if (wallet.hideBalance && isBiometricsEnabled) {
              const unlocked = await unlockWithBiometrics();
              if (!unlocked) throw new Error('Biometrics failed');
            }
            wallet.hideBalance = isShouldBeVisible;
            await saveToDisk();
          }}
          onManageFundsPressed={id => {
            if (wallet.type === MultisigHDWallet.type) {
              navigateToViewEditCosigners();
            } else if (wallet.type === LightningCustodianWallet.type || wallet.type === LightningArkWallet.type) {
              if (wallet.getUserHasSavedExport()) {
                if (!id) return;
                onManageFundsPressed(id);
              } else {
                presentWalletExportReminder()
                  .then(async () => {
                    if (!id) return;
                    wallet.setUserHasSavedExport(true);
                    await saveToDisk();
                    onManageFundsPressed(id);
                  })
                  .catch(() => {
                    navigate('WalletExport', {
                      walletID,
                    });
                  });
              }
            }
          }}
        />
        <>
          <View style={[styles.flex, stylesHook.backgroundContainer]}>
            <View style={styles.listHeaderTextRow}>
              <Text style={[styles.listHeaderText, stylesHook.listHeaderText]}>{loc.transactions.list_title}</Text>
            </View>
          </View>
          <View style={stylesHook.backgroundContainer}>
            {wallet.type === WatchOnlyWallet.type && wallet.isWatchOnlyWarningVisible && (
              <WatchOnlyWarning
                handleDismiss={() => {
                  wallet.isWatchOnlyWarningVisible = false;
                  LayoutAnimation.configureNext(LayoutAnimation.Presets.linear);
                  saveToDisk();
                }}
              />
            )}
          </View>
        </>
      </View>
    ),
    [
      wallet,
      measureHeaderHeight,
      stylesHook.backgroundContainer,
      stylesHook.listHeaderText,
      saveToDisk,
      isBiometricUseCapableAndEnabled,
      navigateToViewEditCosigners,
      onManageFundsPressed,
      navigate,
      walletID,
    ],
  );

  useEffect(() => {
    if (flatListRef.current) {
      flatListRef.current.scrollToOffset({ offset: 0, animated: true });
    }
  }, [walletID]);

  return (
    <View style={[styles.flex, stylesHook.backgroundContainer]}>
      <View style={[styles.refreshIndicatorBackground, stylesHook.gradientBackground]} testID="TransactionsListView" />
      <FlatList<Transaction>
        ref={flatListRef}
        getItemLayout={getItemLayout}
        updateCellsBatchingPeriod={50}
        onEndReachedThreshold={0.3}
        onEndReached={loadMoreTransactions}
        ListFooterComponent={renderListFooterComponent}
        data={getTransactions(limit)}
        extraData={wallet}
        keyExtractor={_keyExtractor}
        renderItem={renderItem}
        initialNumToRender={10}
        removeClippedSubviews
        contentContainerStyle={stylesHook.backgroundContainer}
        contentInset={{ top: 0, left: 0, bottom: 90, right: 0 }}
        maxToRenderPerBatch={10}
        onScroll={handleScroll}
        windowSize={15}
        scrollEventThrottle={16}
        ListHeaderComponent={ListHeaderComponent}
        ListEmptyComponent={
          <ScrollView style={[styles.emptyTxsContainer, stylesHook.backgroundContainer]} contentContainerStyle={styles.scrollViewContent}>
            <Text numberOfLines={0} style={styles.emptyTxs} testID="TransactionsListEmpty">
              {(isLightning() && loc.wallets.list_empty_txs1_lightning) || loc.wallets.list_empty_txs1}
            </Text>
            {isLightning() && <Text style={styles.emptyTxsLightning}>{loc.wallets.list_empty_txs2_lightning}</Text>}
          </ScrollView>
        }
        refreshControl={
          !isDesktop && !isElectrumDisabled ? (
            <RefreshControl refreshing={isLoading} onRefresh={() => refreshTransactions(true)} tintColor={colors.msSuccessCheck} />
          ) : undefined
        }
      />

      <FContainer ref={walletActionButtonsRef}>
        {wallet.allowReceive() && (
          <FButton
            testID="ReceiveButton"
            text={loc.receive.header}
            onPress={() => {
              if (wallet.chain === Chain.OFFCHAIN) {
                navigate('LNDCreateInvoiceRoot', { screen: 'LNDCreateInvoice', params: { walletID } });
              } else {
                navigate('ReceiveDetails', { walletID });
              }
            }}
            icon={
              <View style={styles.iconContainer}>
                <Icon
                  name="arrow-down"
                  size={buttonFontSize}
                  type="font-awesome"
                  color={colors.buttonAlternativeTextColor}
                  style={stylesHook.receiveIcon}
                />
              </View>
            }
          />
        )}
        {(wallet.allowSend() || (wallet.type === WatchOnlyWallet.type && wallet.isHd())) && (
          <FButton
            onLongPress={sendButtonLongPress}
            onPress={sendButtonPress}
            text={loc.send.header}
            testID="SendButton"
            icon={
              <View style={styles.iconContainer}>
                <Icon
                  name="arrow-down"
                  size={buttonFontSize}
                  type="font-awesome"
                  color={colors.buttonAlternativeTextColor}
                  style={stylesHook.sendIcon}
                />
              </View>
            }
          />
        )}
      </FContainer>
      {wallet.chain === Chain.ONCHAIN && wallet.type !== MultisigHDWallet.type && wallet.getXpub && wallet.getXpub() ? (
        <HandOffComponent
          title={wallet.getLabel()}
          type={HandOffActivityType.Xpub}
          url={`https://www.blockonomics.co/#/search?q=${wallet.getXpub()}`}
        />
      ) : null}
    </View>
  );
};

export default WalletTransactions;

const styles = StyleSheet.create({
  flex: { flex: 1 },
  scrollViewContent: { flex: 1, justifyContent: 'center', paddingHorizontal: 16, paddingBottom: 500 },
  activityIndicator: { marginVertical: 20 },
  listHeaderTextRow: { flex: 1, margin: 16, flexDirection: 'row', justifyContent: 'space-between' },
  listHeaderText: { marginTop: 8, marginBottom: 8, fontWeight: 'bold', fontSize: 24 },
  refreshIndicatorBackground: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
  },
  emptyTxsContainer: { height: '10%', minHeight: '10%', flex: 1 },
  emptyTxs: { fontSize: 18, color: '#9aa0aa', textAlign: 'center', marginVertical: 16 },
  emptyTxsLightning: { fontSize: 18, color: '#9aa0aa', textAlign: 'center', fontWeight: '600' },
  iconContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    width: buttonFontSize * 1.5,
    height: buttonFontSize * 1.5,
    overflow: 'visible',
  },
});


================================================
FILE: ./screen/wallets/SelectWallet.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useState, useRef, useCallback } from 'react';
import { useNavigationState, useRoute, RouteProp } from '@react-navigation/native';
import { ActivityIndicator, StyleSheet, View } from 'react-native';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinText } from '../../MalinComponents';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { Chain } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import WalletsCarousel from '../../components/WalletsCarousel';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { TWallet } from '../../class/wallets/types';
import { pop } from '../../NavigationService';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type NavigationProps = NativeStackNavigationProp<SendDetailsStackParamList, 'SelectWallet'>;

type RouteProps = RouteProp<SendDetailsStackParamList, 'SelectWallet'>;

const SelectWallet: React.FC = () => {
  const route = useRoute<RouteProps>();
  const {
    chainType,
    onWalletSelect,
    availableWallets,
    noWalletExplanationText,
    onChainRequireSend = false,
    selectedWalletID,
  } = route.params;
  const [isLoading, setIsLoading] = useState(true);
  const navigation = useExtendedNavigation<NavigationProps>();
  const { wallets } = useStorage();
  const { colors } = useTheme();
  const isModal = useNavigationState(state => state.routes.length > 1);
  const walletsCarousel = useRef<any>(null);
  const previousRouteName = useNavigationState(state => state.routes[state.routes.length - 2]?.name);
  const [filteredWallets, setFilteredWallets] = useState<TWallet[]>([]);

  const stylesHook = StyleSheet.create({
    loading: {
      backgroundColor: colors.background,
    },
  });

  const filterWallets = useCallback(() => {
    if (availableWallets && availableWallets.length > 0) {
      return availableWallets;
    }

    if (!onChainRequireSend && chainType === Chain.ONCHAIN) {
      return wallets.filter(item => item.chain === Chain.ONCHAIN);
    }

    if (chainType) {
      return wallets.filter(item => item.chain === chainType && item.allowSend());
    }

    return wallets.filter(item => item.allowSend());
  }, [availableWallets, chainType, onChainRequireSend, wallets]);

  // Initialize filtered wallets and handle loading state
  useEffect(() => {
    console.log('SelectWallet - useEffect');
    const filtered = filterWallets();
    setFilteredWallets(filtered);
    setIsLoading(false);
  }, [filterWallets]);

  // Scroll to the selected wallet if provided
  useEffect(() => {
    if (!isLoading && selectedWalletID && walletsCarousel.current) {
      const walletIndex = filteredWallets.findIndex(wallet => wallet.getID() === selectedWalletID);

      if (walletIndex !== -1) {
        // Add a slight delay to ensure the carousel is fully rendered
        setTimeout(() => {
          if (walletsCarousel.current) {
            walletsCarousel.current.scrollToIndex({
              index: walletIndex,
              animated: true,
              viewPosition: 0.5, // Center the item
            });

            console.log(`Scrolled to wallet index ${walletIndex} with ID ${selectedWalletID}`);
          }
        }, 200);
      } else {
        console.log(`Wallet with ID ${selectedWalletID} not found in filtered wallets`);
      }
    }
  }, [isLoading, selectedWalletID, filteredWallets]);

  useEffect(() => {
    navigation.setOptions({
      statusBarStyle: isLoading || filteredWallets.length === 0 ? 'light' : 'auto',
    });
  }, [isLoading, filteredWallets, navigation]);

  useEffect(() => {
    if (!isModal) {
      navigation.setOptions({ headerBackVisible: false });
    }
  }, [isModal, navigation]);

  const onPress = (item: TWallet) => {
    triggerHapticFeedback(HapticFeedbackTypes.Selection);
    if (onWalletSelect) {
      // @ts-ignore idk how to fix
      onWalletSelect(item, { navigation: { pop, navigate: navigation.navigate } });
    } else {
      // @ts-ignore: fix later
      navigation.popTo(previousRouteName, { walletID: item.getID(), merge: true });
    }
  };

  if (isLoading) {
    return (
      <View style={[styles.loading, stylesHook.loading]}>
        <ActivityIndicator />
      </View>
    );
  }

  if (filteredWallets.length <= 0) {
    return (
      <SafeArea>
        <View style={styles.noWallets}>
          <MalinText style={styles.center}>{loc.wallets.select_no_bitcoin}</MalinText>
          <MalinSpacing20 />
          <MalinText style={styles.center}>{noWalletExplanationText || loc.wallets.select_no_bitcoin_exp}</MalinText>
        </View>
      </SafeArea>
    );
  }

  return (
    <WalletsCarousel
      data={filteredWallets}
      scrollEnabled
      onPress={onPress}
      ref={walletsCarousel}
      testID="SelectWalletsList"
      horizontal={false}
      style={styles.walletsCarousel}
      animateChanges={true}
    />
  );
};

export default SelectWallet;

const styles = StyleSheet.create({
  loading: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'center',
    paddingTop: 20,
  },

  noWallets: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: 20,
  },
  center: {
    textAlign: 'center',
  },
  walletsCarousel: {
    flex: 1,
    paddingHorizontal: 16,
  },
});


================================================
FILE: ./screen/wallets/PaymentCodesList.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useMemo, useState } from 'react';
import Clipboard from '@react-native-clipboard/clipboard';
import { RouteProp, StackActions, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import assert from 'assert';
import { sha256 } from '@noble/hashes/sha256';
import { SectionList, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { satoshiToLocalCurrency } from '../../malin_modules/currency';
import { HDSegwitBech32Wallet } from '../../class';
import { ContactList } from '../../class/contact-list';
import { AbstractHDElectrumWallet } from '../../class/wallets/abstract-hd-electrum-wallet';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import { useTheme } from '../../components/themes';
import ToolTipMenu from '../../components/TooltipMenu';
import { Action } from '../../components/types';
import confirm from '../../helpers/confirm';
import prompt from '../../helpers/prompt';
import loc, { formatBalance } from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import SafeArea from '../../components/SafeArea';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useStorage } from '../../hooks/context/useStorage';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { MalinLoading } from '../../components/MalinLoading';

interface DataSection {
  title: string;
  data: string[];
}

enum Actions {
  pay,
  rename,
  copyToClipboard,
  hide,
}

const actionKeys: Action[] = [
  {
    id: Actions.pay,
    text: loc.bip47.pay_this_contact,
    icon: {
      iconValue: 'paperplane',
    },
  },
  {
    id: Actions.rename,
    text: loc.bip47.rename_contact,
    icon: {
      iconValue: 'pencil',
    },
  },
  {
    id: Actions.copyToClipboard,
    text: loc.bip47.copy_payment_code,
    icon: {
      iconValue: 'doc.on.doc',
    },
  },
  {
    id: Actions.hide,
    text: loc.bip47.hide_contact,
    icon: {
      iconValue: 'eye.slash',
    },
  },
];

function onlyUnique(value: any, index: number, self: any[]) {
  return self.indexOf(value) === index;
}

type PaymentCodeListRouteProp = RouteProp<DetailViewStackParamList, 'PaymentCodeList'>;
type PaymentCodesListNavigationProp = NativeStackNavigationProp<DetailViewStackParamList, 'PaymentCodeList'>;

export default function PaymentCodesList() {
  const navigation = useExtendedNavigation<PaymentCodesListNavigationProp>();
  const route = useRoute<PaymentCodeListRouteProp>();
  const { walletID } = route.params;
  const { wallets, txMetadata, counterpartyMetadata, saveToDisk } = useStorage();
  const [reload, setReload] = useState<number>(0);
  const [data, setData] = useState<DataSection[]>([]);
  const { colors } = useTheme();
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [loadingText, setLoadingText] = useState<string>('Loading...');
  const state = navigation.getState();
  const previousRouteIndex = state.index - 1;

  let previousRouteName: string | null;
  if (previousRouteIndex >= 0) {
    previousRouteName = state.routes[previousRouteIndex].name;
  }

  useEffect(() => {
    if (!walletID) return;

    const foundWallet = wallets.find(w => w.getID() === walletID) as unknown as AbstractHDElectrumWallet;
    if (!foundWallet) return;

    const newData: DataSection[] = [
      {
        title: '',
        data: foundWallet.getBIP47SenderPaymentCodes().concat(foundWallet.getBIP47ReceiverPaymentCodes()).filter(onlyUnique),
      },
    ];
    setData(newData);
  }, [walletID, wallets, reload]);

  const toolTipActions = useMemo(() => actionKeys, []);

  const shortenContactName = (name: string): string => {
    if (name.length < 20) return name;
    return name.substr(0, 10) + '...' + name.substr(name.length - 10, 10);
  };

  const onToolTipPress = async (id: any, pc: string) => {
    try {
      setIsLoading(true);
      await _onToolTipPress(id, pc);
    } catch (error: any) {
      presentAlert({ message: error.message });
    } finally {
      setIsLoading(false);
    }
  };

  const _onToolTipPress = async (id: any, pc: string) => {
    switch (String(id)) {
      case String(Actions.copyToClipboard): {
        Clipboard.setString(pc);
        break;
      }
      case String(Actions.rename): {
        const newName = await prompt(loc.bip47.rename, loc.bip47.provide_name, true, 'plain-text');
        if (!newName) return;

        counterpartyMetadata[pc] = { label: newName };
        setReload(Math.random());
        await saveToDisk();
        break;
      }
      case String(Actions.pay): {
        const cl = new ContactList();
        // ok its a SilentPayments code/regular address, no need to check for notif tx, ok to just send
        if (cl.isBip352PaymentCodeValid(pc) || cl.isAddressValid(pc)) {
          _navigateToSend(pc);
          return;
        }
        // check if notif tx is in place and has confirmations
        const foundWallet = wallets.find(w => w.getID() === walletID) as unknown as HDSegwitBech32Wallet;
        assert(foundWallet, 'Internal error: cant find walletID ' + walletID);
        const notifTx = foundWallet.getBIP47NotificationTransaction(pc);
        if (!notifTx) {
          await _addContact(pc);
          return;
        }
        if (!notifTx.confirmations) {
          // when we just sent the confirmation tx and it havent confirmed yet
          presentAlert({ message: loc.bip47.notification_tx_unconfirmed });
          return;
        }
        _navigateToSend(pc);
        break;
      }
      case String(Actions.hide): {
        if (!(await confirm(loc.wallets.details_are_you_sure))) {
          return;
        }
        counterpartyMetadata[pc] = { label: counterpartyMetadata[pc]?.label, hidden: true };
        setReload(Math.random());
        await saveToDisk();
        break;
      }
      default:
        break;
    }
  };

  const _navigateToSend = (pc: string) => {
    const previousRoute = state.routes[state.routes.length - 2];

    if (previousRoute.name === ('SendDetails' as string)) {
      const popToAction = StackActions.popTo('SendDetails', {
        walletID,
        addRecipientParams: {
          address: pc,
        },
        merge: true,
      });
      navigation.dispatch(popToAction);
    } else {
      navigation.navigate('SendDetailsRoot', {
        paymentCode: pc,
        walletID,
      });
    }
  };

  const renderItem = (pc: string, index: number) => {
    if (counterpartyMetadata?.[pc]?.hidden) return null; // hidden contact, do not render

    const color = Buffer.from(sha256(pc)).toString('hex').substring(0, 6);

    const displayName = shortenContactName(counterpartyMetadata?.[pc]?.label || pc);

    if (previousRouteName === 'SendDetails') {
      return (
        <TouchableOpacity onPress={() => onToolTipPress(Actions.pay, pc)}>
          <View style={styles.contactRowContainer}>
            <View style={[styles.circle, { backgroundColor: '#' + color }]} />
            <View style={styles.contactRowBody}>
              <Text testID={`ContactListItem${index}`} style={[styles.contactRowNameText, { color: colors.labelText }]}>
                {displayName}
              </Text>
            </View>
          </View>
          <View style={styles.stick} />
        </TouchableOpacity>
      );
    }

    return (
      <ToolTipMenu
        actions={toolTipActions}
        onPressMenuItem={(item: any) => onToolTipPress(item, pc)}
        isButton={true}
        isMenuPrimaryAction={true}
      >
        <View style={styles.contactRowContainer}>
          <View style={[styles.circle, { backgroundColor: '#' + color }]} />
          <View style={styles.contactRowBody}>
            <Text testID={`ContactListItem${index}`} style={[styles.contactRowNameText, { color: colors.labelText }]}>
              {displayName}
            </Text>
          </View>
        </View>
        <View style={styles.stick} />
      </ToolTipMenu>
    );
  };

  const onAddContactPress = async () => {
    try {
      const newPc = await prompt(loc.bip47.add_contact, loc.bip47.provide_payment_code, true, 'plain-text');
      if (!newPc) return;

      await _addContact(newPc);
    } catch (error: any) {
      console.debug(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  const _addContact = async (newPc: string) => {
    const foundWallet = wallets.find(w => w.getID() === walletID) as unknown as HDSegwitBech32Wallet;
    assert(foundWallet, 'Internal error: cant find walletID ' + walletID);

    if (counterpartyMetadata[newPc]?.hidden) {
      // contact already present, just need to unhide it
      counterpartyMetadata[newPc].hidden = false;
      await saveToDisk();
      setReload(Math.random());
      return;
    }

    const cl = new ContactList();

    if (cl.isAddressValid(newPc)) {
      // this is not a payment code but a regular onchain address. pretending its a payment code and adding it
      foundWallet.addBIP47Receiver(newPc);
      await saveToDisk();
      setReload(Math.random());
      return;
    }

    if (!cl.isPaymentCodeValid(newPc)) {
      presentAlert({ message: loc.bip47.invalid_pc });
      return;
    }

    if (cl.isBip352PaymentCodeValid(newPc)) {
      // ok its a SilentPayments code, notification tx is not needed, just add it to recipients:
      foundWallet.addBIP47Receiver(newPc);
      await saveToDisk();
      setReload(Math.random());
      return;
    }

    setIsLoading(true);

    const notificationTx = foundWallet.getBIP47NotificationTransaction(newPc);

    if (notificationTx && notificationTx.confirmations > 0) {
      // we previously sent notification transaction to him, so just need to add him to internals
      foundWallet.addBIP47Receiver(newPc);
      await foundWallet.syncBip47ReceiversAddresses(newPc); // so we can unwrap and save all his possible addresses
      // (for a case if already have txs with him, we will now be able to label them on tx list)
      await saveToDisk();
      setReload(Math.random());
      return;
    }

    if (notificationTx && notificationTx.confirmations === 0) {
      // for a rare case when we just sent the confirmation tx and it havent confirmed yet
      presentAlert({ message: loc.bip47.notification_tx_unconfirmed });
      return;
    }

    // need to send notif tx:

    setLoadingText('Fetching UTXO...');
    await foundWallet.fetchUtxo();
    setLoadingText('Fetching fees...');
    const fees = await MalinElectrum.estimateFees();
    setLoadingText('Fetching change address...');
    const changeAddress = await foundWallet.getChangeAddressAsync();
    setLoadingText('Crafting notification transaction...');
    if (foundWallet.getUtxo().length === 0) {
      // no balance..?
      presentAlert({ message: loc.send.details_total_exceeds_balance });
      return;
    }
    const { tx, fee } = foundWallet.createBip47NotificationTransaction(foundWallet.getUtxo(), newPc, fees.fast, changeAddress);

    if (!tx) {
      presentAlert({ message: loc.bip47.failed_create_notif_tx });
      return;
    }

    setLoadingText('');
    if (
      await confirm(
        loc.bip47.onchain_tx_needed,
        `${loc.send.create_fee}: ${formatBalance(fee, BitcoinUnit.BTC)} (${satoshiToLocalCurrency(fee)}). `,
      )
    ) {
      setLoadingText('Broadcasting...');
      try {
        await foundWallet.broadcastTx(tx.toHex());
        foundWallet.addBIP47Receiver(newPc);
        presentAlert({ message: loc.bip47.notif_tx_sent });
        txMetadata[tx.getId()] = { memo: loc.bip47.notif_tx };
        setReload(Math.random());
        await new Promise(resolve => setTimeout(resolve, 5000)); // tx propagate on backend so our fetch will actually get the new tx
      } catch (_) {}
      setLoadingText('Fetching transactions...');
      await foundWallet.fetchTransactions();
      setLoadingText('');
    }
  };

  if (isLoading) {
    return (
      <View style={styles.container}>
        <MalinLoading />
        <Text>{loadingText}</Text>
      </View>
    );
  }

  return (
    <SafeArea style={styles.container}>
      {!walletID ? (
        <Text>Internal error</Text>
      ) : (
        <View style={styles.sectionListContainer}>
          <SectionList
            sections={data}
            keyExtractor={(item, index) => item + index}
            renderItem={({ item, index }) => renderItem(item, index)}
          />
        </View>
      )}

      <Button title={loc.bip47.add_contact} onPress={onAddContactPress} />
    </SafeArea>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  sectionListContainer: { flex: 1, width: '100%' },
  circle: {
    width: 35,
    height: 35,
    borderRadius: 25,
  },
  contactRowBody: { flex: 6, justifyContent: 'center', top: -3 },
  contactRowNameText: { marginLeft: 10, fontSize: 16 },
  contactRowContainer: { flexDirection: 'row', padding: 15 },
  stick: { borderStyle: 'solid', borderWidth: 0.5, borderColor: 'gray', opacity: 0.5, top: 0, left: -10, width: '110%' },
});


================================================
FILE: ./screen/wallets/signVerify.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useState } from 'react';
import { useRoute } from '@react-navigation/native';
import {
  ActivityIndicator,
  Keyboard,
  LayoutAnimation,
  Platform,
  ScrollView,
  StyleSheet,
  TextInput,
  View
} from 'react-native';
import { Icon } from '@rneui/themed';
import Share from 'react-native-share';
import triggerHapticFeedback, {
  HapticFeedbackTypes
} from '../../malin_modules/hapticFeedback';
import { MalinFormLabel } from '../../MalinComponents';
import presentAlert from '../../components/Alert';
import { FButton, FContainer } from '../../components/FloatButtons';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import {
  DoneAndDismissKeyboardInputAccessory,
  DoneAndDismissKeyboardInputAccessoryViewID,
} from '../../components/DoneAndDismissKeyboardInputAccessory';
import {
  MalinSpacing10,
  MalinSpacing20,
  MalinSpacing40
} from '../../components/MalinSpacing';

const SignVerify = () => {
  const { colors } = useTheme();
  const { wallets, sleep } = useStorage();
  const { params } = useRoute();
  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false);
  const [address, setAddress] = useState(params.address ?? '');
  const [message, setMessage] = useState(params.message ?? '');
  const [signature, setSignature] = useState('');
  const [loading, setLoading] = useState(false);
  const [messageHasFocus, setMessageHasFocus] = useState(false);
  const [isShareVisible, setIsShareVisible] = useState(false);

  const wallet = wallets.find((w) => w.getID() === params.walletID);
  const isToolbarVisibleForAndroid =
    Platform.OS === 'android' && messageHasFocus && isKeyboardVisible;

  useEffect(() => {
    const showSubscription = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow',
      () => setIsKeyboardVisible(true),
    )
    const hideSubscription = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide',
      () => setIsKeyboardVisible(false),
    )
    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    }
  }, []);

  const stylesHooks = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    text: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
      color: colors.foregroundColor,
    }
  });

  const handleShare = () => {
    const baseUri = 'https://malinwallet.github.io/VerifySignature';
    const uri = `${baseUri}?a=${address}&m=${encodeURIComponent(message)}&s=${encodeURIComponent(signature)}`;
    Share.open({ message: uri }).catch((error) => console.log(error));
  }

  const handleSign = async () => {
    setLoading(true);
    await sleep(10); // wait for loading indicator to appear
    let newSignature;
    try {
      newSignature = wallet.signMessage(message, address);
      setSignature(newSignature);
      setIsShareVisible(true);
    } catch (e) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ title: loc.errors.error, message: e.message });
    }

    setLoading(false);
  }

  const handleVerify = async () => {
    setLoading(true);
    await sleep(10); // wait for loading indicator to appear
    try {
      const res = wallet.verifyMessage(message, address, signature);
      presentAlert({
        title: res ? loc._.success : loc.errors.error,
        message: res
          ? loc.addresses.sign_signature_correct
          : loc.addresses.sign_signature_incorrect,
      })
      if (res) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      }
    } catch (e) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ title: loc.errors.error, message: e.message });
    }
    setLoading(false);
  }

  const handleFocus = (value) => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setMessageHasFocus(value);
  }

  if (loading) {
    return (
      <View style={[stylesHooks.root, styles.loading]}>
        <ActivityIndicator />
      </View>
    );
  }

  return (
    <ScrollView
      automaticallyAdjustContentInsets
      automaticallyAdjustKeyboardInsets
      contentInsetAdjustmentBehavior="automatic"
      contentContainerStyle={styles.root}
      style={[styles.root, stylesHooks.root]}
    >
      {!isKeyboardVisible && (
        <>
          <MalinSpacing20 />
          <MalinFormLabel>{loc.addresses.sign_help}</MalinFormLabel>
          <MalinSpacing20 />
        </>
      )}

      <TextInput
        multiline
        textAlignVertical="top"
        blurOnSubmit
        placeholder={loc.addresses.sign_placeholder_address}
        placeholderTextColor="#81868e"
        value={address}
        onChangeText={(t) => setAddress(t.replace('\n', ''))}
        testID="Signature"
        style={[styles.text, stylesHooks.text]}
        autoCorrect={false}
        autoCapitalize="none"
        spellCheck={false}
        editable={!loading}
      />
      <MalinSpacing10 />

      <TextInput
        multiline
        textAlignVertical="top"
        blurOnSubmit
        placeholder={loc.addresses.sign_placeholder_signature}
        placeholderTextColor="#81868e"
        value={signature}
        onChangeText={(t) => setSignature(t.replace('\n', ''))}
        testID="Signature"
        style={[styles.text, stylesHooks.text]}
        autoCorrect={false}
        autoCapitalize="none"
        spellCheck={false}
        editable={!loading}
      />
      <MalinSpacing10 />

      <TextInput
        multiline
        placeholder={loc.addresses.sign_placeholder_message}
        placeholderTextColor="#81868e"
        value={message}
        onChangeText={setMessage}
        testID="Message"
        inputAccessoryViewID={DoneAndDismissKeyboardInputAccessoryViewID}
        style={[styles.flex, styles.text, styles.textMessage, stylesHooks.text]}
        autoCorrect={false}
        autoCapitalize="none"
        spellCheck={false}
        editable={!loading}
        onFocus={() => handleFocus(true)}
        onBlur={() => handleFocus(false)}
      />
      <MalinSpacing40 />

      {isShareVisible && !isKeyboardVisible && (
        <>
          <FContainer inline>
            <FButton
              onPress={handleShare}
              text={loc.multisig.share}
              icon={
                <View style={styles.buttonsIcon}>
                  <Icon
                    name='external-link'
                    size={16}
                    type='font-awesome'
                    color={colors.buttonAlternativeTextColor}
                  />
                </View>
              }
            />
          </FContainer>
          <MalinSpacing10 />
        </>
      )}

      {!isKeyboardVisible && (
        <>
          <FContainer inline>
            <FButton
              onPress={handleSign}
              text={loc.addresses.sign_sign}
              disabled={loading}
            />
            <FButton
              onPress={handleVerify}
              text={loc.addresses.sign_verify}
              disabled={loading}
            />
          </FContainer>
          <MalinSpacing10 />
        </>
      )}

      {Platform.select({
        ios: (
          <DoneAndDismissKeyboardInputAccessory
            onClearTapped={() => setMessage('')}
            onPasteTapped={(text) => {
              setMessage(text);
              Keyboard.dismiss();
            }}
          />
        ),
        android: isToolbarVisibleForAndroid && (
          <DoneAndDismissKeyboardInputAccessory
            onClearTapped={() => {
              setMessage('');
              Keyboard.dismiss();
            }}
            onPasteTapped={(text) => {
              setMessage(text);
              Keyboard.dismiss();
            }}
          />
        ),
      })}
    </ScrollView>
  );
}

export default SignVerify;

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  text: {
    paddingHorizontal: 8,
    paddingVertical: 8,
    marginTop: 5,
    marginHorizontal: 20,
    borderWidth: 1,
    borderBottomWidth: 0.5,
    borderRadius: 4,
    textAlignVertical: 'top',
  },
  textMessage: {
    minHeight: 50,
  },
  flex: {
    flex: 1,
  },
  loading: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
})


================================================
FILE: ./screen/wallets/ProvideEntropy.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useReducer, useState } from 'react';
import {
  RouteProp,
  StackActions,
  useNavigation,
  useRoute
} from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { Icon } from '@rneui/themed';
import BN from 'bignumber.js';
import {
  Alert,
  Dimensions,
  Image,
  PixelRatio,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from 'react-native';

import { randomBytes } from '../../class/rng';
import { FButton, FContainer } from '../../components/FloatButtons';
import SafeArea from '../../components/SafeArea';
import { Tabs } from '../../components/Tabs';
import { MalinCurrentTheme, useTheme } from '../../components/themes';
import loc from '../../loc';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { MalinSpacing20 } from '../../components/MalinSpacing';
import {
  concatUint8Arrays,
  uint8ArrayToHex
} from '../../malin_modules/uint8array-extras';

type RouteProps = RouteProp<AddWalletStackParamList, 'ProvideEntropy'>;
type NavigationProp = NativeStackNavigationProp<
  AddWalletStackParamList,
  'ProvideEntropy'
>;

export enum EActionType {
  push = 'push',
  pop = 'pop',
  limit = 'limit',
  noop = 'noop',
}

type TEntropy = { value: number; bits: number };
type TState = { entropy: BN; bits: number; items: number[]; limit: number };
type TAction =
  | ({ type: EActionType.push } & TEntropy)
  | { type: EActionType.pop }
  | { type: EActionType.limit; limit: number }
  | { type: EActionType.noop };
type TPush = (v: TEntropy | null) => void;
type TPop = () => void;

const initialState: TState = {
  entropy: BN(0),
  bits: 0,
  items: [],
  limit: 256,
}

const shiftLeft = (value: BN, places: number) =>
  value.multipliedBy(2 ** places);
const shiftRight = (value: BN, places: number) =>
  value.div(2 ** places).dp(0, BN.ROUND_DOWN);

export const eReducer = (
  state: TState = initialState,
  action: TAction
): TState => {
  switch (action.type) {
    case EActionType.noop:
      return state;

    case EActionType.push: {
      let value: number | BN = action.value;
      let bits: number = action.bits;

      if (value >= 2 ** bits) {
        throw new TypeError("Can't push value exceeding size in bits");
      }
      if (state.bits === state.limit) return state;
      if (state.bits + bits > state.limit) {
        value = shiftRight(BN(value), bits + state.bits - state.limit);
        bits = state.limit - state.bits;
      }
      const entropy = shiftLeft(state.entropy, bits).plus(value);
      const items = [...state.items, bits];
      return { ...state, entropy, bits: state.bits + bits, items };
    }

    case EActionType.pop: {
      if (state.bits === 0) return state;
      const bits = state.items.pop()!;
      const entropy = shiftRight(state.entropy, bits);
      return {
        ...state,
        entropy,
        bits: state.bits - bits,
        items: [...state.items]
      }
    }

    case EActionType.limit: {
      return { ...state, limit: action.limit };
    }

    default:
      return state;
  }
};

export const entropyToHex = ({
  entropy,
  bits
}: {
  entropy: BN;
  bits: number;
}): string => {
  if (bits === 0) return '0x';
  const hex = entropy.toString(16);
  const hexSize = Math.floor((bits - 1) / 4) + 1;
  return '0x' + '0'.repeat(hexSize - hex.length) + hex;
}

export const getEntropy = (number: number, base: number): TEntropy | null => {
  if (base === 1) return null;
  let maxPow = 1;
  while (2 ** (maxPow + 1) <= base) {
    maxPow += 1;
  }

  let bits = maxPow;
  let summ = 0;
  while (bits >= 1) {
    const block = 2 ** bits;
    if (summ + block > base) {
      bits -= 1;
      continue
    }
    if (number < summ + block) {
      return { value: number - summ, bits };
    }
    summ += block;
    bits -= 1;
  }
  return null;
}

// cut entropy to bytes, convert to Uint8Array
export const convertToBuffer = ({
  entropy,
  bits
}: {
  entropy: BN;
  bits: number;
}): Uint8Array => {
  if (bits < 8) return new Uint8Array([]);
  const bytes = Math.floor(bits / 8);

  // convert to byte array
  const arr: string[] = [];
  const ent = entropy.toString(16).split('').reverse();
  ent.forEach((v, index) => {
    if (index % 2 === 1) {
      arr[0] = v + arr[0];
    } else {
      arr.unshift(v);
    }
  });

  let arr2 = arr.map((i) => parseInt(i, 16));

  if (arr.length > bytes) {
    arr2.shift();
  } else if (arr2.length < bytes) {
    const zeros = [...Array(bytes - arr2.length)].map(() => 0);
    arr2 = [...zeros, ...arr2];
  }
  return new Uint8Array(arr2);
}

const Coin = ({ push }: { push: TPush }) => (
  <View style={styles.coinRoot}>
    <TouchableOpacity
      accessibilityRole='button'
      onPress={() => push(getEntropy(0, 2))}
      style={styles.coinBody}
    >
      <Image style={styles.coinImage} source={require('../../img/coin1.png')} />
    </TouchableOpacity>
    <TouchableOpacity
      accessibilityRole='button'
      onPress={() => push(getEntropy(1, 2))}
      style={styles.coinBody}
    >
      <Image style={styles.coinImage} source={require('../../img/coin2.png')} />
    </TouchableOpacity>
  </View>
);

const diceIcon = (i: number): string => {
  switch (i) {
    case 1:
      return 'dice-one';
    case 2:
      return 'dice-two';
    case 3:
      return 'dice-three';
    case 4:
      return 'dice-four';
    case 5:
      return 'dice-five';
    default:
      return 'dice-six';
  }
};

const Dice = ({ push, sides }: { push: TPush; sides: number }) => {
  const { width } = useWindowDimensions();
  const { colors } = useTheme();
  const diceWidth = width / 4;
  const stylesHook = StyleSheet.create({
    dice: {
      borderColor: colors.buttonBackgroundColor,
    },
    diceText: {
      color: colors.foregroundColor,
    },
    diceContainer: {
      backgroundColor: colors.elevated,
    }
  });

  return (
    <ScrollView
      contentContainerStyle={[styles.diceContainer, stylesHook.diceContainer]}
    >
      {[...Array(sides)].map((_, i) => (
        <TouchableOpacity
          accessibilityRole='button'
          key={i}
          onPress={() => push(getEntropy(i, sides))}
        >
          <View style={[styles.diceRoot, { width: diceWidth }]}>
            {sides === 6 ? (
  <Icon
                style={styles.diceIcon}
                name={diceIcon(i + 1)}
                size={70}
                color='grey'
                type='font-awesome-5'
              />
                ) : (
              <View style={[styles.dice, stylesHook.dice]}>
                    <Text style={stylesHook.diceText}>{i + 1}</Text>
                  </View>
                )}
          </View>
        </TouchableOpacity>
      ))}
    </ScrollView>
  );
}

const buttonFontSize =
  PixelRatio.roundToNearestPixel(Dimensions.get('window').width / 26) > 22
    ? 22
    : PixelRatio.roundToNearestPixel(Dimensions.get('window').width / 26);

const Buttons = ({
  pop,
  save,
  colors
}: {
  pop: TPop;
  save: () => void;
  colors: any;
}) => (
  <FContainer>
    <FButton
      onPress={pop}
      text={loc.entropy.undo}
      icon={
        <View style={styles.buttonsIcon}>
          <Icon
            name='undo'
            size={buttonFontSize}
            type='font-awesome'
            color={colors.buttonAlternativeTextColor}
          />
        </View>
      }
    />
    <FButton
      onPress={save}
      text={loc.entropy.save}
      icon={
        <View style={styles.buttonsIcon}>
          <Icon
            name='arrow-down'
            size={buttonFontSize}
            type='font-awesome'
            color={colors.buttonAlternativeTextColor}
          />
        </View>
      }
    />
  </FContainer>
);

const TollTab = ({ active }: { active: boolean }) => {
  const { colors } = useTheme();
  return (
    <Icon
      name='toll'
      type='material'
      color={
        active
          ? colors.buttonAlternativeTextColor
          : colors.buttonBackgroundColor
      }
    />
  )
}

const D6Tab = ({ active }: { active: boolean }) => {
  const { colors } = useTheme();
  return (
    <Icon
      name='dice'
      type='font-awesome-5'
      color={
        active
          ? colors.buttonAlternativeTextColor
          : colors.buttonBackgroundColor
      }
    />
  )
}

const D20Tab = ({ active }: { active: boolean }) => {
  const { colors } = useTheme();
  return (
    <Icon
      name='dice-d20'
      type='font-awesome-5'
      color={
        active
          ? colors.buttonAlternativeTextColor
          : colors.buttonBackgroundColor
      }
    />
  )
}

const ProvideEntropy = () => {
  const [entropy, dispatch] = useReducer(eReducer, initialState);
  const { words } = useRoute<RouteProps>().params;
  const navigation = useNavigation<NavigationProp>();
  const [tab, setTab] = useState(1);
  const [show, setShow] = useState(false);
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    entropy: {
      backgroundColor: colors.inputBackgroundColor,
    },
    entropyText: {
      color: colors.foregroundColor,
    }
  });

  useEffect(() => {
    dispatch({ type: EActionType.limit, limit: words === 24 ? 256 : 128 });
  }, [dispatch, words]);

  const handlePush: TPush = (v) => {
    if (v === null) {
      dispatch({ type: EActionType.noop });
    } else {
      dispatch({ type: EActionType.push, value: v.value, bits: v.bits });
    }
  };

  const handlePop: TPop = () => {
    dispatch({ type: EActionType.pop });
  }

  const handleSave = async () => {
    let buf = convertToBuffer(entropy);
    const bufLength = words === 24 ? 32 : 16;
    const remaining = bufLength - buf.length;

    let entropyTitle = '';
    if (buf.length < bufLength) {
      entropyTitle = loc.formatString(loc.wallets.add_entropy_remain, {
        gen: buf.length,
        rem: remaining,
      })
    } else {
      entropyTitle = loc.formatString(loc.wallets.add_entropy_generated, {
        gen: buf.length,
      })
    }

    Alert.alert(
      loc.wallets.add_entropy,
      entropyTitle,
      [
        {
          text: loc._.cancel,
          onPress: () => {},
          style: 'cancel',
        },
        {
          text: loc._.ok,
          onPress: async () => {
            if (remaining > 0) {
              const random = await randomBytes(remaining);
              buf = concatUint8Arrays([buf, random], bufLength);
            }

            /* Convert Uint8Array to hex string before navigating as React Navigation
              does not support passing Uint8Array objects between screens
            */

            const popTo = StackActions.popTo(
              'AddWallet',
              { entropy: uint8ArrayToHex(buf), words },
              { merge: true }
            );

            navigation.dispatch(popTo);
          },
          style: 'default',
        },
      ],
      { cancelable: true },
    )
  }

  const hex = entropyToHex(entropy);
  let bits = entropy.bits.toString();
  bits = ' '.repeat(bits.length < 3 ? 3 - bits.length : 0) + bits;

  return (
    <SafeArea>
      <MalinSpacing20 />
      <TouchableOpacity
        accessibilityRole='button'
        onPress={() => setShow(!show)}
      >
        <View style={[styles.entropy, stylesHook.entropy]}>
          <Text style={[styles.entropyText, stylesHook.entropyText]}>
            {show
              ? hex
              : loc.formatString(loc.entropy.amountOfEntropy, {
                bits,
                limit: entropy.limit
                })}
          </Text>
        </View>
      </TouchableOpacity>

      <Tabs active={tab} onSwitch={setTab} tabs={[TollTab, D6Tab, D20Tab]} />

      {tab === 0 && <Coin push={handlePush} />}
      {tab === 1 && <Dice sides={6} push={handlePush} />}
      {tab === 2 && <Dice sides={20} push={handlePush} />}

      <Buttons pop={handlePop} save={handleSave} colors={colors} />
    </SafeArea>
  );
}

const styles = StyleSheet.create({
  entropy: {
    padding: 5,
    marginLeft: 10,
    marginRight: 10,
    borderRadius: 9,
    minHeight: 49,
    paddingHorizontal: 8,
    justifyContent: 'center',
    flexDirection: 'row',
    alignItems: 'center',
  },
  entropyText: {
    fontSize: 15,
    fontFamily: 'Courier',
  },
  coinRoot: {
    flex: 1,
    justifyContent: 'center',
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  coinBody: {
    flex: 0.33,
    justifyContent: 'center',
    alignItems: 'center',
    aspectRatio: 1,
    borderWidth: 1,
    borderRadius: 5,
    borderColor: MalinCurrentTheme.colors.lightButton,
    margin: 10,
    padding: 10,
    maxWidth: 100,
    maxHeight: 100,
  },
  coinImage: {
    aspectRatio: 1,
    width: '100%',
    height: '100%',
    borderRadius: 75,
  },
  diceContainer: {
    alignItems: 'flex-start',
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    paddingBottom: 100,
  },
  diceRoot: {
    aspectRatio: 1,
    maxWidth: 100,
    maxHeight: 100,
  },
  dice: {
    margin: 3,
    borderWidth: 1,
    borderRadius: 5,
    justifyContent: 'center',
    alignItems: 'center',
    aspectRatio: 1,
    borderColor: MalinCurrentTheme.colors.buttonBackgroundColor,
  },
  diceIcon: {
    margin: 3,
    justifyContent: 'center',
    alignItems: 'center',
    aspectRatio: 1,
    color: 'grey',
  },
  buttonsIcon: {
    backgroundColor: 'transparent',
    transform: [{ rotate: '-45deg' }],
    alignItems: 'center',
  },
})

export default ProvideEntropy;


================================================
FILE: ./screen/wallets/PleaseBackup.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp, useFocusEffect, useLocale, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import React, { useCallback, useEffect } from 'react';
import { BackHandler, ScrollView, StyleSheet, Text, View } from 'react-native';
import Button from '../../components/Button';
import { useTheme } from '../../components/themes';
import { useSettings } from '../../hooks/context/useSettings';
import { useStorage } from '../../hooks/context/useStorage';
import loc from '../../loc';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import SeedWords from '../../components/SeedWords';
import { useScreenProtect } from '../../hooks/useScreenProtect';

type RouteProps = RouteProp<AddWalletStackParamList, 'PleaseBackup'>;
type NavigationProp = NativeStackNavigationProp<AddWalletStackParamList, 'PleaseBackup'>;

const PleaseBackup: React.FC = () => {
  const { wallets } = useStorage();
  const { walletID } = useRoute<RouteProps>().params;
  const wallet = wallets.find(w => w.getID() === walletID)!;
  const navigation = useNavigation<NavigationProp>();
  const { isPrivacyBlurEnabled } = useSettings();
  const { colors } = useTheme();
  const { direction } = useLocale();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();

  const stylesHook = StyleSheet.create({
    flex: {
      backgroundColor: colors.elevated,
    },
    pleaseText: {
      color: colors.foregroundColor,
      writingDirection: direction,
    },
  });

  const handleBackButton = useCallback(() => {
    navigation.getParent()?.goBack();
    return true;
  }, [navigation]);

  useEffect(() => {
    const subscription = BackHandler.addEventListener('hardwareBackPress', handleBackButton);

    return () => {
      subscription.remove();
    };
  }, [handleBackButton]);

  useFocusEffect(
    useCallback(() => {
      if (isPrivacyBlurEnabled) enableScreenProtect();
      return () => {
        disableScreenProtect();
      };
    }, [disableScreenProtect, enableScreenProtect, isPrivacyBlurEnabled]),
  );

  return (
    <ScrollView
      style={styles.root}
      contentContainerStyle={[styles.flex, stylesHook.flex]}
      testID="PleaseBackupScrollView"
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior="automatic"
    >
      <View style={styles.please}>
        <Text style={[styles.pleaseText, stylesHook.pleaseText]}>{loc.pleasebackup.text}</Text>
      </View>
      <View style={styles.list}>
        <SeedWords seed={wallet.getSecret() ?? ''} />
      </View>
      <View style={styles.bottom}>
        <Button testID="PleasebackupOk" onPress={handleBackButton} title={loc.pleasebackup.ok} />
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  flex: {
    flex: 1,
    justifyContent: 'space-around',
  },
  please: {
    flexGrow: 1,
    paddingHorizontal: 16,
  },
  list: {
    flexGrow: 8,
    marginTop: 14,
    paddingHorizontal: 16,
  },
  bottom: {
    flexGrow: 2,
    alignItems: 'center',
    justifyContent: 'center',
  },
  pleaseText: {
    marginVertical: 16,
    fontSize: 16,
    fontWeight: '500',
  },
});

export default PleaseBackup;


================================================
FILE: ./screen/wallets/xpub.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { NavigationProp, RouteProp, useFocusEffect, useNavigation, useRoute } from '@react-navigation/native';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { ActivityIndicator, InteractionManager, View } from 'react-native';
import Share from 'react-native-share';
import { MalinText } from '../../MalinComponents';
import Button from '../../components/Button';
import CopyTextToClipboard from '../../components/CopyTextToClipboard';
import HandOffComponent from '../../components/HandOffComponent';
import QRCodeComponent from '../../components/QRCodeComponent';
import SafeArea from '../../components/SafeArea';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import loc from '../../loc';
import { styles, useDynamicStyles } from './xpub.styles';
import { useStorage } from '../../hooks/context/useStorage';
import { HandOffActivityType } from '../../components/types';
import { useSettings } from '../../hooks/context/useSettings';
import { MalinSpacing20 } from '../../components/MalinSpacing';
import { HDTaprootWallet } from '../../class';
import { WalletDescriptor } from '../../class/wallet-descriptor.ts';

type WalletXpubRouteProp = RouteProp<{ params: { walletID: string; xpub: string } }, 'params'>;
export type RootStackParamList = {
  WalletXpub: {
    walletID: string;
    xpub: string;
  };
};

const WalletXpub: React.FC = () => {
  const { wallets } = useStorage();
  const route = useRoute<WalletXpubRouteProp>();
  const { walletID, xpub } = route.params;
  const wallet = wallets.find(w => w.getID() === walletID);
  const { isPrivacyBlurEnabled } = useSettings();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [xPubText, setXPubText] = useState<string | undefined>(undefined);
  const navigation = useNavigation<NavigationProp<RootStackParamList, 'WalletXpub'>>();
  const stylesHook = useDynamicStyles(); // This now includes the theme implicitly
  const [qrCodeSize, setQRCodeSize] = useState<number>(90);
  const lastWalletIdRef = useRef<string | undefined>();

  useFocusEffect(
    useCallback(() => {
      if (isPrivacyBlurEnabled) enableScreenProtect();
      // Skip execution if walletID hasn't changed
      if (lastWalletIdRef.current === walletID) {
        return;
      }
      const task = InteractionManager.runAfterInteractions(async () => {
        if (wallet) {
          const walletXpub = wallet.getXpub();
          if (xpub !== walletXpub) {
            navigation.setParams({ xpub: walletXpub || undefined });
          }

          setIsLoading(false);
        } else if (xpub) {
          setIsLoading(false);
        }
      });
      lastWalletIdRef.current = walletID;
      return () => {
        disableScreenProtect();
        task.cancel();
      };
    }, [isPrivacyBlurEnabled, walletID, wallet, xpub, navigation, enableScreenProtect, disableScreenProtect]),
  );

  useEffect(() => {
    (async () => {
      if (wallet && wallet?.type === HDTaprootWallet.type && wallet.getDerivationPath) {
        await new Promise(resolve => setTimeout(resolve, 100)); // sleep to propagate ui
        // need to convert xpub to a wallet descriptor
        const fp = wallet.getMasterFingerprintHex();
        const path = wallet.getDerivationPath() ?? '';
        const xpub2 = WalletDescriptor.getDescriptor(fp, path, wallet.getXpub());
        setXPubText(xpub2);
      } else {
        setXPubText(xpub);
      }
    })();
  }, [wallet, xpub]);

  const onLayout = (e: { nativeEvent: { layout: { width: any; height?: any } } }) => {
    const { height, width } = e.nativeEvent.layout;

    const isPortrait = height > width;
    const maxQRSize = 450;

    if (isPortrait) {
      const heightBasedSize = Math.min(height * 0.6, maxQRSize);
      const widthBasedSize = width * 0.8;
      setQRCodeSize(Math.min(heightBasedSize, widthBasedSize));
    } else {
      const heightBasedSize = Math.min(height * 0.55, maxQRSize);
      const widthBasedSize = width * 0.38;
      setQRCodeSize(Math.min(heightBasedSize, widthBasedSize));
    }
  };

  const handleShareButtonPressed = useCallback(() => {
    Share.open({ message: xPubText || xpub }).catch(console.log);
  }, [xPubText, xpub]);

  return (
    <SafeArea style={[styles.root, stylesHook.root]} onLayout={onLayout}>
      {isLoading ? (
        <ActivityIndicator />
      ) : (
        <>
          <View style={styles.container}>
            {wallet && (
              <>
                <View>
                  <MalinText>{wallet.typeReadable}</MalinText>
                </View>
                <MalinSpacing20 />
              </>
            )}
            <QRCodeComponent value={xPubText || xpub} size={qrCodeSize} />

            {xPubText && <CopyTextToClipboard text={xPubText} />}
          </View>
          <HandOffComponent title={loc.wallets.xpub_title} type={HandOffActivityType.Xpub} userInfo={{ xpub: xPubText }} />
          <View style={styles.share}>
            <Button onPress={handleShareButtonPressed} title={loc.receive.details_share} />
          </View>
        </>
      )}
    </SafeArea>
  );
};

export default WalletXpub;


================================================
FILE: ./screen/wallets/WalletExport.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import Clipboard from '@react-native-clipboard/clipboard';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { Icon } from '@rneui/themed';
import { LayoutChangeEvent, ScrollView, StyleSheet, Pressable, View } from 'react-native';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import { validateMnemonic } from '../../malin_modules/bip39';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinText } from '../../MalinComponents';
import { LightningCustodianWallet, WatchOnlyWallet } from '../../class';
import HandOffComponent from '../../components/HandOffComponent';
import QRCodeComponent from '../../components/QRCodeComponent';
import SeedWords from '../../components/SeedWords';
import { useTheme } from '../../components/themes';
import { HandOffActivityType } from '../../components/types';
import { useSettings } from '../../hooks/context/useSettings';
import { useStorage } from '../../hooks/context/useStorage';
import useAppState from '../../hooks/useAppState';
import loc from '../../loc';
import { WalletExportStackParamList } from '../../navigation/WalletExportStack';
import { WalletDescriptor } from '../../class/wallet-descriptor.ts';

type RouteProps = RouteProp<WalletExportStackParamList, 'WalletExport'>;

const HORIZONTAL_PADDING = 20;

const CopyBox: React.FC<{ text: string; onPress: () => void }> = ({ text, onPress }) => {
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    copyRoot: { backgroundColor: colors.lightBorder },
  });

  return (
    <Pressable onPress={onPress} style={({ pressed }) => [pressed && styles.pressed, styles.copyRoot, stylesHook.copyRoot]}>
      <View style={styles.copyLeft}>
        <MalinText textBreakStrategy="balanced" style={styles.copyText}>
          {text}
        </MalinText>
      </View>
      <View style={styles.copyRight}>
        <Icon name="copy" type="font-awesome-5" color={colors.foregroundColor} />
      </View>
    </Pressable>
  );
};

const DoNotDisclose: React.FC = () => {
  const { colors } = useTheme();

  return (
    <View style={[styles.warningBox, { backgroundColor: colors.changeText }]}>
      <Icon type="font-awesome-5" name="exclamation-circle" color="white" />
      <MalinText style={styles.warning}>{loc.wallets.warning_do_not_disclose}</MalinText>
    </View>
  );
};

const WalletExport: React.FC = () => {
  const { wallets } = useStorage();
  const { walletID } = useRoute<RouteProps>().params;
  const navigation = useNavigation();
  const { isPrivacyBlurEnabled } = useSettings();
  const { colors } = useTheme();
  const wallet = wallets.find(w => w.getID() === walletID)!;
  const [qrCodeSize, setQRCodeSize] = useState(90);
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const { currentAppState, previousAppState } = useAppState();
  const stylesHook = StyleSheet.create({
    root: { backgroundColor: colors.elevated },
  });

  const secrets: string[] = useMemo(() => {
    try {
      let secret = wallet.getSecret();
      if (wallet instanceof WatchOnlyWallet) {
        try {
          const path = wallet.getDerivationPath();
          if (path?.startsWith('m/86')) {
            // for taproot watch-only HD we dont just show xpub, we show wallet descriptor
            const fp = wallet.getMasterFingerprintHex();
            secret = WalletDescriptor.getDescriptor(fp, path, secret);
          }
        } catch (e: any) {
          console.log(e.message);
        }
      }
      return typeof secret === 'string' ? [secret] : Array.isArray(secret) ? secret : [];
    } catch (error) {
      console.error('Failed to get wallet secret:', error);
      return [];
    }
  }, [wallet]);

  const secretIsMnemonic: boolean = useMemo(() => {
    return validateMnemonic(wallet.getSecret());
  }, [wallet]);

  useEffect(() => {
    if (previousAppState === 'active' && currentAppState !== 'active') {
      disableScreenProtect();
      const timer = setTimeout(() => {
        navigation.goBack();
      }, 500);
      return () => clearTimeout(timer);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentAppState, previousAppState]);

  useEffect(() => {
    if (isPrivacyBlurEnabled) {
      enableScreenProtect();
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isPrivacyBlurEnabled]);

  const onLayout = useCallback((e: LayoutChangeEvent) => {
    const { height, width } = e.nativeEvent.layout;

    const isPortrait = height > width;
    const maxQRSize = 400;

    if (isPortrait) {
      const heightBasedSize = Math.min(height * 0.5, maxQRSize);
      const widthBasedSize = width * 0.75 - HORIZONTAL_PADDING * 2;
      setQRCodeSize(Math.min(heightBasedSize, widthBasedSize));
    } else {
      const heightBasedSize = Math.min(height * 0.6, maxQRSize);
      const widthBasedSize = width * 0.35;
      setQRCodeSize(Math.min(heightBasedSize, widthBasedSize));
    }
  }, []);

  const handleCopy = useCallback(() => {
    Clipboard.setString(secrets[0]);
    triggerHapticFeedback(HapticFeedbackTypes.Selection);
  }, [secrets]);

  const Scroll = useCallback(
    // eslint-disable-next-line react/no-unused-prop-types
    ({ children }: { children: React.ReactNode | React.ReactNodeArray }) => (
      <ScrollView
        automaticallyAdjustContentInsets
        contentInsetAdjustmentBehavior="automatic"
        style={stylesHook.root}
        contentContainerStyle={styles.scrollViewContent}
        onLayout={onLayout}
        testID="WalletExportScroll"
      >
        {children}
      </ScrollView>
    ),
    [onLayout, stylesHook.root],
  );

  // for SLIP39
  if (secrets.length !== 1) {
    return (
      <Scroll>
        <DoNotDisclose />

        <View>
          <MalinText style={styles.manualText}>{loc.wallets.write_down_header}</MalinText>
          <MalinText style={styles.writeText}>{loc.wallets.write_down}</MalinText>
        </View>

        {secrets.map((secret, index) => (
          <React.Fragment key={secret}>
            <MalinText style={styles.scanText}>{loc.formatString(loc.wallets.share_number, { number: index + 1 })}</MalinText>
            <SeedWords seed={secret} />
          </React.Fragment>
        ))}

        <MalinText style={styles.typeText}>{loc.formatString(loc.wallets.wallet_type_this, { type: wallet.typeReadable })}</MalinText>
      </Scroll>
    );
  }

  const secret = secrets[0];

  return (
    <ScrollView
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior="automatic"
      style={stylesHook.root}
      contentContainerStyle={styles.scrollViewContent}
      onLayout={onLayout}
      testID="WalletExportScroll"
    >
      {wallet.type !== WatchOnlyWallet.type && <DoNotDisclose />}

      <MalinText style={styles.scanText}>{loc.wallets.scan_import}</MalinText>

      <View style={styles.qrCodeContainer}>
        <QRCodeComponent isMenuAvailable={false} value={secret} size={qrCodeSize} logoSize={70} />
      </View>

      {/* Do not allow to copy mnemonic */}
      {secretIsMnemonic ? (
        <>
          <View>
            <MalinText style={styles.manualText}>{loc.wallets.write_down_header}</MalinText>
            <MalinText style={styles.writeText}>{loc.wallets.write_down}</MalinText>
          </View>
          <SeedWords seed={secret} />
        </>
      ) : (
        <>
          <MalinText style={styles.writeText}>
            {wallet.type === LightningCustodianWallet.type ? loc.wallets.copy_ln_url : loc.wallets.copy_ln_public}
          </MalinText>
          <CopyBox text={secret} onPress={handleCopy} />
        </>
      )}

      {wallet.type === WatchOnlyWallet.type && (
        <HandOffComponent title={loc.wallets.xpub_title} type={HandOffActivityType.Xpub} userInfo={{ xpub: secret }} />
      )}

      <MalinText style={styles.typeText}>{loc.formatString(loc.wallets.wallet_type_this, { type: wallet.typeReadable })}</MalinText>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  scrollViewContent: {
    justifyContent: 'center',
    flexGrow: 1,
    gap: 32,
    paddingHorizontal: HORIZONTAL_PADDING,
    paddingTop: 10,
    paddingBottom: 20,
  },
  warningBox: {
    alignItems: 'center',
    padding: 12,
    borderRadius: 10,
    alignSelf: 'stretch',
    flexDirection: 'row',
    gap: 8,
  },
  warning: {
    fontSize: 20,
    color: 'white',
  },
  scanText: {
    textAlign: 'center',
    fontSize: 20,
  },
  writeText: {
    textAlign: 'center',
    fontSize: 17,
  },
  manualText: {
    textAlign: 'center',
    fontSize: 20,
    marginBottom: 10,
  },
  typeText: {
    textAlign: 'center',
    fontSize: 17,
    color: 'grey',
  },
  copyRoot: {
    padding: 10,
    borderRadius: 8,
    flexDirection: 'row',
  },
  copyLeft: {
    flexShrink: 1,
  },
  copyRight: {
    justifyContent: 'center',
    marginHorizontal: 8,
  },
  copyText: {
    fontSize: 17,
  },
  qrCodeContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
  },
  pressed: {
    opacity: 0.6,
  },
});

export default WalletExport;


================================================
FILE: ./screen/wallets/ImportCustomDerivationPath.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { FlatList, StyleSheet, TextInput, View } from 'react-native';
import debounce from '../../malin_modules/debounce';
import { MalinFormLabel, MalinTextCentered } from '../../MalinComponents';
import { HDLegacyP2PKHWallet, HDSegwitBech32Wallet, HDSegwitP2SHWallet, HDTaprootWallet } from '../../class';
import { validateBip32 } from '../../class/wallet-import';
import { TWallet } from '../../class/wallets/types';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import WalletToImport from '../../components/WalletToImport';
import { useStorage } from '../../hooks/context/useStorage';
import loc from '../../loc';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { useSettings } from '../../hooks/context/useSettings';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type RouteProps = RouteProp<AddWalletStackParamList, 'ImportCustomDerivationPath'>;
type NavigationProp = NativeStackNavigationProp<AddWalletStackParamList, 'ImportCustomDerivationPath'>;

const ListEmptyComponent: React.FC = () => <MalinTextCentered>{loc.wallets.import_wrong_path}</MalinTextCentered>;

const WRONG_PATH = 'WRONG_PATH';
enum STATUS {
  WALLET_FOUND = 'WALLET_FOUND',
  WALLET_NOTFOUND = 'WALLET_NOTFOUND',
  WALLET_UNKNOWN = 'WALLET_UNKNOWN',
}
type TWalletsByType = { [type: string]: TWallet };
type TWalletsByPath = { [path: string]: TWalletsByType | 'WRONG_PATH' };

type TUsedByType = { [type: string]: STATUS };
type TUsedByPath = { [path: string]: TUsedByType };

type TItem = [type: string, typeReadable: string, STATUS | undefined];

const ImportCustomDerivationPath: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { colors } = useTheme();
  const { importText, password } = useRoute<RouteProps>().params;
  const { addAndSaveWallet } = useStorage();
  const [path, setPath] = useState<string>("m/84'/0'/0'");
  const [wallets, setWallets] = useState<TWalletsByPath>({});
  const [used, setUsed] = useState<TUsedByPath>({});
  const [selected, setSelected] = useState<string>('');
  const importing = useRef(false);
  const { isElectrumDisabled } = useSettings();

  const debouncedSavePath = useRef(
    debounce(async newPath => {
      if (!validateBip32(newPath)) {
        setWallets(ws => ({ ...ws, [newPath]: WRONG_PATH }));
        return;
      }

      // create wallets
      const newWallets: { [type: string]: TWallet } = {};
      for (const Wallet of [HDLegacyP2PKHWallet, HDSegwitP2SHWallet, HDSegwitBech32Wallet, HDTaprootWallet]) {
        const wallet = new Wallet();
        wallet.setSecret(importText);
        if (password) {
          wallet.setPassphrase(password);
        }
        wallet.setDerivationPath(newPath);
        newWallets[Wallet.type] = wallet;
      }
      setWallets(ws => ({ ...ws, [newPath]: newWallets }));

      if (isElectrumDisabled) {
        // do not check if electrum is disabled
        Object.values(newWallets).forEach(w => {
          setUsed(u => ({ ...u, [newPath]: { ...u[newPath], [w.type]: STATUS.WALLET_UNKNOWN } }));
        });
        return;
      }

      // discover was they ever used
      const promises = Object.values(newWallets).map(w => {
        return w.wasEverUsed().then(v => {
          const status = v ? STATUS.WALLET_FOUND : STATUS.WALLET_NOTFOUND;
          setUsed(u => ({ ...u, [newPath]: { ...u[newPath], [w.type]: status } }));
        });
      });
      try {
        await Promise.all(promises);
      } catch (e) {
        Object.values(newWallets).forEach(w => {
          setUsed(u => ({ ...u, [newPath]: { ...u[newPath], [w.type]: STATUS.WALLET_UNKNOWN } }));
        });
      }
    }, 500),
  );

  useEffect(() => {
    if (path in wallets) return;
    debouncedSavePath.current(path);
  }, [path, wallets]);

  const items: TItem[] = useMemo(() => {
    if (wallets[path] === WRONG_PATH) return [];
    return [
      [HDLegacyP2PKHWallet.type, HDLegacyP2PKHWallet.typeReadable, used[path]?.[HDLegacyP2PKHWallet.type]],
      [HDSegwitP2SHWallet.type, HDSegwitP2SHWallet.typeReadable, used[path]?.[HDSegwitP2SHWallet.type]],
      [HDSegwitBech32Wallet.type, HDSegwitBech32Wallet.typeReadable, used[path]?.[HDSegwitBech32Wallet.type]],
      [HDTaprootWallet.type, HDTaprootWallet.typeReadable, used[path]?.[HDTaprootWallet.type]],
    ];
  }, [path, used, wallets]);

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    center: {
      backgroundColor: colors.elevated,
    },
    pathInput: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const saveWallet = (type: string) => {
    if (importing.current) return;
    importing.current = true;
    if (wallets[path] === WRONG_PATH) return;
    addAndSaveWallet(wallets[path][type]);
    navigation.getParent()?.goBack();
  };

  const renderItem = ({ item }: { item: TItem }) => {
    const [type, title, found] = item;
    let subtitle;
    switch (found) {
      case STATUS.WALLET_FOUND:
        subtitle = loc.wallets.import_derivation_found;
        break;
      case STATUS.WALLET_NOTFOUND:
        subtitle = loc.wallets.import_derivation_found_not;
        break;
      case STATUS.WALLET_UNKNOWN:
        subtitle = loc.wallets.import_derivation_unknown;
        break;
      default:
        subtitle = loc.wallets.import_derivation_loading;
    }

    return <WalletToImport key={type} title={title} subtitle={subtitle} active={selected === type} onPress={() => setSelected(type)} />;
  };

  const disabled = wallets[path] === WRONG_PATH || wallets[path]?.[selected] === undefined;

  return (
    <SafeArea style={[styles.root, stylesHook.root]}>
      <MalinSpacing20 />
      <MalinFormLabel>{loc.wallets.import_derivation_subtitle}</MalinFormLabel>
      <MalinSpacing20 />
      <TextInput
        testID="DerivationPathInput"
        placeholder={loc.send.details_note_placeholder}
        value={path}
        placeholderTextColor="#81868e"
        style={[styles.pathInput, stylesHook.pathInput]}
        onChangeText={setPath}
      />
      <FlatList
        data={items}
        keyExtractor={w => path + w[0]}
        renderItem={renderItem}
        contentContainerStyle={styles.flatListContainer}
        ListEmptyComponent={ListEmptyComponent}
      />

      <View style={[styles.center, stylesHook.center]}>
        <View style={styles.buttonContainer}>
          <Button disabled={disabled} title={loc.wallets.import_do_import} testID="ImportButton" onPress={() => saveWallet(selected)} />
        </View>
      </View>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  root: {
    paddingTop: 10,
  },
  flatListContainer: {
    marginHorizontal: 16,
  },
  center: {
    marginHorizontal: 16,
    alignItems: 'center',
    top: -100,
  },
  buttonContainer: {
    height: 45,
  },
  pathInput: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    marginHorizontal: 16,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    marginVertical: 8,
    borderRadius: 4,
    paddingHorizontal: 8,
    color: '#81868e',
  },
});

export default ImportCustomDerivationPath;


================================================
FILE: ./screen/wallets/ImportWallet.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { RouteProp, useRoute } from '@react-navigation/native';
import Clipboard from '@react-native-clipboard/clipboard';
import { Keyboard, Platform, StyleSheet, TouchableWithoutFeedback, View, TouchableOpacity, Image } from 'react-native';
import { MalinFormLabel, MalinFormMultiInput } from '../../MalinComponents';
import Button from '../../components/Button';
import {
  DoneAndDismissKeyboardInputAccessory,
  DoneAndDismissKeyboardInputAccessoryViewID,
} from '../../components/DoneAndDismissKeyboardInputAccessory';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import { useTheme } from '../../components/themes';
import { useSettings } from '../../hooks/context/useSettings';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useKeyboard } from '../../hooks/useKeyboard';
import loc from '../../loc';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { AddressInputScanButton } from '../../components/AddressInputScanButton';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type RouteProps = RouteProp<AddWalletStackParamList, 'ImportWallet'>;
type NavigationProps = NativeStackNavigationProp<AddWalletStackParamList, 'ImportWallet'>;

const ImportWallet = () => {
  const navigation = useExtendedNavigation<NavigationProps>();
  const { colors, closeImage } = useTheme();
  const route = useRoute<RouteProps>();
  const label = route?.params?.label ?? '';
  const triggerImport = route?.params?.triggerImport ?? false;
  const [importText, setImportText] = useState<string>(label);
  const [isToolbarVisibleForAndroid, setIsToolbarVisibleForAndroid] = useState<boolean>(false);
  const [, setSpeedBackdoor] = useState<number>(0);
  const [searchAccountsMenuState, setSearchAccountsMenuState] = useState<boolean>(false);
  const [askPassphraseMenuState, setAskPassphraseMenuState] = useState<boolean>(false);
  const [clearClipboardMenuState, setClearClipboardMenuState] = useState<boolean>(true);
  const { isPrivacyBlurEnabled } = useSettings();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const styles = StyleSheet.create({
    root: {
      paddingTop: 10,
      backgroundColor: colors.elevated,
      flex: 1,
    },
    center: {
      flex: 1,
      marginHorizontal: 16,
      backgroundColor: colors.elevated,
    },
    button: {
      padding: 10,
    },
  });

  const onBlur = useCallback(() => {
    const valueWithSingleWhitespace = importText.replace(/^\s+|\s+$|\s+(?=\s)/g, '');
    setImportText(valueWithSingleWhitespace);
    return valueWithSingleWhitespace;
  }, [importText]);

  useKeyboard({
    onKeyboardDidShow: () => {
      setIsToolbarVisibleForAndroid(true);
    },
    onKeyboardDidHide: () => {
      setIsToolbarVisibleForAndroid(false);
    },
  });

  const importMnemonic = useCallback(
    async (text: string) => {
      if (clearClipboardMenuState) {
        try {
          if (await Clipboard.hasString()) {
            Clipboard.setString('');
          }
        } catch (error) {
          console.error('Failed to clear clipboard:', error);
        }
      }

      Keyboard.dismiss();

      navigation.navigate('ImportWalletDiscovery', {
        importText: text,
        askPassphrase: askPassphraseMenuState,
        searchAccounts: searchAccountsMenuState,
      });
    },

    [askPassphraseMenuState, clearClipboardMenuState, navigation, searchAccountsMenuState],
  );

  const handleImport = useCallback(() => {
    const textToImport = onBlur();
    if (textToImport.trim().length === 0) {
      return;
    }
    importMnemonic(textToImport);
  }, [importMnemonic, onBlur]);

  const onBarScanned = useCallback(
    (value: string | { data: any }) => {
      // no objects here, only strings
      const newValue: string = typeof value !== 'string' ? value.data + '' : value;
      setImportText(newValue);
      setTimeout(() => importMnemonic(newValue), 500);
    },
    [importMnemonic],
  );

  useEffect(() => {
    const data = route.params?.onBarScanned;
    if (data) {
      onBarScanned(data);
      navigation.setParams({ onBarScanned: undefined });
    }
  }, [route.name, onBarScanned, route.params?.onBarScanned, navigation]);

  const speedBackdoorTap = () => {
    setSpeedBackdoor(v => {
      v += 1;
      if (v < 5) return v;
      navigation.navigate('ImportSpeed');
      return 0;
    });
  };

  const toolTipOnPressMenuItem = useCallback(
    (menuItem: string) => {
      Keyboard.dismiss();
      if (menuItem === CommonToolTipActions.Passphrase.id) {
        setAskPassphraseMenuState(!askPassphraseMenuState);
      } else if (menuItem === CommonToolTipActions.SearchAccount.id) {
        setSearchAccountsMenuState(!searchAccountsMenuState);
      } else if (menuItem === CommonToolTipActions.ClearClipboard.id) {
        setClearClipboardMenuState(!clearClipboardMenuState);
      }
    },
    [askPassphraseMenuState, clearClipboardMenuState, searchAccountsMenuState],
  );

  // ToolTipMenu actions for advanced options
  const toolTipActions = useMemo(() => {
    return [
      { ...CommonToolTipActions.Passphrase, menuState: askPassphraseMenuState },
      { ...CommonToolTipActions.SearchAccount, menuState: searchAccountsMenuState },
      { ...CommonToolTipActions.ClearClipboard, menuState: clearClipboardMenuState },
    ];
  }, [askPassphraseMenuState, clearClipboardMenuState, searchAccountsMenuState]);

  const HeaderRight = useMemo(
    () => <HeaderMenuButton onPressMenuItem={toolTipOnPressMenuItem} actions={toolTipActions} />,
    [toolTipOnPressMenuItem, toolTipActions],
  );

  useEffect(() => {
    if (isPrivacyBlurEnabled) {
      enableScreenProtect();
    }
    return () => {
      disableScreenProtect();
    };
  }, [isPrivacyBlurEnabled, enableScreenProtect, disableScreenProtect]);

  useEffect(() => {
    if (triggerImport) handleImport();
  }, [triggerImport, handleImport]);

  // Adding the ToolTipMenu to the header
  useEffect(() => {
    navigation.setOptions({
      headerRight: () => HeaderRight,
      headerLeft:
        navigation.getState().index === 0
          ? () => (
              <TouchableOpacity
                accessibilityRole="button"
                accessibilityLabel={loc._.close}
                style={styles.button}
                onPress={() => navigation.goBack()}
                testID="NavigationCloseButton"
              >
                <Image source={closeImage} />
              </TouchableOpacity>
            )
          : undefined,
    });
  }, [colors, navigation, toolTipActions, HeaderRight, styles.button, closeImage]);

  const renderOptionsAndImportButton = (
    <>
      <MalinSpacing20 />
      <View style={styles.center}>
        <>
          <Button disabled={importText.trim().length === 0} title={loc.wallets.import_do_import} testID="DoImport" onPress={handleImport} />
          <MalinSpacing20 />
          <AddressInputScanButton type="link" onChangeText={setImportText} testID="ScanImport" />
        </>
      </View>
    </>
  );

  return (
    <SafeAreaScrollView contentContainerStyle={styles.root} keyboardShouldPersistTaps="always" automaticallyAdjustKeyboardInsets>
      <MalinSpacing20 />
      <TouchableWithoutFeedback accessibilityRole="button" onPress={speedBackdoorTap} testID="SpeedBackdoor">
        <MalinFormLabel>{loc.wallets.import_explanation}</MalinFormLabel>
      </TouchableWithoutFeedback>
      <MalinSpacing20 />
      <MalinFormMultiInput
        value={importText}
        onBlur={onBlur}
        onChangeText={setImportText}
        testID="MnemonicInput"
        inputAccessoryViewID={DoneAndDismissKeyboardInputAccessoryViewID}
      />

      {Platform.select({ android: !isToolbarVisibleForAndroid && renderOptionsAndImportButton, default: renderOptionsAndImportButton })}
      {Platform.select({
        ios: (
          <DoneAndDismissKeyboardInputAccessory
            onClearTapped={() => {
              setImportText('');
            }}
            onPasteTapped={text => {
              setImportText(text);
              Keyboard.dismiss();
            }}
          />
        ),
        default: null,
      })}
    </SafeAreaScrollView>
  );
};

export default ImportWallet;


================================================
FILE: ./screen/wallets/ExportMultisigCoordinationSetup.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp, useFocusEffect, useNavigation, useRoute } from '@react-navigation/native';
import React, { useCallback, useMemo, useReducer, useRef } from 'react';
import { ActivityIndicator, InteractionManager, ScrollView, StyleSheet, Text, View } from 'react-native';
import { MalinText } from '../../MalinComponents';
import { TWallet } from '../../class/wallets/types';
import { DynamicQRCode } from '../../components/DynamicQRCode';
import SaveFileButton from '../../components/SaveFileButton';
import { SquareButton } from '../../components/SquareButton';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { ExportMultisigCoordinationSetupStackRootParamList } from '../../navigation/ExportMultisigCoordinationSetupStack';
import { useSettings } from '../../hooks/context/useSettings';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import SafeArea from '../../components/SafeArea';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const enum ActionType {
  SET_LOADING = 'SET_LOADING',
  SET_SHARE_BUTTON_TAPPED = 'SET_SHARE_BUTTON_TAPPED',
  SET_ERROR = 'SET_ERROR',
  SET_QR_CODE_CONTENTS = 'SET_QR_CODE_CONTENTS',
  SET_XPUB = 'SET_XPUB',
  SET_CLOSE_BUTTON_STATE = 'SET_CLOSE_BUTTON_STATE',
}

type State = {
  isLoading: boolean;
  isShareButtonTapped: boolean;
  qrCodeContents?: string;
  xpub?: string;
  error: string | null;
  closeButtonState: boolean;
};

type Action =
  | { type: ActionType.SET_LOADING; isLoading: boolean }
  | { type: ActionType.SET_SHARE_BUTTON_TAPPED; isShareButtonTapped: boolean }
  | { type: ActionType.SET_ERROR; error: string | null }
  | { type: ActionType.SET_QR_CODE_CONTENTS; qrCodeContents: string }
  | { type: ActionType.SET_XPUB; xpub: string }
  | { type: ActionType.SET_CLOSE_BUTTON_STATE; closeButtonState: boolean };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case ActionType.SET_LOADING:
      return { ...state, isLoading: action.isLoading };
    case ActionType.SET_SHARE_BUTTON_TAPPED:
      return { ...state, isShareButtonTapped: action.isShareButtonTapped };
    case ActionType.SET_ERROR:
      return { ...state, error: action.error, isLoading: false, closeButtonState: true };
    case ActionType.SET_QR_CODE_CONTENTS:
      return { ...state, qrCodeContents: action.qrCodeContents, isLoading: false, closeButtonState: true };
    case ActionType.SET_XPUB:
      return { ...state, xpub: action.xpub, isLoading: false };
    case ActionType.SET_CLOSE_BUTTON_STATE:
      return { ...state, closeButtonState: action.closeButtonState };
    default:
      return state;
  }
}

const initialState: State = {
  isLoading: true,
  isShareButtonTapped: false,
  qrCodeContents: undefined,
  xpub: undefined,
  error: null,
  closeButtonState: false,
};

const ExportMultisigCoordinationSetup: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const { isLoading, isShareButtonTapped, qrCodeContents, xpub, closeButtonState } = state;
  const { params } = useRoute<RouteProp<ExportMultisigCoordinationSetupStackRootParamList, 'ExportMultisigCoordinationSetup'>>();
  const walletID = params.walletID;
  const { wallets } = useStorage();
  const { isPrivacyBlurEnabled } = useSettings();
  const wallet: TWallet | undefined = wallets.find(w => w.getID() === walletID);
  const dynamicQRCode = useRef<any>();
  const { colors } = useTheme();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();

  const navigation = useNavigation();
  const stylesHook = StyleSheet.create({
    scrollViewContent: {
      backgroundColor: colors.elevated,
    },
    type: { color: colors.foregroundColor },
    secret: { color: colors.foregroundColor },
    exportButton: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
  });

  const label = useMemo(() => wallet?.getLabel(), [wallet]);

  const setIsShareButtonTapped = (value: boolean) => {
    dispatch({ type: ActionType.SET_SHARE_BUTTON_TAPPED, isShareButtonTapped: value });
  };

  useFocusEffect(
    useCallback(() => {
      dispatch({ type: ActionType.SET_LOADING, isLoading: true });

      const task = InteractionManager.runAfterInteractions(() => {
        if (wallet) {
          setTimeout(async () => {
            try {
              const walletXpub = await wallet.getXpub();
              if (walletXpub) {
                const value = Buffer.from(walletXpub, 'ascii').toString('hex');
                dispatch({ type: ActionType.SET_XPUB, xpub: walletXpub });
                dispatch({ type: ActionType.SET_QR_CODE_CONTENTS, qrCodeContents: value });
              } else {
                dispatch({ type: ActionType.SET_ERROR, error: 'xpub not found' });
              }
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
              dispatch({ type: ActionType.SET_ERROR, error: errorMessage });
            }
            dispatch({ type: ActionType.SET_CLOSE_BUTTON_STATE, closeButtonState: true });
          }, 0);
        } else {
          dispatch({ type: ActionType.SET_ERROR, error: 'Wallet not found' });
          dispatch({ type: ActionType.SET_CLOSE_BUTTON_STATE, closeButtonState: true });
        }
      });

      return () => {
        task.cancel();
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [walletID]),
  );

  useFocusEffect(
    useCallback(() => {
      if (isPrivacyBlurEnabled) {
        enableScreenProtect();
      }
      return () => {
        disableScreenProtect();
      };
    }, [isPrivacyBlurEnabled, enableScreenProtect, disableScreenProtect]),
  );

  useFocusEffect(
    useCallback(() => {
      if (closeButtonState) {
        navigation.setOptions({ closeButtonState: 'Enabled' });
      }
    }, [closeButtonState, navigation]),
  );

  const exportTxtFileBeforeOnPress = async () => {
    setIsShareButtonTapped(true);
    dynamicQRCode.current?.stopAutoMove();
  };

  const exportTxtFileAfterOnPress = () => {
    setIsShareButtonTapped(false);
    dynamicQRCode.current?.startAutoMove();
  };

  const renderView = wallet ? (
    <SafeArea style={[styles.scrollViewContent, stylesHook.scrollViewContent]}>
      <View>
        <MalinText style={[styles.type, stylesHook.type]}>{label}</MalinText>
      </View>
      <MalinSpacing20 />
      {qrCodeContents && <DynamicQRCode value={qrCodeContents} ref={dynamicQRCode} />}
      <MalinSpacing20 />
      {isShareButtonTapped ? (
        <ActivityIndicator />
      ) : (
        label &&
        xpub && (
          <SaveFileButton
            style={[styles.exportButton, stylesHook.exportButton]}
            fileName={`${label}.txt`}
            fileContent={xpub}
            beforeOnPress={exportTxtFileBeforeOnPress}
            afterOnPress={exportTxtFileAfterOnPress}
          >
            <SquareButton title={loc.multisig.share} />
          </SaveFileButton>
        )
      )}

      <MalinSpacing20 />
      <Text selectable style={[styles.secret, stylesHook.secret]}>
        {xpub}
      </Text>
    </SafeArea>
  ) : null;

  return (
    <ScrollView
      style={stylesHook.scrollViewContent}
      centerContent
      automaticallyAdjustContentInsets
      automaticallyAdjustKeyboardInsets
      automaticallyAdjustsScrollIndicatorInsets
      contentInsetAdjustmentBehavior="automatic"
    >
      {isLoading ? <ActivityIndicator /> : renderView}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  scrollViewContent: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  type: {
    fontSize: 17,
    fontWeight: '700',
  },
  secret: {
    alignItems: 'center',
    paddingHorizontal: 16,
    fontSize: 16,
    lineHeight: 24,
  },
  exportButton: {
    height: 48,
    borderRadius: 8,
    justifyContent: 'center',
    paddingHorizontal: 16,
    width: '80%',
    maxWidth: 300,
  },
});

export default ExportMultisigCoordinationSetup;


================================================
FILE: ./screen/wallets/addMultisigStep2.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useFocusEffect, useLocale, useRoute } from '@react-navigation/native';
import {
  ActivityIndicator,
  FlatList,
  InteractionManager,
  Keyboard,
  LayoutAnimation,
  Platform,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { Icon } from '@rneui/themed';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { encodeUR } from '../../malin_modules/ur';
import { MalinFormMultiInput, MalinTextCentered } from '../../MalinComponents';
import { HDSegwitBech32Wallet, MultisigCosigner, MultisigHDWallet } from '../../class';
import presentAlert from '../../components/Alert';
import BottomModal from '../../components/BottomModal';
import Button from '../../components/Button';
import QRCodeComponent from '../../components/QRCodeComponent';
import { useTheme } from '../../components/themes';
import confirm from '../../helpers/confirm';
import prompt from '../../helpers/prompt';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import ToolTipMenu from '../../components/TooltipMenu';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { useSettings } from '../../hooks/context/useSettings';
import { useKeyboard } from '../../hooks/useKeyboard';
import {
  DoneAndDismissKeyboardInputAccessory,
  DoneAndDismissKeyboardInputAccessoryViewID,
} from '../../components/DoneAndDismissKeyboardInputAccessory';
import Clipboard from '@react-native-clipboard/clipboard';
import MultipleStepsListItem, {
  MultipleStepsListItemButtonType,
  MultipleStepsListItemDashType,
} from '../../components/MultipleStepsListItem';
import { AddressInputScanButton } from '../../components/AddressInputScanButton';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';

const staticCache = {};

const WalletsAddMultisigStep2 = () => {
  const { addAndSaveWallet, isElectrumDisabled, sleep, currentSharedCosigner, setSharedCosigner } = useStorage();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const { colors } = useTheme();

  const navigation = useExtendedNavigation();
  const params = useRoute().params;
  const { m, n, format, walletLabel } = params;
  const [cosigners, setCosigners] = useState([]); // array of cosigners user provided. if format [cosigner, fp, path]
  const [isLoading, setIsLoading] = useState(false);
  const mnemonicsModalRef = useRef(null);
  const provideMnemonicsModalRef = useRef(null);
  const renderCosignersXpubModalRef = useRef(null);
  const [cosignerXpub, setCosignerXpub] = useState(''); // string used in exportCosigner()
  const [cosignerXpubURv2, setCosignerXpubURv2] = useState(''); // string displayed in renderCosignersXpubModal()
  const [cosignerXpubFilename, setCosignerXpubFilename] = useState('bw-cosigner.bwcosigner');
  const [vaultKeyData, setVaultKeyData] = useState({ keyIndex: 1, xpub: '', seed: '', isLoading: false }); // string rendered in modal
  const [importText, setImportText] = useState('');
  const [askPassphrase, setAskPassphrase] = useState(false);
  const { isPrivacyBlurEnabled } = useSettings();
  const data = useRef(new Array(n));
  const { isVisible } = useKeyboard();
  const { direction } = useLocale();

  useFocusEffect(
    useCallback(() => {
      if (isPrivacyBlurEnabled) {
        enableScreenProtect();
      }
      return () => {
        disableScreenProtect();
      };
    }, [isPrivacyBlurEnabled, enableScreenProtect, disableScreenProtect]),
  );

  useEffect(() => {
    console.log(currentSharedCosigner);
    if (currentSharedCosigner) {
      (async function () {
        if (await confirm(loc.multisig.shared_key_detected, loc.multisig.shared_key_detected_question)) {
          setImportText(currentSharedCosigner);
          provideMnemonicsModalRef.current.present();
          setSharedCosigner('');
        }
      })();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentSharedCosigner]);

  const handleOnHelpPress = async () => {
    navigation.navigate('WalletsAddMultisigHelp');
  };

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    askPassphrase: {
      backgroundColor: colors.lightButton,
    },
    textDestination: {
      color: colors.foregroundColor,
    },
    vaultKeyText: {
      color: colors.alternativeTextColor,
    },
    vaultKeyCircleSuccess: {
      backgroundColor: colors.msSuccessBG,
    },
    word: {
      backgroundColor: colors.inputBackgroundColor,
    },
    wordText: {
      color: colors.labelText,
    },
    helpButton: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    helpButtonText: {
      color: colors.foregroundColor,
    },
    helpButtonWrapper: {
      flexDirection: direction === 'rtl' ? 'row' : 'row-reverse',
    },
    secretContainer: {
      flexDirection: direction === 'rtl' ? 'row-reverse' : 'row',
    },
  });

  const onCreate = async () => {
    setIsLoading(true);
    navigation.setOptions({ headerBackVisible: false });
    await sleep(100);
    try {
      await _onCreate(); // this can fail with "Duplicate fingerprint" error or other
    } catch (e) {
      setIsLoading(false);
      navigation.setOptions({ headerBackVisible: true });
      presentAlert({ message: e.message });
      console.log('create MS wallet error', e);
    }
  };

  const _onCreate = async () => {
    const w = new MultisigHDWallet();
    w.setM(m);
    switch (format) {
      case MultisigHDWallet.FORMAT_P2WSH:
        w.setNativeSegwit();
        w.setDerivationPath(MultisigHDWallet.PATH_NATIVE_SEGWIT);
        break;
      case MultisigHDWallet.FORMAT_P2SH_P2WSH:
      case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT:
        w.setWrappedSegwit();
        w.setDerivationPath(MultisigHDWallet.PATH_WRAPPED_SEGWIT);
        break;
      case MultisigHDWallet.FORMAT_P2SH:
        w.setLegacy();
        w.setDerivationPath(MultisigHDWallet.PATH_LEGACY);
        break;
      default:
        console.error('Unexpected format:', format);
        throw new Error('This should never happen');
    }
    for (const cc of cosigners) {
      const fp = cc[1] || getFpCacheForMnemonics(cc[0], cc[3]);
      w.addCosigner(cc[0], fp, cc[2], cc[3]);
    }
    w.setLabel(walletLabel);
    if (!isElectrumDisabled) {
      await w.fetchBalance();
    }

    addAndSaveWallet(w);

    triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    navigation.getParent()?.goBack();
  };

  const getPath = useCallback(() => {
    let path = '';
    switch (format) {
      case MultisigHDWallet.FORMAT_P2WSH:
        path = MultisigHDWallet.PATH_NATIVE_SEGWIT;
        break;
      case MultisigHDWallet.FORMAT_P2SH_P2WSH:
      case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT:
        path = MultisigHDWallet.PATH_WRAPPED_SEGWIT;
        break;
      case MultisigHDWallet.FORMAT_P2SH:
        path = MultisigHDWallet.PATH_LEGACY;
        break;
      default:
        console.error('Unexpected format:', format);
        throw new Error('This should never happen');
    }
    return path;
  }, [format]);

  const setXpubCacheForMnemonics = useCallback(
    (seed, passphrase) => {
      const path = getPath();
      const w = new MultisigHDWallet();
      w.setDerivationPath(path);
      staticCache[seed + path + passphrase] = w.convertXpubToMultisignatureXpub(MultisigHDWallet.seedToXpub(seed, path, passphrase));
      return staticCache[seed + path + passphrase];
    },
    [getPath],
  );

  const generateNewKey = () => {
    const w = new HDSegwitBech32Wallet();
    w.generate().then(() => {
      const cosignersCopy = [...cosigners];
      cosignersCopy.push([w.getSecret(), false, false]);
      if (Platform.OS !== 'android') LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setCosigners(cosignersCopy);
      setVaultKeyData({ keyIndex: cosignersCopy.length, seed: w.getSecret(), xpub: w.getXpub(), isLoading: false });
      setIsLoading(true);
      mnemonicsModalRef.current.present();
      setTimeout(() => {
        // filling cache
        setXpubCacheForMnemonics(w.getSecret());
        setFpCacheForMnemonics(w.getSecret());
        setIsLoading(false);
      }, 500);
    });
  };

  const viewKey = cosigner => {
    if (MultisigHDWallet.isXpubValid(cosigner[0])) {
      setCosignerXpub(MultisigCosigner.exportToJson(cosigner[1], cosigner[0], cosigner[2]));
      setCosignerXpubURv2(encodeUR(MultisigCosigner.exportToJson(cosigner[1], cosigner[0], cosigner[2]))[0]);
      setCosignerXpubFilename('bw-cosigner-' + cosigner[1] + '.bwcosigner');
      renderCosignersXpubModalRef.current.present();
    } else {
      const path = getPath();

      const xpub = getXpubCacheForMnemonics(cosigner[0], cosigner[3]);
      const fp = getFpCacheForMnemonics(cosigner[0], cosigner[3]);
      setCosignerXpub(MultisigCosigner.exportToJson(fp, xpub, path));
      setCosignerXpubURv2(encodeUR(MultisigCosigner.exportToJson(fp, xpub, path))[0]);
      setCosignerXpubFilename('bw-cosigner-' + fp + '.bwcosigner');
      renderCosignersXpubModalRef.current.present();
    }
  };

  const getXpubCacheForMnemonics = useCallback(
    (seed, passphrase) => {
      const path = getPath();
      return staticCache[seed + path + passphrase] || setXpubCacheForMnemonics(seed, passphrase);
    },
    [getPath, setXpubCacheForMnemonics],
  );

  const getFpCacheForMnemonics = (seed, passphrase) => {
    return staticCache[seed + (passphrase ?? '')] || setFpCacheForMnemonics(seed, passphrase);
  };

  const setFpCacheForMnemonics = (seed, passphrase) => {
    staticCache[seed + (passphrase ?? '')] = MultisigHDWallet.mnemonicToFingerprint(seed, passphrase);
    return staticCache[seed + (passphrase ?? '')];
  };

  const iHaveMnemonics = () => {
    provideMnemonicsModalRef.current.present();
  };

  const tryUsingXpub = useCallback(
    async (xpub, fp, path) => {
      if (!MultisigHDWallet.isXpubForMultisig(xpub)) {
        setIsLoading(false);
        setImportText('');
        setAskPassphrase(false);
        presentAlert({ message: loc.multisig.not_a_multisignature_xpub });
        return;
      }
      if (fp) {
        //  do nothing, it's already set
      } else {
        try {
          fp = await prompt(loc.multisig.input_fp, loc.multisig.input_fp_explain, true, 'plain-text');
          fp = (fp + '').toUpperCase();
          if (!MultisigHDWallet.isFpValid(fp)) fp = '00000000';
        } catch (e) {
          return setIsLoading(false);
        }
      }
      if (path) {
        //  do nothing, it's already set
      } else {
        try {
          path = await prompt(
            loc.multisig.input_path,
            loc.formatString(loc.multisig.input_path_explain, { default: getPath() }),
            true,
            'plain-text',
          );
          if (!MultisigHDWallet.isPathValid(path)) path = getPath();
        } catch {
          return setIsLoading(false);
        }
      }

      setIsLoading(false);
      setImportText('');
      setAskPassphrase(false);

      const cosignersCopy = [...cosigners];
      cosignersCopy.push([xpub, fp, path]);
      if (Platform.OS !== 'android') LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setCosigners(cosignersCopy);
    },
    [cosigners, getPath],
  );

  const isValidMnemonicSeed = mnemonicSeed => {
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(mnemonicSeed);
    return hd.validateMnemonic();
  };

  const onBarScanned = useCallback(
    async ret => {
      if (!ret.data) ret = { data: ret };

      try {
        let retData = JSON.parse(ret.data);
        if (Array.isArray(retData) && retData.length === 1) {
          // UR:CRYPTO-ACCOUNT now parses as an array of accounts, even if it is just one,
          // so in case of cosigner data its gona be an array of 1 cosigner account. lets pop it for
          // the code that expects it
          retData = retData.pop();
          ret.data = JSON.stringify(retData);
        }
      } catch (e) {
        console.debug('JSON parsing failed for ret.data:', e);
      }

      if (ret.data.toUpperCase().startsWith('UR')) {
        presentAlert({ message: 'BC-UR not decoded. This should never happen' });
      } else if (isValidMnemonicSeed(ret.data)) {
        setImportText(ret.data);
        setTimeout(async () => {
          await provideMnemonicsModalRef.current.present();
        }, 100);
      } else {
        if (MultisigHDWallet.isXpubValid(ret.data) && !MultisigHDWallet.isXpubForMultisig(ret.data)) {
          return presentAlert({ message: loc.multisig.not_a_multisignature_xpub });
        }
        if (MultisigHDWallet.isXpubValid(ret.data)) {
          return tryUsingXpub(ret.data);
        }
        let cosigner = new MultisigCosigner(ret.data);
        if (!cosigner.isValid()) {
          return presentAlert({ message: loc.multisig.invalid_cosigner });
        }

        if (cosigner.howManyCosignersWeHave() > 1) {
          // lets look for the correct cosigner. thats probably gona be the one with specific corresponding path,
          // for example m/48'/0'/0'/2' if user chose to setup native segwit in BW
          for (const cc of cosigner.getAllCosigners()) {
            switch (format) {
              case MultisigHDWallet.FORMAT_P2WSH:
                if (cc.getPath().startsWith('m/48') && cc.getPath().endsWith("/2'")) {
                  // found it
                  cosigner = cc;
                }
                break;
              case MultisigHDWallet.FORMAT_P2SH_P2WSH:
              case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT:
                if (cc.getPath().startsWith('m/48') && cc.getPath().endsWith("/1'")) {
                  // found it
                  cosigner = cc;
                }
                break;
              case MultisigHDWallet.FORMAT_P2SH:
                if (cc.getPath().startsWith('m/45')) {
                  // found it
                  cosigner = cc;
                }
                break;
              default:
                console.error('Unexpected format:', format);
                throw new Error('This should never happen');
            }
          }
        }

        for (const existingCosigner of cosigners) {
          let existingXpub = existingCosigner[0];
          if (!MultisigHDWallet.isXpubValid(existingXpub)) {
            // derive the xpub from mnemonic-based cosigner
            existingXpub = getXpubCacheForMnemonics(existingCosigner[0], existingCosigner[3]);
          }
          if (existingXpub === cosigner.getXpub()) {
            return presentAlert({ message: loc.multisig.this_cosigner_is_already_imported });
          }
        }
        // now, validating that cosigner is in correct format:

        let correctFormat = false;
        switch (format) {
          case MultisigHDWallet.FORMAT_P2WSH:
            if (cosigner.getPath().startsWith('m/48') && cosigner.getPath().endsWith("/2'")) {
              correctFormat = true;
            }
            break;
          case MultisigHDWallet.FORMAT_P2SH_P2WSH:
          case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT:
            if (cosigner.getPath().startsWith('m/48') && cosigner.getPath().endsWith("/1'")) {
              correctFormat = true;
            }
            break;
          case MultisigHDWallet.FORMAT_P2SH:
            if (cosigner.getPath().startsWith('m/45')) {
              correctFormat = true;
            }
            break;
          default:
            console.error('Unexpected format:', format);
            throw new Error('This should never happen');
        }
        if (!correctFormat) {
          return presentAlert({ message: loc.formatString(loc.multisig.invalid_cosigner_format, { format }) });
        }
        const cosignersCopy = [...cosigners];
        cosignersCopy.push([cosigner.getXpub(), cosigner.getFp(), cosigner.getPath()]);
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setCosigners(cosignersCopy);
      }
    },
    [cosigners, format, getXpubCacheForMnemonics, tryUsingXpub],
  );

  const utilizeMnemonicPhrase = useCallback(async () => {
    try {
      await provideMnemonicsModalRef.current.dismiss();
    } catch {}
    setIsLoading(true);

    if (MultisigHDWallet.isXpubValid(importText)) {
      return tryUsingXpub(importText);
    }
    try {
      const jsonText = JSON.parse(importText);
      let fp;
      let path;
      if (jsonText.xpub) {
        if (jsonText.xfp) {
          fp = jsonText.xfp;
        }
        if (jsonText.path) {
          path = jsonText.path;
        }
        return tryUsingXpub(jsonText.xpub, fp, path);
      }
    } catch {}
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(importText);
    if (!hd.validateMnemonic()) {
      setIsLoading(false);
      return presentAlert({ message: loc.multisig.invalid_mnemonics });
    }

    let passphrase;
    if (askPassphrase) {
      try {
        passphrase = await prompt(loc.wallets.import_passphrase_title, loc.wallets.import_passphrase_message);
      } catch (e) {
        if (e.message === 'Cancel Pressed') {
          setIsLoading(false);
          return;
        }
        throw e;
      }
    }

    const cosignersCopy = [...cosigners];
    cosignersCopy.push([hd.getSecret(), false, false, passphrase]);
    if (Platform.OS !== 'android') LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setCosigners(cosignersCopy);

    setIsLoading(false);
    setImportText('');
    setAskPassphrase(false);
  }, [askPassphrase, cosigners, importText, tryUsingXpub]);

  useEffect(() => {
    InteractionManager.runAfterInteractions(() => {
      const scannedData = params.onBarScanned;
      if (scannedData) {
        onBarScanned(scannedData);
        navigation.setParams({ onBarScanned: undefined });
      }
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [navigation, params.onBarScanned]);

  const dashType = ({ index, lastIndex, isChecked, isFocus }) => {
    if (isChecked) {
      if (index === lastIndex) {
        return MultipleStepsListItemDashType;
      } else {
        return MultipleStepsListItemDashType.TopAndBottom;
      }
    } else {
      if (index === lastIndex) {
        return isFocus ? MultipleStepsListItemDashType.TopAndBottom : MultipleStepsListItemDashType.Top;
      } else {
        return MultipleStepsListItemDashType.TopAndBottom;
      }
    }
  };

  const _renderKeyItem = el => {
    const renderProvideKeyButtons = el.index === cosigners.length;
    const isChecked = el.index < cosigners.length;
    return (
      <View>
        <MultipleStepsListItem
          circledText={String(el.index + 1)}
          leftText={loc.formatString(loc.multisig.vault_key, { number: el.index + 1 })}
          dashes={dashType({ index: el.index, lastIndex: data.current.length - 1, isChecked, isFocus: renderProvideKeyButtons })}
          checked={isChecked}
          rightButton={{
            disabled: vaultKeyData.isLoading,
            text: loc.multisig.share,
            onPress: () => {
              viewKey(cosigners[el.index]);
            },
          }}
        />
        {renderProvideKeyButtons && (
          <>
            <MultipleStepsListItem
              showActivityIndicator={vaultKeyData.keyIndex === el.index && vaultKeyData.isLoading}
              button={{
                buttonType: MultipleStepsListItemButtonType.Full,
                onPress: () => {
                  setVaultKeyData({ keyIndex: el.index, xpub: '', seed: '', isLoading: true });
                  generateNewKey();
                },
                text: loc.multisig.create_new_key,
                disabled: vaultKeyData.isLoading,
              }}
              dashes={MultipleStepsListItemDashType.TopAndBottom}
              checked={isChecked}
            />
            <MultipleStepsListItem
              button={{
                testID: 'VaultCosignerImport' + String(el.index + 1),
                onPress: iHaveMnemonics,
                buttonType: MultipleStepsListItemButtonType.Full,
                text: loc.wallets.import_do_import,
                disabled: vaultKeyData.isLoading,
              }}
              dashes={el.index === data.current.length - 1 ? MultipleStepsListItemDashType.Top : MultipleStepsListItemDashType.TopAndBottom}
              checked={isChecked}
            />
          </>
        )}
      </View>
    );
  };

  const renderSecret = entries => {
    const component = [];
    const entriesObject = entries.entries();
    for (const [index, secret] of entriesObject) {
      if (entries.length > 1) {
        const text = `${index + 1}. ${secret}  `;
        component.push(
          <View style={[styles.word, stylesHook.word]} key={`${secret}${index}`}>
            <Text style={[styles.wordText, stylesHook.wordText]} textBreakStrategy="simple">
              {text}
            </Text>
          </View>,
        );
      } else {
        const text = `${secret}  `;
        component.push(
          <View style={[styles.word, stylesHook.word]} key={`${secret}${index}`}>
            <Text style={[styles.wordText, stylesHook.wordText]} textBreakStrategy="simple">
              {text}
            </Text>
          </View>,
        );
      }
    }
    return component;
  };

  const dismissMnemonicsModal = async () => {
    await mnemonicsModalRef.current.dismiss();
  };

  const renderMnemonicsModal = () => {
    return (
      <BottomModal
        ref={mnemonicsModalRef}
        isGrabberVisible={false}
        dismissible={false}
        showCloseButton={!isLoading}
        sizes={[Platform.OS === 'ios' ? 'auto' : '80%']}
        backgroundColor={colors.modal}
        footer={
          <View style={styles.modalFooterBottomPadding}>
            {isLoading ? <ActivityIndicator /> : <Button title={loc.send.success_done} onPress={dismissMnemonicsModal} />}
          </View>
        }
      >
        <View style={styles.itemKeyUnprovidedWrapper}>
          <View style={[styles.vaultKeyCircleSuccess, stylesHook.vaultKeyCircleSuccess]}>
            <Icon size={24} name="check" type="ionicons" color={colors.msSuccessCheck} />
          </View>
          <View style={styles.vaultKeyTextWrapper}>
            <Text style={[styles.vaultKeyText, stylesHook.vaultKeyText]}>
              {loc.formatString(loc.multisig.vault_key, { number: vaultKeyData.keyIndex })}
            </Text>
          </View>
        </View>
        <MalinSpacing20 />
        <Text style={[styles.headerText, stylesHook.textDestination]}>{loc.multisig.wallet_key_created}</Text>
        <MalinSpacing20 />
        <Text style={[styles.textDestination, stylesHook.textDestination]}>{loc._.seed}</Text>
        <MalinSpacing10 />
        <View style={[styles.secretContainer, stylesHook.secretContainer]}>{renderSecret(vaultKeyData.seed.split(' '))}</View>
        <MalinSpacing20 />
      </BottomModal>
    );
  };

  const toolTipActions = useMemo(() => {
    const passphrase = CommonToolTipActions.Passphrase;
    passphrase.menuState = askPassphrase;
    return [passphrase];
  }, [askPassphrase]);

  const renderProvideMnemonicsModal = () => {
    const opacity = isVisible ? 0 : 1;
    return (
      <BottomModal
        footer={
          <View style={[styles.modalFooterBottomPadding, { opacity }]}>
            {isLoading ? (
              <ActivityIndicator />
            ) : (
              <>
                <Button
                  testID="DoImportKeyButton"
                  disabled={importText.trim().length === 0}
                  title={loc.wallets.import_do_import}
                  onPress={utilizeMnemonicPhrase}
                />
                <View style={styles.height16} />

                <AddressInputScanButton
                  beforePress={async () => {
                    await provideMnemonicsModalRef.current.dismiss();
                  }}
                  onBarScanned={onBarScanned}
                  testID="ScanOrOpenFile"
                  type="link"
                  disabled={isLoading}
                />
              </>
            )}
          </View>
        }
        keyboardMode="auto"
        ref={provideMnemonicsModalRef}
        backgroundColor={colors.modal}
        contentContainerStyle={styles.provideMnemonicsModalStyle}
        isGrabberVisible={false}
        showCloseButton={true}
        sizes={[Platform.OS === 'ios' ? 'auto' : 420]}
        onDismiss={() => {
          Keyboard.dismiss();
          setImportText('');
          setAskPassphrase(false);
        }}
        header={
          <ToolTipMenu
            isButton
            isMenuPrimaryAction
            onPressMenuItem={_id => {
              LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
              setAskPassphrase(!askPassphrase);
            }}
            actions={toolTipActions}
            style={[styles.askPassprase, stylesHook.askPassphrase]}
          >
            <Icon size={22} name="more-horiz" type="material" color={colors.foregroundColor} />
          </ToolTipMenu>
        }
      >
        <MalinTextCentered>{loc.multisig.type_your_mnemonics}</MalinTextCentered>
        <MalinSpacing20 />
        <View style={styles.multiLineTextInput}>
          <MalinFormMultiInput
            value={importText}
            onChangeText={setImportText}
            inputAccessoryViewID={DoneAndDismissKeyboardInputAccessoryViewID}
          />
          {Platform.select({
            ios: (
              <DoneAndDismissKeyboardInputAccessory
                onClearTapped={() => setImportText('')}
                onPasteTapped={async () => {
                  const paste = await Clipboard.getString();
                  setImportText(paste);
                }}
              />
            ),
          })}

          <MalinSpacing20 />
        </View>
      </BottomModal>
    );
  };

  const hideCosignersXpubModal = () => {
    Keyboard.dismiss();
    renderCosignersXpubModalRef.current.dismiss();
  };

  const renderCosignersXpubModal = () => {
    return (
      <BottomModal
        onClose={hideCosignersXpubModal}
        ref={renderCosignersXpubModalRef}
        backgroundColor={colors.modal}
        shareContent={{ fileContent: cosignerXpub, fileName: cosignerXpubFilename }}
        footerDefaultMargins
        contentContainerStyle={styles.modalContent}
        footer={<View style={styles.modalFooterBottomPadding}>{isLoading ? <ActivityIndicator /> : null}</View>}
      >
        <Text style={[styles.headerText, stylesHook.textDestination]}>
          {loc.multisig.this_is_cosigners_xpub} {Platform.OS === 'ios' ? loc.multisig.this_is_cosigners_xpub_airdrop : ''}
        </Text>
        <MalinSpacing20 />
        <View style={styles.qrContainer}>
          <QRCodeComponent value={cosignerXpubURv2} size={260} />
        </View>
        <MalinSpacing20 />
      </BottomModal>
    );
  };

  const renderHelp = () => {
    const opacity = isLoading ? 0.5 : 1;
    return (
      <View style={[styles.helpButtonWrapper, stylesHook.helpButtonWrapper]}>
        <TouchableOpacity
          accessibilityRole="button"
          style={[styles.helpButton, stylesHook.helpButton, { opacity }]}
          onPress={handleOnHelpPress}
          disabled={isLoading}
        >
          <Icon size={20} name="help" type="octaicon" color={colors.foregroundColor} />
          <Text style={[styles.helpButtonText, stylesHook.helpButtonText]}>{loc.multisig.ms_help}</Text>
        </TouchableOpacity>
      </View>
    );
  };

  const footer = (
    <View style={styles.buttonBottom}>
      {isLoading ? (
        <ActivityIndicator />
      ) : (
        <Button testID="CreateButton" title={loc.multisig.create} onPress={onCreate} disabled={cosigners.length !== n} />
      )}
    </View>
  );

  return (
    <View style={[styles.root, stylesHook.root]}>
      {renderHelp()}
      <View style={styles.wrapBox}>
        <FlatList data={data.current} renderItem={_renderKeyItem} keyExtractor={(_item, index) => `${index}`} extraData={cosigners} />
      </View>
      {renderMnemonicsModal()}

      {renderProvideMnemonicsModal()}

      {renderCosignersXpubModal()}
      {footer}
      <MalinSpacing20 />
    </View>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
    paddingHorizontal: 20,
  },
  wrapBox: {
    flex: 1,
    marginVertical: 24,
  },
  height16: {
    height: 16,
  },
  buttonBottom: {
    marginHorizontal: 20,
    flex: 0.12,
    marginBottom: 40,
    justifyContent: 'flex-end',
  },
  itemKeyUnprovidedWrapper: { flexDirection: 'row' },
  vaultKeyText: { fontSize: 18, fontWeight: 'bold' },
  vaultKeyTextWrapper: { justifyContent: 'center', alignItems: 'center', paddingLeft: 16 },
  textDestination: { fontWeight: '600' },
  modalContent: {
    paddingHorizontal: 22,
    paddingVertical: 32,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 400,
  },
  multiLineTextInput: {
    minHeight: 200,
  },
  modalFooterBottomPadding: { padding: 38 },
  vaultKeyCircleSuccess: {
    width: 42,
    height: 42,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  word: {
    width: 'auto',
    marginRight: 8,
    marginBottom: 8,
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 8,
    paddingRight: 8,
    borderRadius: 4,
  },
  askPassprase: { marginLeft: 32, justifyContent: 'center', width: 33, height: 33, borderRadius: 33 / 2 },

  secretContainer: {
    justifyContent: 'flex-start',
    flexWrap: 'wrap',
  },
  wordText: {
    fontWeight: 'bold',
  },
  headerText: { fontSize: 15, color: '#13244D' },
  qrContainer: {
    alignItems: 'center',
  },
  helpButtonWrapper: {
    alignItems: 'flex-end',
  },
  helpButton: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 50,
    flexDirection: 'row',
  },
  helpButtonText: {
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  provideMnemonicsModalStyle: {
    minHeight: 420,
  },
});

export default WalletsAddMultisigStep2;


================================================
FILE: ./screen/wallets/ViewEditMultisigCosigners.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { RouteProp, useFocusEffect, useRoute, usePreventRemove, StackActions } from '@react-navigation/native';
import {
  ActivityIndicator,
  Alert,
  findNodeHandle,
  FlatList,
  GestureResponderEvent,
  InteractionManager,
  Keyboard,
  LayoutAnimation,
  ListRenderItemInfo,
  Platform,
  StyleSheet,
  Text,
  View,
} from 'react-native';
import { Badge, Icon } from '@rneui/themed';
import { isDesktop } from '../../malin_modules/environment';
import { encodeUR } from '../../malin_modules/ur';
import { MalinCard, MalinFormMultiInput, MalinTextCentered } from '../../MalinComponents';
import { HDSegwitBech32Wallet, MultisigCosigner, MultisigHDWallet } from '../../class';
import presentAlert from '../../components/Alert';
import BottomModal, { BottomModalHandle } from '../../components/BottomModal';
import Button from '../../components/Button';
import MultipleStepsListItem, {
  MultipleStepsListItemButtonType,
  MultipleStepsListItemDashType,
} from '../../components/MultipleStepsListItem';
import QRCodeComponent from '../../components/QRCodeComponent';
import SquareEnumeratedWords, { SquareEnumeratedWordsContentAlign } from '../../components/SquareEnumeratedWords';
import { useTheme } from '../../components/themes';
import prompt from '../../helpers/prompt';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import loc from '../../loc';
import ActionSheet from '../ActionSheet';
import { useStorage } from '../../hooks/context/useStorage';
import ToolTipMenu from '../../components/TooltipMenu';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { useSettings } from '../../hooks/context/useSettings';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import SafeArea from '../../components/SafeArea';
import { TWallet } from '../../class/wallets/types';
import { AddressInputScanButton } from '../../components/AddressInputScanButton';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { MalinSpacing10, MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';

type RouteParams = RouteProp<DetailViewStackParamList, 'ViewEditMultisigCosigners'>;
type NavigationProp = NativeStackNavigationProp<DetailViewStackParamList, 'ViewEditMultisigCosigners'>;

const ViewEditMultisigCosigners: React.FC = () => {
  const hasLoaded = useRef(false);
  const { colors } = useTheme();
  const { wallets, setWalletsWithNewOrder } = useStorage();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const { isElectrumDisabled, isPrivacyBlurEnabled } = useSettings();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const { dispatch, setParams, setOptions } = useExtendedNavigation<NavigationProp>();
  const route = useRoute<RouteParams>();
  const { walletID } = route.params;
  const w = useRef(wallets.find(wallet => wallet.getID() === walletID));
  const tempWallet = useRef(new MultisigHDWallet());
  const [wallet, setWallet] = useState<MultisigHDWallet>();
  const [isLoading, setIsLoading] = useState(true);
  const [isSaveButtonDisabled, setIsSaveButtonDisabled] = useState(true);
  const [currentlyEditingCosignerNum, setCurrentlyEditingCosignerNum] = useState<number | false>(false);
  const shareModalRef = useRef<BottomModalHandle>(null);
  const provideMnemonicsModalRef = useRef<BottomModalHandle>(null);
  const mnemonicsModalRef = useRef<BottomModalHandle>(null);
  const [importText, setImportText] = useState('');
  const [exportString, setExportString] = useState('{}'); // used in exportCosigner()
  const [exportStringURv2, setExportStringURv2] = useState(''); // used in QR
  const [exportFilename, setExportFilename] = useState('bw-cosigner.json');
  const [vaultKeyData, setVaultKeyData] = useState({ keyIndex: 1, xpub: '', seed: '', passphrase: '', path: '', fp: '', isLoading: false }); // string rendered in modal
  const [isVaultKeyIndexDataLoading, setIsVaultKeyIndexDataLoading] = useState<number | undefined>(undefined);
  const [askPassphrase, setAskPassphrase] = useState(false);
  const [walletData, setWalletData] = useState<TWallet[]>([]);
  /* discardChangesRef is only so the action sheet can be shown on mac catalyst when a
    user tries to leave the screen with unsaved changes.
    Why the container view ? It was the easiest to get the ref for. No other reason.
  */
  const discardChangesRef = useRef<View>(null);

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    textDestination: {
      color: colors.foregroundColor,
    },
    vaultKeyText: {
      color: colors.alternativeTextColor,
    },
    askPassphrase: {
      backgroundColor: colors.lightButton,
    },
    vaultKeyCircleSuccess: {
      backgroundColor: colors.msSuccessBG,
    },
    tipKeys: {
      color: colors.alternativeTextColor,
    },
    tipLabel: {
      backgroundColor: colors.inputBackgroundColor,
      borderColor: colors.inputBackgroundColor,
    },
    tipLabelText: {
      color: colors.buttonTextColor,
    },
  });

  usePreventRemove(!isSaveButtonDisabled, ({ data }) => {
    if (isDesktop) {
      if (!discardChangesRef.current) return dispatch(data.action);
      const anchor = findNodeHandle(discardChangesRef.current);
      if (!anchor) return dispatch(data.action);
      ActionSheet.showActionSheetWithOptions(
        {
          options: [loc._.cancel, loc._.ok],
          cancelButtonIndex: 0,
          title: loc._.discard_changes,
          message: loc._.discard_changes_explain,
          anchor,
        },
        buttonIndex => {
          if (buttonIndex === 1) {
            dispatch(data.action);
          }
        },
      );
    } else {
      Alert.alert(loc._.discard_changes, loc._.discard_changes_explain, [
        { text: loc._.cancel, style: 'cancel', onPress: () => {} },
        {
          text: loc._.ok,
          style: 'default',
          onPress: () => dispatch(data.action),
        },
      ]);
    }
  });

  const onSave = async () => {
    if (!wallet) {
      throw new Error('Wallet is undefined');
    }
    setIsLoading(true);

    const isBiometricsEnabled = await isBiometricUseCapableAndEnabled();

    if (isBiometricsEnabled) {
      if (!(await unlockWithBiometrics())) {
        setIsLoading(false);
        return;
      }
    }

    setOptions({ headerRight: () => null });

    setTimeout(async () => {
      // eslint-disable-next-line prefer-const
      let newWallets = wallets.filter(newWallet => {
        return newWallet.getID() !== walletID;
      }) as MultisigHDWallet[];
      if (!isElectrumDisabled) {
        await wallet?.fetchBalance();
      }
      newWallets.push(wallet);
      setIsSaveButtonDisabled(true);
      setWalletsWithNewOrder(newWallets);
      setTimeout(() => {
        const popTo = StackActions.popTo('WalletTransactions', {
          walletID,
          walletType: wallet.type,
        });
        dispatch(popTo);
      }, 500);
    }, 100);
  };

  useFocusEffect(
    useCallback(() => {
      // useFocusEffect is called on willAppear (example: when camera dismisses). we want to avoid this.
      if (hasLoaded.current) return;
      setIsLoading(true);
      if (isPrivacyBlurEnabled) enableScreenProtect();

      const task = InteractionManager.runAfterInteractions(async () => {
        if (!w.current) {
          // lets create fake wallet so renderer wont throw any errors
          w.current = new MultisigHDWallet();
          w.current.setNativeSegwit();
        } else {
          tempWallet.current.setSecret(w.current.getSecret());
          setWalletData(new Array(tempWallet.current.getN()));
          setWallet(tempWallet.current);
        }
        hasLoaded.current = true;
        setIsLoading(false);
      });
      return () => {
        disableScreenProtect();
        task.cancel();
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [walletID]),
  );

  const renderMnemonicsModal = () => {
    return (
      <BottomModal
        ref={mnemonicsModalRef}
        backgroundColor={colors.elevated}
        contentContainerStyle={[styles.newKeyModalContent, styles.paddingTop44]}
        shareButtonOnPress={() => {
          shareModalRef.current?.present();
        }}
        sizes={[Platform.OS === 'ios' ? 'auto' : '50%']}
        header={
          <View style={styles.itemKeyUnprovidedWrapper}>
            <View style={[styles.vaultKeyCircleSuccess, stylesHook.vaultKeyCircleSuccess]}>
              <Icon size={24} name="check" type="ionicons" color={colors.msSuccessCheck} />
            </View>
            <View style={styles.vaultKeyTextWrapper}>
              <Text style={[styles.vaultKeyText, stylesHook.vaultKeyText]}>
                {loc.formatString(loc.multisig.vault_key, { number: vaultKeyData.keyIndex })}
              </Text>
            </View>
          </View>
        }
      >
        {vaultKeyData.xpub.length > 1 && (
          <>
            <Text style={[styles.textDestination, stylesHook.textDestination]}>{loc._.wallet_key}</Text>
            <MalinSpacing10 />
            <SquareEnumeratedWords
              contentAlign={SquareEnumeratedWordsContentAlign.left}
              entries={[vaultKeyData.xpub, vaultKeyData.fp, vaultKeyData.path]}
              appendNumber={false}
            />
          </>
        )}
        {vaultKeyData.seed.length > 1 && (
          <>
            <MalinSpacing20 />
            <Text style={[styles.textDestination, stylesHook.textDestination]}>{loc._.seed}</Text>
            <MalinSpacing10 />
            <SquareEnumeratedWords
              contentAlign={SquareEnumeratedWordsContentAlign.left}
              entries={vaultKeyData.seed.split(' ')}
              appendNumber
            />
            {vaultKeyData.passphrase.length > 1 && (
              <Text style={[styles.textDestination, stylesHook.textDestination]}>{vaultKeyData.passphrase}</Text>
            )}
          </>
        )}
        {renderShareModal()}
      </BottomModal>
    );
  };

  const resetModalData = () => {
    setVaultKeyData({
      keyIndex: 1,
      xpub: '',
      seed: '',
      passphrase: '',
      path: '',
      fp: '',
      isLoading: false,
    });
    setImportText('');
    setExportString('{}');
    setExportStringURv2('');
    setExportFilename('');
    setIsSaveButtonDisabled(false);
    setAskPassphrase(false);
  };

  const _renderKeyItem = (el: ListRenderItemInfo<any>) => {
    if (!wallet) {
      // failsafe
      return null;
    }
    const isXpub = MultisigHDWallet.isXpubValid(wallet.getCosigner(el.index + 1));
    let leftText;
    if (isXpub) {
      leftText = wallet.getCosigner(el.index + 1);
      const currentAddress = leftText;
      const firstFour = currentAddress.substring(0, 5);
      const lastFour = currentAddress.substring(currentAddress.length - 5, currentAddress.length);
      leftText = `${firstFour}...${lastFour}`;
    } else {
      const secret = wallet.getCosigner(el.index + 1).split(' ');
      leftText = `${secret[0]}...${secret[secret.length - 1]}`;
    }

    const length = walletData.length;

    return (
      <View>
        <MultipleStepsListItem
          checked
          leftText={loc.formatString(loc.multisig.vault_key, { number: el.index + 1 })}
          dashes={el.index === length - 1 ? MultipleStepsListItemDashType.Bottom : MultipleStepsListItemDashType.TopAndBottom}
        />

        {isXpub ? (
          <View>
            {!vaultKeyData.isLoading && (
              <MultipleStepsListItem
                button={{
                  buttonType: MultipleStepsListItemButtonType.Partial,
                  leftText,
                  text: loc.multisig.view,
                  showActivityIndicator: isVaultKeyIndexDataLoading === el.index + 1,
                  disabled: vaultKeyData.isLoading,
                  onPress: () => {
                    setIsVaultKeyIndexDataLoading(el.index + 1);
                    setTimeout(() => {
                      const keyIndex = el.index + 1;
                      const xpub = wallet.getCosigner(keyIndex);
                      const fp = wallet.getFingerprint(keyIndex);
                      const path = wallet.getCustomDerivationPathForCosigner(keyIndex);
                      if (!path) {
                        presentAlert({ message: 'Cannot find derivation path for this cosigner' });
                        return;
                      }
                      setVaultKeyData({
                        keyIndex,
                        seed: '',
                        passphrase: '',
                        xpub,
                        fp,
                        path,
                        isLoading: false,
                      });
                      setExportString(MultisigCosigner.exportToJson(fp, xpub, path));
                      setExportStringURv2(encodeUR(MultisigCosigner.exportToJson(fp, xpub, path))[0]);
                      setExportFilename('bw-cosigner-' + fp + '.json');
                      mnemonicsModalRef.current?.present();
                      setIsVaultKeyIndexDataLoading(undefined);
                    }, 100);
                  },
                }}
                dashes={MultipleStepsListItemDashType.TopAndBottom}
              />
            )}
            <MultipleStepsListItem
              showActivityIndicator={vaultKeyData.keyIndex === el.index + 1 && vaultKeyData.isLoading}
              button={{
                text: loc.multisig.i_have_mnemonics,
                buttonType: MultipleStepsListItemButtonType.Full,
                disabled: vaultKeyData.isLoading,
                onPress: () => {
                  setCurrentlyEditingCosignerNum(el.index + 1);
                  provideMnemonicsModalRef.current?.present();
                },
              }}
              dashes={el.index === length - 1 ? MultipleStepsListItemDashType.Top : MultipleStepsListItemDashType.TopAndBottom}
            />
          </View>
        ) : (
          <View>
            {!vaultKeyData.isLoading && (
              <MultipleStepsListItem
                showActivityIndicator={vaultKeyData.keyIndex === el.index + 1 && vaultKeyData.isLoading}
                button={{
                  leftText,
                  text: loc.multisig.view,
                  disabled: vaultKeyData.isLoading,
                  showActivityIndicator: isVaultKeyIndexDataLoading === el.index + 1,
                  buttonType: MultipleStepsListItemButtonType.Partial,
                  onPress: () => {
                    setIsVaultKeyIndexDataLoading(el.index + 1);
                    setTimeout(() => {
                      const keyIndex = el.index + 1;
                      const seed = wallet.getCosigner(keyIndex);
                      const passphrase = wallet.getCosignerPassphrase(keyIndex);
                      setVaultKeyData({
                        keyIndex,
                        seed,
                        xpub: '',
                        fp: '',
                        path: '',
                        passphrase: passphrase ?? '',
                        isLoading: false,
                      });
                      const fp = wallet.getFingerprint(keyIndex);
                      const path = wallet.getCustomDerivationPathForCosigner(keyIndex);
                      if (!path) {
                        presentAlert({ message: 'Cannot find derivation path for this cosigner' });
                        return;
                      }
                      const xpub = wallet.convertXpubToMultisignatureXpub(MultisigHDWallet.seedToXpub(seed, path, passphrase));
                      setExportString(MultisigCosigner.exportToJson(fp, xpub, path));
                      setExportStringURv2(encodeUR(MultisigCosigner.exportToJson(fp, xpub, path))[0]);
                      setExportFilename('bw-cosigner-' + fp + '.json');
                      mnemonicsModalRef.current?.present();
                      setIsVaultKeyIndexDataLoading(undefined);
                    }, 100);
                  },
                }}
                dashes={MultipleStepsListItemDashType.TopAndBottom}
              />
            )}

            <MultipleStepsListItem
              actionSheetOptions={{
                options: [loc._.cancel, loc.multisig.confirm],
                title: loc._.seed,
                message: loc.multisig.are_you_sure_seed_will_be_lost,
                cancelButtonIndex: 0,
                confirmButtonIndex: 1,
              }}
              showActivityIndicator={vaultKeyData.keyIndex === el.index + 1 && vaultKeyData.isLoading}
              dashes={el.index === length - 1 ? MultipleStepsListItemDashType.Top : MultipleStepsListItemDashType.TopAndBottom}
              button={{
                text: loc.multisig.forget_this_seed,
                disabled: vaultKeyData.isLoading,
                buttonType: MultipleStepsListItemButtonType.Full,

                onPress: (e: number | GestureResponderEvent) => {
                  if (e === 0) return;
                  LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
                  setVaultKeyData({
                    ...vaultKeyData,
                    isLoading: true,
                    keyIndex: el.index + 1,
                  });
                  setTimeout(
                    () =>
                      xpubInsteadOfSeed(el.index + 1).finally(() => {
                        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
                        setVaultKeyData({
                          ...vaultKeyData,
                          isLoading: false,
                          keyIndex: el.index + 1,
                        });
                      }),
                    100,
                  );
                },
              }}
            />
          </View>
        )}
      </View>
    );
  };

  const _handleUseMnemonicPhrase = useCallback(
    (mnemonic: string, passphrase?: string) => {
      if (!wallet || !currentlyEditingCosignerNum) {
        // failsafe
        return;
      }

      const hd = new HDSegwitBech32Wallet();
      hd.setSecret(mnemonic);
      if (!hd.validateMnemonic()) return presentAlert({ message: loc.multisig.invalid_mnemonics });
      try {
        wallet.replaceCosignerXpubWithSeed(currentlyEditingCosignerNum, hd.getSecret(), passphrase);
      } catch (e: any) {
        console.log(e);
        return presentAlert({ message: e.message });
      }

      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setWallet(wallet);
      provideMnemonicsModalRef.current?.dismiss();
      setIsSaveButtonDisabled(false);
      setImportText('');
      setAskPassphrase(false);
    },
    [wallet, currentlyEditingCosignerNum],
  );

  const handleUseMnemonicPhrase = useCallback(async () => {
    let passphrase;
    if (askPassphrase) {
      try {
        passphrase = await prompt(loc.wallets.import_passphrase_title, loc.wallets.import_passphrase_message);
      } catch (e: any) {
        if (e.message === 'Cancel Pressed') {
          setIsLoading(false);
          return;
        }
        throw e;
      }
    }
    return _handleUseMnemonicPhrase(importText, passphrase);
  }, [askPassphrase, importText, _handleUseMnemonicPhrase]);

  const xpubInsteadOfSeed = (index: number): Promise<void> => {
    return new Promise((resolve, reject) => {
      InteractionManager.runAfterInteractions(() => {
        try {
          wallet?.replaceCosignerSeedWithXpub(index);
        } catch (e: any) {
          reject(e);
          return presentAlert({ message: e.message });
        }
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setWallet(wallet);
        setIsSaveButtonDisabled(false);
        resolve();
      });
    });
  };

  useEffect(() => {
    const scannedData = route.params.onBarScanned;
    if (scannedData) {
      setImportText(String(scannedData));
      handleUseMnemonicPhrase();
    }
  }, [route.params.onBarScanned, setParams, handleUseMnemonicPhrase]);

  const hideProvideMnemonicsModal = () => {
    Keyboard.dismiss();
    provideMnemonicsModalRef.current?.dismiss();
    resetModalData();
  };

  const hideShareModal = () => {};

  const toolTipActions = useMemo(() => {
    return [{ ...CommonToolTipActions.Passphrase, menuState: askPassphrase }];
  }, [askPassphrase]);

  const renderProvideMnemonicsModal = () => {
    return (
      <BottomModal
        onClose={hideProvideMnemonicsModal}
        ref={provideMnemonicsModalRef}
        contentContainerStyle={styles.newKeyModalContent}
        backgroundColor={colors.elevated}
        footerDefaultMargins
        header={
          <ToolTipMenu
            isButton
            isMenuPrimaryAction
            onPressMenuItem={(id: string) => {
              LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
              setAskPassphrase(!askPassphrase);
            }}
            actions={toolTipActions}
            style={[styles.askPassprase, stylesHook.askPassphrase]}
          >
            <Icon size={22} name="more-horiz" type="material" color={colors.foregroundColor} />
          </ToolTipMenu>
        }
        footer={
          <>
            {isLoading ? (
              <ActivityIndicator />
            ) : (
              <Button disabled={importText.trim().length === 0} title={loc.wallets.import_do_import} onPress={handleUseMnemonicPhrase} />
            )}

            {!isLoading && (
              <>
                <MalinSpacing40 />
                <AddressInputScanButton
                  beforePress={async () => {
                    await provideMnemonicsModalRef.current?.dismiss();
                  }}
                  isLoading={isLoading}
                  type="link"
                  onChangeText={setImportText}
                />
                <MalinSpacing40 />
              </>
            )}
          </>
        }
      >
        <>
          <MalinTextCentered>{loc.multisig.type_your_mnemonics}</MalinTextCentered>
          <MalinSpacing20 />
          <View style={styles.multiLineTextInput}>
            <MalinFormMultiInput editable={!isLoading} value={importText} onChangeText={setImportText} />
          </View>
        </>
      </BottomModal>
    );
  };

  const renderShareModal = () => {
    return (
      <BottomModal
        ref={shareModalRef}
        onClose={hideShareModal}
        contentContainerStyle={[styles.modalContent, styles.alignItemsCenter, styles.shareModalHeight]}
        backgroundColor={colors.elevated}
        shareContent={{ fileName: exportFilename, fileContent: exportString }}
      >
        <SafeArea>
          <View style={styles.alignItemsCenter}>
            <Text style={[styles.headerText, stylesHook.textDestination]}>
              {loc.multisig.this_is_cosigners_xpub} {Platform.OS === 'ios' ? loc.multisig.this_is_cosigners_xpub_airdrop : ''}
            </Text>
            <MalinSpacing20 />
            <QRCodeComponent value={exportStringURv2} size={260} isLogoRendered={false} />
          </View>
        </SafeArea>
      </BottomModal>
    );
  };

  if (isLoading)
    return (
      <View style={[styles.root, stylesHook.root]}>
        <MalinLoading />
      </View>
    );

  const howMany = (
    <Badge
      value={wallet?.getM() ?? 0}
      badgeStyle={[styles.tipLabel, stylesHook.tipLabel]}
      textStyle={[styles.tipLabelText, stylesHook.tipLabelText]}
    />
  );

  const andHere = (
    <Badge
      value={wallet?.howManySignaturesCanWeMake() ?? 0}
      badgeStyle={[styles.tipLabel, stylesHook.tipLabel]}
      textStyle={[styles.tipLabelText, stylesHook.tipLabelText]}
    />
  );

  const tipKeys = () => {
    return (
      <View>
        <MalinSpacing20 />
        <Text style={[styles.tipKeys, stylesHook.tipKeys]}>
          {loc.formatString(loc.multisig.signatures_required_to_spend, { number: howMany })}
          {loc.formatString(loc.multisig.signatures_we_can_make, { number: andHere })}
        </Text>
        <MalinSpacing10 />
        <MalinSpacing20 />
      </View>
    );
  };

  const footer = <Button disabled={vaultKeyData.isLoading || isSaveButtonDisabled} title={loc._.save} onPress={onSave} />;

  return (
    <View style={[styles.root, stylesHook.root]} ref={discardChangesRef}>
      <FlatList
        ListHeaderComponent={tipKeys}
        data={walletData}
        extraData={vaultKeyData}
        renderItem={_renderKeyItem}
        automaticallyAdjustKeyboardInsets
        contentInsetAdjustmentBehavior="automatic"
        automaticallyAdjustContentInsets
        keyExtractor={(_item, index) => `${index}`}
        contentContainerStyle={styles.contentContainerStyle}
      />
      <MalinCard>{footer}</MalinCard>
      <MalinSpacing20 />

      {renderProvideMnemonicsModal()}

      {renderMnemonicsModal()}
    </View>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
    justifyContent: 'space-between',
  },
  itemKeyUnprovidedWrapper: { flexDirection: 'row', paddingTop: 22 },
  textDestination: { fontWeight: '600' },
  vaultKeyText: { fontSize: 18, fontWeight: 'bold' },
  vaultKeyTextWrapper: { justifyContent: 'center', alignItems: 'center', paddingLeft: 16 },
  newKeyModalContent: {
    paddingHorizontal: 22,
    minHeight: 350,
  },
  paddingTop44: { paddingTop: 44 },
  multiLineTextInput: {
    minHeight: 200,
  },
  contentContainerStyle: {
    padding: 16,
  },
  modalContent: {
    padding: 22,
    justifyContent: 'center',
  },
  vaultKeyCircleSuccess: {
    width: 42,
    height: 42,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },

  headerText: { fontSize: 15, color: '#13244D' },
  alignItemsCenter: { alignItems: 'center', justifyContent: 'space-between' },
  shareModalHeight: { minHeight: 370 },
  tipKeys: {
    fontSize: 15,
    fontWeight: '600',
    flex: 1,
  },
  tipLabel: {
    width: 30,
    marginRight: 6,
    position: 'relative',
    bottom: -3,
  },
  tipLabelText: {
    fontWeight: '500',
  },

  askPassprase: { top: 0, left: 0, justifyContent: 'center', width: 33, height: 33, borderRadius: 33 / 2 },
});

export default ViewEditMultisigCosigners;


================================================
FILE: ./screen/wallets/ImportWalletDiscovery.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { RouteProp, useRoute } from '@react-navigation/native';
import { ActivityIndicator, FlatList, LayoutAnimation, Platform, StyleSheet, UIManager, View } from 'react-native';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinButtonLink, MalinFormLabel, MalinText } from '../../MalinComponents';
import { HDSegwitBech32Wallet, WatchOnlyWallet } from '../../class';
import startImport, { TImport } from '../../class/wallet-import';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import WalletToImport from '../../components/WalletToImport';
import prompt from '../../helpers/prompt';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { THDWalletForWatchOnly, TWallet } from '../../class/wallets/types';
import { useSettings } from '../../hooks/context/useSettings';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import { MalinSpacing10, MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';

type RouteProps = RouteProp<AddWalletStackParamList, 'ImportWalletDiscovery'>;
type NavigationProp = NativeStackNavigationProp<AddWalletStackParamList, 'ImportWalletDiscovery'>;

type WalletEntry = {
  wallet: TWallet | THDWalletForWatchOnly;
  subtitle: string;
  id: string;
};

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const ImportWalletDiscovery: React.FC = () => {
  const navigation = useExtendedNavigation<NavigationProp>();
  const { colors } = useTheme();
  const route = useRoute<RouteProps>();
  const { importText, askPassphrase, searchAccounts } = route.params;
  const { isElectrumDisabled, isPrivacyBlurEnabled } = useSettings();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();
  const task = useRef<TImport | null>(null);
  const { addAndSaveWallet } = useStorage();
  const [loading, setLoading] = useState<boolean>(true);
  const [wallets, setWallets] = useState<WalletEntry[]>([]);
  const [password, setPassword] = useState<string | undefined>();
  const [selected, setSelected] = useState<number>(0);
  const [progress, setProgress] = useState<string | undefined>();
  const importing = useRef<boolean>(false);
  const bip39 = useMemo(() => {
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(importText);
    return hd.validateMnemonic();
  }, [importText]);

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    center: {
      backgroundColor: colors.elevated,
    },
  });

  const saveWallet = useCallback(
    (wallet: TWallet | THDWalletForWatchOnly) => {
      if (importing.current) return;
      importing.current = true;
      addAndSaveWallet(wallet);
      navigation.getParent()?.goBack();
    },
    [addAndSaveWallet, navigation],
  );

  const handleSave = () => {
    if (wallets.length === 0) return;
    saveWallet(wallets[selected].wallet);
  };

  useEffect(() => {
    const onProgress = (data: string) => setProgress(data);

    const onWallet = (wallet: TWallet | THDWalletForWatchOnly) => {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      const id = wallet.getID();
      let subtitle: string | undefined;

      try {
        // For watch-only wallets, display the descriptor or xpub
        if (wallet.type === WatchOnlyWallet.type) {
          if (wallet.isHd() && wallet.getSecret()) {
            subtitle = wallet.getSecret(); // Display descriptor
            if (wallet._hdWalletInstance) {
              subtitle = `[${wallet._hdWalletInstance.typeReadable}]\n${subtitle}`;
            }
          } else {
            subtitle = wallet.getAddress(); // Display address
          }
        } else {
          subtitle = (wallet as THDWalletForWatchOnly).getDerivationPath?.();
        }
      } catch (e) {}

      setWallets(w => [...w, { wallet, subtitle: subtitle || '', id }]);
    };

    const onPassword = async (title: string, subtitle: string) => {
      try {
        const pass = await prompt(title, subtitle);
        setPassword(pass);
        return pass;
      } catch (e: any) {
        if (e.message === 'Cancel Pressed') {
          navigation.goBack();
        }
        throw e;
      }
    };

    task.current = startImport(importText, askPassphrase, searchAccounts, isElectrumDisabled, onProgress, onWallet, onPassword);

    task.current.promise
      .then(({ cancelled, wallets: w }) => {
        if (cancelled) return;
        if (w.length === 1) saveWallet(w[0]); // Instantly save wallet if only one has been discovered
        if (w.length === 0) {
          triggerHapticFeedback(HapticFeedbackTypes.ImpactLight);
        }
      })
      .catch(e => {
        console.warn('import error', e);
        console.warn('err.stack', e.stack);
        presentAlert({ title: 'Import error', message: e.message });
      })
      .finally(() => {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setLoading(false);
      });

    return () => {
      task.current?.stop();
    };
  }, [askPassphrase, importText, isElectrumDisabled, navigation, saveWallet, searchAccounts]);

  useEffect(() => {
    if (isPrivacyBlurEnabled) {
      enableScreenProtect();
    }
    return () => {
      disableScreenProtect();
    };
  }, [isPrivacyBlurEnabled, enableScreenProtect, disableScreenProtect]);

  const handleCustomDerivation = () => {
    task.current?.stop();
    navigation.navigate('ImportCustomDerivationPath', { importText, password });
  };

  const renderItem = ({ item, index }: { item: WalletEntry; index: number }) => (
    <WalletToImport
      key={item.id}
      title={item.wallet.typeReadable}
      subtitle={item.subtitle}
      active={selected === index}
      onPress={() => {
        setSelected(index);
        triggerHapticFeedback(HapticFeedbackTypes.Selection);
      }}
    />
  );

  const keyExtractor = (w: WalletEntry) => w.id;

  const ListHeaderComponent = useMemo(
    () => (
      <>
        {wallets.length > 0 ? (
          <>
            {isElectrumDisabled && (
              <>
                <MalinFormLabel>{loc.wallets.import_discovery_offline}</MalinFormLabel>
                <MalinSpacing20 />
              </>
            )}
            <MalinFormLabel>{loc.wallets.import_discovery_subtitle}</MalinFormLabel>
            <MalinSpacing10 />
          </>
        ) : null}
      </>
    ),
    [wallets, isElectrumDisabled],
  );

  const ListEmptyComponent = useMemo(
    () => (
      <View style={styles.noWallets}>
        {loading ? (
          <>
            <MalinSpacing40 />
            <ActivityIndicator testID="Loading" />
            <MalinSpacing20 />
            <MalinFormLabel>{progress}</MalinFormLabel>
            <MalinSpacing40 />
          </>
        ) : (
          <>
            <MalinText style={styles.center}>{loc.wallets.import_discovery_no_wallets}</MalinText>
            <MalinSpacing20 />
          </>
        )}
      </View>
    ),
    [loading, progress],
  );

  return (
    <SafeArea style={[styles.root, stylesHook.root]}>
      <FlatList
        ListHeaderComponent={ListHeaderComponent}
        contentContainerStyle={styles.flatListContainer}
        data={wallets}
        ListEmptyComponent={ListEmptyComponent}
        keyExtractor={keyExtractor}
        renderItem={renderItem}
        automaticallyAdjustContentInsets
        contentInsetAdjustmentBehavior="always"
      />
      <View style={[styles.center, stylesHook.center]}>
        {bip39 && (
          <MalinButtonLink
            title={loc.wallets.import_discovery_derivation}
            testID="CustomDerivationPathButton"
            onPress={handleCustomDerivation}
          />
        )}
        <MalinSpacing10 />
        <View style={styles.buttonContainer}>
          <Button disabled={wallets?.length === 0} title={loc.wallets.import_do_import} onPress={handleSave} />
        </View>
      </View>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  flatListContainer: {
    marginHorizontal: 16,
  },
  center: {
    margin: 16,
    alignItems: 'center',
  },
  buttonContainer: {
    height: 45,
    marginBottom: 16,
  },
  noWallets: {
    flexGrow: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default ImportWalletDiscovery;


================================================
FILE: ./screen/wallets/generateWord.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useTheme } from '@react-navigation/native';
import React, { useState } from 'react';
import { Keyboard, StyleSheet, TextInput, View } from 'react-native';

import { generateChecksumWords } from '../../malin_modules/checksumWords';
import { MalinCard, MalinText } from '../../MalinComponents';
import { randomBytes } from '../../class/rng';
import Button from '../../components/Button';
import loc from '../../loc';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';

const GenerateWord = () => {
  const { colors } = useTheme();

  const [mnemonic, setMnemonic] = useState('');
  const [result, setResult] = useState('');

  const stylesHooks = StyleSheet.create({
    input: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const handleUpdateMnemonic = nextValue => {
    setMnemonic(nextValue);
    setResult();
  };

  const checkMnemonic = async () => {
    Keyboard.dismiss();

    const seedPhrase = mnemonic.toString();

    const possibleWords = generateChecksumWords(seedPhrase);

    if (!possibleWords) {
      // likely because of an invalid mnemonic
      setResult(loc.autofill_word.error);
      return;
    }

    const random = await randomBytes(1);
    const randomindex = Math.round((random[0] / 255) * (possibleWords.length - 1));

    setResult(possibleWords[randomindex]);
  };

  const clearMnemonicInput = () => {
    setMnemonic('');
    setResult();
  };

  return (
    <SafeAreaScrollView
      style={styles.malinArea}
      keyboardShouldPersistTaps="handled"
      automaticallyAdjustContentInsets
      automaticallyAdjustKeyboardInsets
      contentInsetAdjustmentBehavior="automatic"
    >
      <View style={styles.wrapper}>
        <MalinCard style={styles.mainCard}>
          <View style={[styles.input, stylesHooks.input]}>
            <TextInput
              style={styles.text}
              maxHeight={100}
              minHeight={100}
              maxWidth="100%"
              minWidth="100%"
              multiline
              editable
              placeholder={loc.autofill_word.enter}
              placeholderTextColor="#81868e"
              value={mnemonic}
              onChangeText={handleUpdateMnemonic}
              testID="MnemonicInput"
            />
          </View>

          <MalinSpacing10 />
          <Button title={loc.send.input_clear} onPress={clearMnemonicInput} />
          <MalinSpacing20 />
          <MalinText style={styles.center} testID="Result">
            {result}
          </MalinText>
          <MalinSpacing20 />
          <View>
            <Button
              disabled={mnemonic.trim().length === 0}
              title={loc.autofill_word.generate_word}
              onPress={checkMnemonic}
              testID="GenerateWord"
            />
          </View>
          <MalinSpacing20 />
        </MalinCard>
      </View>
    </SafeAreaScrollView>
  );
};

export default GenerateWord;

const styles = StyleSheet.create({
  wrapper: {
    marginTop: 16,
    alignItems: 'center',
    justifyContent: 'flex-start',
  },
  malinArea: {
    paddingTop: 19,
  },
  mainCard: {
    padding: 0,
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'flex-start',
  },
  input: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    alignItems: 'center',
    borderRadius: 4,
  },
  center: {
    textAlign: 'center',
  },
  text: {
    padding: 8,
    minHeight: 33,
    color: '#81868e',
  },
});


================================================
FILE: ./screen/wallets/WalletsAddMultisig.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useReducer, useCallback } from 'react';
import { useRoute, RouteProp } from '@react-navigation/native';
import LottieView from 'lottie-react-native';
import { StyleSheet, Text, View } from 'react-native';
import { MultisigHDWallet } from '../../class';
import Button from '../../components/Button';
import ListItem from '../../components/ListItem';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type NavigationProps = NativeStackNavigationProp<AddWalletStackParamList, 'WalletsAddMultisig'>;
type RouteProps = RouteProp<AddWalletStackParamList, 'WalletsAddMultisig'>;

enum MultisigActions {
  SET_M = 'SET_M',
  SET_N = 'SET_N',
  SET_FORMAT = 'SET_FORMAT',
}

interface MultisigState {
  m: number;
  n: number;
  format: string;
}

type MultisigAction =
  | { type: MultisigActions.SET_M; payload: number }
  | { type: MultisigActions.SET_N; payload: number }
  | { type: MultisigActions.SET_FORMAT; payload: string };

const multisigReducer = (state: MultisigState, action: MultisigAction): MultisigState => {
  switch (action.type) {
    case MultisigActions.SET_M:
      return { ...state, m: action.payload };
    case MultisigActions.SET_N:
      return { ...state, n: action.payload };
    case MultisigActions.SET_FORMAT:
      return { ...state, format: action.payload };
    default:
      return state;
  }
};

const WalletsAddMultisig: React.FC = () => {
  const { colors } = useTheme();
  const { navigate } = useExtendedNavigation<NavigationProps>();
  const { walletLabel } = useRoute<RouteProps>().params;

  const [state, dispatch] = useReducer(multisigReducer, {
    m: 2,
    n: 3,
    format: MultisigHDWallet.FORMAT_P2WSH,
  });

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
      justifyContent: 'space-between',
      flex: 1,
    },
    textdesc: {
      color: colors.alternativeTextColor,
    },
  });

  const onLetsStartPress = useCallback(() => {
    navigate('WalletsAddMultisigStep2', { m: state.m, n: state.n, format: state.format, walletLabel });
  }, [navigate, state.m, state.n, state.format, walletLabel]);

  const showAdvancedOptionsModal = useCallback(() => {
    navigate('MultisigAdvanced', {
      m: state.m,
      n: state.n,
      format: state.format,
      onSave: (m: number, n: number, format: string) => {
        dispatch({ type: MultisigActions.SET_M, payload: m });
        dispatch({ type: MultisigActions.SET_N, payload: n });
        dispatch({ type: MultisigActions.SET_FORMAT, payload: format });
      },
    });
  }, [navigate, state.m, state.n, state.format]);

  const getCurrentlySelectedFormat = (code: string) => {
    switch (code) {
      case 'format':
        return getCurrentFormatReadable(state.format);
      case 'quorum':
        return loc.formatString(loc.multisig.quorum, { m: state.m, n: state.n });
      default:
        throw new Error('This should never happen');
    }
  };

  return (
    <SafeArea style={stylesHook.root}>
      <View style={styles.descriptionContainer}>
        <View style={styles.imageWrapper}>
          <LottieView source={require('../../img/msvault.json')} style={styles.lottie} autoPlay loop={false} />
        </View>
        <MalinSpacing20 />
        <Text style={[styles.textdesc, stylesHook.textdesc]}>
          {loc.multisig.what_is_vault}
          <Text style={[styles.textdescBold, stylesHook.textdesc]}>
            {loc.formatString(loc.multisig.what_is_vault_numberOfWallets, { m: state.m, n: state.n })}
          </Text>
          <Text style={[styles.textdesc, stylesHook.textdesc]}>{loc.multisig.what_is_vault_wallet}</Text>
        </Text>

        <MalinSpacing20 />

        <Text style={[styles.textdesc, stylesHook.textdesc]}>
          {loc.multisig.needs}
          <Text style={[styles.textdescBold, stylesHook.textdesc]}>
            {loc.formatString(loc.multisig.what_is_vault_description_number_of_vault_keys, { m: state.m })}
          </Text>
          <Text style={[styles.textdesc, stylesHook.textdesc]}>
            {state.m === 2 && state.n === 3
              ? loc.multisig.what_is_vault_description_to_spend
              : loc.multisig.what_is_vault_description_to_spend_other}
          </Text>
        </Text>
      </View>
      <View>
        <ListItem
          testID="VaultAdvancedCustomize"
          onPress={showAdvancedOptionsModal}
          title={loc.multisig.vault_advanced_customize}
          subtitle={`${getCurrentlySelectedFormat('format')}, ${getCurrentlySelectedFormat('quorum')}`}
          chevron
        />
      </View>

      <View style={styles.buttonContainer}>
        <Button
          testID="LetsStart"
          buttonTextColor={colors.buttonAlternativeTextColor}
          title={loc.multisig.lets_start}
          onPress={onLetsStartPress}
        />
      </View>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  descriptionContainer: {
    alignContent: 'center',
    justifyContent: 'center',
    flex: 0.8,
  },
  buttonContainer: {
    padding: 24,
  },
  textdesc: {
    fontWeight: '500',
    alignSelf: 'center',
    textAlign: 'center',
  },
  textdescBold: {
    fontWeight: '700',
    alignSelf: 'center',
    textAlign: 'center',
  },
  lottie: {
    width: 233,
    height: 176,
  },
  imageWrapper: {
    borderWidth: 0,
    alignItems: 'center',
  },
});

const getCurrentFormatReadable = (f: string) => {
  switch (f) {
    case MultisigHDWallet.FORMAT_P2WSH:
      return loc.multisig.native_segwit_title;
    case MultisigHDWallet.FORMAT_P2SH_P2WSH:
    case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT:
      return loc.multisig.wrapped_segwit_title;
    case MultisigHDWallet.FORMAT_P2SH:
      return loc.multisig.legacy_title;
    default:
      throw new Error('This should never happen');
  }
};

export default WalletsAddMultisig;


================================================
FILE: ./screen/wallets/MultisigAdvanced.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, FC } from 'react';
import { StyleSheet, Text, View, Pressable, Platform } from 'react-native';
import { RouteProp, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { Icon } from '@rneui/themed';
import { MultisigHDWallet } from '../../class';
import ListItem from '../../components/ListItem';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import HeaderRightButton from '../../components/HeaderRightButton';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type NavigationProps = NativeStackNavigationProp<AddWalletStackParamList, 'MultisigAdvanced'>;
type RouteProps = RouteProp<AddWalletStackParamList, 'MultisigAdvanced'>;

interface QuorumSelectorProps {
  m: number;
  n: number;
  onMChange: (m: number) => void;
  onNChange: (n: number) => void;
  colors: any;
}

const QuorumSelector: FC<QuorumSelectorProps> = ({ m, n, onMChange, onNChange, colors }) => {
  const increaseM = useCallback(() => {
    if (n === m) return;
    if (m === 7) return;
    onMChange(m + 1);
  }, [m, n, onMChange]);

  const decreaseM = useCallback(() => {
    if (m === 2) return;
    onMChange(m - 1);
  }, [m, onMChange]);

  const increaseN = useCallback(() => {
    if (n === 7) return;
    onNChange(n + 1);
  }, [n, onNChange]);

  const decreaseN = useCallback(() => {
    if (n === m) return;
    onNChange(n - 1);
  }, [n, m, onNChange]);

  return (
    <View style={styles.rowCenter}>
      <View style={styles.column}>
        <Pressable
          accessibilityRole="button"
          onPress={increaseM}
          disabled={n === m || m === 7}
          style={({ pressed }) => [pressed && styles.pressed, styles.chevron]}
        >
          <Icon name="chevron-up" size={22} type="font-awesome-5" color={n === m || m === 7 ? colors.buttonDisabledTextColor : '#007AFF'} />
        </Pressable>
        <Text style={[styles.textM, { color: colors.outputValue }]}>{m}</Text>
        <Pressable
          accessibilityRole="button"
          onPress={decreaseM}
          disabled={m === 2}
          style={({ pressed }) => [pressed && styles.pressed, styles.chevron]}
        >
          <Icon name="chevron-down" size={22} type="font-awesome-5" color={m === 2 ? colors.buttonDisabledTextColor : '#007AFF'} />
        </Pressable>
      </View>

      <View style={styles.columnOf}>
        <Text style={styles.textOf}>{loc.multisig.of}</Text>
      </View>

      <View style={styles.column}>
        <Pressable
          accessibilityRole="button"
          disabled={n === 7}
          onPress={increaseN}
          style={({ pressed }) => [pressed && styles.pressed, styles.chevron]}
        >
          <Icon name="chevron-up" size={22} type="font-awesome-5" color={n === 7 ? colors.buttonDisabledTextColor : '#007AFF'} />
        </Pressable>
        <Text style={[styles.textM, { color: colors.outputValue }]}>{n}</Text>
        <Pressable
          accessibilityRole="button"
          onPress={decreaseN}
          disabled={n === m}
          style={({ pressed }) => [pressed && styles.pressed, styles.chevron]}
          testID="DecreaseN"
        >
          <Icon name="chevron-down" size={22} type="font-awesome-5" color={n === m ? colors.buttonDisabledTextColor : '#007AFF'} />
        </Pressable>
      </View>
    </View>
  );
};

interface FormatSelectorProps {
  format: string;
  onFormatChange: (format: string) => void;
  colors: any;
}

const FormatSelector: FC<FormatSelectorProps> = ({ format, onFormatChange, colors }) => {
  const isP2wsh = useCallback(() => format === MultisigHDWallet.FORMAT_P2WSH, [format]);
  const isP2shP2wsh = useCallback(
    () => format === MultisigHDWallet.FORMAT_P2SH_P2WSH || format === MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT,
    [format],
  );
  const isP2sh = useCallback(() => format === MultisigHDWallet.FORMAT_P2SH, [format]);

  const setFormatP2wsh = useCallback(() => onFormatChange(MultisigHDWallet.FORMAT_P2WSH), [onFormatChange]);
  const setFormatP2shP2wsh = useCallback(() => onFormatChange(MultisigHDWallet.FORMAT_P2SH_P2WSH), [onFormatChange]);
  const setFormatP2sh = useCallback(() => onFormatChange(MultisigHDWallet.FORMAT_P2SH), [onFormatChange]);

  const getItemStyle = useCallback(
    (isSelected: boolean) => [
      styles.borderRadius6,
      styles.item,
      isSelected ? { paddingHorizontal: 8, backgroundColor: colors.elevated } : { paddingHorizontal: 8, backgroundColor: 'transparent' },
    ],
    [colors.elevated],
  );

  return (
    <>
      <ListItem
        bottomDivider={false}
        onPress={setFormatP2wsh}
        title={`${loc.multisig.native_segwit_title} (${MultisigHDWallet.FORMAT_P2WSH})`}
        checkmark={isP2wsh()}
        containerStyle={getItemStyle(isP2wsh())}
      />
      <ListItem
        bottomDivider={false}
        onPress={setFormatP2shP2wsh}
        title={`${loc.multisig.wrapped_segwit_title} (${MultisigHDWallet.FORMAT_P2SH_P2WSH})`}
        checkmark={isP2shP2wsh()}
        containerStyle={getItemStyle(isP2shP2wsh())}
      />
      <ListItem
        bottomDivider={false}
        onPress={setFormatP2sh}
        title={`${loc.multisig.legacy_title} (${MultisigHDWallet.FORMAT_P2SH})`}
        checkmark={isP2sh()}
        containerStyle={getItemStyle(isP2sh())}
      />
    </>
  );
};

const MultisigAdvanced: React.FC = () => {
  const { colors } = useTheme();
  const navigation = useExtendedNavigation<NavigationProps>();
  const route = useRoute<RouteProps>();
  const { m, n, format, onSave } = route.params;

  const [currentM, setCurrentM] = React.useState(m);
  const [currentN, setCurrentN] = React.useState(n);
  const [currentFormat, setCurrentFormat] = React.useState(format);

  // Check if there are unsaved changes
  const hasUnsavedChanges = React.useMemo(() => {
    return currentM !== m || currentN !== n || currentFormat !== format;
  }, [currentM, currentN, currentFormat, m, n, format]);

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
      flex: 1,
    },
    textHeader: {
      color: colors.outputValue,
    },
    textSubtitle: {
      color: colors.alternativeTextColor,
    },
  });

  const handleSave = useCallback(() => {
    onSave(currentM, currentN, currentFormat);
    navigation.goBack();
  }, [onSave, currentM, currentN, currentFormat, navigation]);

  const SaveButton = useCallback(
    () => <HeaderRightButton title={loc.send.input_done} onPress={handleSave} disabled={!hasUnsavedChanges} testID="ModalDoneButton" />,
    [handleSave, hasUnsavedChanges],
  );

  React.useLayoutEffect(() => {
    if (Platform.OS !== 'android') {
      navigation.setOptions({
        headerRight: SaveButton,
      });
    }
  }, [navigation, SaveButton]);

  return (
    <SafeArea style={stylesHook.root}>
      {Platform.OS === 'android' && (
        <View style={styles.androidHeader}>
          <View style={styles.androidHeaderContent}>
            <Pressable
              onPress={() => navigation.goBack()}
              style={({ pressed }) => [pressed && styles.pressed, styles.androidBackButton]}
              accessibilityRole="button"
              accessibilityLabel="Go back"
            >
              <Icon name="arrow-back" type="material" size={24} color={colors.foregroundColor} />
            </Pressable>
            <Text style={[styles.androidHeaderTitle, { color: colors.foregroundColor }]}>{loc.multisig.multisig_vault}</Text>
            <View style={styles.androidSaveButton}>
              <HeaderRightButton title={loc.send.input_done} onPress={handleSave} disabled={!hasUnsavedChanges} testID="ModalDoneButton" />
            </View>
          </View>
        </View>
      )}
      <View style={styles.container}>
        <Text style={[styles.textHeader, stylesHook.textHeader]}>{loc.multisig.quorum_header}</Text>
        <Text style={[styles.textSubtitle, stylesHook.textSubtitle]}>{loc.multisig.required_keys_out_of_total}</Text>
        <QuorumSelector m={currentM} n={currentN} onMChange={setCurrentM} onNChange={setCurrentN} colors={colors} />

        <MalinSpacing20 />

        <Text style={[styles.textHeader, stylesHook.textHeader]}>{loc.multisig.wallet_type}</Text>
        <MalinSpacing20 />
        <FormatSelector format={currentFormat} onFormatChange={setCurrentFormat} colors={colors} />
      </View>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
  },
  androidHeader: {
    backgroundColor: 'transparent',
    borderBottomWidth: 0.5,
    borderBottomColor: '#e1e1e1',
  },
  androidHeaderContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    height: 56,
  },
  androidBackButton: {
    padding: 8,
    minWidth: 40,
  },
  androidHeaderTitle: {
    flex: 1,
    textAlign: 'center',
    fontSize: 18,
    fontWeight: '600',
    marginHorizontal: 16,
  },
  androidSaveButton: {
    minWidth: 40,
    alignItems: 'flex-end',
  },
  item: {
    paddingHorizontal: 0,
  },
  borderRadius6: {
    borderRadius: 6,
    minHeight: 54,
  },
  column: {
    paddingRight: 20,
    paddingLeft: 20,
  },
  chevron: {
    paddingBottom: 10,
    paddingTop: 10,
    fontSize: 24,
  },
  columnOf: {
    paddingRight: 20,
    paddingLeft: 20,
    justifyContent: 'center',
  },
  textM: {
    fontSize: 50,
    fontWeight: '700',
  },
  textOf: {
    fontSize: 30,
    color: '#9AA0AA',
  },
  textHeader: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  textSubtitle: {
    fontSize: 13,
    fontWeight: '500',
    marginTop: 4,
  },
  rowCenter: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingVertical: 30,
  },
  pressed: {
    opacity: 0.6,
  },
});

export default MultisigAdvanced;


================================================
FILE: ./screen/wallets/WalletsList.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, {
  useCallback,
  useEffect,
  useReducer,
  useRef,
  useMemo
} from 'react';
import {
  useFocusEffect,
  useIsFocused,
  useRoute,
  RouteProp
} from '@react-navigation/native';
import {
  Alert,
  findNodeHandle,
  Image,
  StyleSheet,
  Text,
  useWindowDimensions,
  View,
  Linking
} from 'react-native';
import { getClipboardContent } from '../../malin_modules/clipboard';
import { isDesktop } from '../../malin_modules/environment';
import * as fs from '../../malin_modules/fs';
import triggerHapticFeedback, {
  HapticFeedbackTypes
} from '../../malin_modules/hapticFeedback';
import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import {
  ExtendedTransaction,
  Transaction,
  TWallet
} from '../../class/wallets/types';
import presentAlert from '../../components/Alert';
import { FButton, FContainer } from '../../components/FloatButtons';
import { useTheme } from '../../components/themes';
import { TransactionListItem } from '../../components/TransactionListItem';
import WalletsCarousel from '../../components/WalletsCarousel';
import { useSizeClass, SizeClass } from '../../malin_modules/sizeClass';
import loc from '../../loc';
import ActionSheet from '../ActionSheet';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useStorage } from '../../hooks/context/useStorage';
import TotalWalletsBalance from '../../components/TotalWalletsBalance';
import { useSettings } from '../../hooks/context/useSettings';
import useMenuElements from '../../hooks/useMenuElements';
import SafeAreaSectionList from '../../components/SafeAreaSectionList';
import { scanQrHelper } from '../../helpers/scan-qr';

const WalletsListSections = {
  CAROUSEL: 'CAROUSEL',
  TRANSACTIONS: 'TRANSACTIONS',
}

type SectionData = {
  key: string;
  data: Transaction[] | string[];
};

enum ActionTypes {
  SET_LOADING,
  SET_WALLETS,
  SET_CURRENT_INDEX,
  SET_REFRESH_FUNCTION,
}

interface SetLoadingAction {
  type: ActionTypes.SET_LOADING;
  payload: boolean;
}

interface SetWalletsAction {
  type: ActionTypes.SET_WALLETS;
  payload: TWallet[];
}

interface SetCurrentIndexAction {
  type: ActionTypes.SET_CURRENT_INDEX;
  payload: number;
}

interface SetRefreshFunctionAction {
  type: ActionTypes.SET_REFRESH_FUNCTION;
  payload: () => void;
}

type WalletListAction =
  | SetLoadingAction
  | SetWalletsAction
  | SetCurrentIndexAction
  | SetRefreshFunctionAction;

interface WalletListState {
  isLoading: boolean;
  wallets: TWallet[];
  currentWalletIndex: number;
  refreshFunction: () => void;
}

const initialState = {
  isLoading: false,
  wallets: [],
  currentWalletIndex: 0,
  refreshFunction: () => {},
}

function reducer(state: WalletListState, action: WalletListAction) {
  switch (action.type) {
    case ActionTypes.SET_LOADING:
      return { ...state, isLoading: action.payload };
    case ActionTypes.SET_WALLETS:
      return { ...state, wallets: action.payload };
    case ActionTypes.SET_CURRENT_INDEX:
      return { ...state, currentWalletIndex: action.payload };
    case ActionTypes.SET_REFRESH_FUNCTION:
      return { ...state, refreshFunction: action.payload };
    default:
      return state;
  }
}

type NavigationProps = NativeStackNavigationProp<
  DetailViewStackParamList,
  'WalletsList'
>;
type RouteProps = RouteProp<DetailViewStackParamList, 'WalletsList'>;

const WalletsList: React.FC = () => {
  const [state, dispatch] = useReducer<
    React.Reducer<WalletListState, WalletListAction>
  >(reducer, initialState);
  const { isLoading } = state;
  const { sizeClass, isLarge } = useSizeClass();
  const walletsCarousel = useRef<any>();
  const currentWalletIndex = useRef<number>(0);
  const { registerTransactionsHandler, unregisterTransactionsHandler } =
    useMenuElements();
  const { wallets, getTransactions, refreshAllWalletTransactions } =
    useStorage();
  const { isTotalBalanceEnabled, isElectrumDisabled } = useSettings();
  const { width } = useWindowDimensions();
  const { colors, scanImage } = useTheme();
  const navigation = useExtendedNavigation<NavigationProps>();
  const isFocused = useIsFocused();
  const route = useRoute<RouteProps>();
  const dataSource = getTransactions(undefined, 10);
  const walletsCount = useRef<number>(wallets.length);
  const walletActionButtonsRef = useRef<any>();

  const stylesHook = StyleSheet.create({
    walletsListWrapper: {
      backgroundColor: colors.brandingColor,
    },
    listHeaderBack: {
      backgroundColor: colors.background,
      paddingTop: sizeClass === SizeClass.Large ? 8 : 0,
    },
    listHeaderText: {
      color: colors.foregroundColor,
      flexShrink: 1,
    }
  });

  const refreshWallets = useCallback(
    async (
      index: number | undefined,
      showLoadingIndicator = true,
      showUpdateStatusIndicator = false
    ) => {
      if (isElectrumDisabled) return;
      dispatch({
        type: ActionTypes.SET_LOADING,
        payload: showLoadingIndicator
      });
      try {
        await refreshAllWalletTransactions(index, showUpdateStatusIndicator);
      } catch (error) {
        console.error(error);
      } finally {
        dispatch({ type: ActionTypes.SET_LOADING, payload: false });
      }
    },
    [isElectrumDisabled, refreshAllWalletTransactions],
  )

  const refreshTransactions = useCallback(() => {
    refreshWallets(undefined, true, true);
  }, [refreshWallets]);

  useEffect(() => {
    const initialLoad = async () => {
      if (isElectrumDisabled) return;
      try {
        await refreshAllWalletTransactions(undefined, true);
      } catch (error) {
        console.error(error);
      }
    };
    initialLoad();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const onRefresh = useCallback(() => {
    console.debug('WalletsList onRefresh');
    refreshTransactions();
  }, [refreshTransactions]);

  useEffect(() => {
    const screenKey = route.name;
    registerTransactionsHandler(onRefresh, screenKey);
    return () => {
      unregisterTransactionsHandler(screenKey);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onRefresh, registerTransactionsHandler, unregisterTransactionsHandler]);

  useFocusEffect(
    useCallback(() => {
      const screenKey = route.name;
      return () => {
        unregisterTransactionsHandler(screenKey);
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [unregisterTransactionsHandler]),
  )

  useEffect(() => {
    if (!isLarge) {
      walletsCount.current = wallets.length;
    }
  }, [isLarge, wallets]);

  const onBarScanned = useCallback(
    (value: any) => {
      if (!value) return;
      try {
        DeeplinkSchemaMatch.navigationRouteFor(
          { url: value },
          (completionValue) => {
            triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
            // @ts-ignore: for now
            navigation.navigate(...completionValue)
          }
        )
      } catch (e: any) {
        Alert.alert(loc.send.details_scan_error, e.message);
      }
    },
    [navigation],
  )

  const navigateToBrowser = useCallback(() => {
    navigation.navigate('Browser');
  }, [navigation]);

  // --- FONCTION ACHAT MONTISE ---
  const openBuyCrypto = useCallback(() => {
    // 1. Rcuprer le wallet actuellement affich dans le carrousel
    const currentWallet = wallets[currentWalletIndex.current];

    // 2. Scuriser l'adresse (fallback vide si pas d'adresse)
    let address = '';
    if (currentWallet && typeof currentWallet.getAddress === 'function') {
      const addr = currentWallet.getAddress();
      if (typeof addr === 'string') {
        address = addr;
      }
    }

    // 3. ID Affiliation (NE PAS MODIFIER)
    const affiliateID = '9817a72d5f2caf';

    // 4. Construction URL ChangeNOW (EUR -> ETH par dfaut)
    const url = `https://changenow.io/exchange?from=eur&to=eth&amount=50&recipient=${address}&link_id=${affiliateID}`;

    // 5. Ouverture Navigateur
    Linking.openURL(url).catch((err) =>
      console.error('Erreur ouverture lien achat', err)
    );
  }, [wallets]);

  const navigateToSwap = useCallback(() => {
    navigation.navigate('Swap');
  }, [navigation]);

  const handleClick = useCallback(
    (item?: TWallet) => {
      if (item?.getID) {
        const walletID = item.getID();
        navigation.navigate('WalletTransactions', {
          walletID,
          walletType: item.type,
        })
      } else {
        navigation.navigate('AddWalletRoot');
      }
    },
    [navigation],
  )

  const onSnapToItem = useCallback(
    (e: { nativeEvent: { contentOffset: any } }) => {
      if (!isFocused) return;

      const contentOffset = e.nativeEvent.contentOffset;
      const index = Math.ceil(contentOffset.x / width);

      if (currentWalletIndex.current !== index) {
        console.debug(
          'onSnapToItem',
          wallets.length === index ? 'NewWallet/Importing card' : index
        );
        if (
          wallets[index] &&
          (wallets[index].timeToRefreshBalance() ||
            wallets[index].timeToRefreshTransaction())
        ) {
          refreshWallets(index, false, false);
        }
        currentWalletIndex.current = index;
      }
    },
    [isFocused, refreshWallets, wallets, width],
  )

  const renderListHeaderComponent = useCallback(() => {
    return (
      <View style={[styles.listHeaderBack, stylesHook.listHeaderBack]}>
        <Text
          textBreakStrategy="simple"
          style={[styles.listHeaderText, stylesHook.listHeaderText]}
          numberOfLines={2}
          adjustsFontSizeToFit
        >
          {`${loc.transactions.list_title}${'  '}`}
        </Text>
      </View>
    );
  }, [stylesHook.listHeaderBack, stylesHook.listHeaderText]);

  const handleLongPress = useCallback(() => {
    navigation.navigate('ManageWallets');
  }, [navigation]);

  const renderTransactionListsRow = useCallback(
    (item: ExtendedTransaction) => (
      <TransactionListItem
        key={item.hash}
        item={item}
        itemPriceUnit={item.walletPreferredBalanceUnit}
        walletID={item.walletID}
      />
    ),
    [],
  )

  const renderWalletsCarousel = useCallback(() => {
    return (
      <>
        <WalletsCarousel
          data={wallets}
          extraData={[wallets]}
          onPress={handleClick}
          handleLongPress={handleLongPress}
          onMomentumScrollEnd={onSnapToItem}
          ref={walletsCarousel}
          onNewWalletPress={handleClick}
          testID="WalletsList"
          horizontal
          scrollEnabled={isFocused}
          animateChanges
        />
      </>
    );
  }, [handleClick, handleLongPress, isFocused, onSnapToItem, wallets]);

  const renderSectionItem = useCallback(
    (item: { section: any; item: ExtendedTransaction }) => {
      switch (item.section.key) {
        case WalletsListSections.CAROUSEL:
          return sizeClass === SizeClass.Large ? null : renderWalletsCarousel();
        case WalletsListSections.TRANSACTIONS:
          return renderTransactionListsRow(item.item);
        default:
          return null;
      }
    },
    [sizeClass, renderTransactionListsRow, renderWalletsCarousel],
  )

  const renderSectionHeader = useCallback(
    (section: { section: { key: any } }) => {
      if (sizeClass === SizeClass.Large) {
        return null;
      }

      switch (section.section.key) {
        case WalletsListSections.TRANSACTIONS:
          return renderListHeaderComponent();
        case WalletsListSections.CAROUSEL: {
          return isTotalBalanceEnabled ? (
  <View style={stylesHook.walletsListWrapper}>
              <TotalWalletsBalance />
            </View>
              ) : null;
        }
        default:
          return null;
      }
    },
    [
      sizeClass,
      isTotalBalanceEnabled,
      renderListHeaderComponent,
      stylesHook.walletsListWrapper
    ],
  );

  const renderSectionFooter = useCallback(
    (section: { section: { key: any } }) => {
      switch (section.section.key) {
        case WalletsListSections.TRANSACTIONS:
          if (dataSource.length === 0 && !isLoading) {
            return (
              <View style={styles.footerRoot} testID="NoTransactionsMessage">
                <Text style={styles.footerEmpty}>
                  {loc.wallets.list_empty_txs1}
                </Text>
                <Text style={styles.footerStart}>
                  {loc.wallets.list_empty_txs2}
                </Text>
              </View>
            );
          } else {
            return null;
          }
        default:
          return null;
      }
    },
    [dataSource.length, isLoading],
  )

  const renderScanButton = useCallback(() => {
    if (wallets.length > 0) {
      return (
        <FContainer ref={walletActionButtonsRef.current}>
          <FButton
            onPress={navigateToBrowser}
            onLongPress={navigateToBrowser}
            icon={
              <View style={{ transform: [{ rotate: '45deg' }] }}>
                <Image
                  resizeMode='stretch'
                  source={require('../../img/close.png')}
                />
              </View>
            }
            text="DApps"
            testID="DAppsButton"
          />
          {/* BOUTON ACHETER (MODIFI) */}
          <FButton
            onPress={openBuyCrypto}
            onLongPress={openBuyCrypto}
            // Utiliser une icne existante (ex: close.png ou buy.png si ajout aux assets)
            icon={
              <View style={{ transform: [{ rotate: '0deg' }] }}>
                <Image
                  resizeMode='stretch'
                  source={require('../../img/close.png')}
                />
              </View>
            }
            text="Acheter"
            testID="BuyButton"
          />
          <FButton
            onPress={navigateToSwap}
            onLongPress={navigateToSwap}
            icon={
              <View style={{ transform: [{ rotate: '45deg' }] }}>
                <Image
                  resizeMode='stretch'
                  source={require('../../img/close.png')}
                />
              </View>
            }
            text="Swap"
            testID="SwapButton"
          />
          <FButton
            onPress={onScanButtonPressed}
            onLongPress={sendButtonLongPress}
            icon={<Image resizeMode="stretch" source={scanImage} />}
            text={loc.send.details_scan}
            testID="HomeScreenScanButton"
          />
        </FContainer>
      );
    } else {
      return null;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scanImage, wallets.length, navigateToBrowser]);

  const sectionListKeyExtractor = useCallback((item: any, index: any) => {
    return `${item}${index}}`;
  }, []);

  const onScanButtonPressed = useCallback(() => {
    scanQrHelper().then(onBarScanned);
  }, [onBarScanned]);

  const pasteFromClipboard = useCallback(async () => {
    onBarScanned(await getClipboardContent());
  }, [onBarScanned]);

  const sendButtonLongPress = useCallback(async () => {
    const isClipboardEmpty = (await getClipboardContent())?.trim().length === 0;

    const options = [
      loc._.cancel,
      loc.wallets.list_long_choose,
      loc.wallets.list_long_scan
    ];
    if (!isClipboardEmpty) {
      options.push(loc.wallets.paste_from_clipboard);
    }

    const props = { title: loc.send.header, options, cancelButtonIndex: 0 };

    const anchor = findNodeHandle(walletActionButtonsRef.current);

    if (anchor) {
      options.push(String(anchor));
    }

    ActionSheet.showActionSheetWithOptions(props, (buttonIndex) => {
      switch (buttonIndex) {
        case 0:
          break;
        case 1:
          fs.showImagePickerAndReadImage()
            .then(onBarScanned)
            .catch((error) => {
              triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
              presentAlert({ title: loc.errors.error, message: error.message });
            })
          break
        case 2:
          scanQrHelper().then(onBarScanned);
          break
        case 3:
          if (!isClipboardEmpty) {
            pasteFromClipboard();
          }
          break;
      }
    });
  }, [onBarScanned, pasteFromClipboard]);

  const refreshProps =
    isDesktop || isElectrumDisabled ? {} : { refreshing: isLoading, onRefresh };

  const sections: SectionData[] = useMemo(() => {
    if (sizeClass === SizeClass.Large) {
      return [{ key: WalletsListSections.TRANSACTIONS, data: dataSource }];
    }
    return [
      {
        key: WalletsListSections.CAROUSEL,
        data: [WalletsListSections.CAROUSEL]
      },
      { key: WalletsListSections.TRANSACTIONS, data: dataSource },
    ]
  }, [sizeClass, dataSource]);

  const TRANSACTION_ITEM_HEIGHT = 80;
  const CAROUSEL_HEIGHT = 195;
  const SECTION_HEADER_HEIGHT = 56;
  const LARGE_TITLE_EXTRA_HEIGHT = 20;

  const getSectionHeaderHeight = useCallback(() => {
    return (
      SECTION_HEADER_HEIGHT +
      (sizeClass === SizeClass.Large ? LARGE_TITLE_EXTRA_HEIGHT : 0)
    )
  }, [sizeClass]);

  const getItemLayout = useCallback(
    (data: any, index: number) => {
      const headerHeight = getSectionHeaderHeight();

      if (sizeClass === SizeClass.Large) {
        return {
          length: TRANSACTION_ITEM_HEIGHT,
          offset: TRANSACTION_ITEM_HEIGHT * index,
          index,
        }
      } else {
        if (index === 0) {
          return {
            length: CAROUSEL_HEIGHT,
            offset: 0,
            index,
          }
        }
        const transactionIndex = index - 1;
        return {
          length: TRANSACTION_ITEM_HEIGHT,
          offset:
            CAROUSEL_HEIGHT +
            headerHeight +
            TRANSACTION_ITEM_HEIGHT * transactionIndex,
          index,
        }
      }
    },
    [sizeClass, getSectionHeaderHeight],
  )

  return (
    <>
      <SafeAreaSectionList<any | string, SectionData>
        renderItem={renderSectionItem}
        keyExtractor={sectionListKeyExtractor}
        renderSectionHeader={renderSectionHeader}
        initialNumToRender={10}
        renderSectionFooter={renderSectionFooter}
        sections={sections}
        floatingButtonHeight={70}
        maxToRenderPerBatch={10}
        updateCellsBatchingPeriod={50}
        getItemLayout={getItemLayout}
        ignoreTopInset
        {...refreshProps}
      />
      {renderScanButton()}
    </>
  );
}

export default WalletsList;

const styles = StyleSheet.create({
  listHeaderBack: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    minHeight: 56,
  },
  listHeaderText: {
    fontWeight: 'bold',
    fontSize: 24,
    marginVertical: 16,
    flexWrap: 'wrap',
  },
  footerRoot: {
    top: 80,
    height: 160,
    marginBottom: 80,
  },
  footerEmpty: {
    fontSize: 18,
    color: '#9aa0aa',
    textAlign: 'center',
  },
  footerStart: {
    fontSize: 18,
    color: '#9aa0aa',
    textAlign: 'center',
    fontWeight: '600',
  },
})


================================================
FILE: ./screen/wallets/xpub.styles.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useMemo } from 'react';
import { StyleSheet } from 'react-native';

import { useTheme } from '../../components/themes';

export const styles = StyleSheet.create({
  root: {
    flex: 1,
    paddingTop: 20,
  },
  container: {
    alignItems: 'center',
    flex: 1,
    justifyContent: 'center',
  },
  share: {
    alignSelf: 'center',
    width: '40%',
  },
});

export const useDynamicStyles = () => {
  const theme = useTheme();

  const stylesHook = useMemo(
    () =>
      StyleSheet.create({
        root: {
          backgroundColor: theme.colors.elevated,
          // Add more dynamic styles as needed
        },
        container: {
          // Example of another dynamic style
          borderColor: theme.colors.inputBorderColor,
          borderWidth: 1,
        },
        // You can add more dynamically themed styles here
      }),
    [theme],
  ); // Recompute styles only when theme changes

  return stylesHook;
};


================================================
FILE: ./screen/wallets/addMultisigHelp.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { Image, ScrollView, StyleSheet, Text, View } from 'react-native';

import { useTheme } from '../../components/themes';
import loc from '../../loc';

const WalletsAddMultisigHelp: React.FC = () => {
  const { colors } = useTheme();

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    intro: {
      backgroundColor: colors.newMalin,
      borderBottomColor: colors.inputBorderColor,
    },
    introTitle: {
      color: colors.inverseForegroundColor,
    },
    introText: {
      color: colors.inverseForegroundColor,
    },
    tipsTitle: {
      color: colors.foregroundColor,
    },
    tipsText: {
      color: colors.alternativeTextColor,
    },
  });

  return (
    <ScrollView
      contentContainerStyle={stylesHook.root}
      style={stylesHook.root}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
    >
      <View style={[styles.intro, stylesHook.intro]}>
        <Text style={[styles.introTitle, stylesHook.introTitle]}>{loc.multisig.ms_help_title}</Text>
        <Text style={[styles.introText, stylesHook.introText]}>{loc.multisig.ms_help_text}</Text>
        <Image style={styles.introImage} source={require('../../img/mshelp/mshelp-intro.png')} />
      </View>
      <View style={styles.tips}>
        <Text style={[styles.tipsTitle, stylesHook.tipsTitle]}>{loc.multisig.ms_help_title1}</Text>
        <Text style={[styles.tipsText, stylesHook.tipsText]}>{loc.multisig.ms_help_1}</Text>
      </View>
      <View style={styles.tips}>
        <Image style={styles.imageTip} source={require('../../img/mshelp/tip2.png')} />
        <Text style={[styles.tipsTitle, stylesHook.tipsTitle]}>{loc.multisig.ms_help_title2}</Text>
        <Text style={[styles.tipsText, stylesHook.tipsText]}>{loc.multisig.ms_help_2}</Text>
      </View>
      <View style={styles.tips}>
        <Image style={styles.imageTip} source={require('../../img/mshelp/tip3.png')} />
        <Text style={[styles.tipsTitle, stylesHook.tipsTitle]}>{loc.multisig.ms_help_title3}</Text>
        <Text style={[styles.tipsText, stylesHook.tipsText]}>{loc.multisig.ms_help_3}</Text>
      </View>
      <View style={styles.tips}>
        <Image style={styles.imageTip} source={require('../../img/mshelp/tip4.png')} />
        <Text style={[styles.tipsTitle, stylesHook.tipsTitle]}>{loc.multisig.ms_help_title4}</Text>
        <Text style={[styles.tipsText, stylesHook.tipsText]}>{loc.multisig.ms_help_4}</Text>
      </View>
      <View style={styles.tips}>
        <Image style={styles.imageTip} source={require('../../img/mshelp/tip5.png')} />
        <Text style={[styles.tipsTitle, stylesHook.tipsTitle]}>{loc.multisig.ms_help_title5}</Text>
        <Text style={[styles.tipsText, stylesHook.tipsText]}>{loc.multisig.ms_help_5}</Text>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  intro: {
    paddingHorizontal: 32,
    borderBottomWidth: 1,
  },
  introTitle: {
    fontSize: 32,
    fontWeight: '700',
    marginTop: 24,
  },
  introText: {
    fontSize: 15,
    marginVertical: 24,
  },
  introImage: {
    flexDirection: 'row',
    alignSelf: 'center',
    justifyContent: 'flex-end',
  },
  tips: {
    paddingHorizontal: 24,
    paddingVertical: 24,
  },
  tipsTitle: {
    fontSize: 22,
    fontWeight: 'bold',
  },
  tipsText: {
    fontSize: 14,
    fontWeight: '500',
    marginTop: 16,
  },
  imageTip: {
    marginBottom: 24,
    width: '100%',
    maxWidth: 390,
  },
});

export default WalletsAddMultisigHelp;


================================================
FILE: ./screen/wallets/pleaseBackupLNDHub.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useNavigation, useRoute } from '@react-navigation/native';
import React, { useCallback, useEffect, useState } from 'react';
import { BackHandler, StyleSheet, View } from 'react-native';
import { MalinTextCentered } from '../../MalinComponents';
import Button from '../../components/Button';
import CopyTextToClipboard from '../../components/CopyTextToClipboard';
import QRCodeComponent from '../../components/QRCodeComponent';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { useSettings } from '../../hooks/context/useSettings';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const PleaseBackupLNDHub = () => {
  const { wallets } = useStorage();
  const { walletID } = useRoute().params;
  const wallet = wallets.find(w => w.getID() === walletID);
  const navigation = useNavigation();
  const { colors } = useTheme();
  const [qrCodeSize, setQRCodeSize] = useState(90);
  const { isPrivacyBlurEnabled } = useSettings();
  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();

  const dismiss = useCallback(() => {
    navigation.getParent().goBack();
  }, [navigation]);
  const styles = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    scrollViewContent: {
      flexGrow: 1,
      backgroundColor: colors.elevated,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
      paddingHorizontal: 30, // Added additional horizontal padding
    },
  });

  useEffect(() => {
    if (isPrivacyBlurEnabled) {
      enableScreenProtect();
    }
    const subscription = BackHandler.addEventListener('hardwareBackPress', () => {
      dismiss();
      return true;
    });

    return () => {
      disableScreenProtect();
      subscription.remove();
    };
  }, [dismiss, isPrivacyBlurEnabled, enableScreenProtect, disableScreenProtect]);

  const onLayout = e => {
    const { height, width } = e.nativeEvent.layout;
    setQRCodeSize(height > width ? width - 40 : e.nativeEvent.layout.width / 1.5);
  };
  return (
    <SafeAreaScrollView style={styles.root} contentContainerStyle={styles.scrollViewContent} centerContent onLayout={onLayout}>
      <View>
        <MalinTextCentered>{loc.pleasebackup.text_lnd}</MalinTextCentered>
        <MalinSpacing20 />
      </View>
      <MalinSpacing20 />
      <QRCodeComponent value={wallet.getSecret()} size={qrCodeSize} />
      <CopyTextToClipboard text={wallet.getSecret()} />
      <MalinSpacing20 />
      <Button onPress={dismiss} title={loc.pleasebackup.ok_lnd} />
    </SafeAreaScrollView>
  );
};

export default PleaseBackupLNDHub;


================================================
FILE: ./screen/wallets/ImportSpeed.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useNavigation } from '@react-navigation/native';
import React, { useState } from 'react';
import { ActivityIndicator, StyleSheet, TextInput, View } from 'react-native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { MalinFormLabel, MalinFormMultiInput } from '../../MalinComponents';
import { HDSegwitBech32Wallet, WatchOnlyWallet } from '../../class';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import { useStorage } from '../../hooks/context/useStorage';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type NavigationProp = NativeStackNavigationProp<AddWalletStackParamList, 'ImportSpeed'>;

const ImportSpeed = () => {
  const navigation = useNavigation<NavigationProp>();
  const { colors } = useTheme();
  const [loading, setLoading] = useState<boolean>(false);
  const [importText, setImportText] = useState<string>('');
  const [walletType, setWalletType] = useState<string>('');
  const [passphrase, setPassphrase] = useState<string>('');
  const { addAndSaveWallet } = useStorage();

  const styles = StyleSheet.create({
    root: {
      paddingTop: 40,
      backgroundColor: colors.elevated,
    },
    center: {
      flex: 1,
      marginHorizontal: 16,
      backgroundColor: colors.elevated,
    },
    pathInput: {
      flexDirection: 'row',
      borderWidth: 1,
      borderBottomWidth: 0.5,
      minHeight: 44,
      height: 44,
      alignItems: 'center',
      marginVertical: 8,
      borderRadius: 4,
      paddingHorizontal: 8,
      color: '#81868e',
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const importMnemonic = async () => {
    setLoading(true);
    try {
      let WalletClass;
      switch (walletType) {
        case HDSegwitBech32Wallet.type:
          WalletClass = HDSegwitBech32Wallet;
          break;
        case WatchOnlyWallet.type:
          WalletClass = WatchOnlyWallet;
          break;
      }

      if (!WalletClass) {
        throw new Error('Invalid wallet type');
      }

      const wallet = new WalletClass();
      wallet.setSecret(importText);
      // check wallet is type of HDSegwitBech32Wallet
      if (passphrase && wallet instanceof HDSegwitBech32Wallet) {
        wallet.setPassphrase(passphrase);
      }
      await wallet.fetchBalance();
      navigation.getParent()?.goBack();
      addAndSaveWallet(wallet);
    } catch (e: any) {
      presentAlert({ message: e.message });
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeArea style={styles.root}>
      <MalinSpacing20 />
      <MalinFormLabel>Mnemonic</MalinFormLabel>
      <MalinSpacing20 />
      <MalinFormMultiInput testID="SpeedMnemonicInput" value={importText} onChangeText={setImportText} />
      <MalinFormLabel>Wallet type</MalinFormLabel>
      <TextInput testID="SpeedWalletTypeInput" value={walletType} style={styles.pathInput} onChangeText={setWalletType} />
      <MalinFormLabel>Passphrase</MalinFormLabel>
      <TextInput testID="SpeedPassphraseInput" value={passphrase} style={styles.pathInput} onChangeText={setPassphrase} />
      <MalinSpacing20 />
      <View style={styles.center}>
        <Button testID="SpeedDoImport" title="Import" onPress={importMnemonic} />
        {loading && <ActivityIndicator />}
      </View>
    </SafeArea>
  );
};

export default ImportSpeed;


================================================
FILE: ./screen/wallets/DrawerList.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { DrawerContentScrollView, DrawerContentComponentProps } from '@react-navigation/drawer';
import { useIsFocused, useNavigationState } from '@react-navigation/native';
import React, { memo, useCallback, useEffect, useMemo, useReducer, useRef } from 'react';
import { InteractionManager, StyleSheet, View, ViewStyle, Animated, ScrollView } from 'react-native';
import { TWallet } from '../../class/wallets/types';
import { Header } from '../../components/Header';
import { useTheme } from '../../components/themes';
import WalletsCarousel from '../../components/WalletsCarousel';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import TotalWalletsBalance from '../../components/TotalWalletsBalance';
import { useSettings } from '../../hooks/context/useSettings';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';

enum WalletActionType {
  SetWallets = 'SET_WALLETS',
  SelectWallet = 'SELECT_WALLET',
  SetFocus = 'SET_FOCUS',
  Navigate = 'NAVIGATE',
  WalletAdded = 'WALLET_ADDED',
  WalletRemoved = 'WALLET_REMOVED',
}

interface WalletState {
  wallets: TWallet[];
  isFocused: boolean;
  walletAdded: boolean;
  walletRemoved: boolean;
}

interface SelectWalletAction {
  type: WalletActionType.SelectWallet;
  walletID: string;
  walletType: string;
}

interface NavigateAction {
  type: WalletActionType.Navigate;
  screen: string;
  params: { [key: string]: any };
}

interface SetFocusAction {
  type: WalletActionType.SetFocus;
  isFocused: boolean;
}

interface SetWalletsAction {
  type: WalletActionType.SetWallets;
  wallets: TWallet[];
}

interface WalletAddedAction {
  type: WalletActionType.WalletAdded;
}

interface WalletRemovedAction {
  type: WalletActionType.WalletRemoved;
}

type WalletAction = SetWalletsAction | SelectWalletAction | SetFocusAction | NavigateAction | WalletAddedAction | WalletRemovedAction;

const walletReducer = (state: WalletState, action: WalletAction): WalletState => {
  switch (action.type) {
    case WalletActionType.SetWallets: {
      return {
        ...state,
        wallets: action.wallets,
      };
    }
    case WalletActionType.SetFocus: {
      return { ...state, isFocused: action.isFocused };
    }
    case WalletActionType.WalletAdded: {
      return { ...state, walletAdded: true, walletRemoved: false };
    }
    case WalletActionType.WalletRemoved: {
      return { ...state, walletAdded: false, walletRemoved: true };
    }
    default:
      return state;
  }
};

const DrawerList: React.FC<DrawerContentComponentProps> = memo((props: DrawerContentComponentProps) => {
  const initialState: WalletState = {
    wallets: [],
    isFocused: false,
    walletAdded: false,
    walletRemoved: false,
  };

  const navigation = useExtendedNavigation();
  const drawerNavigation = props.navigation;

  const [state, dispatch] = useReducer(walletReducer, initialState);
  const walletsCarousel = useRef<any>(null);
  const { wallets, selectedWalletID } = useStorage();
  const { colors } = useTheme();
  const isFocused = useIsFocused();
  const { isTotalBalanceEnabled } = useSettings();
  const prevWalletCount = useRef(wallets.length);

  const fadeAnim = useRef(new Animated.Value(1)).current;

  const navigationState = useNavigationState(value => value);
  const currentSelectedWalletID = selectedWalletID ? selectedWalletID() : undefined;

  useEffect(() => {
    console.debug('[DrawerList] Navigation state changed, current selectedWalletID:', currentSelectedWalletID);
  }, [navigationState, currentSelectedWalletID]);

  const prevWalletIds = useRef<string[]>([]);

  const scrollViewRef = useRef<ScrollView>(null);
  const lastAddedWalletId = useRef<string | null>(null);

  useEffect(() => {
    if (wallets.length !== prevWalletCount.current) {
      const currentWalletIds = wallets.map(wallet => wallet.getID());

      if (wallets.length > prevWalletCount.current) {
        const addedWalletIds = currentWalletIds.filter(id => !prevWalletIds.current.includes(id));
        if (addedWalletIds.length > 0) {
          dispatch({ type: WalletActionType.WalletAdded });
          lastAddedWalletId.current = addedWalletIds[addedWalletIds.length - 1];

          Animated.sequence([
            Animated.timing(fadeAnim, {
              toValue: 0.7,
              duration: 100,
              useNativeDriver: true,
            }),
            Animated.timing(fadeAnim, {
              toValue: 1,
              duration: 300,
              useNativeDriver: true,
            }),
          ]).start();

          setTimeout(() => {
            if (scrollViewRef.current && lastAddedWalletId.current !== null) {
              const walletIndex = currentWalletIds.indexOf(lastAddedWalletId.current);
              if (walletIndex !== -1) {
                const WALLET_CARD_HEIGHT = 195;
                const scrollPosition = walletIndex * WALLET_CARD_HEIGHT;

                scrollViewRef.current.scrollTo({ y: scrollPosition, animated: true });
              }
            }
          }, 700);
        }
      } else {
        dispatch({ type: WalletActionType.WalletRemoved });

        Animated.sequence([
          Animated.timing(fadeAnim, {
            toValue: 0.5,
            duration: 100,
            useNativeDriver: true,
          }),
          Animated.timing(fadeAnim, {
            toValue: 1,
            duration: 300,
            useNativeDriver: true,
          }),
        ]).start();
      }

      prevWalletCount.current = wallets.length;
      prevWalletIds.current = currentWalletIds;

      setTimeout(() => {
        dispatch({ type: WalletActionType.SetWallets, wallets });
      }, 600);
    } else {
      prevWalletIds.current = wallets.map(wallet => wallet.getID());
    }
  }, [wallets, fadeAnim]);

  const isWalletsListActive = useMemo(() => {
    const drawerRoute = navigationState?.routes?.find(route => route.name === 'DrawerRoot');
    if (!drawerRoute || !drawerRoute.state) return true;

    const detailStack = drawerRoute.state.routes.find(route => route.name === 'DetailViewStackScreensStack');
    if (!detailStack || !detailStack.state) return true;

    const currentScreenName = detailStack.state.routes[detailStack.state.index || 0]?.name;
    return currentScreenName === 'WalletsList';
  }, [navigationState]);

  const stylesHook = useMemo(
    () =>
      StyleSheet.create({
        root: { backgroundColor: colors.elevated } as ViewStyle,
      }),
    [colors.elevated],
  );

  useEffect(() => {
    dispatch({ type: WalletActionType.SetWallets, wallets });
    dispatch({ type: WalletActionType.SetFocus, isFocused });
  }, [wallets, isFocused]);

  const handleClick = useCallback(
    (item?: TWallet) => {
      if (item?.getID) {
        const walletID = item.getID();
        const walletType = item.type;
        dispatch({ type: WalletActionType.SelectWallet, walletID, walletType });
        InteractionManager.runAfterInteractions(() => {
          drawerNavigation.navigate('DetailViewStackScreensStack', {
            screen: 'WalletTransactions',
            params: { walletID, walletType },
          });
          drawerNavigation.closeDrawer();
        });
      }
    },
    [drawerNavigation],
  );

  const handleLongPress = useCallback(() => {
    drawerNavigation.closeDrawer();
    navigation.navigate('DrawerRoot', {
      screen: 'DetailViewStackScreensStack',
      params: {
        screen: 'ManageWallets',
      },
    });
  }, [navigation, drawerNavigation]);

  const onNewWalletPress = useCallback(() => {
    drawerNavigation.closeDrawer();

    navigation.navigate('AddWalletRoot');
  }, [navigation, drawerNavigation]);

  return (
    <DrawerContentScrollView
      ref={scrollViewRef}
      {...props}
      contentContainerStyle={stylesHook.root}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets={true}
      showsHorizontalScrollIndicator={false}
      showsVerticalScrollIndicator={false}
      directionalLockEnabled
    >
      <Header leftText={loc.wallets.list_title} onNewWalletPress={onNewWalletPress} isDrawerList />
      {isTotalBalanceEnabled && (
        <View style={stylesHook.root}>
          <TotalWalletsBalance />
        </View>
      )}
      <Animated.View style={{ opacity: fadeAnim }}>
        <WalletsCarousel
          data={state.wallets}
          extraData={[state.wallets, currentSelectedWalletID, state.walletAdded, state.walletRemoved, lastAddedWalletId.current]}
          onPress={handleClick}
          handleLongPress={handleLongPress}
          ref={walletsCarousel}
          horizontal={false}
          isFlatList={false}
          onNewWalletPress={onNewWalletPress}
          testID="WalletsList"
          selectedWallet={isWalletsListActive ? undefined : currentSelectedWalletID}
          scrollEnabled={state.isFocused}
          animateChanges
        />
      </Animated.View>
    </DrawerContentScrollView>
  );
});

export default DrawerList;


================================================
FILE: ./screen/wallets/Add.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, {
  useCallback,
  useEffect,
  useMemo,
  useReducer,
  useState
} from 'react';
import {
  ActivityIndicator,
  Alert,
  Keyboard,
  LayoutAnimation,
  Linking,
  Platform,
  StyleSheet,
  TextInput,
  useColorScheme,
  View,
} from 'react-native';
import assert from 'assert';

import triggerHapticFeedback, {
  HapticFeedbackTypes
} from '../../malin_modules/hapticFeedback';
import { MalinButtonLink, MalinFormLabel, MalinText } from '../../MalinComponents';
import {
  HDSegwitBech32Wallet,
  HDTaprootWallet,
  LightningCustodianWallet,
  HDLegacyP2PKHWallet,
  EthereumWallet,
  SolanaWallet
} from '../../class';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import { useTheme } from '../../components/themes';
import WalletButton from '../../components/WalletButton';
import loc from '../../loc';
import { Chain } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { Action } from '../../components/types';
import { getLNDHub } from '../../helpers/lndHub';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { AddWalletStackParamList } from '../../navigation/AddWalletStack';
import { RouteProp, useRoute } from '@react-navigation/native';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';
import {
  hexToUint8Array,
  uint8ArrayToHex
} from '../../malin_modules/uint8array-extras';
import { LightningArkWallet } from '../../class/wallets/lightning-ark-wallet.ts';

enum ButtonSelected {
  // @ts-ignore: Return later to update
  ONCHAIN = Chain.ONCHAIN,
  // @ts-ignore: Return later to update
  OFFCHAIN = Chain.OFFCHAIN,
  VAULT = 'VAULT',
  ARK = 'ARK',
  ETHEREUM = 'ETHEREUM',
  SOLANA = 'SOLANA',
}

interface State {
  isLoading: boolean;
  walletBaseURI: string;
  selectedIndex: number;
  label: string;
  selectedWalletType: ButtonSelected;
}

const ActionTypes = {
  SET_LOADING: 'SET_LOADING',
  SET_WALLET_BASE_URI: 'SET_WALLET_BASE_URI',
  SET_SELECTED_INDEX: 'SET_SELECTED_INDEX',
  SET_LABEL: 'SET_LABEL',
  SET_SELECTED_WALLET_TYPE: 'SET_SELECTED_WALLET_TYPE',
} as const;
type ActionTypes = (typeof ActionTypes)[keyof typeof ActionTypes];

interface TAction {
  type: ActionTypes;
  payload?: any;
}

const index2walletType: Record<
  number,
  { text: string; subtitle: string; walletType: string }
> = {
  0: {
    subtitle: 'p2wpkh/HD',
    text: `${loc.multisig.native_segwit_title}`,
    walletType: HDSegwitBech32Wallet.type
  },
  1: {
    subtitle: 'p2pkh/HD',
    text: `${loc.multisig.legacy_title}`,
    walletType: HDLegacyP2PKHWallet.type
  },
  2: { subtitle: 'p2tr/HD', text: 'Taproot', walletType: HDTaprootWallet.type },
  3: {
    // lightning
    subtitle: LightningCustodianWallet.subtitleReadable,
    text: LightningCustodianWallet.typeReadable,
    walletType: LightningCustodianWallet.type,
  }
}

const initialState: State = {
  isLoading: true,
  walletBaseURI: '',
  selectedIndex: 0,
  label: '',
  selectedWalletType: ButtonSelected.ONCHAIN,
}

const walletReducer = (state: State, action: TAction): State => {
  switch (action.type) {
    case ActionTypes.SET_LOADING:
      return { ...state, isLoading: action.payload };
    case ActionTypes.SET_WALLET_BASE_URI:
      return { ...state, walletBaseURI: action.payload };
    case ActionTypes.SET_SELECTED_INDEX:
      return {
        ...state,
        selectedIndex: action.payload,
        selectedWalletType: ButtonSelected.ONCHAIN
      }
    case ActionTypes.SET_LABEL:
      return { ...state, label: action.payload };
    case ActionTypes.SET_SELECTED_WALLET_TYPE:
      return { ...state, selectedWalletType: action.payload };
    default:
      return state;
  }
};

type NavigationProps = NativeStackNavigationProp<
  AddWalletStackParamList,
  'AddWallet'
>;

type RouteProps = RouteProp<AddWalletStackParamList, 'AddWallet'>;

const WalletsAdd: React.FC = () => {
  const { colors } = useTheme();

  // State
  const [state, dispatch] = useReducer(walletReducer, initialState);
  const [backdoorPressed, setBackdoorPressed] = useState(0);
  const isLoading = state.isLoading;
  const walletBaseURI = state.walletBaseURI;
  const selectedIndex = state.selectedIndex;
  const label = state.label;
  const selectedWalletType = state.selectedWalletType;
  const colorScheme = useColorScheme();
  //
  const { addWallet, saveToDisk } = useStorage();
  const { entropy: entropyHex, words } = useRoute<RouteProps>().params || {};
  const entropy = entropyHex ? hexToUint8Array(entropyHex) : undefined;
  const { navigate, goBack, setOptions, setParams } =
    useExtendedNavigation<NavigationProps>();
  const stylesHook = {
    advancedText: {
      color: colors.feeText,
    },
    label: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    noPadding: {
      backgroundColor: colors.elevated,
    },
    root: {
      backgroundColor: colors.elevated,
    },
    lndUri: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    }
  }

  const entropyButtonText = useMemo(() => {
    if (!entropy) {
      return loc.wallets.add_entropy_provide;
    }
    return loc.formatString(loc.wallets.add_entropy_bytes, {
      bytes: entropy?.length,
    })
  }, [entropy]);

  const confirmResetEntropy = useCallback(
    (newWalletType: ButtonSelected) => {
      if (entropy || words) {
        Alert.alert(
          loc.wallets.add_entropy_reset_title,
          loc.wallets.add_entropy_reset_message,
          [
            {
              text: loc._.cancel,
              style: 'cancel',
            },
            {
              text: loc._.ok,
              style: 'destructive',
              onPress: () => {
                setParams({ entropy: undefined, words: undefined });
                setSelectedWalletType(newWalletType);
              }
            }
          ],
          { cancelable: true },
        )
      } else {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setSelectedWalletType(newWalletType);
      }
    },
    [entropy, setParams, words],
  )

  const toolTipActions = useMemo(() => {
    const walletSubactions: Action[] = [
      {
        id: index2walletType[0].walletType,
        text: index2walletType[0].text,
        subtitle: index2walletType[0].subtitle,
        menuState:
          selectedIndex === 0 && selectedWalletType === ButtonSelected.ONCHAIN,
      },
      {
        id: index2walletType[1].walletType,
        text: index2walletType[1].text,
        subtitle: index2walletType[1].subtitle,
        menuState:
          selectedIndex === 1 && selectedWalletType === ButtonSelected.ONCHAIN,
      },
      {
        id: index2walletType[2].walletType,
        text: index2walletType[2].text,
        subtitle: index2walletType[2].subtitle,
        menuState:
          selectedIndex === 2 && selectedWalletType === ButtonSelected.ONCHAIN,
      },
      {
        id: index2walletType[3].walletType,
        text: index2walletType[3].text,
        subtitle: index2walletType[3].subtitle,
        menuState: selectedWalletType === ButtonSelected.OFFCHAIN,
      }
    ]

    const walletAction: Action = {
      id: 'wallets',
      text: loc.multisig.wallet_type,
      subactions: walletSubactions,
      displayInline: true,
    }

    const entropySubActions: Action[] = [
      {
        id: '12_words',
        text: loc.wallets.add_wallet_seed_length_12,
        subtitle: loc.wallets.add_wallet_seed_length,
        menuState: words === 12,
      },
      {
        id: '24_words',
        text: loc.wallets.add_wallet_seed_length_24,
        subtitle: loc.wallets.add_wallet_seed_length,
        menuState: words === 24,
      },
      { ...CommonToolTipActions.ResetToDefault, hidden: !entropy },
    ]

    const entropyActions: Action = {
      ...CommonToolTipActions.Entropy,
      text: entropyButtonText,
      subactions: entropySubActions,
    }

    return selectedWalletType === ButtonSelected.ONCHAIN
      ? [walletAction, entropyActions]
      : [walletAction];
  }, [selectedWalletType, selectedIndex, entropy, words, entropyButtonText]);

  const handleOnLightningArkButtonPressed = useCallback(() => {
    confirmResetEntropy(ButtonSelected.ARK);
  }, [confirmResetEntropy]);

  const handleOnLightningButtonPressed = useCallback(() => {
    confirmResetEntropy(ButtonSelected.OFFCHAIN);
  }, [confirmResetEntropy]);

  const HeaderRight = useMemo(
    () => (
      <HeaderMenuButton
        onPressMenuItem={(id: string) => {
          LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

          if (id === LightningCustodianWallet.type) {
            handleOnLightningButtonPressed();
          } else if (id === '12_words') {
            navigate('ProvideEntropy', {
              words: 12,
              entropy: entropy ? uint8ArrayToHex(entropy) : undefined
            });
          } else if (id === '24_words') {
            navigate('ProvideEntropy', {
              words: 24,
              entropy: entropy ? uint8ArrayToHex(entropy) : undefined
            });
          } else if (id === CommonToolTipActions.ResetToDefault.id) {
            confirmResetEntropy(ButtonSelected.ONCHAIN);
          } else {
            for (let c = 0; c < Object.values(index2walletType).length; c++) {
              if (index2walletType[c].walletType === id) {
                // found our item that was pressed
                setSelectedIndex(c);
                break
              }
            }
          }
        }}
        actions={toolTipActions}
      />
    ),
    [
      handleOnLightningButtonPressed,
      toolTipActions,
      entropy,
      confirmResetEntropy,
      navigate
    ],
  );

  useEffect(() => {
    setOptions({
      headerRight: () => HeaderRight,
      statusBarStyle: Platform.select({
        ios: 'light',
        default: colorScheme === 'dark' ? 'light' : 'dark',
      }),
    })
  }, [
    HeaderRight,
    colorScheme,
    colors.foregroundColor,
    setOptions,
    toolTipActions
  ]);

  useEffect(() => {
    getLNDHub()
      .then((url) => (url ? setWalletBaseURI(url) : setWalletBaseURI('')))
      .catch(() => setWalletBaseURI(''))
      .finally(() => setIsLoading(false));
  }, []);

  const setIsLoading = (value: boolean) => {
    dispatch({ type: 'SET_LOADING', payload: value });
  }

  const setWalletBaseURI = (value: string) => {
    dispatch({ type: 'SET_WALLET_BASE_URI', payload: value });
  }

  const setSelectedIndex = (value: number) => {
    dispatch({ type: 'SET_SELECTED_INDEX', payload: value });
  }

  const setLabel = (value: string) => {
    dispatch({ type: 'SET_LABEL', payload: value });
  }

  const setSelectedWalletType = (value: ButtonSelected) => {
    dispatch({ type: 'SET_SELECTED_WALLET_TYPE', payload: value });
  }

  const createWallet = async () => {
    setIsLoading(true);

    if (selectedWalletType === ButtonSelected.OFFCHAIN) {
      createLightningWallet();
    } else if (selectedWalletType === ButtonSelected.ARK) {
      createLightningArkWallet();
    } else if (selectedWalletType === ButtonSelected.ETHEREUM) {
      const w = new EthereumWallet();
      w.setLabel(label || 'Ethereum');
      await w.generate();
      addWallet(w);
      await saveToDisk();
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      goBack();
    } else if (selectedWalletType === ButtonSelected.SOLANA) {
      const w = new SolanaWallet();
      w.setLabel(label || 'Solana');
      await w.generate();
      addWallet(w);
      await saveToDisk();
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      goBack();
    } else if (selectedWalletType === ButtonSelected.ONCHAIN) {
      let w: HDSegwitBech32Wallet | HDLegacyP2PKHWallet | HDTaprootWallet;

      for (let c = 0; c < Object.values(index2walletType).length; c++) {
        if (c === selectedIndex) {
          switch (index2walletType[c].walletType) {
            case HDTaprootWallet.type:
              w = new HDTaprootWallet();
              w.setLabel(label || loc.wallets.details_title);
              break
            case HDLegacyP2PKHWallet.type:
              w = new HDLegacyP2PKHWallet();
              w.setLabel(label || loc.wallets.details_title);
              break
            case HDSegwitBech32Wallet.type:
              w = new HDSegwitBech32Wallet();
              w.setLabel(label || loc.wallets.details_title);
              break
          }
        }
      }

      assert(w!, 'Internal error: could not decide which wallet to create');

      if (selectedWalletType === ButtonSelected.ONCHAIN) {
        if (entropy) {
          try {
            await w.generateFromEntropy(entropy);
          } catch (e: any) {
            console.log(e.toString());
            presentAlert({ message: e.toString() });
            return
          }
        } else {
          await w.generate();
        }
        addWallet(w);
        await saveToDisk();

        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        if (
          w.type === HDLegacyP2PKHWallet.type ||
          w.type === HDSegwitBech32Wallet.type ||
          w.type === HDTaprootWallet.type
        ) {
          navigate('PleaseBackup', {
            walletID: w.getID(),
          })
        } else {
          goBack();
        }
      }
    } else if (selectedWalletType === ButtonSelected.VAULT) {
      setIsLoading(false);
      navigate('WalletsAddMultisig', {
        walletLabel:
          label.trim().length > 0 ? label : loc.multisig.default_label
      });
    }
  };

  const createLightningWallet = async () => {
    const wallet = new LightningCustodianWallet();
    wallet.setLabel(label || loc.wallets.details_title);

    try {
      const lndhub = walletBaseURI?.trim();
      if (lndhub) {
        const isValidNodeAddress =
          await LightningCustodianWallet.isValidNodeAddress(lndhub);
        if (isValidNodeAddress) {
          wallet.setBaseURI(lndhub);
          await wallet.init();
        } else {
          throw new Error(
            'The provided node address is not valid LNDHub node.',
          )
        }
      }
      await wallet.createAccount();
      await wallet.authorize();
    } catch (Err: any) {
      setIsLoading(false);
      console.warn('lnd create failure', Err);
      if (Err.message) {
        return presentAlert({ message: Err.message });
      } else {
        return presentAlert({ message: loc.wallets.add_lndhub_error });
      }
      // giving app, not adding anything
    }

    await wallet.generate();
    addWallet(wallet);
    await saveToDisk();

    triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    navigate('PleaseBackupLNDHub', {
      walletID: wallet.getID(),
    })
  }

  const createLightningArkWallet = async () => {
    const wallet = new LightningArkWallet();
    wallet.setLabel(label || loc.wallets.details_title);
    try {
      await wallet.generate();
    } catch (Err: any) {
      setIsLoading(false);
      console.warn('lightning ark create failure', Err);
      return presentAlert({ message: Err.message ?? '' });
    }

    addWallet(wallet);
    await saveToDisk();

    triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    navigate('PleaseBackupLNDHub', {
      walletID: wallet.getID(),
    })
  }

  const navigateToImportWallet = () => {
    navigate('ImportWallet');
  };

  const handleOnVaultButtonPressed = () => {
    Keyboard.dismiss();
    confirmResetEntropy(ButtonSelected.VAULT);
  }

  const handleOnBitcoinButtonPressed = () => {
    setBackdoorPressed((prevState) => prevState + 1);
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    Keyboard.dismiss();
    setSelectedWalletType(ButtonSelected.ONCHAIN);
  }

  const handleOnEthereumButtonPressed = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    Keyboard.dismiss();
    setSelectedWalletType(ButtonSelected.ETHEREUM);
  }

  const handleOnSolanaButtonPressed = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    Keyboard.dismiss();
    setSelectedWalletType(ButtonSelected.SOLANA);
  }

  const onLearnMorePressed = () => {
    Linking.openURL('https://malinwallet.io/lightning/');
  };

  const LightningButtonMemo = useMemo(
    () => (
      <WalletButton
        buttonType="Lightning"
        testID="ActivateLightningButton"
        active={selectedWalletType === ButtonSelected.OFFCHAIN}
        onPress={handleOnLightningButtonPressed}
        size={styles.button}
      />
    ),
    [selectedWalletType, handleOnLightningButtonPressed],
  )

  return (
    <SafeAreaScrollView
      style={stylesHook.root}
      testID="ScrollView"
      automaticallyAdjustKeyboardInsets
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
      automaticallyAdjustsScrollIndicatorInsets
    >
      <MalinSpacing20 />
      <MalinFormLabel>{loc.wallets.add_wallet_name}</MalinFormLabel>
      <View style={[styles.label, stylesHook.label]}>
        <TextInput
          testID="WalletNameInput"
          value={label}
          placeholderTextColor="#81868e"
          placeholder={loc.wallets.add_placeholder}
          onChangeText={setLabel}
          style={styles.textInputCommon}
          editable={!isLoading}
          underlineColorAndroid="transparent"
        />
      </View>
      <MalinFormLabel>{loc.wallets.add_wallet_type}</MalinFormLabel>
      <View style={styles.buttons}>
        <WalletButton
          buttonType="Bitcoin"
          testID="ActivateBitcoinButton"
          active={selectedWalletType === ButtonSelected.ONCHAIN}
          onPress={handleOnBitcoinButtonPressed}
          size={styles.button}
        />
        <WalletButton
          buttonType="Vault"
          testID="ActivateVaultButton"
          active={selectedWalletType === ButtonSelected.VAULT}
          onPress={handleOnVaultButtonPressed}
          size={styles.button}
        />
        <WalletButton
          buttonType="Ethereum"
          testID="ActivateEthereumButton"
          active={selectedWalletType === ButtonSelected.ETHEREUM}
          onPress={handleOnEthereumButtonPressed}
          size={styles.button}
        />
        <WalletButton
          buttonType="Solana"
          testID="ActivateSolanaButton"
          active={selectedWalletType === ButtonSelected.SOLANA}
          onPress={handleOnSolanaButtonPressed}
          size={styles.button}
        />
        {backdoorPressed >= 20 ? (
  <WalletButton
            buttonType='LightningArk'
            testID='ActivateLightningArkButton'
            active={selectedWalletType === ButtonSelected.ARK}
            onPress={handleOnLightningArkButtonPressed}
            size={styles.button}
          />
            ) : null}
        {selectedWalletType === ButtonSelected.OFFCHAIN && LightningButtonMemo}
      </View>
      <View style={styles.advanced}>
        {selectedWalletType === ButtonSelected.OFFCHAIN && (
          <>
            <MalinSpacing20 />
            <View style={styles.lndhubTitle}>
              <MalinText>{loc.wallets.add_lndhub}</MalinText>
              <MalinButtonLink
                title={loc.wallets.learn_more}
                onPress={onLearnMorePressed}
              />
            </View>

            <View style={[styles.lndUri, stylesHook.lndUri]}>
              <TextInput
                value={walletBaseURI}
                onChangeText={setWalletBaseURI}
                onSubmitEditing={Keyboard.dismiss}
                placeholder={loc.wallets.add_lndhub_placeholder}
                clearButtonMode="while-editing"
                autoCapitalize="none"
                textContentType="URL"
                autoCorrect={false}
                placeholderTextColor="#81868e"
                style={styles.textInputCommon}
                editable={!isLoading}
                underlineColorAndroid="transparent"
              />
            </View>
          </>
        )}

        <MalinSpacing20 />
        {!isLoading ? (
  <>
            <Button
      testID="Create"
      title={loc.wallets.add_create}
      disabled={
                !selectedWalletType ||
                (selectedWalletType === ButtonSelected.OFFCHAIN &&
                  (walletBaseURI ?? '').trim().length === 0)
              }
      onPress={createWallet}
    />

            <MalinButtonLink
      testID="ImportWallet"
      style={styles.import}
      title={loc.wallets.add_import_wallet}
      onPress={navigateToImportWallet}
    />
            <MalinSpacing40 />
          </>
            ) : (
          <ActivityIndicator />
            )}
      </View>
    </SafeAreaScrollView>
  );
}

const styles = StyleSheet.create({
  label: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    marginHorizontal: 20,
    alignItems: 'center',
    marginVertical: 16,
    borderRadius: 4,
  },
  textInputCommon: {
    flex: 1,
    marginHorizontal: 8,
    color: '#81868e',
  },
  buttons: {
    flexDirection: 'column',
    marginHorizontal: 20,
    marginTop: 16,
    borderWidth: 0,
    minHeight: 100,
  },
  button: {
    width: '100%',
    height: 'auto',
  },
  advanced: {
    marginHorizontal: 20,
  },
  lndUri: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    marginVertical: 16,
    borderRadius: 4,
  },
  import: {
    marginVertical: 24,
  },
  lndhubTitle: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
})

export default WalletsAdd;


================================================
FILE: ./screen/wallets/ManageWallets.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useLayoutEffect, useReducer, useCallback, useMemo, useRef, useState, lazy, Suspense } from 'react';
import {
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert,
  Animated,
  FlatList,
  ActivityIndicator,
  LayoutAnimation,
  UIManager,
  Platform,
  Keyboard,
} from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { useLocale, usePreventRemove } from '@react-navigation/native';
import { useTheme } from '../../components/themes';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { TTXMetadata } from '../../class';
import { ExtendedTransaction, LightningTransaction, Transaction, TWallet } from '../../class/wallets/types';
import useBounceAnimation from '../../hooks/useBounceAnimation';
import HeaderRightButton from '../../components/HeaderRightButton';
import DragList, { DragListRenderItemInfo } from 'react-native-draglist';
import useDebounce from '../../hooks/useDebounce';
import { ItemType, AddressItemData } from '../../models/itemTypes';
import { WalletGroupComponent } from '../../components/ManageWalletsListItem';
import HighlightedText from '../../components/HighlightedText';

const ManageWalletsListItem = lazy(() => import('../../components/ManageWalletsListItem'));

interface WalletItem {
  type: ItemType.WalletSection;
  data: TWallet;
}

interface TransactionItem {
  type: ItemType.TransactionSection;
  data: ExtendedTransaction & LightningTransaction;
}

interface AddressItem {
  type: ItemType.AddressSection;
  data: Omit<AddressItemData, 'label'>;
}

interface WalletGroupItem {
  type: ItemType.WalletGroupSection;
  wallet: TWallet;
  transactions: TransactionItem[];
  addresses: AddressItem[];
}

type Item = WalletItem | TransactionItem | AddressItem | WalletGroupItem;

const SET_SEARCH_QUERY = 'SET_SEARCH_QUERY';
const SET_IS_SEARCH_FOCUSED = 'SET_IS_SEARCH_FOCUSED';
const SET_INITIAL_DATA = 'SET_INITIAL_DATA';
const SET_MANAGED_DATA = 'SET_MANAGED_DATA';
const REMOVE_WALLET = 'REMOVE_WALLET';
const SAVE_CHANGES = 'SAVE_CHANGES';

interface SaveChangesAction {
  type: typeof SAVE_CHANGES;
  payload: TWallet[];
}

interface SetSearchQueryAction {
  type: typeof SET_SEARCH_QUERY;
  payload: string;
}

interface SetIsSearchFocusedAction {
  type: typeof SET_IS_SEARCH_FOCUSED;
  payload: boolean;
}

interface SetInitialDataAction {
  type: typeof SET_INITIAL_DATA;
  payload: { wallets: TWallet[]; txMetadata: TTXMetadata };
}

interface SetManagedDataAction {
  type: typeof SET_MANAGED_DATA;
  payload: Item[];
}

interface RemoveWalletAction {
  type: typeof REMOVE_WALLET;
  payload: string; // Wallet ID
}

type Action =
  | SetSearchQueryAction
  | SetIsSearchFocusedAction
  | SetInitialDataAction
  | SetManagedDataAction
  | SaveChangesAction
  | RemoveWalletAction;

interface State {
  searchQuery: string;
  isSearchFocused: boolean;
  originalWallets: TWallet[]; // Only used for verifying unsaved changes
  walletsCopy: TWallet[]; // Copy used for display and filtering
  managedWalletsData: Item[];
  txMetadata: TTXMetadata;
}

const initialState: State = {
  searchQuery: '',
  isSearchFocused: false,
  originalWallets: [],
  walletsCopy: [],
  managedWalletsData: [],
  txMetadata: {},
};

const deepCopyWallets = (wallets: TWallet[]): TWallet[] => {
  return wallets.map(wallet => Object.assign(Object.create(Object.getPrototypeOf(wallet)), wallet));
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case SET_SEARCH_QUERY:
      return { ...state, searchQuery: action.payload };
    case SET_IS_SEARCH_FOCUSED:
      return { ...state, isSearchFocused: action.payload };
    case SET_INITIAL_DATA: {
      const walletsCopy = deepCopyWallets(action.payload.wallets);
      const managedWalletsData: WalletItem[] = walletsCopy.map(wallet => ({
        type: ItemType.WalletSection,
        data: wallet,
      }));

      return {
        ...state,
        originalWallets: deepCopyWallets(action.payload.wallets),
        walletsCopy,
        txMetadata: action.payload.txMetadata,
        managedWalletsData,
      };
    }
    case SET_MANAGED_DATA: {
      const updatedWalletsCopy = action.payload
        .filter((item): item is WalletItem => item.type === ItemType.WalletSection)
        .map(item => item.data);

      return {
        ...state,
        walletsCopy: updatedWalletsCopy.length > 0 ? updatedWalletsCopy : state.walletsCopy,
        managedWalletsData: action.payload,
      };
    }
    case SAVE_CHANGES: {
      return {
        ...state,
        originalWallets: deepCopyWallets(action.payload),
        walletsCopy: deepCopyWallets(action.payload),
      };
    }
    case REMOVE_WALLET: {
      const walletId = action.payload;
      const updatedOrder = state.managedWalletsData.filter(item => item.type !== ItemType.WalletSection || item.data.getID() !== walletId);
      const updatedWalletsCopy = state.walletsCopy.filter(wallet => wallet.getID() !== walletId);

      return {
        ...state,
        managedWalletsData: updatedOrder,
        walletsCopy: updatedWalletsCopy,
      };
    }
    default:
      throw new Error(`Unhandled action type: ${(action as Action).type}`);
  }
};

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const ManageWallets: React.FC = () => {
  const { colors, closeImage } = useTheme();
  const { wallets: persistedWallets, setWalletsWithNewOrder, txMetadata, handleWalletDeletion } = useStorage();
  const initialWalletsRef = useRef<TWallet[]>(deepCopyWallets(persistedWallets));
  const { navigate, setOptions, goBack, dispatch: navigationDispatch } = useExtendedNavigation();
  const { direction } = useLocale();
  const [state, dispatch] = useReducer(reducer, initialState);
  const debouncedSearchQuery = useDebounce(state.searchQuery, 300);
  const bounceAnim = useBounceAnimation(state.searchQuery);
  const stylesHook = {
    root: {
      backgroundColor: colors.elevated,
    },
    noResultsText: {
      color: colors.foregroundColor,
      writingDirection: direction,
    },
  };
  const [noResultsOpacity] = useState(new Animated.Value(0));

  const listRef = useRef<FlatList<Item> | null>(null);
  const [saveInProgress, setSaveInProgress] = useState(false);

  const getFilteredWalletsData = useCallback(() => {
    if (debouncedSearchQuery) {
      const lowerQuery = debouncedSearchQuery.toLowerCase();

      const walletsWithMatches = new Map<
        string,
        {
          wallet: TWallet;
          transactions: TransactionItem[];
          addresses: AddressItem[];
        }
      >();

      const walletIdSet = new Set(state.walletsCopy.map(wallet => wallet.getID()));

      const matchingTxids = Object.entries(state.txMetadata).filter(
        ([_, metadata]) => metadata.memo && metadata.memo.toLowerCase().includes(lowerQuery),
      );

      if (matchingTxids.length > 0) {
        const txidToWalletMap = new Map<string, string>();

        state.walletsCopy.forEach(wallet => {
          try {
            const transactions = wallet.getTransactions();
            if (transactions && transactions.length) {
              const walletID = wallet.getID();
              transactions.forEach((tx: Transaction) => {
                const txid = tx.hash || tx.txid;
                if (txid) {
                  txidToWalletMap.set(txid, walletID);
                }
              });
            }
          } catch (e) {}
        });

        matchingTxids.forEach(([txid]) => {
          const walletID = txidToWalletMap.get(txid);
          if (walletID && walletIdSet.has(walletID)) {
            const wallet = state.walletsCopy.find(w => w.getID() === walletID);
            if (wallet) {
              if (!walletsWithMatches.has(walletID)) {
                walletsWithMatches.set(walletID, {
                  wallet,
                  transactions: [],
                  addresses: [],
                });
              }

              try {
                const tx = wallet.getTransactions().find((t: Transaction) => t.hash === txid || t.txid === txid);
                if (tx) {
                  const group = walletsWithMatches.get(walletID)!;
                  const txExists = group.transactions.some(item => item.data.hash === txid || item.data.txid === txid);

                  if (!txExists) {
                    group.transactions.push({
                      type: ItemType.TransactionSection,
                      data: tx as ExtendedTransaction & LightningTransaction,
                    });
                  }
                }
              } catch (e) {}
            }
          }
        });
      }

      state.walletsCopy.forEach(wallet => {
        const walletID = wallet.getID();
        const walletLabel = wallet.getLabel() || '';

        if (walletLabel.toLowerCase().includes(lowerQuery) && !walletsWithMatches.has(walletID)) {
          walletsWithMatches.set(walletID, {
            wallet,
            transactions: [],
            addresses: [],
          });
        }
      });

      if (walletsWithMatches.size < 10) {
        state.walletsCopy.forEach(wallet => {
          const walletID = wallet.getID();

          if (walletsWithMatches.has(walletID)) return;

          try {
            const transactions = wallet.getTransactions();
            if (transactions && transactions.length) {
              const txToProcess = Math.min(transactions.length, 100);

              for (let i = 0; i < txToProcess; i++) {
                const tx = transactions[i];
                const txid = tx.hash || tx.txid;

                const txAmount = tx.value?.toString() || '';
                const txIdMatches = txid.toLowerCase().includes(lowerQuery);
                const txDataMatches = txAmount.includes(lowerQuery);

                if (txIdMatches || txDataMatches) {
                  if (!walletsWithMatches.has(walletID)) {
                    walletsWithMatches.set(walletID, {
                      wallet,
                      transactions: [],
                      addresses: [],
                    });
                  }

                  const group = walletsWithMatches.get(walletID)!;
                  if (!group.transactions.some(item => item.data.hash === txid || item.data.txid === txid)) {
                    group.transactions.push({
                      type: ItemType.TransactionSection,
                      data: tx as ExtendedTransaction & LightningTransaction,
                    });
                  }

                  break;
                }
              }
            }
          } catch (e) {}

          if (walletsWithMatches.size < 20) {
            try {
              const addresses = wallet.getAllExternalAddresses();
              if (addresses && addresses.length) {
                const addressLimit = Math.min(addresses.length, 50);

                for (let i = 0; i < addressLimit; i++) {
                  const address = addresses[i];
                  const addressValue = typeof address === 'string' ? address : (address as { address: string }).address || '';

                  if (addressValue.toLowerCase().includes(lowerQuery)) {
                    if (!walletsWithMatches.has(walletID)) {
                      walletsWithMatches.set(walletID, {
                        wallet,
                        transactions: [],
                        addresses: [],
                      });
                    }

                    const group = walletsWithMatches.get(walletID)!;
                    const addressItem: AddressItem = {
                      type: ItemType.AddressSection,
                      data: {
                        address: addressValue,
                        walletID,
                        index: i,
                        isInternal: false,
                      },
                    };

                    if (!group.addresses.some(item => item.data.address === addressValue)) {
                      group.addresses.push(addressItem);
                    }

                    break;
                  }
                }
              }
            } catch (e) {}
          }
        });
      }

      const resultItems = Array.from(walletsWithMatches.values());
      const result: Item[] = [];

      resultItems.sort((a, b) => {
        const aMatches = a.transactions.length + a.addresses.length;
        const bMatches = b.transactions.length + b.addresses.length;
        return bMatches - aMatches;
      });

      resultItems.forEach(matchData => {
        const { wallet, transactions, addresses } = matchData;

        if (transactions.length > 0 || addresses.length > 0) {
          transactions.sort((a, b) => {
            if (a.data.timestamp && b.data.timestamp) {
              return b.data.timestamp - a.data.timestamp;
            }
            return 0;
          });

          const limitedTransactions = transactions.slice(0, 15);
          const limitedAddresses = addresses.slice(0, 10);

          result.push({
            type: ItemType.WalletGroupSection,
            wallet,
            transactions: limitedTransactions,
            addresses: limitedAddresses,
          });
        } else {
          result.push({
            type: ItemType.WalletSection,
            data: wallet,
          });
        }
      });

      return result;
    }

    return state.managedWalletsData;
  }, [debouncedSearchQuery, state.managedWalletsData, state.walletsCopy, state.txMetadata]);

  useEffect(() => {
    dispatch({ type: SET_INITIAL_DATA, payload: { wallets: initialWalletsRef.current, txMetadata } });
  }, [txMetadata]);

  useEffect(() => {
    if (state.searchQuery && getFilteredWalletsData().length === 0) {
      Animated.timing(noResultsOpacity, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    } else {
      noResultsOpacity.setValue(0);
    }
  }, [getFilteredWalletsData, state.searchQuery, noResultsOpacity]);

  const hasUnsavedChanges = useMemo(() => {
    if (state.searchQuery.length > 0 || state.isSearchFocused) {
      return false;
    }

    const currentWalletIds = state.managedWalletsData
      .filter((item): item is WalletItem => item.type === ItemType.WalletSection)
      .map(item => item.data.getID());

    const originalWalletIds = state.originalWallets.map(wallet => wallet.getID());

    if (currentWalletIds.length !== originalWalletIds.length) {
      return true;
    }

    for (let i = 0; i < currentWalletIds.length; i++) {
      if (currentWalletIds[i] !== originalWalletIds[i]) {
        return true;
      }
    }

    const modifiedWallets = state.managedWalletsData
      .filter((item): item is WalletItem => item.type === ItemType.WalletSection)
      .map(item => item.data);

    for (const modifiedWallet of modifiedWallets) {
      const originalWallet = state.originalWallets.find(w => w.getID() === modifiedWallet.getID());
      if (originalWallet && originalWallet.hideBalance !== modifiedWallet.hideBalance) {
        return true;
      }
    }

    return false;
  }, [state.managedWalletsData, state.originalWallets, state.searchQuery, state.isSearchFocused]);

  usePreventRemove(hasUnsavedChanges && !saveInProgress, ({ data: preventRemoveData }) => {
    Alert.alert(loc._.discard_changes, loc._.discard_changes_explain, [
      { text: loc._.cancel, style: 'cancel' },
      {
        text: loc._.ok,
        style: 'destructive',
        onPress: () => navigationDispatch(preventRemoveData.action),
      },
    ]);
  });

  useEffect(() => {
    if (saveInProgress) {
      goBack();
      setSaveInProgress(false);
    }
  }, [saveInProgress, goBack]);

  const handleClose = useCallback(() => {
    if (state.searchQuery.length === 0 && !state.isSearchFocused) {
      const reorderedWallets = state.managedWalletsData
        .filter((item): item is WalletItem => item.type === ItemType.WalletSection)
        .map(item => item.data);

      const walletsToDelete = state.originalWallets.filter(
        originalWallet => !reorderedWallets.some(wallet => wallet.getID() === originalWallet.getID()),
      );

      setWalletsWithNewOrder(reorderedWallets);
      dispatch({ type: SAVE_CHANGES, payload: reorderedWallets });
      initialWalletsRef.current = deepCopyWallets(reorderedWallets);

      walletsToDelete.forEach(wallet => {
        handleWalletDeletion(wallet.getID());
      });

      setSaveInProgress(true);
    } else {
      dispatch({ type: SET_SEARCH_QUERY, payload: '' });
      dispatch({ type: SET_IS_SEARCH_FOCUSED, payload: false });
    }
  }, [
    setWalletsWithNewOrder,
    state.searchQuery,
    state.isSearchFocused,
    state.managedWalletsData,
    state.originalWallets,
    handleWalletDeletion,
  ]);

  const buttonOpacity = useMemo(() => ({ opacity: saveInProgress ? 0.5 : 1 }), [saveInProgress]);
  const HeaderLeftButton = useMemo(
    () => (
      <TouchableOpacity
        accessibilityRole="button"
        accessibilityLabel={loc._.close}
        style={[styles.button, buttonOpacity]}
        onPress={goBack}
        disabled={saveInProgress}
        testID="NavigationCloseButton"
      >
        <Image source={closeImage} />
      </TouchableOpacity>
    ),
    [buttonOpacity, goBack, saveInProgress, closeImage],
  );

  const SaveButton = useMemo(
    () => <HeaderRightButton disabled={!hasUnsavedChanges} title={loc.send.input_done} onPress={handleClose} />,
    [handleClose, hasUnsavedChanges],
  );

  useLayoutEffect(() => {
    const searchBarOptions = {
      hideWhenScrolling: false,
      onChangeText: (event: { nativeEvent: { text: any } }) => dispatch({ type: SET_SEARCH_QUERY, payload: event.nativeEvent.text }),
      onClear: () => dispatch({ type: SET_SEARCH_QUERY, payload: '' }),
      onFocus: () => dispatch({ type: SET_IS_SEARCH_FOCUSED, payload: true }),
      onBlur: () => dispatch({ type: SET_IS_SEARCH_FOCUSED, payload: false }),
      placeholder: loc.wallets.manage_wallets_search_placeholder,
    };
    setOptions({
      headerLeft: () => HeaderLeftButton,
      headerRight: () => SaveButton,
      headerSearchBarOptions: searchBarOptions,
    });
  }, [setOptions, HeaderLeftButton, SaveButton]);

  const renderHighlightedText = useCallback(
    (text: string, query: string) => {
      return <HighlightedText text={text} query={query} bounceAnim={bounceAnim} />;
    },
    [bounceAnim],
  );

  const handleDeleteWallet = useCallback(async (wallet: TWallet) => {
    if (Platform.OS === 'ios') {
      LayoutAnimation.configureNext({
        duration: 300,
        create: {
          type: LayoutAnimation.Types.easeInEaseOut,
          property: LayoutAnimation.Properties.opacity,
        },
        update: {
          type: LayoutAnimation.Types.easeInEaseOut,
        },
        delete: {
          type: LayoutAnimation.Types.spring,
          property: LayoutAnimation.Properties.scaleXY,
          springDamping: 0.9,
          duration: 300,
        },
      });
    } else {
      LayoutAnimation.configureNext({
        duration: 250,
        create: {
          type: LayoutAnimation.Types.easeInEaseOut,
          property: LayoutAnimation.Properties.opacity,
        },
        update: {
          type: LayoutAnimation.Types.easeInEaseOut,
        },
        delete: {
          type: LayoutAnimation.Types.easeOut,
          property: LayoutAnimation.Properties.opacity,
          duration: 200,
        },
      });
    }

    dispatch({ type: REMOVE_WALLET, payload: wallet.getID() });
  }, []);

  const handleToggleHideBalance = useCallback(
    (wallet: TWallet) => {
      const updatedOrder = state.managedWalletsData.map(item => {
        if (item.type === ItemType.WalletSection && item.data.getID() === wallet.getID()) {
          item.data.hideBalance = !item.data.hideBalance;
          return {
            ...item,
            data: item.data,
          };
        }
        return item;
      });

      dispatch({ type: SET_MANAGED_DATA, payload: updatedOrder });
    },
    [state.managedWalletsData],
  );

  const navigateToWallet = useCallback(
    (wallet: TWallet) => {
      Keyboard.dismiss();
      const walletID = wallet.getID();
      navigate('WalletTransactions', {
        walletID,
        walletType: wallet.type,
      });
    },
    [navigate],
  );

  const navigateToAddress = useCallback(
    (address: string) => {
      Keyboard.dismiss();

      navigate('ReceiveDetails', {
        address,
      });
    },
    [navigate],
  );

  const renderItem = useCallback(
    (info: DragListRenderItemInfo<Item>) => {
      const { item, onDragStart, isActive } = info;

      const compatibleState = {
        wallets: state.walletsCopy,
        searchQuery: state.searchQuery,
        isSearchFocused: state.isSearchFocused,
      };

      if (item.type === ItemType.WalletGroupSection) {
        return (
          <WalletGroupComponent
            wallet={item.wallet}
            transactions={item.transactions}
            addresses={item.addresses}
            state={compatibleState}
            navigateToWallet={navigateToWallet}
            navigateToAddress={navigateToAddress}
            renderHighlightedText={renderHighlightedText}
            isSearching={state.searchQuery.length > 0}
          />
        );
      }

      return (
        <ManageWalletsListItem
          item={item}
          onPressIn={undefined}
          onPressOut={undefined}
          isDraggingDisabled={state.searchQuery.length > 0 || state.isSearchFocused}
          state={compatibleState}
          navigateToWallet={navigateToWallet}
          navigateToAddress={navigateToAddress}
          renderHighlightedText={renderHighlightedText}
          handleDeleteWallet={handleDeleteWallet}
          handleToggleHideBalance={handleToggleHideBalance}
          isActive={isActive}
          drag={onDragStart}
        />
      );
    },
    [
      state.walletsCopy,
      state.searchQuery,
      state.isSearchFocused,
      navigateToWallet,
      navigateToAddress,
      renderHighlightedText,
      handleDeleteWallet,
      handleToggleHideBalance,
    ],
  );

  const onReordered = useCallback(
    (fromIndex: number, toIndex: number) => {
      if (state.searchQuery.length > 0 || state.isSearchFocused) {
        return;
      }

      const updatedOrder = [...state.managedWalletsData];
      const removed = updatedOrder.splice(fromIndex, 1);
      updatedOrder.splice(toIndex, 0, removed[0]);

      dispatch({ type: SET_MANAGED_DATA, payload: updatedOrder });
    },
    [state.managedWalletsData, state.searchQuery, state.isSearchFocused],
  );

  const keyExtractor = useCallback((item: Item, index: number) => index.toString(), []);

  return (
    <Suspense fallback={<ActivityIndicator size="large" color={colors.brandingColor} />}>
      <GestureHandlerRootView style={[{ backgroundColor: colors.background }, styles.root]}>
        {state.searchQuery && getFilteredWalletsData().length === 0 ? (
          <Animated.View style={[styles.noResultsContainer, { opacity: noResultsOpacity }]}>
            <Animated.Text style={[styles.noResultsText, stylesHook.noResultsText]}>{loc.wallets.no_results_found}</Animated.Text>
          </Animated.View>
        ) : (
          <DragList
            automaticallyAdjustContentInsets
            automaticallyAdjustsScrollIndicatorInsets
            contentInsetAdjustmentBehavior="automatic"
            data={getFilteredWalletsData()}
            containerStyle={[{ backgroundColor: colors.background }, styles.root]}
            keyExtractor={keyExtractor}
            onReordered={onReordered}
            renderItem={renderItem}
            ref={listRef}
            extraData={debouncedSearchQuery}
          />
        )}
      </GestureHandlerRootView>
    </Suspense>
  );
};

export default React.memo(ManageWallets);

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  button: {
    padding: 16,
  },
  noResultsText: {
    textAlign: 'center',
    justifyContent: 'center',
    marginTop: 34,
    fontWeight: 'bold',
    fontSize: 19,
  },
  noResultsContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
});


================================================
FILE: ./screen/lnd/lnurlAuth.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useLocale, useNavigation, useRoute } from '@react-navigation/native';
import React, { useCallback, useMemo, useState } from 'react';
import { ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { Icon } from '@rneui/themed';
import URL from 'url';
import { MalinCard, MalinText } from '../../MalinComponents';
import Lnurl from '../../class/lnurl';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import selectWallet from '../../helpers/select-wallet';
import loc from '../../loc';
import { Chain } from '../../models/bitcoinUnits';
import { SuccessView } from '../send/success';
import { useStorage } from '../../hooks/context/useStorage';
import { MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';

const AuthState = {
  USER_PROMPT: 0,
  IN_PROGRESS: 1,
  SUCCESS: 2,
  ERROR: 3,
};

const LnurlAuth = () => {
  const { wallets } = useStorage();
  const { name } = useRoute();
  const { direction } = useLocale();
  const { walletID, lnurl } = useRoute().params;
  const wallet = useMemo(() => wallets.find(w => w.getID() === walletID), [wallets, walletID]);
  const LN = useMemo(() => new Lnurl(lnurl), [lnurl]);
  const parsedLnurl = useMemo(
    () => (lnurl ? URL.parse(Lnurl.getUrlFromLnurl(lnurl), true) : {}), // eslint-disable-line n/no-deprecated-api
    [lnurl],
  );
  const [authState, setAuthState] = useState(AuthState.USER_PROMPT);
  const [errMsg, setErrMsg] = useState('');
  const navigation = useExtendedNavigation();
  const { setParams } = useNavigation();
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.background,
    },
    walletWrapLabel: {
      color: colors.buttonAlternativeTextColor,
    },
  });

  const showSelectWalletScreen = useCallback(() => {
    selectWallet(navigation, name, Chain.OFFCHAIN).then(w => setParams({ walletID: w.getID() }));
  }, [navigation, name, setParams]);

  const authenticate = useCallback(() => {
    wallet
      .authenticate(LN)
      .then(() => {
        setAuthState(AuthState.SUCCESS);
        setErrMsg('');
      })
      .catch(err => {
        setAuthState(AuthState.ERROR);
        setErrMsg(err);
      });
  }, [wallet, LN]);

  if (!parsedLnurl || !wallet || authState === AuthState.IN_PROGRESS)
    return (
      <View style={[styles.root, stylesHook.root]}>
        <MalinLoading />
      </View>
    );

  const renderWalletSelectionButton = authState === AuthState.USER_PROMPT && (
    <View style={styles.walletSelectRoot}>
      {authState !== AuthState.IN_PROGRESS && (
        <TouchableOpacity accessibilityRole="button" style={styles.walletSelectTouch} onPress={showSelectWalletScreen}>
          <Text style={styles.walletSelectText}>{loc.wallets.select_wallet.toLowerCase()}</Text>
          <Icon name={direction === 'rlt' ? 'angle-left' : 'angle-right'} size={18} type="font-awesome" color="#9aa0aa" />
        </TouchableOpacity>
      )}
      <View style={styles.walletWrap}>
        <TouchableOpacity accessibilityRole="button" style={styles.walletWrapTouch} onPress={showSelectWalletScreen}>
          <Text style={[styles.walletWrapLabel, stylesHook.walletWrapLabel]}>{wallet.getLabel()}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );

  return (
    <SafeArea style={styles.root}>
      {authState === AuthState.USER_PROMPT && (
        <>
          <ScrollView>
            <MalinCard>
              <MalinText style={styles.alignSelfCenter}>{loc.lnurl_auth[`${parsedLnurl.query.action || 'auth'}_question_part_1`]}</MalinText>
              <MalinText style={styles.domainName}>{parsedLnurl.hostname}</MalinText>
              <MalinText style={styles.alignSelfCenter}>{loc.lnurl_auth[`${parsedLnurl.query.action || 'auth'}_question_part_2`]}</MalinText>
              <MalinSpacing40 />
              <Button title={loc.lnurl_auth.authenticate} onPress={authenticate} />
              <MalinSpacing40 />
            </MalinCard>
          </ScrollView>
          {renderWalletSelectionButton}
        </>
      )}

      {authState === AuthState.SUCCESS && (
        <>
          <SuccessView />
          <MalinSpacing20 />
          <MalinText style={styles.alignSelfCenter}>
            {loc.formatString(loc.lnurl_auth[`${parsedLnurl.query.action || 'auth'}_answer`], { hostname: parsedLnurl.hostname })}
          </MalinText>
          <MalinSpacing20 />
        </>
      )}

      {authState === AuthState.ERROR && (
        <MalinCard>
          <MalinSpacing20 />
          <MalinText style={styles.alignSelfCenter}>
            {loc.formatString(loc.lnurl_auth.could_not_auth, { hostname: parsedLnurl.hostname })}
          </MalinText>
          <MalinText style={styles.alignSelfCenter}>{errMsg}</MalinText>
          <MalinSpacing20 />
        </MalinCard>
      )}
    </SafeArea>
  );
};

export default LnurlAuth;

const styles = StyleSheet.create({
  alignSelfCenter: {
    alignSelf: 'center',
  },
  domainName: {
    alignSelf: 'center',
    fontWeight: 'bold',
    fontSize: 25,
    paddingVertical: 10,
  },
  root: {
    flex: 1,
    justifyContent: 'center',
  },
  walletSelectRoot: {
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  walletSelectTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletSelectText: {
    color: '#9aa0aa',
    fontSize: 14,
    marginRight: 8,
  },
  walletWrap: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  walletWrapTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletWrapLabel: {
    fontSize: 14,
  },
});


================================================
FILE: ./screen/lnd/lnurlPay.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import { RouteProp, useLocale, useRoute } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { Image, ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { Icon } from '@rneui/themed';
import { btcToSatoshi, fiatToBTC, satoshiToBTC, satoshiToLocalCurrency } from '../../malin_modules/currency';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import Lnurl from '../../class/lnurl';
import presentAlert from '../../components/Alert';
import * as AmountInput from '../../components/AmountInput';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import prompt from '../../helpers/prompt';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import loc, { formatBalance, formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { DismissKeyboardInputAccessory, DismissKeyboardInputAccessoryViewID } from '../../components/DismissKeyboardInputAccessory';
import { LightningCustodianWallet } from '../../class/wallets/lightning-custodian-wallet';
import { TWallet } from '../../class/wallets/types';
import { pop } from '../../NavigationService';
import { MalinSpacing20 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';

type RouteParams = {
  walletID: string;
  lnurl: string;
};

const _cacheFiatToSat: Record<string, string> = {};

const LnurlPay: React.FC = () => {
  const { wallets } = useStorage();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const route = useRoute<RouteProp<Record<string, RouteParams>, string>>();
  const { walletID, lnurl } = route.params;
  const wallet = wallets.find(w => w.getID() === walletID) as LightningCustodianWallet;
  const [unit, setUnit] = useState<BitcoinUnit>(wallet?.getPreferredBalanceUnit() ?? BitcoinUnit.BTC);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [_LN, setLN] = useState<Lnurl | undefined>();
  const [payButtonDisabled, setPayButtonDisabled] = useState<boolean>(true);
  const [payload, setPayload] = useState<any>();
  const { setParams, navigate } = useExtendedNavigation();
  const [amount, setAmount] = useState<string | undefined>();
  const { colors } = useTheme();
  const { direction } = useLocale();
  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.background,
    },
    walletWrapLabel: {
      color: colors.buttonAlternativeTextColor,
    },
    walletWrapBalance: {
      color: colors.buttonAlternativeTextColor,
    },
    walletWrapSats: {
      color: colors.buttonAlternativeTextColor,
    },
  });

  useEffect(() => {
    if (lnurl) {
      const ln = new Lnurl(lnurl, AsyncStorage);
      ln.callLnurlPayService()
        .then(setPayload)
        .catch(error => {
          presentAlert({ message: error.message });
          pop();
        });
      setLN(ln);
      setIsLoading(false);
    }
  }, [lnurl]);

  useEffect(() => {
    setPayButtonDisabled(isLoading);
  }, [isLoading]);

  useEffect(() => {
    if (payload && _LN) {
      let originalSatAmount: number | false;
      let newAmount: number | boolean | string = (originalSatAmount = _LN.getMin());
      if (!newAmount) {
        presentAlert({ message: 'Internal error: incorrect LNURL amount' });
        return;
      }
      switch (unit) {
        case BitcoinUnit.BTC:
          newAmount = satoshiToBTC(newAmount);
          break;
        case BitcoinUnit.LOCAL_CURRENCY:
          newAmount = satoshiToLocalCurrency(newAmount, false);
          _cacheFiatToSat[newAmount] = String(originalSatAmount);
          break;
      }
      setAmount(newAmount.toString());
    }
  }, [payload, _LN, unit]);

  const onWalletSelect = (w: TWallet) => {
    setParams({ walletID: w.getID() });
    pop();
  };

  const pay = async () => {
    setPayButtonDisabled(true);
    if (!_LN || !amount) return;

    const isBiometricsEnabled = await isBiometricUseCapableAndEnabled();
    if (isBiometricsEnabled) {
      if (!(await unlockWithBiometrics())) {
        return;
      }
    }

    let amountSats: number | false;
    switch (unit) {
      case BitcoinUnit.SATS:
        amountSats = parseInt(amount, 10);
        break;
      case BitcoinUnit.BTC:
        amountSats = btcToSatoshi(amount);
        break;
      case BitcoinUnit.LOCAL_CURRENCY:
        if (_cacheFiatToSat[String(amount)]) {
          amountSats = parseInt(_cacheFiatToSat[amount], 10);
        } else {
          amountSats = btcToSatoshi(fiatToBTC(parseFloat(amount)));
        }
        break;
      default:
        throw new Error('Unknown unit type');
    }

    try {
      let comment: string | undefined;
      if (_LN.getCommentAllowed()) {
        comment = await prompt('Comment', '', false, 'plain-text');
      }

      const bolt11payload = await _LN.requestBolt11FromLnurlPayService(amountSats, comment);
      await wallet.payInvoice(bolt11payload.pr);
      const decoded = wallet.decodeInvoice(bolt11payload.pr);
      setPayButtonDisabled(false);

      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      if (wallet.last_paid_invoice_result && wallet.last_paid_invoice_result.payment_preimage) {
        await _LN.storeSuccess(decoded.payment_hash, wallet.last_paid_invoice_result.payment_preimage);
      }

      navigate('ScanLNDInvoiceRoot', {
        screen: 'LnurlPaySuccess',
        params: {
          paymentHash: decoded.payment_hash,
          justPaid: true,
          fromWalletID: walletID,
        },
      });
      setIsLoading(false);
    } catch (err) {
      console.log((err as Error).message);
      setIsLoading(false);
      setPayButtonDisabled(false);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      return presentAlert({ message: (err as Error).message });
    }
  };

  const renderWalletSelectionButton = (
    <View style={styles.walletSelectRoot}>
      {!isLoading && (
        <TouchableOpacity
          accessibilityRole="button"
          style={styles.walletSelectTouch}
          onPress={() => navigate('SelectWallet', { onWalletSelect, chainType: Chain.OFFCHAIN })}
        >
          <Text style={styles.walletSelectText}>{loc.wallets.select_wallet.toLowerCase()}</Text>
          <Icon name={direction === 'rtl' ? 'angle-left' : 'angle-right'} size={18} type="font-awesome" color="#9aa0aa" />
        </TouchableOpacity>
      )}
      <View style={styles.walletWrap}>
        <TouchableOpacity
          accessibilityRole="button"
          style={styles.walletWrapTouch}
          onPress={() => navigate('SelectWallet', { onWalletSelect, chainType: Chain.OFFCHAIN })}
        >
          <Text style={[styles.walletWrapLabel, stylesHook.walletWrapLabel]}>{wallet.getLabel()}</Text>
          <Text style={[styles.walletWrapBalance, stylesHook.walletWrapBalance]}>
            {formatBalanceWithoutSuffix(wallet.getBalance(), BitcoinUnit.SATS, false)}
          </Text>
          <Text style={[styles.walletWrapSats, stylesHook.walletWrapSats]}>{BitcoinUnit.SATS}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );

  const renderGotPayload = () => {
    return (
      <SafeArea>
        <ScrollView contentContainerStyle={styles.scrollviewContainer}>
          <MalinCard>
            <AmountInput.AmountInput
              isLoading={isLoading}
              amount={amount}
              onAmountUnitChange={setUnit}
              onChangeText={setAmount}
              disabled={payload?.fixed}
              unit={unit}
              inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
            />
            <DismissKeyboardInputAccessory />
            <MalinText style={styles.alignSelfCenter}>
              {loc.formatString(loc.lndViewInvoice.please_pay_between_and, {
                min: formatBalance(payload?.min, unit),
                max: formatBalance(payload?.max, unit),
              })}
            </MalinText>
            <MalinSpacing20 />
            {payload?.image && (
              <>
                <Image style={styles.img} source={{ uri: payload?.image }} />
                <MalinSpacing20 />
              </>
            )}
            <MalinText style={styles.alignSelfCenter}>{payload?.description}</MalinText>
            <MalinText style={styles.alignSelfCenter}>{payload?.domain}</MalinText>
            <MalinSpacing20 />
            {payButtonDisabled ? <MalinLoading /> : <Button title={loc.lnd.payButton} onPress={pay} />}
            <MalinSpacing20 />
          </MalinCard>
        </ScrollView>
        {renderWalletSelectionButton}
      </SafeArea>
    );
  };

  return isLoading || !wallet || amount === undefined ? (
    <View style={[styles.root, stylesHook.root]}>
      <MalinLoading />
    </View>
  ) : (
    renderGotPayload()
  );
};

export default LnurlPay;

const styles = StyleSheet.create({
  scrollviewContainer: { justifyContent: 'space-around' },
  img: { width: 200, height: 200, alignSelf: 'center' },
  alignSelfCenter: {
    alignSelf: 'center',
  },
  root: {
    flex: 1,
    justifyContent: 'center',
  },
  walletSelectRoot: {
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  walletSelectTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletSelectText: {
    color: '#9aa0aa',
    fontSize: 14,
    marginRight: 8,
  },
  walletWrap: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  walletWrapTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletWrapLabel: {
    fontSize: 14,
  },
  walletWrapBalance: {
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 4,
    marginRight: 4,
  },
  walletWrapSats: {
    fontSize: 11,
    fontWeight: '600',
    textAlignVertical: 'bottom',
    marginTop: 2,
  },
});


================================================
FILE: ./screen/lnd/ScanLNDInvoice.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useState } from 'react';
import { RouteProp, useFocusEffect, useRoute, useLocale } from '@react-navigation/native';
import { ActivityIndicator, Keyboard, ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { Icon } from '@rneui/themed';

import { btcToSatoshi, fiatToBTC } from '../../malin_modules/currency';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinCard } from '../../MalinComponents';
import Lnurl from '../../class/lnurl';
import AddressInput from '../../components/AddressInput';
import presentAlert from '../../components/Alert';
import * as AmountInput from '../../components/AmountInput';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import { useBiometrics, unlockWithBiometrics } from '../../hooks/useBiometrics';
import loc, { formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import { DismissKeyboardInputAccessory, DismissKeyboardInputAccessoryViewID } from '../../components/DismissKeyboardInputAccessory';
import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { LNDStackParamsList } from '../../navigation/LNDStackParamsList';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { LightningCustodianWallet } from '../../class/wallets/lightning-custodian-wallet';
import { DecodedInvoice, TWallet } from '../../class/wallets/types';
import { useKeyboard } from '../../hooks/useKeyboard';
import { MalinLoading } from '../../components/MalinLoading';

type RouteProps = RouteProp<LNDStackParamsList, 'ScanLNDInvoice'>;
type NavigationProps = NativeStackNavigationProp<LNDStackParamsList, 'ScanLNDInvoice'>;

const ScanLNDInvoice = () => {
  const { wallets, fetchAndSaveWalletTransactions } = useStorage();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const { colors } = useTheme();
  const { direction } = useLocale();
  const route = useRoute<RouteProps>();
  const { walletID, uri, invoice } = route.params || {};
  const [wallet, setWallet] = useState<LightningCustodianWallet | undefined>(
    (wallets.find(item => item.getID() === walletID) as LightningCustodianWallet) ||
      (wallets.find(item => item.chain === Chain.OFFCHAIN) as LightningCustodianWallet),
  );
  const { navigate, setParams, goBack, pop } = useExtendedNavigation<NavigationProps>();
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [renderWalletSelectionButtonHidden, setRenderWalletSelectionButtonHidden] = useState<boolean>(false);
  const [destination, setDestination] = useState<string>('');
  const [unit, setUnit] = useState<BitcoinUnit>(BitcoinUnit.SATS);
  const [decoded, setDecoded] = useState<DecodedInvoice | undefined>();
  const [amount, setAmount] = useState<string | undefined>();
  const [isAmountInitiallyEmpty, setIsAmountInitiallyEmpty] = useState<boolean | undefined>();
  const [expiresIn, setExpiresIn] = useState<string | undefined>();
  const stylesHook = StyleSheet.create({
    walletWrapLabel: {
      color: colors.buttonAlternativeTextColor,
    },
    walletWrapBalance: {
      color: colors.buttonAlternativeTextColor,
    },
    walletWrapSats: {
      color: colors.buttonAlternativeTextColor,
    },
    root: {
      backgroundColor: colors.elevated,
    },
    expiresIn: {
      writingDirection: direction,
      color: '#81868e',
      fontSize: 12,
      left: 20,
      top: 10,
    },
  });

  useEffect(() => {
    if (walletID && wallet?.getID() !== walletID) {
      const newWallet = wallets.find(w => w.getID() === walletID) as LightningCustodianWallet;
      if (newWallet) {
        setWallet(newWallet);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [walletID]);

  useFocusEffect(
    useCallback(() => {
      if (!wallet) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        goBack();
        setTimeout(
          () => presentAlert({ message: loc.wallets.no_ln_wallet_error, hapticFeedback: HapticFeedbackTypes.NotificationError }),
          500,
        );
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [wallet]),
  );

  useEffect(() => {
    if (wallet && uri) {
      if (Lnurl.isLnurl(uri)) return processLnurlPay(uri);
      if (Lnurl.isLightningAddress(uri)) return processLnurlPay(uri);

      let data = uri;
      // handling BIP21 w/BOLT11 support
      const ind = data.indexOf('lightning=');
      if (ind !== -1) {
        data = data.substring(ind + 10).split('&')[0];
      }

      data = data.replace('LIGHTNING:', '').replace('lightning:', '');
      console.log(data);

      let newDecoded: DecodedInvoice;
      try {
        newDecoded = wallet.decodeInvoice(data);

        const expiryTimeMs = (newDecoded.timestamp * 1 + newDecoded.expiry * 1) * 1000; // ms
        let newExpiresIn: string;

        if (+new Date() > expiryTimeMs) {
          newExpiresIn = loc.lnd.expired;
        } else {
          const time = Math.round((expiryTimeMs - +new Date()) / (60 * 1000));
          newExpiresIn = loc.formatString(loc.lnd.expiresIn, { time });
        }

        Keyboard.dismiss();
        setParams({ uri: undefined, invoice: data });
        setIsAmountInitiallyEmpty(newDecoded.num_satoshis === 0);
        setDestination(data);
        setIsLoading(false);
        setAmount(newDecoded.num_satoshis.toString());
        setExpiresIn(newExpiresIn);
        setDecoded(newDecoded);
      } catch (Err: any) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        Keyboard.dismiss();
        setParams({ uri: undefined });
        setTimeout(() => presentAlert({ message: Err.message, hapticFeedback: HapticFeedbackTypes.NotificationError }), 10);
        setIsLoading(false);
        setAmount(undefined);
        setDestination('');
        setExpiresIn(undefined);
        setDecoded(undefined);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [uri]);

  const _keyboardDidShow = (): void => {
    setRenderWalletSelectionButtonHidden(true);
  };

  const _keyboardDidHide = (): void => {
    setRenderWalletSelectionButtonHidden(false);
  };

  useKeyboard({ onKeyboardDidShow: _keyboardDidShow, onKeyboardDidHide: _keyboardDidHide });

  const processInvoice = (data: string): void => {
    if (Lnurl.isLnurl(data)) return processLnurlPay(data);
    if (Lnurl.isLightningAddress(data)) return processLnurlPay(data);
    setParams({ uri: data });
  };

  const processLnurlPay = (data: string): void => {
    navigate('LnurlPay', {
      lnurl: data,
      walletID: walletID || wallet?.getID() || '',
    });
  };

  const pay = async () => {
    if (!decoded || !wallet || !amount || !invoice) {
      return null;
    }

    const isBiometricsEnabled = await isBiometricUseCapableAndEnabled();

    if (isBiometricsEnabled) {
      if (!(await unlockWithBiometrics())) {
        return;
      }
    }

    let amountSats: number = parseInt(amount, 10);
    switch (unit) {
      case BitcoinUnit.SATS:
        // amount is already in sats
        break;
      case BitcoinUnit.BTC:
        amountSats = btcToSatoshi(amount);
        break;
      case BitcoinUnit.LOCAL_CURRENCY:
        amountSats = btcToSatoshi(fiatToBTC(Number(amount)));
        break;
    }
    setIsLoading(true);

    const expiryTimeMs = (decoded.timestamp * 1 + decoded.expiry * 1) * 1000; // ms
    if (+new Date() > expiryTimeMs) {
      setIsLoading(false);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      return presentAlert({ message: loc.lnd.errorInvoiceExpired });
    }

    const currentUserInvoices = wallet.user_invoices_raw; // not fetching invoices, as we assume they were loaded previously
    if (currentUserInvoices.some(i => i.payment_hash === decoded.payment_hash)) {
      setIsLoading(false);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      return presentAlert({ message: loc.lnd.sameWalletAsInvoiceError });
    }

    try {
      await wallet.payInvoice(invoice, amountSats);
    } catch (Err: any) {
      console.log(Err.message);
      setIsLoading(false);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      return presentAlert({ message: Err.message });
    }

    navigate('Success', {
      amount: amountSats,
      amountUnit: BitcoinUnit.SATS,
      invoiceDescription: decoded.description,
    });
    fetchAndSaveWalletTransactions(wallet.getID());
  };

  const processTextForInvoice = (text: string): void => {
    if (
      (text && text.toLowerCase().startsWith('lnb')) ||
      text.toLowerCase().startsWith('lightning:lnb') ||
      Lnurl.isLnurl(text) ||
      Lnurl.isLightningAddress(text)
    ) {
      processInvoice(text);
    } else {
      setDecoded(undefined);
      setExpiresIn(undefined);
      setDestination(text);
    }
  };

  const shouldDisablePayButton = (): boolean => {
    if (!decoded) {
      return true;
    } else {
      if (!amount) {
        return true;
      }
    }
    return !(parseInt(amount, 10) > 0);
  };

  const naviageToSelectWallet = (): void => {
    navigate('SelectWallet', { onWalletSelect, chainType: Chain.OFFCHAIN });
  };

  const renderWalletSelectionButton = (): JSX.Element | undefined => {
    if (renderWalletSelectionButtonHidden || !wallet) return;
    const walletLabel = wallet.getLabel();
    return (
      <View style={styles.walletSelectRoot}>
        {!isLoading && (
          <TouchableOpacity accessibilityRole="button" style={styles.walletSelectTouch} onPress={naviageToSelectWallet}>
            <Text style={styles.walletSelectText}>{loc.wallets.select_wallet.toLowerCase()}</Text>
            <Icon name={direction === 'rtl' ? 'angle-left' : 'angle-right'} size={18} type="font-awesome" color="#9aa0aa" />
          </TouchableOpacity>
        )}
        <View style={styles.walletWrap}>
          <TouchableOpacity accessibilityRole="button" disabled={isLoading} style={styles.walletWrapTouch} onPress={naviageToSelectWallet}>
            <Text style={[styles.walletWrapLabel, stylesHook.walletWrapLabel]}>{walletLabel}</Text>
            <Text style={[styles.walletWrapBalance, stylesHook.walletWrapBalance]}>
              {formatBalanceWithoutSuffix(wallet.getBalance(), BitcoinUnit.SATS, false)}
            </Text>
            <Text style={[styles.walletWrapSats, stylesHook.walletWrapSats]}>{BitcoinUnit.SATS}</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  const getFees = (): string => {
    if (!decoded) return '';
    const num_satoshis = parseInt(decoded.num_satoshis.toString(), 10);
    const min = Math.floor(num_satoshis * 0.003);
    const max = Math.floor(num_satoshis * 0.01) + 1;
    return `${min} ${BitcoinUnit.SATS} - ${max} ${BitcoinUnit.SATS}`;
  };

  const onBlur = (): void => {
    processTextForInvoice(destination);
  };

  const onWalletSelect = (selectedWallet: TWallet): void => {
    setParams({ walletID: selectedWallet.getID() });
    pop();
  };

  const onBarScanned = useCallback(
    (value: string): void => {
      if (!value) return;
      DeeplinkSchemaMatch.navigationRouteFor({ url: value }, (completionValue: any) => {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        navigate(...completionValue);
      });
    },
    [navigate],
  );

  useEffect(() => {
    const data = route.params?.onBarScanned;
    if (data) {
      onBarScanned(data);
      setParams({ onBarScanned: undefined });
    }
  }, [navigate, onBarScanned, route.params?.onBarScanned, setParams]);

  const onChangeText = (text: string): void => {
    const trimmedText = text.trim();
    setDestination(trimmedText);
    processTextForInvoice(trimmedText);
  };

  if (wallet === undefined || !wallet) {
    return (
      <View style={[styles.loadingIndicator, stylesHook.root]}>
        <MalinLoading />
      </View>
    );
  }

  return (
    <SafeArea style={stylesHook.root}>
      <View style={[styles.root, stylesHook.root]}>
        <ScrollView
          contentContainerStyle={styles.scroll}
          keyboardShouldPersistTaps="handled"
          automaticallyAdjustContentInsets
          automaticallyAdjustKeyboardInsets
          contentInsetAdjustmentBehavior="automatic"
        >
          <View style={styles.scrollMargin}>
            <AmountInput.AmountInput
              isLoading={isLoading}
              amount={amount}
              onAmountUnitChange={setUnit}
              onChangeText={setAmount}
              disabled={!isAmountInitiallyEmpty || !decoded || isLoading || decoded.num_satoshis > 0}
              unit={unit}
              inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
            />
          </View>

          <MalinCard>
            <AddressInput
              onChangeText={onChangeText}
              address={destination}
              isLoading={isLoading}
              placeholder={loc.lnd.placeholder}
              inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
              onBlur={onBlur}
              keyboardType="email-address"
              style={styles.addressInput}
            />
            <View style={styles.description}>
              <Text numberOfLines={0} style={styles.descriptionText}>
                {decoded !== undefined ? decoded.description : ''}
              </Text>
            </View>
            {expiresIn !== undefined && (
              <View>
                <Text style={stylesHook.expiresIn}>{expiresIn}</Text>
                {decoded && decoded.num_satoshis > 0 && (
                  <Text style={stylesHook.expiresIn}>{loc.formatString(loc.lnd.potentialFee, { fee: getFees() })}</Text>
                )}
              </View>
            )}
            <MalinCard>
              {isLoading ? (
                <View>
                  <ActivityIndicator />
                </View>
              ) : (
                <View>
                  <Button title={loc.lnd.payButton} onPress={pay} disabled={shouldDisablePayButton()} />
                </View>
              )}
            </MalinCard>
          </MalinCard>

          {renderWalletSelectionButton()}
        </ScrollView>
      </View>
      <DismissKeyboardInputAccessory />
    </SafeArea>
  );
};

export default ScanLNDInvoice;

const styles = StyleSheet.create({
  walletSelectRoot: {
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  loadingIndicator: {
    flex: 1,
    justifyContent: 'center',
  },
  walletSelectTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletSelectText: {
    color: '#9aa0aa',
    fontSize: 14,
    marginRight: 8,
  },
  walletWrap: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  walletWrapTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletWrapLabel: {
    fontSize: 14,
  },
  walletWrapBalance: {
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 4,
    marginRight: 4,
  },
  walletWrapSats: {
    fontSize: 11,
    fontWeight: '600',
    textAlignVertical: 'bottom',
    marginTop: 2,
  },
  root: {
    flex: 1,
  },
  scroll: {
    flex: 1,
    justifyContent: 'space-between',
  },
  scrollMargin: {
    marginTop: 60,
  },
  description: {
    flexDirection: 'row',
    marginHorizontal: 16,
    alignItems: 'center',
    marginVertical: 0,
    borderRadius: 4,
  },
  descriptionText: {
    color: '#81868e',
    fontWeight: '500',
    fontSize: 14,
  },
  addressInput: {
    marginHorizontal: 16,
  },
});


================================================
FILE: ./screen/lnd/lndViewAdditionalInvoicePreImage.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useRoute } from '@react-navigation/native';
import React from 'react';
import { StyleSheet, View } from 'react-native';

import { MalinTextCentered } from '../../MalinComponents';
import CopyTextToClipboard from '../../components/CopyTextToClipboard';
import QRCodeComponent from '../../components/QRCodeComponent';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const LNDViewAdditionalInvoicePreImage = () => {
  // state = { walletInfo: undefined };
  const { colors } = useTheme();
  const { preImageData } = useRoute().params;
  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
  });

  return (
    <SafeArea style={stylesHook.root}>
      <View style={styles.wrapper}>
        <MalinTextCentered>{loc.lndViewInvoice.preimage}:</MalinTextCentered>
        <MalinSpacing20 />
        <View style={styles.qrCodeContainer}>
          <QRCodeComponent value={preImageData} size={300} logoSize={90} />
        </View>
        <MalinSpacing20 />
        <CopyTextToClipboard text={preImageData} />
      </View>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  wrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  qrCodeContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 16,
  },
});

export default LNDViewAdditionalInvoicePreImage;


================================================
FILE: ./screen/lnd/lnurlPaySuccess.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Image, Linking, ScrollView, StyleSheet, View } from 'react-native';
import { MalinButtonLink, MalinCard, MalinText } from '../../MalinComponents';
import Lnurl from '../../class/lnurl';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import loc from '../../loc';
import { SuccessView } from '../send/success';
import { popToTop } from '../../NavigationService';
import { useRoute, RouteProp } from '@react-navigation/native';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation.ts';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading.tsx';

type LnurlPaySuccessRouteProp = RouteProp<DetailViewStackParamList, 'LnurlPaySuccess'>;
type LnurlPaySuccessNavigationProp = NativeStackNavigationProp<DetailViewStackParamList, 'LnurlPaySuccess'>;

const LnurlPaySuccess: React.FC = () => {
  const route = useRoute<LnurlPaySuccessRouteProp>();
  const { navigate } = useExtendedNavigation<LnurlPaySuccessNavigationProp>();
  const { paymentHash, fromWalletID, justPaid } = route.params;
  console.log({ paymentHash, fromWalletID, justPaid });

  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [LN, setLN] = useState<Lnurl | null>(null);
  const [preamble, setPreamble] = useState<string>('');
  const [message, setMessage] = useState<string>('');
  const [url, setUrl] = useState<string>('');

  useEffect(() => {
    const loadSuccessfulPayment = async () => {
      const lnurl = new Lnurl(false, AsyncStorage);
      await lnurl.loadSuccessfulPayment(paymentHash);

      const successAction = lnurl.getSuccessAction();
      if (!successAction) {
        setIsLoading(false);
        setLN(lnurl);
        return;
      }

      switch (successAction.tag) {
        case 'aes': {
          const preimage = lnurl.getPreimage();
          if (!preimage) {
            break;
          }
          setMessage(Lnurl.decipherAES(successAction.ciphertext, preimage, successAction.iv));
          setPreamble(successAction.description);
          break;
        }
        case 'url':
          setUrl(successAction.url);
          setPreamble(successAction.description);
          break;
        case 'message':
          setMessage(successAction.message);
          break;
      }

      setIsLoading(false);
      setLN(lnurl);
    };

    loadSuccessfulPayment();
  }, [paymentHash]);

  if (isLoading || !LN) {
    return <MalinLoading />;
  }

  const domain = LN.getDomain();
  const repeatable = !LN.getDisposable();
  const lnurl = LN.getLnurl();
  const description = LN.getDescription();
  const image = LN.getImage();

  return (
    <SafeArea style={styles.root}>
      <ScrollView style={styles.container}>
        {justPaid && <SuccessView />}

        <MalinSpacing40 />
        <MalinText style={styles.alignSelfCenter}>{domain}</MalinText>
        <MalinText style={[styles.alignSelfCenter, styles.description]}>{description}</MalinText>
        {image && <Image style={styles.img} source={{ uri: image }} />}
        <MalinSpacing20 />

        {(preamble || url || message) && (
          <MalinCard>
            <View style={styles.successContainer}>
              <MalinText style={styles.successText}>{preamble}</MalinText>
              {url ? (
                <MalinButtonLink
                  title={url}
                  onPress={() => {
                    Linking.openURL(url);
                  }}
                />
              ) : (
                <MalinText selectable>{message}</MalinText>
              )}
            </View>
          </MalinCard>
        )}

        <MalinCard>
          {repeatable ? (
            <Button
              onPress={() => {
                navigate('ScanLNDInvoiceRoot', {
                  screen: 'LnurlPay',
                  params: {
                    // @ts-ignore  fixme
                    lnurl,
                    walletID: fromWalletID,
                  },
                });
              }}
              title="repeat" // TODO: translate this
              icon={{ name: 'refresh', type: 'font-awesome', color: '#9aa0aa' }}
            />
          ) : (
            <Button
              onPress={() => {
                popToTop();
              }}
              title={loc.send.success_done}
            />
          )}
        </MalinCard>
      </ScrollView>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  img: { width: 200, height: 200, alignSelf: 'center' },
  alignSelfCenter: {
    alignSelf: 'center',
  },
  root: {
    padding: 0,
  },
  container: {
    paddingHorizontal: 16,
  },
  successContainer: {
    marginTop: 10,
  },
  successText: {
    textAlign: 'center',
    margin: 4,
  },
  description: {
    marginTop: 20,
  },
});

export default LnurlPaySuccess;


================================================
FILE: ./screen/lnd/lndViewInvoice.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useRef, useState } from 'react';
import { RouteProp, useNavigation, useNavigationState, useRoute, useLocale } from '@react-navigation/native';
import { BackHandler, Image, ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { Icon } from '@rneui/themed';
import Share from 'react-native-share';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinText, MalinTextCentered } from '../../MalinComponents';
import Button from '../../components/Button';
import CopyTextToClipboard from '../../components/CopyTextToClipboard';
import QRCodeComponent from '../../components/QRCodeComponent';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { SuccessView } from '../send/success';
import LNDCreateInvoice from './lndCreateInvoice';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import BigNumber from 'bignumber.js';
import { LightningTransaction } from '../../class/wallets/types';
import dayjs from 'dayjs';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';
import { LightningCustodianWallet } from '../../class';

type LNDViewInvoiceRouteParams = {
  walletID: string;
  invoice: LightningTransaction | string; // its first passed as string and then decoded and turned into object
};

const LNDViewInvoice = () => {
  const { invoice, walletID } = useRoute<RouteProp<{ params: LNDViewInvoiceRouteParams }, 'params'>>().params;
  const { wallets, fetchAndSaveWalletTransactions } = useStorage();
  const { colors, closeImage } = useTheme();
  const { direction } = useLocale();
  const { goBack, navigate, setParams, setOptions } = useExtendedNavigation();
  const navigation = useNavigation();

  const wallet = wallets.find(w => w.getID() === walletID) as LightningCustodianWallet | undefined;
  const [isFetchingInvoices, setIsFetchingInvoices] = useState<boolean>(true);
  const [invoiceStatusChanged, setInvoiceStatusChanged] = useState<boolean>(false);
  const [qrCodeSize, setQRCodeSize] = useState<number>(90);
  const fetchInvoiceInterval = useRef<any>();
  const isModal = useNavigationState(state => state.routeNames[0] === LNDCreateInvoice.routeName);

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.background,
    },
    detailsText: {
      color: colors.alternativeTextColor,
    },
    expired: {
      backgroundColor: colors.success,
    },
  });

  useEffect(() => {
    const subscription = BackHandler.addEventListener('hardwareBackPress', () => {
      goBack();
      return true;
    });

    return () => {
      subscription.remove();
      clearInterval(fetchInvoiceInterval.current);
      fetchInvoiceInterval.current = undefined;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    setOptions(
      isModal
        ? {
            headerStyle: {
              backgroundColor: colors.customHeader,
            },
            gestureEnabled: false,
            headerBackVisible: false,
            // eslint-disable-next-line react/no-unstable-nested-components
            headerRight: () => (
              <TouchableOpacity
                accessibilityRole="button"
                onPress={() => {
                  // @ts-ignore: navigation
                  navigation?.getParent().pop();
                }}
                testID="NavigationCloseButton"
              >
                <Image source={closeImage} />
              </TouchableOpacity>
            ),
          }
        : {
            headerRight: () => {},
            headerStyle: {
              backgroundColor: colors.customHeader,
            },
          },
    );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [colors, isModal]);

  useEffect(() => {
    console.log('LNDViewInvoice - useEffect', { invoice });

    if (!wallet) {
      return;
    }
    if (!(invoice as LightningTransaction).ispaid) {
      fetchInvoiceInterval.current = setInterval(async () => {
        if (isFetchingInvoices) {
          try {
            // @ts-ignore - getUserInvoices is not set on TWallet
            const userInvoices: LightningTransaction[] = await wallet.getUserInvoices(20);
            // fetching only last 20 invoices
            // for invoice that was created just now - that should be enough (it is basically the last one, so limit=1 would be sufficient)
            // but that might not work as intended IF user creates 21 invoices, and then tries to check the status of invoice #0, it just wont be updated
            const updatedUserInvoice = userInvoices.filter((filteredInvoice: LightningTransaction) =>
              typeof invoice === 'object'
                ? filteredInvoice.payment_request === invoice.payment_request
                : filteredInvoice.payment_request === invoice,
            )[0];
            if (updatedUserInvoice) {
              setInvoiceStatusChanged(true);
              setParams({ invoice: updatedUserInvoice });
              if (updatedUserInvoice.ispaid) {
                // we fetched the invoice, and it is paid :-)
                setIsFetchingInvoices(false);
                clearInterval(fetchInvoiceInterval.current);
                triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
                fetchAndSaveWalletTransactions(walletID);
              } else {
                const currentDate = new Date();
                const now = (currentDate.getTime() / 1000) | 0; // eslint-disable-line no-bitwise
                const invoiceExpiration = (updatedUserInvoice.timestamp ?? 0) + (updatedUserInvoice.expire_time ?? 0);
                if (invoiceExpiration < now && !updatedUserInvoice.ispaid) {
                  // invoice expired :-(
                  fetchAndSaveWalletTransactions(walletID);
                  setIsFetchingInvoices(false);
                  triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
                  clearInterval(fetchInvoiceInterval.current);
                  fetchInvoiceInterval.current = undefined;
                }
              }
            }
          } catch (error) {
            console.log(error);
          }
        }
      }, 3000);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const navigateToPreImageScreen = (preImageData: string) => {
    navigate('LNDViewAdditionalInvoicePreImage', { preImageData });
  };

  const handleOnSharePressed = () => {
    if (typeof invoice === 'string' || !invoice.payment_request) return;
    Share.open({ message: `lightning:${invoice.payment_request}` }).catch(error => console.log(error));
  };

  useEffect(() => {
    if (typeof invoice === 'string') return;
    if (invoice.ispaid && invoiceStatusChanged) {
      setInvoiceStatusChanged(true);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [invoice]);

  useEffect(() => {
    if (invoiceStatusChanged) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    }
  }, [invoiceStatusChanged]);

  const onLayout = (e: any) => {
    const { height, width } = e.nativeEvent.layout;
    setQRCodeSize(height > width ? width - 40 : e.nativeEvent.layout.width / 1.8);
  };

  const render = () => {
    if (typeof invoice === 'object') {
      const currentDate = new Date();
      const now = (currentDate.getTime() / 1000) | 0; // eslint-disable-line no-bitwise
      const invoiceExpiration = invoice?.timestamp && invoice?.expire_time ? invoice.timestamp + invoice.expire_time : undefined;
      if (invoice.ispaid || invoice.type === 'paid_invoice') {
        let amount = 0;
        let description;
        let invoiceDate;
        if (invoice.type === 'paid_invoice' && invoice?.value) {
          amount = invoice.value;
        } else if (invoice.type === 'user_invoice' && invoice.amt) {
          amount = invoice.amt;
        }
        if (invoice.description) {
          description = invoice.description;
        } else if (invoice.memo && invoice.memo.length > 0) {
          description = invoice.memo;
        }
        if (invoice.timestamp) {
          invoiceDate = dayjs(invoice.timestamp * (String(invoice.timestamp).length === 10 ? 1000 : 1)).format('LLL');
        }
        return (
          <View style={styles.root}>
            <SuccessView
              amount={amount}
              amountUnit={BitcoinUnit.SATS}
              invoiceDescription={description}
              fee={invoice.fee ? new BigNumber(invoice.fee).multipliedBy(-1).dividedBy(1e8).toNumber() : undefined}
              shouldAnimate={false}
            />
            <View style={styles.detailsRoot}>
              <Text style={[styles.detailsText, stylesHook.detailsText]}>
                {loc.lndViewInvoice.date_time}: {invoiceDate}
              </Text>
              {invoice.payment_preimage && typeof invoice.payment_preimage === 'string' ? (
                <TouchableOpacity
                  accessibilityRole="button"
                  style={styles.detailsTouch}
                  onPress={() => navigateToPreImageScreen(String(invoice.payment_preimage))}
                >
                  <Text style={[styles.detailsText, stylesHook.detailsText]}>{loc.send.create_details}</Text>
                  <Icon
                    name={direction === 'rtl' ? 'angle-left' : 'angle-right'}
                    size={18}
                    type="font-awesome"
                    color={colors.alternativeTextColor}
                  />
                </TouchableOpacity>
              ) : undefined}
            </View>
          </View>
        );
      }
      if (invoiceExpiration ? invoiceExpiration < now : undefined) {
        return (
          <View style={[styles.root, stylesHook.root, styles.justifyContentCenter]}>
            <View style={[styles.expired, stylesHook.expired]}>
              <Icon name="times" size={50} type="font-awesome" color={colors.successCheck} />
            </View>
            <MalinTextCentered>{loc.lndViewInvoice.wasnt_paid_and_expired}</MalinTextCentered>
          </View>
        );
      }
      // Invoice has not expired, nor has it been paid for.
      if (invoice.payment_request) {
        return (
          <ScrollView>
            <View style={[styles.activeRoot, stylesHook.root]}>
              <View style={styles.activeQrcode}>
                <QRCodeComponent value={invoice.payment_request} size={qrCodeSize} />
              </View>
              <MalinSpacing20 />
              <MalinText>
                {loc.lndViewInvoice.please_pay} {invoice.amt} {loc.lndViewInvoice.sats}
              </MalinText>
              {'description' in invoice && (invoice.description?.length ?? 0) > 0 && (
                <MalinText>
                  {loc.lndViewInvoice.for} {invoice.description ?? ''}
                </MalinText>
              )}
              <CopyTextToClipboard truncated text={invoice.payment_request} />
              <Button onPress={handleOnSharePressed} title={loc.receive.details_share} />
            </View>
          </ScrollView>
        );
      }
    } else if (invoice) {
      // `invoice` is string, just not decoded yet. lets just display it as a QR code first (till it gets decoded
      // and more data is rendered)
      return (
        <View style={[styles.activeRoot, stylesHook.root]}>
          <View style={styles.activeQrcode}>
            <QRCodeComponent value={invoice} size={qrCodeSize} />
          </View>
        </View>
      );
    } else {
      // something is not right
      return (
        <View style={[styles.root, stylesHook.root]}>
          <MalinTextCentered>Internal error: invoice is not provided</MalinTextCentered>
        </View>
      );
    }
  };

  return <SafeAreaScrollView onLayout={onLayout}>{render()}</SafeAreaScrollView>;
};

export default LNDViewInvoice;

const styles = StyleSheet.create({
  root: {
    flex: 1,
    justifyContent: 'space-between',
  },
  justifyContentCenter: {
    justifyContent: 'center',
  },
  detailsRoot: {
    justifyContent: 'flex-end',
    marginBottom: 24,
    alignItems: 'center',
  },
  detailsTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  detailsText: {
    fontSize: 14,
    marginRight: 8,
  },
  expired: {
    width: 120,
    height: 120,
    borderRadius: 60,
    alignSelf: 'center',
    justifyContent: 'center',
    marginBottom: 30,
  },
  activeRoot: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  activeQrcode: {
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 16,
  },
});


================================================
FILE: ./screen/lnd/lndCreateInvoice.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useFocusEffect, useLocale, useNavigation, useRoute, CommonActions } from '@react-navigation/native';
import { navigationRef } from '../../NavigationService';
import {
  ActivityIndicator,
  Image,
  Keyboard,
  Platform,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  TouchableWithoutFeedback,
  View,
} from 'react-native';
import { Icon } from '@rneui/themed';
import { parse } from 'url'; // eslint-disable-line n/no-deprecated-api
import { btcToSatoshi, fiatToBTC, satoshiToBTC } from '../../malin_modules/currency';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import Lnurl from '../../class/lnurl';
import presentAlert from '../../components/Alert';
import * as AmountInput from '../../components/AmountInput';
import Button from '../../components/Button';
import { useTheme } from '../../components/themes';
import { presentWalletExportReminder } from '../../helpers/presentWalletExportReminder';
import loc, { formatBalance, formatBalancePlain, formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import * as NavigationService from '../../NavigationService';
import { useStorage } from '../../hooks/context/useStorage';
import { DismissKeyboardInputAccessory, DismissKeyboardInputAccessoryViewID } from '../../components/DismissKeyboardInputAccessory';
import { majorTomToGroundControl, tryToObtainPermissions } from '../../malin_modules/notifications';
import { MalinLoading } from '../../components/MalinLoading';

const LNDCreateInvoice = () => {
  const { wallets, saveToDisk } = useStorage();
  const { walletID, uri } = useRoute().params;
  const wallet = useRef(wallets.find(item => item.getID() === walletID) || wallets.find(item => item.chain === Chain.OFFCHAIN));
  const { params } = useRoute();
  const { colors } = useTheme();
  const { navigate, getParent, goBack, pop, setParams } = useNavigation();
  const [unit, setUnit] = useState(wallet.current?.getPreferredBalanceUnit() || BitcoinUnit.BTC);
  const [amount, setAmount] = useState();
  const { direction } = useLocale();
  const [renderWalletSelectionButtonHidden, setRenderWalletSelectionButtonHidden] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [description, setDescription] = useState('');
  const [lnurlParams, setLNURLParams] = useState();

  const styleHooks = StyleSheet.create({
    scanRoot: {
      backgroundColor: colors.scanLabel,
    },
    scanClick: {
      color: colors.inverseForegroundColor,
    },
    walletNameText: {
      color: colors.buttonAlternativeTextColor,
    },
    walletNameBalance: {
      color: colors.buttonAlternativeTextColor,
    },
    walletNameSats: {
      color: colors.buttonAlternativeTextColor,
    },
    root: {
      backgroundColor: colors.elevated,
    },
    amount: {
      backgroundColor: colors.elevated,
    },
    fiat: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const processLnurl = useCallback(
    async data => {
      setIsLoading(true);
      if (!wallet.current) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: loc.wallets.no_ln_wallet_error });
        return goBack();
      }

      // decoding the lnurl
      const url = Lnurl.getUrlFromLnurl(data);
      const { query } = parse(url, true);

      if (query.tag === Lnurl.TAG_LOGIN_REQUEST) {
        // Close the modal first, then navigate to LnurlAuth in the drawer
        goBack();
        setTimeout(() => {
          navigationRef.dispatch(
            CommonActions.navigate({
              name: 'LnurlAuth',
              params: {
                lnurl: data,
                walletID: walletID ?? wallet.current.getID(),
              },
            }),
          );
        }, 100);
        return;
      }

      // calling the url
      try {
        const resp = await fetch(url, { method: 'GET' });
        if (resp.status >= 300) {
          throw new Error('Bad response from server');
        }
        const reply = await resp.json();
        if (reply.status === 'ERROR') {
          throw new Error('Reply from server: ' + reply.reason);
        }

        if (reply.tag === Lnurl.TAG_PAY_REQUEST) {
          // we are here by mistake. user wants to SEND to lnurl-pay, but he is on a screen that creates
          // invoices (including through lnurl-withdraw)
          navigate('ScanLNDInvoiceRoot', {
            screen: 'LnurlPay',
            params: {
              lnurl: data,
              walletID: walletID ?? wallet.current.getID(),
            },
          });
          return;
        }

        if (reply.tag !== Lnurl.TAG_WITHDRAW_REQUEST) {
          throw new Error('Unsupported lnurl');
        }

        // amount that comes from lnurl is always in sats
        let newAmount = (reply.maxWithdrawable / 1000).toString();
        const sats = newAmount;
        switch (unit) {
          case BitcoinUnit.SATS:
            // nop
            break;
          case BitcoinUnit.BTC:
            newAmount = satoshiToBTC(newAmount);
            break;
          case BitcoinUnit.LOCAL_CURRENCY:
            newAmount = formatBalancePlain(newAmount, BitcoinUnit.LOCAL_CURRENCY);
            AmountInput.setCachedSatoshis(newAmount, sats);
            break;
        }

        // setting the invoice creating screen with the parameters
        setLNURLParams({
          k1: reply.k1,
          callback: reply.callback,
          fixed: reply.minWithdrawable === reply.maxWithdrawable,
          min: (reply.minWithdrawable || 0) / 1000,
          max: reply.maxWithdrawable / 1000,
        });
        setAmount(newAmount);
        setDescription(reply.defaultDescription);
        setIsLoading(false);
      } catch (Err) {
        Keyboard.dismiss();
        setIsLoading(false);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: Err.message });
      }
    },
    [goBack, navigate, unit, walletID],
  );

  useEffect(() => {
    const data = params.onBarScanned;
    if (data) {
      processLnurl(data);
      setParams({ onBarScanned: undefined });
    }
  }, [params.onBarScanned, processLnurl, setParams]);

  useEffect(() => {
    const showSubscription = Keyboard.addListener(Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow', _keyboardDidShow);
    const hideSubscription = Keyboard.addListener(Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide', _keyboardDidHide);
    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, []);

  const renderReceiveDetails = async () => {
    try {
      wallet.current.setUserHasSavedExport(true);
      await saveToDisk();
      if (uri) {
        processLnurl(uri);
      }
    } catch (e) {
      console.log(e);
    }
    setIsLoading(false);
  };

  useFocusEffect(
    useCallback(() => {
      if (wallet.current) {
        if (wallet.current.getUserHasSavedExport()) {
          renderReceiveDetails();
        } else {
          presentWalletExportReminder()
            .then(() => {
              renderReceiveDetails();
            })
            .catch(() => {
              getParent().pop();
              NavigationService.navigate('WalletExport', {
                walletID: wallet.current.getID(),
              });
            });
        }
      } else {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: loc.wallets.add_ln_wallet_first });
        goBack();
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [wallet]),
  );

  const _keyboardDidShow = () => {
    setRenderWalletSelectionButtonHidden(true);
  };

  const _keyboardDidHide = () => {
    setRenderWalletSelectionButtonHidden(false);
  };

  const createInvoice = async () => {
    setIsLoading(true);
    try {
      let invoiceAmount = amount;
      switch (unit) {
        case BitcoinUnit.SATS:
          invoiceAmount = parseInt(invoiceAmount, 10); // basically nop
          break;
        case BitcoinUnit.BTC:
          invoiceAmount = btcToSatoshi(invoiceAmount);
          break;
        case BitcoinUnit.LOCAL_CURRENCY:
          // trying to fetch cached sat equivalent for this fiat amount
          invoiceAmount = AmountInput.getCachedSatoshis(invoiceAmount) || btcToSatoshi(fiatToBTC(invoiceAmount));
          break;
      }

      if (lnurlParams) {
        const { min, max } = lnurlParams;
        if (invoiceAmount < min || invoiceAmount > max) {
          let text;
          if (invoiceAmount < min) {
            text =
              unit === BitcoinUnit.SATS
                ? loc.formatString(loc.receive.minSats, { min })
                : loc.formatString(loc.receive.minSatsFull, { min, currency: formatBalance(min, unit) });
          } else {
            text =
              unit === BitcoinUnit.SATS
                ? loc.formatString(loc.receive.maxSats, { max })
                : loc.formatString(loc.receive.maxSatsFull, { max, currency: formatBalance(max, unit) });
          }
          triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
          presentAlert({ message: text });
          setIsLoading(false);
          return;
        }
      }

      const invoiceRequest = await wallet.current.addInvoice(invoiceAmount, description);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);

      // lets decode payreq and subscribe groundcontrol so we can receive push notification when our invoice is paid
      /** @type LightningCustodianWallet */
      const decoded = await wallet.current.decodeInvoice(invoiceRequest);
      tryToObtainPermissions()
        .then(res => majorTomToGroundControl([], [decoded.payment_hash], []))
        .catch(err => console.error(err.message));

      // send to lnurl-withdraw callback url if that exists
      if (lnurlParams) {
        const { callback, k1 } = lnurlParams;
        const callbackUrl = callback + (callback.indexOf('?') !== -1 ? '&' : '?') + 'k1=' + k1 + '&pr=' + invoiceRequest;

        const resp = await fetch(callbackUrl, { method: 'GET' });
        if (resp.status >= 300) {
          const text = await resp.text();
          throw new Error(text);
        }
        const reply = await resp.json();

        if (reply.status === 'ERROR') {
          throw new Error('Reply from server: ' + reply.reason);
        }
      }

      setTimeout(async () => {
        // wallet object doesnt have this fresh invoice in its internals, so we refetch it and only then save
        await wallet.current.fetchUserInvoices(1);
        await saveToDisk();
      }, 1000);

      navigate('LNDViewInvoice', {
        invoice: invoiceRequest,
        walletID: wallet.current.getID(),
      });
    } catch (Err) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      setIsLoading(false);
      presentAlert({ message: Err.message });
    }
  };

  const renderCreateButton = () => {
    return (
      <View style={styles.createButton}>
        {isLoading ? <ActivityIndicator /> : <Button disabled={!(amount > 0)} onPress={createInvoice} title={loc.send.details_create} />}
      </View>
    );
  };

  const navigateToScanQRCode = () => {
    navigate('ScanQRCode', {
      showFileImportButton: true,
    });
    Keyboard.dismiss();
  };

  const renderScanClickable = () => {
    return (
      <TouchableOpacity
        disabled={isLoading}
        onPress={navigateToScanQRCode}
        style={[styles.scanRoot, styleHooks.scanRoot]}
        accessibilityRole="button"
        accessibilityLabel={loc.send.details_scan}
        accessibilityHint={loc.send.details_scan_hint}
      >
        <Image style={{}} source={require('../../img/scan-white.png')} />
        <Text style={[styles.scanClick, styleHooks.scanClick]}>{loc.send.details_scan}</Text>
      </TouchableOpacity>
    );
  };

  const navigateToSelectWallet = () => {
    navigate('SelectWallet', { onWalletSelect, chainType: Chain.OFFCHAIN });
  };

  const renderWalletSelectionButton = () => {
    if (renderWalletSelectionButtonHidden) return;
    return (
      <View style={styles.walletRoot}>
        {!isLoading && (
          <TouchableOpacity accessibilityRole="button" style={styles.walletChooseWrap} onPress={navigateToSelectWallet}>
            <Text style={styles.walletChooseText}>{loc.wallets.select_wallet.toLowerCase()}</Text>
            <Icon name={direction === 'rtl' ? 'angle-left' : 'angle-right'} size={18} type="font-awesome" color="#9aa0aa" />
          </TouchableOpacity>
        )}
        <View style={styles.walletNameWrap}>
          <TouchableOpacity accessibilityRole="button" style={styles.walletNameTouch} onPress={navigateToSelectWallet}>
            <Text style={[styles.walletNameText, styleHooks.walletNameText]}>{wallet.current.getLabel()}</Text>
            <Text style={[styles.walletNameBalance, styleHooks.walletNameBalance]}>
              {formatBalanceWithoutSuffix(wallet.current.getBalance(), BitcoinUnit.SATS, false)}
            </Text>
            <Text style={[styles.walletNameSats, styleHooks.walletNameSats]}>{BitcoinUnit.SATS}</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  const onWalletSelect = selectedWallet => {
    setParams({ walletID: selectedWallet.getID() });
    pop();
  };

  if (!wallet.current) {
    return (
      <View style={[styles.root, styleHooks.root]}>
        <MalinLoading />
      </View>
    );
  }

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss} accessible={false}>
      <View style={[styles.root, styleHooks.root]}>
        <View style={[styles.amount, styleHooks.amount]}>
          <AmountInput.AmountInput
            isLoading={isLoading}
            amount={amount}
            onAmountUnitChange={setUnit}
            onChangeText={setAmount}
            disabled={isLoading || (lnurlParams && lnurlParams.fixed)}
            unit={unit}
            inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
          />
          <View style={[styles.fiat, styleHooks.fiat]}>
            <TextInput
              onChangeText={setDescription}
              placeholder={loc.receive.details_label}
              value={description}
              numberOfLines={1}
              placeholderTextColor="#81868e"
              style={styles.fiat2}
              editable={!isLoading}
              onSubmitEditing={Keyboard.dismiss}
              inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
            />
            {lnurlParams ? null : renderScanClickable()}
          </View>
          <DismissKeyboardInputAccessory />
          {renderCreateButton()}
        </View>
        {renderWalletSelectionButton()}
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  createButton: {
    marginHorizontal: 16,
    marginVertical: 16,
    minHeight: 45,
  },
  scanRoot: {
    height: 36,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderRadius: 4,
    paddingVertical: 4,
    paddingHorizontal: 8,
    marginHorizontal: 4,
  },
  scanClick: {
    marginLeft: 4,
  },
  walletRoot: {
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  walletChooseWrap: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletChooseText: {
    color: '#9aa0aa',
    fontSize: 14,
    marginRight: 8,
  },
  walletNameWrap: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  walletNameTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  walletNameText: {
    fontSize: 14,
  },
  walletNameBalance: {
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 8,
    marginRight: 4,
  },
  walletNameSats: {
    fontSize: 11,
    fontWeight: '600',
    textAlignVertical: 'bottom',
    marginTop: 2,
  },
  root: {
    flex: 1,
    justifyContent: 'space-between',
  },
  amount: {
    flex: 1,
  },
  fiat: {
    flexDirection: 'row',
    borderWidth: 1.0,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    marginHorizontal: 20,
    alignItems: 'center',
    marginVertical: 8,
    borderRadius: 4,
  },
  fiat2: {
    flex: 1,
    marginHorizontal: 8,
    minHeight: 33,
    color: '#81868e',
  },
});

export default LNDCreateInvoice;
LNDCreateInvoice.routeName = 'LNDCreateInvoice';


================================================
FILE: ./screen/send/psbtWithHardwareWallet.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import Clipboard from '@react-native-clipboard/clipboard';
import { StackActions, useIsFocused, useRoute } from '@react-navigation/native';
import * as bitcoin from 'bitcoinjs-lib';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { ActivityIndicator, Linking, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import presentAlert from '../../components/Alert';
import CopyToClipboardButton from '../../components/CopyToClipboardButton';
import { DynamicQRCode } from '../../components/DynamicQRCode';
import SaveFileButton from '../../components/SaveFileButton';
import { SecondButton } from '../../components/SecondButton';
import { useTheme } from '../../components/themes';
import { useBiometrics, unlockWithBiometrics } from '../../hooks/useBiometrics';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useSettings } from '../../hooks/context/useSettings';
import { majorTomToGroundControl } from '../../malin_modules/notifications';
import { openSignedTransactionRaw } from '../../malin_modules/fs';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const PsbtWithHardwareWallet = () => {
  const { txMetadata, fetchAndSaveWalletTransactions, wallets } = useStorage();
  const { isElectrumDisabled } = useSettings();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const navigation = useExtendedNavigation();
  const route = useRoute();
  const { walletID, memo, psbt, deepLinkPSBT, launchedBy } = route.params;
  const wallet = wallets.find(w => w.getID() === walletID);
  const routeParamsPSBT = useRef(route.params.psbt);
  const routeParamsTXHex = route.params.txhex;
  const { colors } = useTheme();
  const [isLoading, setIsLoading] = useState(false);
  const [txHex, setTxHex] = useState(route.params.txhex);
  const openScannerButton = useRef();
  const dynamicQRCode = useRef();
  const isFocused = useIsFocused();

  const stylesHook = StyleSheet.create({
    scrollViewContent: {
      backgroundColor: colors.elevated,
    },
    rootPadding: {
      backgroundColor: colors.elevated,
    },
    hexWrap: {
      backgroundColor: colors.elevated,
    },
    hexLabel: {
      color: colors.foregroundColor,
    },
    hexInput: {
      borderColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
      color: colors.foregroundColor,
    },
    hexText: {
      color: colors.foregroundColor,
    },
  });

  const _combinePSBT = useCallback(
    receivedPSBT => {
      return wallet.combinePsbt(psbt, receivedPSBT);
    },
    [psbt, wallet],
  );

  const onBarScanned = useCallback(
    ret => {
      if (ret && !ret.data) ret = { data: ret };
      if (ret.data.toUpperCase().startsWith('UR')) {
        presentAlert({ message: 'BC-UR not decoded. This should never happen' });
      }
      if (ret.data.indexOf('+') === -1 && ret.data.indexOf('=') === -1 && ret.data.indexOf('=') === -1) {
        // this looks like NOT base64, so maybe its transaction's hex
        setTxHex(ret.data);
        return;
      }
      try {
        const Tx = _combinePSBT(ret.data);
        setTxHex(Tx.toHex());
        if (launchedBy) {
          // we must navigate back to the screen who requested psbt (instead of broadcasting it ourselves)
          // most likely for LN channel opening
          const popToAction = StackActions.popTo(launchedBy, { psbt }, true);
          navigation.dispatch(popToAction);
          // ^^^ we just use `psbt` variable sinse it was finalized in the above _combinePSBT()
          // (passed by reference)
        }
      } catch (Err) {
        console.log('error in _combinePSBT():', Err);
        presentAlert({ message: Err.message });
      }
    },
    [_combinePSBT, launchedBy, navigation, psbt],
  );

  useEffect(() => {
    if (isFocused) {
      dynamicQRCode.current?.startAutoMove();
    } else {
      dynamicQRCode.current?.stopAutoMove();
    }
  }, [isFocused]);

  useEffect(() => {
    if (!psbt && !route.params.txhex) {
      presentAlert({ message: loc.send.no_tx_signing_in_progress });
    }

    if (deepLinkPSBT) {
      const newPsbt = bitcoin.Psbt.fromBase64(deepLinkPSBT);
      try {
        const Tx = wallet.combinePsbt(routeParamsPSBT.current, newPsbt);
        setTxHex(Tx.toHex());
      } catch (Err) {
        console.log('error in wallet.combinePsbt():', Err);
        presentAlert({ message: Err });
      }
    } else if (routeParamsTXHex) {
      setTxHex(routeParamsTXHex);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [deepLinkPSBT, routeParamsTXHex]);

  const broadcast = async () => {
    setIsLoading(true);
    const isBiometricsEnabled = await isBiometricUseCapableAndEnabled();

    if (isBiometricsEnabled) {
      if (!(await unlockWithBiometrics())) {
        setIsLoading(false);
        return;
      }
    }
    try {
      await MalinElectrum.ping();
      await MalinElectrum.waitTillConnected();
      const result = await wallet.broadcastTx(txHex);
      if (result) {
        setIsLoading(false);
        const txDecoded = bitcoin.Transaction.fromHex(txHex);
        const txid = txDecoded.getId();
        majorTomToGroundControl([], [], [txid]);
        if (memo) {
          txMetadata[txid] = { memo };
        }
        navigation.navigate('Success', { amount: undefined });
        await new Promise(resolve => setTimeout(resolve, 3000)); // sleep to make sure network propagates
        fetchAndSaveWalletTransactions(wallet.getID());
      } else {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        setIsLoading(false);
        presentAlert({ message: loc.errors.broadcast });
      }
    } catch (error) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      setIsLoading(false);
      console.log('error broadcasting:', error);
      presentAlert({ message: error.message });
    }
  };

  const handleOnVerifyPressed = () => {
    Linking.openURL('https://coinb.in/?verify=' + txHex);
  };

  const copyHexToClipboard = () => {
    Clipboard.setString(txHex);
  };

  const _renderBroadcastHex = () => {
    return (
      <View style={[styles.rootPadding, stylesHook.rootPadding]}>
        <MalinCard style={[styles.hexWrap, stylesHook.hexWrap]}>
          <MalinText style={[styles.hexLabel, stylesHook.hexLabel]}>{loc.send.create_this_is_hex}</MalinText>
          <TextInput style={[styles.hexInput, stylesHook.hexInput]} height={112} multiline editable value={txHex} />

          <TouchableOpacity accessibilityRole="button" style={styles.hexTouch} onPress={copyHexToClipboard}>
            <Text style={[styles.hexText, stylesHook.hexText]}>{loc.send.create_copy}</Text>
          </TouchableOpacity>
          <TouchableOpacity accessibilityRole="button" style={styles.hexTouch} onPress={handleOnVerifyPressed}>
            <Text style={[styles.hexText, stylesHook.hexText]}>{loc.send.create_verify}</Text>
          </TouchableOpacity>
          <MalinSpacing20 />
          <SecondButton
            disabled={isElectrumDisabled}
            onPress={broadcast}
            title={loc.send.confirm_sendNow}
            testID="PsbtWithHardwareWalletBroadcastTransactionButton"
          />
        </MalinCard>
      </View>
    );
  };

  const saveFileButtonBeforeOnPress = () => {
    dynamicQRCode.current?.stopAutoMove();
  };

  const saveFileButtonAfterOnPress = () => {
    dynamicQRCode.current?.startAutoMove();
  };

  const onOpenSignedTransaction = async () => {
    const file = await openSignedTransactionRaw();
    file && onBarScanned({ data: file });
  };

  useEffect(() => {
    const data = route.params.onBarScanned;
    if (data) {
      onBarScanned({ data });
      navigation.setParams({ onBarScanned: undefined });
    }
  }, [navigation, onBarScanned, route.params.onBarScanned]);

  const openScanner = async () => {
    navigation.navigate('ScanQRCode', {
      showFileImportButton: true,
    });
  };

  if (txHex) return _renderBroadcastHex();

  const renderView = isLoading ? (
    <ActivityIndicator />
  ) : (
    <View style={styles.container}>
      <MalinCard>
        <MalinText testID="TextHelperForPSBT">{loc.send.psbt_this_is_psbt}</MalinText>
        <MalinSpacing20 />
        <Text testID="PSBTHex" style={styles.hidden}>
          {psbt.toHex()}
        </Text>
        <DynamicQRCode value={psbt.toHex()} ref={dynamicQRCode} />
        <MalinSpacing20 />
        <SecondButton
          testID="PsbtTxScanButton"
          icon={{
            name: 'qrcode',
            type: 'font-awesome',
            color: colors.secondButtonTextColor,
          }}
          onPress={openScanner}
          ref={openScannerButton}
          title={loc.send.psbt_tx_scan}
        />
        <MalinSpacing20 />
        <SecondButton
          icon={{
            name: 'login',
            type: 'entypo',
            color: colors.secondButtonTextColor,
          }}
          onPress={onOpenSignedTransaction}
          title={loc.send.psbt_tx_open}
        />
        <MalinSpacing20 />
        <SaveFileButton
          fileName={`${Date.now()}.psbt`}
          fileContent={typeof psbt === 'string' ? psbt : psbt.toBase64()}
          style={styles.exportButton}
          beforeOnPress={saveFileButtonBeforeOnPress}
          afterOnPress={saveFileButtonAfterOnPress}
        >
          <SecondButton
            icon={{
              name: 'share-alternative',
              type: 'entypo',
              color: colors.secondButtonTextColor,
            }}
            title={loc.send.psbt_tx_export}
          />
        </SaveFileButton>
        <MalinSpacing20 />
        <View style={styles.copyToClipboard}>
          <CopyToClipboardButton stringToCopy={typeof psbt === 'string' ? psbt : psbt.toBase64()} displayText={loc.send.psbt_clipboard} />
        </View>
      </MalinCard>
    </View>
  );

  return (
    <ScrollView
      centerContent
      style={stylesHook.scrollViewContent}
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior="automatic"
      contentContainerStyle={[styles.scrollViewContent, stylesHook.scrollViewContent]}
      testID="PsbtWithHardwareScrollView"
    >
      {renderView}
    </ScrollView>
  );
};

export default PsbtWithHardwareWallet;

const styles = StyleSheet.create({
  scrollViewContent: {
    flexGrow: 1,
    justifyContent: 'space-between',
  },
  container: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingTop: 16,
    paddingBottom: 16,
  },
  rootPadding: {
    flex: 1,
    paddingTop: 20,
  },
  hexWrap: {
    alignItems: 'center',
    flex: 1,
  },
  hexLabel: {
    fontWeight: '500',
  },
  hexInput: {
    borderRadius: 4,
    marginTop: 20,
    fontWeight: '500',
    fontSize: 14,
    paddingHorizontal: 16,
    paddingBottom: 16,
    paddingTop: 16,
  },
  hexTouch: {
    marginVertical: 24,
  },
  hexText: {
    fontSize: 15,
    fontWeight: '500',
    alignSelf: 'center',
  },
  copyToClipboard: {
    marginVertical: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  hidden: {
    width: 0,
    height: 0,
  },
});


================================================
FILE: ./screen/send/Broadcast.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useState } from 'react';
import * as bitcoin from 'bitcoinjs-lib';
import { ActivityIndicator, Keyboard, Linking, StyleSheet, TextInput, View } from 'react-native';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinButtonLink, MalinCard, MalinFormLabel, MalinTextCentered } from '../../MalinComponents';
import { HDSegwitBech32Wallet } from '../../class';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useSettings } from '../../hooks/context/useSettings';
import { majorTomToGroundControl } from '../../malin_modules/notifications';
import { scanQrHelper } from '../../helpers/scan-qr.ts';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';
import { MalinBigCheckmark } from '../../components/MalinBigCheckmark.tsx';

const BROADCAST_RESULT = Object.freeze({
  none: 'Input transaction hex',
  pending: 'pending',
  success: 'success',
  error: 'error',
});

const Broadcast: React.FC = () => {
  const [tx, setTx] = useState<string | undefined>();
  const [txHex, setTxHex] = useState<string | undefined>();
  const { colors } = useTheme();
  const [broadcastResult, setBroadcastResult] = useState<string>(BROADCAST_RESULT.none);
  const { selectedBlockExplorer } = useSettings();

  const stylesHooks = StyleSheet.create({
    input: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const handleScannedData = useCallback((scannedData: string) => {
    if (scannedData.indexOf('+') === -1 && scannedData.indexOf('=') === -1 && scannedData.indexOf('=') === -1) {
      // this looks like NOT base64, so maybe its transaction's hex
      return handleUpdateTxHex(scannedData);
    }

    try {
      // should be base64 encoded PSBT
      const validTx = bitcoin.Psbt.fromBase64(scannedData).extractTransaction();
      return handleUpdateTxHex(validTx.toHex());
    } catch (e) {}
  }, []);

  const handleUpdateTxHex = (nextValue: string) => setTxHex(nextValue.trim());

  const handleBroadcast = async () => {
    Keyboard.dismiss();
    setBroadcastResult(BROADCAST_RESULT.pending);
    try {
      await MalinElectrum.ping();
      await MalinElectrum.waitTillConnected();
      const walletObj = new HDSegwitBech32Wallet();
      if (txHex) {
        const result = await walletObj.broadcastTx(txHex);
        if (result) {
          const newTx = bitcoin.Transaction.fromHex(txHex);
          const txid = newTx.getId();
          setTx(txid);

          setBroadcastResult(BROADCAST_RESULT.success);
          triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
          majorTomToGroundControl([], [], [txid]);
        } else {
          setBroadcastResult(BROADCAST_RESULT.error);
        }
      }
    } catch (error: any) {
      presentAlert({ title: loc.errors.error, message: error.message });
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      setBroadcastResult(BROADCAST_RESULT.error);
    }
  };

  const handleQRScan = async () => {
    const scannedData = await scanQrHelper();
    if (scannedData) {
      handleScannedData(scannedData);
    }
  };

  let status;
  switch (broadcastResult) {
    case BROADCAST_RESULT.none:
      status = loc.send.broadcastNone;
      break;
    case BROADCAST_RESULT.pending:
      status = loc.send.broadcastPending;
      break;
    case BROADCAST_RESULT.success:
      status = loc.send.broadcastSuccess;
      break;
    case BROADCAST_RESULT.error:
      status = loc.send.broadcastError;
      break;
    default:
      status = broadcastResult;
  }

  return (
    <SafeArea>
      <View style={styles.wrapper} testID="BroadcastView">
        {BROADCAST_RESULT.success !== broadcastResult && (
          <MalinCard style={styles.mainCard}>
            <View style={styles.topFormRow}>
              <MalinFormLabel>{status}</MalinFormLabel>
              {BROADCAST_RESULT.pending === broadcastResult && <ActivityIndicator size="small" />}
            </View>

            <View style={[styles.input, stylesHooks.input]}>
              <TextInput
                style={styles.text}
                multiline
                editable
                placeholderTextColor="#81868e"
                value={txHex}
                onChangeText={handleUpdateTxHex}
                onSubmitEditing={Keyboard.dismiss}
                testID="TxHex"
              />
            </View>
            <MalinSpacing20 />

            <Button title={loc.multisig.scan_or_open_file} onPress={handleQRScan} />
            <MalinSpacing20 />

            <Button
              title={loc.send.broadcastButton}
              onPress={handleBroadcast}
              disabled={broadcastResult === BROADCAST_RESULT.pending || txHex?.length === 0 || txHex === undefined}
              testID="BroadcastButton"
            />
            <MalinSpacing20 />
          </MalinCard>
        )}
        {BROADCAST_RESULT.success === broadcastResult && tx && <SuccessScreen tx={tx} url={`${selectedBlockExplorer.url}/tx/${tx}`} />}
      </View>
    </SafeArea>
  );
};

const SuccessScreen: React.FC<{ tx: string; url: string }> = ({ tx, url }) => {
  if (!tx) {
    return null;
  }

  return (
    <View style={styles.wrapper}>
      <MalinCard>
        <View style={styles.broadcastResultWrapper}>
          <MalinBigCheckmark />
          <MalinSpacing20 />
          <MalinTextCentered>{loc.settings.success_transaction_broadcasted}</MalinTextCentered>
          <MalinSpacing10 />
          <MalinButtonLink title={loc.settings.open_link_in_explorer} onPress={() => Linking.openURL(url)} />
        </View>
      </MalinCard>
    </View>
  );
};

export default Broadcast;

const styles = StyleSheet.create({
  wrapper: {
    marginTop: 16,
    alignItems: 'center',
    justifyContent: 'flex-start',
  },
  broadcastResultWrapper: {
    flex: 1,
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    height: '100%',
    width: '100%',
  },
  mainCard: {
    padding: 0,
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'flex-start',
  },
  topFormRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingBottom: 10,
    paddingTop: 0,
    paddingRight: 100,
  },
  input: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    alignItems: 'center',
    borderRadius: 4,
  },
  text: {
    padding: 8,
    color: '#81868e',
    maxHeight: 100,
    minHeight: 100,
    maxWidth: '100%',
    minWidth: '100%',
  },
});


================================================
FILE: ./screen/send/CoinControl.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { RouteProp, StackActions, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { Avatar, Badge, Icon, ListItem as RNElementsListItem } from '@rneui/themed';
import {
  ActivityIndicator,
  Keyboard,
  LayoutAnimation,
  PixelRatio,
  Platform,
  StyleSheet,
  Text,
  TextInput,
  TouchableWithoutFeedback,
  useWindowDimensions,
  View,
} from 'react-native';
import * as RNLocalize from 'react-native-localize';
import debounce from '../../malin_modules/debounce';
import { TWallet, Utxo } from '../../class/wallets/types';
import BottomModal, { BottomModalHandle } from '../../components/BottomModal';
import Button from '../../components/Button';
import { FButton, FContainer } from '../../components/FloatButtons';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import ListItem from '../../components/ListItem';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import { Action } from '../../components/types';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc, { formatBalance } from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { useKeyboard } from '../../hooks/useKeyboard';
import TipBox from '../../components/TipBox';
import SafeAreaFlatList from '../../components/SafeAreaFlatList';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';

type NavigationProps = NativeStackNavigationProp<SendDetailsStackParamList, 'CoinControl'>;
type RouteProps = RouteProp<SendDetailsStackParamList, 'CoinControl'>;

const FrozenBadge: React.FC = () => {
  const { colors } = useTheme();
  const oStyles = StyleSheet.create({
    freeze: { backgroundColor: colors.redBG, borderWidth: 0, marginLeft: 4 },
    freezeText: { color: colors.redText, marginTop: -1 },
  });
  return <Badge value={loc.cc.freeze} badgeStyle={oStyles.freeze} textStyle={oStyles.freezeText} />;
};

const ChangeBadge: React.FC = () => {
  const { colors } = useTheme();
  const oStyles = StyleSheet.create({
    change: { backgroundColor: colors.buttonDisabledBackgroundColor, borderWidth: 0, marginLeft: 4 },
    changeText: { color: colors.alternativeTextColor, marginTop: -1 },
  });
  return <Badge value={loc.cc.change} badgeStyle={oStyles.change} textStyle={oStyles.changeText} />;
};

type TOutputListProps = {
  item: Utxo;
  balanceUnit: string;
  oMemo?: string;
  frozen: boolean;
  change: boolean;
  onOpen: () => void;
  selected: boolean;
  selectionStarted: boolean;
  onSelect: () => void;
  onDeSelect: () => void;
};

const OutputList: React.FC<TOutputListProps> = ({
  item: { address, txid, value },
  balanceUnit = BitcoinUnit.BTC,
  oMemo,
  frozen,
  change,
  onOpen,
  selected,
  selectionStarted,
  onSelect,
  onDeSelect,
}: TOutputListProps) => {
  const { colors } = useTheme();
  const { txMetadata } = useStorage();
  const memo = oMemo || txMetadata[txid]?.memo || '';
  const color = `#${txid.substring(0, 6)}`;
  const amount = formatBalance(value, balanceUnit, true);

  const oStyles = StyleSheet.create({
    container: { borderBottomColor: colors.lightBorder, backgroundColor: colors.elevated },
    containerSelected: {
      backgroundColor: colors.ballOutgoingExpired,
      borderBottomColor: 'rgba(0, 0, 0, 0)',
    },
    avatar: { borderColor: 'white', borderWidth: 1, backgroundColor: color },
    amount: { fontWeight: 'bold', color: colors.foregroundColor },
    memo: { fontSize: 13, marginTop: 3, color: colors.alternativeTextColor },
  });

  let onPress = onOpen;
  if (selectionStarted) {
    onPress = selected ? onDeSelect : onSelect;
  }

  return (
    <RNElementsListItem bottomDivider onPress={onPress} containerStyle={selected ? oStyles.containerSelected : oStyles.container}>
      <Avatar
        rounded
        size={40}
        containerStyle={oStyles.avatar}
        onPress={selected ? onDeSelect : onSelect}
        icon={selected ? { name: 'check', type: 'font-awesome-6' } : undefined}
      />
      <RNElementsListItem.Content>
        <RNElementsListItem.Title style={oStyles.amount}>{amount}</RNElementsListItem.Title>
        <RNElementsListItem.Subtitle style={oStyles.memo} numberOfLines={1} ellipsizeMode="middle">
          {memo || address}
        </RNElementsListItem.Subtitle>
      </RNElementsListItem.Content>
      <View style={styles.badges}>
        {frozen && <FrozenBadge />}
        {change && <ChangeBadge />}
      </View>
    </RNElementsListItem>
  );
};

type TOutputModalProps = {
  item: Utxo;
  balanceUnit: string;
  oMemo?: string;
};

const OutputModal: React.FC<TOutputModalProps> = ({
  item: { address, txid, value, vout, confirmations = 0 },
  balanceUnit = BitcoinUnit.BTC,
  oMemo,
}) => {
  const { colors } = useTheme();
  const { txMetadata } = useStorage();
  const memo = oMemo || txMetadata[txid]?.memo || '';
  const fullId = `${txid}:${vout}`;
  const color = `#${txid.substring(0, 6)}`;
  const amount = formatBalance(value, balanceUnit, true);

  const oStyles = StyleSheet.create({
    container: { paddingHorizontal: 0, borderBottomColor: colors.lightBorder, backgroundColor: 'transparent' },
    avatar: { borderColor: 'white', borderWidth: 1, backgroundColor: color },
    amount: { fontWeight: 'bold', color: colors.foregroundColor },
    tranContainer: { paddingLeft: 20 },
    tranText: { fontWeight: 'normal', fontSize: 13, color: colors.alternativeTextColor },
    memo: { fontSize: 13, marginTop: 3, color: colors.alternativeTextColor },
  });
  const confirmationsFormatted = new Intl.NumberFormat(RNLocalize.getLocales()[0].languageCode, { maximumSignificantDigits: 3 }).format(
    confirmations,
  );

  return (
    <RNElementsListItem bottomDivider containerStyle={oStyles.container}>
      <Avatar rounded size={40} containerStyle={oStyles.avatar} />
      <RNElementsListItem.Content>
        <RNElementsListItem.Title numberOfLines={1} adjustsFontSizeToFit style={oStyles.amount}>
          {amount}
          <View style={oStyles.tranContainer}>
            <Text style={oStyles.tranText}>{loc.formatString(loc.transactions.list_conf, { number: confirmationsFormatted })}</Text>
          </View>
        </RNElementsListItem.Title>
        {memo ? (
          <>
            <RNElementsListItem.Subtitle style={oStyles.memo}>{memo}</RNElementsListItem.Subtitle>
            <MalinSpacing10 />
          </>
        ) : null}
        <RNElementsListItem.Subtitle style={oStyles.memo}>{address}</RNElementsListItem.Subtitle>
        <MalinSpacing10 />
        <RNElementsListItem.Subtitle style={oStyles.memo}>{fullId}</RNElementsListItem.Subtitle>
      </RNElementsListItem.Content>
    </RNElementsListItem>
  );
};

const mStyles = StyleSheet.create({
  memoTextInput: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    marginVertical: 8,
    borderRadius: 4,
    paddingHorizontal: 8,
    color: '#81868e',
  },
  buttonContainer: {
    height: 45,
    marginBottom: 36,
    marginHorizontal: 24,
  },
});

type TOutputModalContentProps = {
  output: Utxo;
  wallet: TWallet;
  onUseCoin: (u: Utxo[]) => void;
  frozen: boolean;
  setFrozen: (value: boolean) => void;
};

const transparentBackground = { backgroundColor: 'transparent' };
const OutputModalContent: React.FC<TOutputModalContentProps> = ({ output, wallet, onUseCoin, frozen, setFrozen }) => {
  const { colors } = useTheme();
  const { txMetadata, saveToDisk } = useStorage();
  const [memo, setMemo] = useState<string>(wallet.getUTXOMetadata(output.txid, output.vout).memo || txMetadata[output.txid]?.memo || '');
  const switchValue = useMemo(() => ({ value: frozen, onValueChange: (value: boolean) => setFrozen(value) }), [frozen, setFrozen]);

  const onMemoChange = (value: string) => setMemo(value);

  // save on form change. Because effect called on each event, debounce it.
  const debouncedSaveMemo = useRef(
    debounce(async m => {
      wallet.setUTXOMetadata(output.txid, output.vout, { memo: m });
      await saveToDisk();
    }, 500),
  );
  useEffect(() => {
    debouncedSaveMemo.current(memo);
  }, [memo]);

  return (
    <View>
      <OutputModal item={output} balanceUnit={wallet.getPreferredBalanceUnit()} />
      <MalinSpacing20 />
      <TextInput
        testID="OutputMemo"
        placeholder={loc.send.details_note_placeholder}
        value={memo}
        placeholderTextColor="#81868e"
        style={[
          mStyles.memoTextInput,
          {
            borderColor: colors.formBorder,
            borderBottomColor: colors.formBorder,
            backgroundColor: colors.inputBackgroundColor,
          },
        ]}
        onChangeText={onMemoChange}
      />
      <ListItem
        title={loc.cc.freezeLabel}
        containerStyle={transparentBackground}
        Component={TouchableWithoutFeedback}
        switch={switchValue}
      />
      <MalinSpacing20 />
    </View>
  );
};

enum ESortDirections {
  asc = 'asc',
  desc = 'desc',
}

enum ESortTypes {
  height = 'height',
  label = 'label',
  value = 'value',
  frozen = 'frozen',
}

const CoinControl: React.FC = () => {
  const { colors } = useTheme();
  const navigation = useExtendedNavigation<NavigationProps>();
  const { width } = useWindowDimensions();
  const bottomModalRef = useRef<BottomModalHandle | null>(null);
  const { walletID } = useRoute<RouteProps>().params;
  const { wallets, saveToDisk, sleep } = useStorage();
  const [sortDirection, setSortDirection] = useState<ESortDirections>(ESortDirections.asc);
  const [sortType, setSortType] = useState<ESortTypes>(ESortTypes.height);
  const wallet = useMemo(() => wallets.find(w => w.getID() === walletID) as TWallet, [walletID, wallets]);
  const [frozen, setFrozen] = useState<string[]>(
    wallet
      .getUtxo(true)
      .filter(out => wallet.getUTXOMetadata(out.txid, out.vout).frozen)
      .map(({ txid, vout }) => `${txid}:${vout}`),
  );
  const utxos: Utxo[] = useMemo(() => {
    const res = wallet.getUtxo(true).sort((a, b) => {
      switch (sortType) {
        case ESortTypes.height:
          return a.height - b.height || a.txid.localeCompare(b.txid) || a.vout - b.vout;
        case ESortTypes.value:
          return a.value - b.value || a.txid.localeCompare(b.txid) || a.vout - b.vout;
        case ESortTypes.label: {
          const aMemo = wallet.getUTXOMetadata(a.txid, a.vout).memo || '';
          const bMemo = wallet.getUTXOMetadata(b.txid, b.vout).memo || '';
          return aMemo.localeCompare(bMemo) || a.txid.localeCompare(b.txid) || a.vout - b.vout;
        }
        case ESortTypes.frozen: {
          const aF = frozen.includes(`${a.txid}:${a.vout}`);
          const bF = frozen.includes(`${b.txid}:${b.vout}`);
          return aF !== bF ? (aF ? -1 : 1) : a.txid.localeCompare(b.txid) || a.vout - b.vout;
        }
        default:
          return 0;
      }
    });
    // invert if descending
    return sortDirection === ESortDirections.desc ? res.reverse() : res;
  }, [sortDirection, sortType, wallet, frozen]);
  const [output, setOutput] = useState<Utxo | undefined>();
  const [loading, setLoading] = useState<boolean>(true);
  const [selected, setSelected] = useState<string[]>([]);
  const { isVisible } = useKeyboard();

  // save frozen status. Because effect called on each event, debounce it.
  const debouncedSaveFronen = useRef(
    debounce(async frzn => {
      utxos.forEach(({ txid, vout }) => {
        wallet.setUTXOMetadata(txid, vout, { frozen: frzn.includes(`${txid}:${vout}`) });
      });
      await saveToDisk();
    }, 500),
  );
  useEffect(() => {
    debouncedSaveFronen.current(frozen);
  }, [frozen]);

  useEffect(() => {
    (async () => {
      try {
        await Promise.race([wallet.fetchUtxo(), sleep(10000)]);
      } catch (e) {
        console.log('coincontrol wallet.fetchUtxo() failed'); // either sleep expired or fetchUtxo threw an exception
      }
      const freshUtxo = wallet.getUtxo(true);
      setFrozen(freshUtxo.filter(out => wallet.getUTXOMetadata(out.txid, out.vout).frozen).map(({ txid, vout }) => `${txid}:${vout}`));
      setLoading(false);
    })();
  }, [wallet, setLoading, sleep]);

  const stylesHook = StyleSheet.create({
    tip: {
      backgroundColor: colors.ballOutgoingExpired,
      borderRadius: 12,
      padding: 16,
      marginVertical: 24,
      marginHorizontal: 16,
    },
  });

  const tipCoins = () => {
    if (utxos.length === 0) return null;

    let text = loc.cc.tip;
    if (selected.length > 0) {
      // show summ of coins if any selected
      const summ = selected.reduce((prev, curr) => {
        return prev + (utxos.find(({ txid, vout }) => `${txid}:${vout}` === curr) as Utxo).value;
      }, 0);

      const value = formatBalance(summ, wallet.getPreferredBalanceUnit(), true);
      text = loc.formatString(loc.cc.selected_summ, { value });
    }

    return <TipBox description={text} containerStyle={stylesHook.tip} />;
  };

  const handleChoose = (item: Utxo) => setOutput(item);

  const handleUseCoin = async (u: Utxo[]) => {
    setOutput(undefined);
    const popToAction = StackActions.popTo('SendDetails', { walletID, utxos: u }, { merge: true });
    navigation.dispatch(popToAction);
  };

  const handleMassFreeze = () => {
    if (allFrozen) {
      setFrozen(f => f.filter(i => !selected.includes(i))); // unfreeze
    } else {
      setFrozen(f => [...new Set([...f, ...selected])]); // freeze
    }
  };

  const handleMassUse = () => {
    const fUtxo = utxos.filter(({ txid, vout }) => selected.includes(`${txid}:${vout}`));
    handleUseCoin(fUtxo);
  };

  // check if any outputs are selected
  const selectionStarted = selected.length > 0;
  // check if all selected items are frozen
  const allFrozen = selectionStarted && selected.reduce((prev, curr) => (prev ? frozen.includes(curr) : false), true);
  const buttonFontSize = PixelRatio.roundToNearestPixel(width / 26) > 22 ? 22 : PixelRatio.roundToNearestPixel(width / 26);

  const renderItem = (p: { item: Utxo }) => {
    const { memo } = wallet.getUTXOMetadata(p.item.txid, p.item.vout);
    const change = wallet.addressIsChange(p.item.address);
    const oFrozen = frozen.includes(`${p.item.txid}:${p.item.vout}`);
    return (
      <OutputList
        balanceUnit={wallet.getPreferredBalanceUnit()}
        item={p.item}
        oMemo={memo}
        frozen={oFrozen}
        change={change}
        onOpen={() => handleChoose(p.item)}
        selected={selected.includes(`${p.item.txid}:${p.item.vout}`)}
        selectionStarted={selectionStarted}
        onSelect={() => {
          setSelected(s => {
            if (s.length === 0) {
              LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut); // animate buttons show
            }
            return [...s, `${p.item.txid}:${p.item.vout}`];
          });
        }}
        onDeSelect={() => {
          setSelected(s => {
            const newValue = s.filter(i => i !== `${p.item.txid}:${p.item.vout}`);
            if (newValue.length === 0) {
              LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut); // animate buttons show
            }
            return newValue;
          });
        }}
      />
    );
  };

  const renderOutputModalContent = (o: Utxo | undefined) => {
    if (!o) {
      return null;
    }
    const oFrozen = frozen.includes(`${o.txid}:${o.vout}`);
    const setOFrozen = (value: boolean) => {
      if (value) {
        setFrozen(f => [...f, `${o.txid}:${o.vout}`]);
      } else {
        setFrozen(f => f.filter(i => i !== `${o.txid}:${o.vout}`));
      }
    };
    return <OutputModalContent output={o} wallet={wallet} onUseCoin={handleUseCoin} frozen={oFrozen} setFrozen={setOFrozen} />;
  };

  useEffect(() => {
    if (output) {
      bottomModalRef.current?.present();
    }
  }, [output]);

  const toolTipActions = useMemo((): Action[] | Action[][] => {
    return [
      [sortDirection === ESortDirections.asc ? CommonToolTipActions.SortASC : CommonToolTipActions.SortDESC],
      [
        { ...CommonToolTipActions.SortHeight, menuState: sortType === ESortTypes.height },
        { ...CommonToolTipActions.SortValue, menuState: sortType === ESortTypes.value },
        { ...CommonToolTipActions.SortLabel, menuState: sortType === ESortTypes.label },
        { ...CommonToolTipActions.SortStatus, menuState: sortType === ESortTypes.frozen },
      ],
    ];
  }, [sortDirection, sortType]);

  const toolTipOnPressMenuItem = useCallback((menuItem: string) => {
    Keyboard.dismiss();
    if (menuItem === CommonToolTipActions.SortASC.id) {
      setSortDirection(ESortDirections.desc);
    } else if (menuItem === CommonToolTipActions.SortDESC.id) {
      setSortDirection(ESortDirections.asc);
    } else if (menuItem === CommonToolTipActions.SortHeight.id) {
      setSortType(ESortTypes.height);
    } else if (menuItem === CommonToolTipActions.SortValue.id) {
      setSortType(ESortTypes.value);
    } else if (menuItem === CommonToolTipActions.SortLabel.id) {
      setSortType(ESortTypes.label);
    } else if (menuItem === CommonToolTipActions.SortStatus.id) {
      setSortType(ESortTypes.frozen);
    }
  }, []);

  const HeaderRight = useMemo(
    () => <HeaderMenuButton onPressMenuItem={toolTipOnPressMenuItem} actions={toolTipActions} title={loc.cc.sort_by} />,
    [toolTipOnPressMenuItem, toolTipActions],
  );

  // Adding the ToolTipMenu to the header
  useEffect(() => {
    navigation.setOptions({
      headerRight: () => (utxos.length > 0 ? HeaderRight : null),
    });
  }, [HeaderRight, navigation, utxos.length]);

  if (loading) {
    return (
      <SafeArea style={[styles.center, { backgroundColor: colors.elevated }]}>
        <ActivityIndicator testID="Loading" />
      </SafeArea>
    );
  }

  return (
    <View style={[styles.root, { backgroundColor: colors.elevated }]}>
      {utxos.length === 0 && (
        <View style={styles.empty}>
          <Text style={{ color: colors.foregroundColor }}>{loc.cc.empty}</Text>
        </View>
      )}

      <BottomModal
        ref={bottomModalRef}
        onClose={() => {
          Keyboard.dismiss();
          setOutput(undefined);
        }}
        backgroundColor={colors.elevated}
        contentContainerStyle={styles.modalMinHeight}
        footer={
          <View style={mStyles.buttonContainer}>
            {!isVisible && (
              <Button
                testID="UseCoin"
                title={loc.cc.use_coin}
                onPress={async () => {
                  if (!output) throw new Error('output is not set');
                  await bottomModalRef.current?.dismiss();
                  handleUseCoin([output]);
                }}
              />
            )}
          </View>
        }
      >
        {renderOutputModalContent(output)}
      </BottomModal>
      <SafeAreaFlatList
        ListHeaderComponent={tipCoins}
        data={utxos}
        renderItem={renderItem}
        keyExtractor={item => `${item.txid}:${item.vout}`}
        contentInset={styles.listContent}
      />

      {selectionStarted && (
        <FContainer>
          <FButton
            onPress={handleMassFreeze}
            text={allFrozen ? loc.cc.freezeLabel_un : loc.cc.freezeLabel}
            icon={<Icon name="snowflake" size={buttonFontSize} type="font-awesome-5" color={colors.buttonAlternativeTextColor} />}
          />
          <FButton
            onPress={handleMassUse}
            text={selected.length > 1 ? loc.cc.use_coins : loc.cc.use_coin}
            icon={
              <View style={styles.sendIcon}>
                <Icon name="arrow-down" size={buttonFontSize} type="font-awesome" color={colors.buttonAlternativeTextColor} />
              </View>
            }
          />
        </FContainer>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalMinHeight: Platform.OS === 'android' ? { minHeight: 530 } : {},
  empty: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  sendIcon: {
    transform: [{ rotate: '225deg' }],
  },
  badges: {
    flexDirection: 'row',
  },
  listContent: {
    top: 0,
    left: 0,
    bottom: 70,
    right: 0,
  },
});

export default CoinControl;


================================================
FILE: ./screen/send/psbtMultisig.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useState } from 'react';
import { RouteProp, useRoute } from '@react-navigation/native';
import BigNumber from 'bignumber.js';
import * as bitcoin from 'bitcoinjs-lib';
import {
  FlatList,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  LayoutAnimation,
  ListRenderItemInfo,
  NativeSyntheticEvent,
  LayoutRectangle,
  NodeHandle,
} from 'react-native';
import { Icon } from '@rneui/themed';

import { satoshiToBTC, satoshiToLocalCurrency } from '../../malin_modules/currency';
import { MalinCard, MalinText } from '../../MalinComponents';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { combinePSBTs } from '../../utils/combinePSBTs';
import { MultisigHDWallet } from '../../class';
import assert from 'assert';

type RouteParams = {
  params: {
    walletID: string;
    psbtBase64: string;
    memo: string;
    receivedPSBTBase64: string;
    launchedBy: string;
  };
};

const PsbtMultisig = () => {
  const { wallets } = useStorage();
  const { navigate, setParams } = useExtendedNavigation();
  const { colors } = useTheme();
  const [flatListHeight, setFlatListHeight] = useState(0);
  const { walletID, psbtBase64, memo, receivedPSBTBase64, launchedBy } = useRoute<RouteProp<RouteParams>>().params;
  const wallet = wallets.find(w => w.getID() === walletID) as MultisigHDWallet;
  assert(wallet, 'Internal error: MultisigHDWallet not found');

  const [psbt, setPsbt] = useState(() => {
    try {
      const initial = bitcoin.Psbt.fromBase64(psbtBase64);
      return initial;
    } catch (error) {
      console.error('Error loading initial PSBT:', error);
      presentAlert({ message: loc.send.invalid_psbt });
      return null;
    }
  });

  useEffect(() => {
    if (receivedPSBTBase64) {
      _combinePSBT();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [receivedPSBTBase64]);

  const data = new Array(wallet.getM());
  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    whitespace: {
      color: colors.elevated,
    },
    textBtc: {
      color: colors.buttonAlternativeTextColor,
    },
    textBtcUnitValue: {
      color: colors.buttonAlternativeTextColor,
    },
    textFiat: {
      color: colors.alternativeTextColor,
    },
    provideSignatureButton: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    provideSignatureButtonText: {
      color: colors.buttonTextColor,
    },
    vaultKeyCircle: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    vaultKeyText: {
      color: colors.alternativeTextColor,
    },
    feeFiatText: {
      color: colors.alternativeTextColor,
    },
    vaultKeyCircleSuccess: {
      backgroundColor: colors.msSuccessBG,
    },
    vaultKeyTextSigned: {
      color: colors.msSuccessBG,
    },
  });

  const [isFiltered, setIsFiltered] = useState(true);

  if (!psbt) return null;

  // if useFilter is true, include only non-owned addresses.
  const getDestinationData = (useFilter = true) => {
    const addresses = [];
    let totalSat = 0;
    const targets = [];
    for (const output of psbt.txOutputs) {
      if (output.address) {
        if (useFilter && wallet.weOwnAddress(output.address)) continue;
        totalSat += Number(output.value);
        addresses.push(output.address);
        targets.push({ address: output.address, value: output.value });
      }
    }
    return { addresses, totalSat, targets };
  };

  const filteredData = getDestinationData(true);
  const unfilteredData = getDestinationData(false);

  const targets = filteredData.targets;

  const displayData = isFiltered ? filteredData : unfilteredData;
  const displayTotalBtc = new BigNumber(displayData.totalSat).dividedBy(100000000).toNumber();
  const displayTotalFiat = satoshiToLocalCurrency(displayData.totalSat);

  const getFee = () => {
    return wallet.calculateFeeFromPsbt(psbt);
  };

  const _renderItem = (el: ListRenderItemInfo<any>) => {
    if (el.index >= howManySignaturesWeHave) return _renderItemUnsigned(el);
    else return _renderItemSigned(el);
  };

  const navigateToPSBTMultisigQRCode = () => {
    navigate('PsbtMultisigQRCode', { walletID, psbtBase64: psbt.toBase64(), isShowOpenScanner: isConfirmEnabled() });
  };

  const _renderItemUnsigned = (el: ListRenderItemInfo<any>) => {
    const renderProvideSignature = el.index === howManySignaturesWeHave;
    return (
      <View testID="ItemUnsigned">
        <View style={styles.itemUnsignedWrapper}>
          <View style={[styles.vaultKeyCircle, stylesHook.vaultKeyCircle]}>
            <Text style={[styles.vaultKeyText, stylesHook.vaultKeyText]}>{el.index + 1}</Text>
          </View>
          <View style={styles.vaultKeyTextWrapper}>
            <Text style={[styles.vaultKeyText, stylesHook.vaultKeyText]}>
              {loc.formatString(loc.multisig.vault_key, { number: el.index + 1 })}
            </Text>
          </View>
        </View>

        {renderProvideSignature && (
          <View>
            <TouchableOpacity
              accessibilityRole="button"
              testID="ProvideSignature"
              style={[styles.provideSignatureButton, stylesHook.provideSignatureButton]}
              onPress={navigateToPSBTMultisigQRCode}
            >
              <Text style={[styles.provideSignatureButtonText, stylesHook.provideSignatureButtonText]}>
                {loc.multisig.provide_signature}
              </Text>
            </TouchableOpacity>
          </View>
        )}
      </View>
    );
  };

  const _renderItemSigned = (el: ListRenderItemInfo<any>) => {
    return (
      <View style={styles.flexDirectionRow} testID="ItemSigned">
        <View style={[styles.vaultKeyCircleSuccess, stylesHook.vaultKeyCircleSuccess]}>
          <Icon size={24} name="check" type="ionicons" color={colors.msSuccessCheck} />
        </View>
        <View style={styles.vaultKeyTextSignedWrapper}>
          <Text style={[styles.vaultKeyTextSigned, stylesHook.vaultKeyTextSigned]}>
            {loc.formatString(loc.multisig.vault_key, { number: el.index + 1 })}
          </Text>
        </View>
      </View>
    );
  };

  const _combinePSBT = () => {
    if (receivedPSBTBase64 && receivedPSBTBase64 !== psbt.toBase64()) {
      try {
        const combined = combinePSBTs({ psbtBase64: psbt.toBase64(), newPSBTBase64: receivedPSBTBase64 });
        setPsbt(combined);
        setParams({ receivedPSBTBase64: undefined });
      } catch (error: any) {
        console.error('Error during PSBT combination:', error);
        presentAlert({ message: error.message });
      }
    }
  };

  const onConfirm = () => {
    try {
      psbt.finalizeAllInputs();
    } catch (err) {
      console.warn('Finalize error (ignored if already finalized):', err);
    }

    if (launchedBy) {
      // we must navigate back to the screen who requested psbt (instead of broadcasting it ourselves)
      // most likely for LN channel opening
      navigate(launchedBy, { psbt });
      return;
    }

    try {
      const tx = psbt.extractTransaction().toHex();
      const satoshiPerByte = Math.round(getFee() / psbt.extractTransaction().virtualSize());
      navigate('Confirm', {
        fee: new BigNumber(getFee()).dividedBy(100000000).toNumber(),
        memo,
        walletID,
        tx,
        recipients: targets,
        satoshiPerByte,
      });
    } catch (error: any) {
      presentAlert({ message: error });
    }
  };

  const howManySignaturesWeHave = wallet.calculateHowManySignaturesWeHaveFromPsbt(psbt);
  const isConfirmEnabled = () => {
    return howManySignaturesWeHave >= wallet.getM();
  };

  const destinationAddress = (useFilter = true) => {
    const addrs = useFilter ? filteredData.addresses : unfilteredData.addresses;
    const displayAddrs = useFilter ? addrs : [...new Set(addrs)];
    const destinationAddressView = [];
    const whitespace = '_';
    const destinations = Object.entries(displayAddrs);
    for (const [index, address] of destinations) {
      if (Number(index) > 1) {
        destinationAddressView.push(
          <View style={styles.destinationTextContainer} key={`end-${index}`}>
            <Text numberOfLines={0} style={[styles.textDestinationFirstFour, stylesHook.textFiat]}>
              and {destinations.length - 2} more...
            </Text>
          </View>,
        );
        break;
      } else {
        const currentAddress = address;
        const firstFour = currentAddress.substring(0, 5);
        const lastFour = currentAddress.substring(currentAddress.length - 5);
        const middle = currentAddress.length > 10 ? currentAddress.slice(5, currentAddress.length - 5) : '';
        destinationAddressView.push(
          <View style={styles.destinationTextContainer} key={`${currentAddress}-${index}`}>
            <Text style={styles.textAlignCenter} selectable>
              <Text numberOfLines={2} style={[styles.textDestinationFirstFour, stylesHook.textBtc]}>
                {firstFour}
                <Text style={stylesHook.whitespace}>{whitespace}</Text>
                <Text style={[styles.textDestination, stylesHook.textFiat]}>{middle}</Text>
                <Text style={stylesHook.whitespace}>{whitespace}</Text>
                <Text style={[styles.textDestinationFirstFour, stylesHook.textBtc]}>{lastFour}</Text>
              </Text>
            </Text>
          </View>,
        );
      }
    }
    return destinationAddressView;
  };

  const handleToggleFilter = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setIsFiltered(prev => !prev);
  };

  const header = (
    <View style={stylesHook.root}>
      <View style={styles.containerText}>
        <TouchableOpacity onPress={handleToggleFilter}>
          <MalinText selectable style={[styles.textBtc, stylesHook.textBtc]}>
            {displayTotalBtc}
          </MalinText>
        </TouchableOpacity>
        <View style={styles.textBtcUnit}>
          <MalinText selectable style={stylesHook.textBtcUnitValue}>
            {' '}
            {BitcoinUnit.BTC}
          </MalinText>
        </View>
      </View>
      <View style={styles.containerText}>
        <TouchableOpacity onPress={handleToggleFilter}>
          <MalinText selectable style={[styles.textFiat, stylesHook.textFiat]}>
            {displayTotalFiat}
          </MalinText>
        </TouchableOpacity>
      </View>
      <View>{destinationAddress(isFiltered)}</View>
    </View>
  );

  const footer = null;

  const onLayout = (event: NativeSyntheticEvent<{ layout: LayoutRectangle; target?: NodeHandle | null }>) => {
    const newHeight = event.nativeEvent.layout.height;
    setFlatListHeight(newHeight);
  };

  return (
    <SafeArea style={stylesHook.root}>
      <View style={styles.flexColumnSpaceBetween}>
        <View style={styles.flexOne}>
          <View style={styles.container}>
            <View style={styles.mstopcontainer}>
              <View style={styles.mscontainer}>
                <View style={[styles.msleft, { height: flatListHeight - 260 }]} />
              </View>
              <View style={styles.msright}>
                <MalinCard>
                  <FlatList
                    data={data}
                    renderItem={_renderItem}
                    keyExtractor={(_item, index) => `${index}`}
                    extraData={psbt} // Ensure FlatList updates when psbt changes
                    ListHeaderComponent={header}
                    ListFooterComponent={footer}
                    onLayout={onLayout}
                  />
                  {isConfirmEnabled() && (
                    <View style={styles.height80}>
                      <TouchableOpacity
                        accessibilityRole="button"
                        testID="ExportSignedPsbt"
                        style={[styles.provideSignatureButton, stylesHook.provideSignatureButton]}
                        onPress={() => {
                          navigateToPSBTMultisigQRCode();
                        }}
                      >
                        <Text style={[styles.provideSignatureButtonText, stylesHook.provideSignatureButtonText]}>
                          {loc.multisig.export_signed_psbt}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  )}
                </MalinCard>
              </View>
            </View>
          </View>
        </View>
        <View style={styles.feeConfirmContainer}>
          <View style={styles.feeContainer}>
            <View style={styles.bottomWrapper}>
              <View style={styles.bottomFeesWrapper}>
                <MalinText selectable style={stylesHook.feeFiatText}>
                  {loc.formatString(loc.multisig.fee, { number: satoshiToLocalCurrency(getFee()) })} -{' '}
                </MalinText>
                <MalinText selectable>{loc.formatString(loc.multisig.fee_btc, { number: satoshiToBTC(getFee()) })}</MalinText>
              </View>
            </View>
          </View>
          <View style={styles.flexConfirm}>
            <Button disabled={!isConfirmEnabled()} title={loc.multisig.confirm} onPress={onConfirm} testID="PsbtMultisigConfirmButton" />
          </View>
        </View>
      </View>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  mstopcontainer: {
    flex: 1,
    flexDirection: 'row',
  },
  mscontainer: {
    flex: 10,
  },
  flexOne: {
    flex: 1,
  },
  msleft: {
    width: 1,
    borderStyle: 'dashed',
    borderWidth: 0.8,
    borderColor: '#c4c4c4',
    marginLeft: 40,
    marginTop: 160,
  },
  msright: {
    flex: 90,
    marginLeft: '-11%',
  },
  container: {
    flexDirection: 'column',
    flex: 1,
  },
  containerText: {
    flexDirection: 'row',
    justifyContent: 'center',
  },
  destinationTextContainer: {
    flexDirection: 'row',
    marginBottom: 4,
    paddingHorizontal: 60,
    fontSize: 14,
    marginVertical: 8,
    justifyContent: 'center',
  },
  textFiat: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 30,
  },
  textBtc: {
    fontWeight: 'bold',
    fontSize: 30,
  },
  textAlignCenter: {
    textAlign: 'center',
  },
  textDestinationFirstFour: {
    fontSize: 14,
  },
  textDestination: {
    paddingTop: 10,
    paddingBottom: 40,
    fontSize: 14,
    flexWrap: 'wrap',
  },
  provideSignatureButton: {
    marginTop: 24,
    marginLeft: 40,
    height: 48,
    borderRadius: 8,
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 16,
    marginBottom: 8,
  },
  provideSignatureButtonText: { fontWeight: '600', fontSize: 15 },
  vaultKeyText: { fontSize: 18, fontWeight: 'bold' },
  vaultKeyTextWrapper: { justifyContent: 'center', alignItems: 'center', paddingLeft: 16 },
  vaultKeyCircle: {
    width: 42,
    height: 42,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  vaultKeyCircleSuccess: {
    width: 42,
    height: 42,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  itemUnsignedWrapper: { flexDirection: 'row', paddingTop: 16 },
  vaultKeyTextSigned: { fontSize: 18, fontWeight: 'bold' },
  vaultKeyTextSignedWrapper: { justifyContent: 'center', alignItems: 'center', paddingLeft: 16 },
  flexDirectionRow: { flexDirection: 'row', paddingVertical: 12 },
  textBtcUnit: { justifyContent: 'flex-end' },
  bottomFeesWrapper: { justifyContent: 'center', alignItems: 'center', flexDirection: 'row' },
  bottomWrapper: { marginTop: 16 },
  height80: {
    height: 80,
  },
  flexColumnSpaceBetween: {
    flex: 1,
    flexDirection: 'column',
    justifyContent: 'space-between',
  },
  flexConfirm: {
    paddingHorizontal: 32,
    paddingVertical: 16,
  },
  feeConfirmContainer: {
    paddingHorizontal: 32,
    paddingVertical: 16,
  },
  feeContainer: {
    marginBottom: 8,
  },
});

export default PsbtMultisig;


================================================
FILE: ./screen/send/ScanQRCode.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp, StackActions, useIsFocused, useRoute } from '@react-navigation/native';
import * as bitcoin from 'bitcoinjs-lib';
import { sha256 } from '@noble/hashes/sha256';
import React, { useEffect, useState } from 'react';
import { Platform, StyleSheet, TextInput, TouchableOpacity, View } from 'react-native';
import Base43 from '../../malin_modules/base43';
import * as fs from '../../malin_modules/fs';
import { MalinURDecoder, decodeUR, extractSingleWorkload } from '../../malin_modules/ur';
import { MalinText } from '../../MalinComponents';
import { openPrivacyDesktopSettings } from '../../class/camera';
import Button from '../../components/Button';
import { useTheme } from '../../components/themes';
import { isCameraAuthorizationStatusGranted } from '../../helpers/scan-qr';
import loc from '../../loc';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import CameraScreen from '../../components/CameraScreen';
import SafeArea from '../../components/SafeArea';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList.ts';
import { MalinSpacing40 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading.tsx';
import { hexToUint8Array, uint8ArrayToBase64, uint8ArrayToHex, uint8ArrayToString } from '../../malin_modules/uint8array-extras/index.js';

let decoder: MalinURDecoder | undefined;

type RouteProps = RouteProp<SendDetailsStackParamList, 'ScanQRCode'>;

const styles = StyleSheet.create({
  root: {
    flex: 1,
    backgroundColor: '#000000',
  },
  openSettingsContainer: {
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    height: '100%',
  },
  backdoorButton: {
    width: 60,
    height: 60,
    backgroundColor: 'rgba(0,0,0,0.01)',
    position: 'absolute',
    top: 60,
    left: '50%',
    transform: [{ translateX: -30 }],
  },
  backdoorInputWrapper: { position: 'absolute', left: '5%', top: '0%', width: '90%', height: '70%', backgroundColor: 'white' },
  progressWrapper: { position: 'absolute', alignSelf: 'center', alignItems: 'center', top: '50%', padding: 8, borderRadius: 8 },
  backdoorInput: {
    height: '50%',
    marginTop: 5,
    marginHorizontal: 20,
    borderWidth: 1,
    borderRadius: 4,
    textAlignVertical: 'top',
  },
});

const ScanQRCode = () => {
  const [isLoading, setIsLoading] = useState(false);
  const navigation = useExtendedNavigation();
  const route = useRoute<RouteProps>();
  const navigationState = navigation.getState();
  const previousRoute = navigationState.routes[navigationState.routes.length - 2];
  const defaultLaunchedBy = previousRoute ? previousRoute.name : undefined;

  const { launchedBy = defaultLaunchedBy, showFileImportButton, onBarScanned } = route.params || {};
  const scannedCache: Record<string, number> = {};
  const { colors } = useTheme();
  const isFocused = useIsFocused();
  const [backdoorPressed, setBackdoorPressed] = useState(0);
  const [urTotal, setUrTotal] = useState(0);
  const [urHave, setUrHave] = useState(0);
  const [backdoorText, setBackdoorText] = useState('');
  const [backdoorVisible, setBackdoorVisible] = useState(false);
  const [animatedQRCodeData, setAnimatedQRCodeData] = useState<Record<string, string>>({});
  const [cameraStatusGranted, setCameraStatusGranted] = useState<boolean | undefined>(undefined);
  const stylesHook = StyleSheet.create({
    openSettingsContainer: {
      backgroundColor: colors.brandingColor,
    },
    progressWrapper: { backgroundColor: colors.brandingColor, borderColor: colors.foregroundColor, borderWidth: 4 },
    backdoorInput: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
      color: colors.foregroundColor,
    },
  });

  useEffect(() => {
    isCameraAuthorizationStatusGranted().then(setCameraStatusGranted);
  }, []);

  const HashIt = function (s: string): string {
    return uint8ArrayToHex(sha256(s));
  };

  const _onReadUniformResourceV2 = (part: string) => {
    if (!decoder) decoder = new MalinURDecoder();
    try {
      decoder.receivePart(part);
      if (decoder.isComplete()) {
        const data = decoder.toString();
        decoder = undefined; // nullify for future use (?)
        if (launchedBy) {
          const merge = true;
          const popToAction = StackActions.popTo(launchedBy, { onBarScanned: data }, { merge });
          if (onBarScanned) {
            onBarScanned(data);
          }

          navigation.dispatch(popToAction);
        }
      } else {
        setUrTotal(100);
        setUrHave(Math.floor(decoder.estimatedPercentComplete() * 100));
      }
    } catch (error: any) {
      console.log('Invalid animated qr code fragment: ' + error.message + ' (continuing scanning)');
    }
  };

  /**
   *
   * @deprecated remove when we get rid of URv1 support
   */
  const _onReadUniformResource = (ur: string) => {
    try {
      const [index, total] = extractSingleWorkload(ur);
      animatedQRCodeData[index + 'of' + total] = ur;
      setUrTotal(total);
      setUrHave(Object.values(animatedQRCodeData).length);
      if (Object.values(animatedQRCodeData).length === total) {
        const payload = decodeUR(Object.values(animatedQRCodeData));
        // lets look inside that data
        let data: false | string = false;
        if (uint8ArrayToString(hexToUint8Array(String(payload))).startsWith('psbt')) {
          // its a psbt, and whoever requested it expects it encoded in base64
          data = uint8ArrayToBase64(hexToUint8Array(String(payload)));
        } else {
          // its something else. probably plain text is expected
          data = uint8ArrayToString(hexToUint8Array(String(payload)));
        }
        if (launchedBy) {
          const merge = true;
          const popToAction = StackActions.popTo(launchedBy, { onBarScanned: data }, { merge });
          if (onBarScanned) {
            onBarScanned(data);
          }

          navigation.dispatch(popToAction);
        }
      } else {
        setAnimatedQRCodeData(animatedQRCodeData);
      }
    } catch (error: any) {
      console.log('Invalid animated qr code fragment: ' + error.message + ' (continuing scanning)');
    }
  };

  const onBarCodeRead = (ret: { data: string }) => {
    const h = HashIt(ret.data);
    if (scannedCache[h]) {
      // this QR was already scanned by this ScanQRCode, lets prevent firing duplicate callbacks
      return;
    }
    scannedCache[h] = +new Date();

    if (ret.data.toUpperCase().startsWith('UR:CRYPTO-ACCOUNT')) {
      return _onReadUniformResourceV2(ret.data);
    }

    if (ret.data.toUpperCase().startsWith('UR:CRYPTO-PSBT')) {
      return _onReadUniformResourceV2(ret.data);
    }

    if (ret.data.toUpperCase().startsWith('UR:CRYPTO-OUTPUT')) {
      return _onReadUniformResourceV2(ret.data);
    }

    if (ret.data.toUpperCase().startsWith('UR:BYTES')) {
      const splitted = ret.data.split('/');
      if (splitted.length === 3 && splitted[1].includes('-')) {
        return _onReadUniformResourceV2(ret.data);
      }
    }

    if (ret.data.toUpperCase().startsWith('UR')) {
      return _onReadUniformResource(ret.data);
    }

    // is it base43? stupid electrum desktop
    try {
      const hex = Base43.decode(ret.data);
      bitcoin.Psbt.fromHex(hex); // if it doesnt throw - all good
      const data = uint8ArrayToBase64(hexToUint8Array(hex));

      if (launchedBy) {
        const merge = true;
        const popToAction = StackActions.popTo(launchedBy, { onBarScanned: data }, { merge });
        if (onBarScanned) {
          onBarScanned(data);
        }
        navigation.dispatch(popToAction);
      }
      return;
    } catch (_) {
      if (!isLoading && launchedBy) {
        setIsLoading(true);
        try {
          const merge = true;

          const popToAction = StackActions.popTo(launchedBy, { onBarScanned: ret.data }, { merge });
          if (onBarScanned) {
            onBarScanned(ret.data);
          }

          navigation.dispatch(popToAction);
        } catch (e) {
          console.log(e);
        }
      }
    }
    setIsLoading(false);
  };

  const showFilePicker = async () => {
    setIsLoading(true);
    const { data } = await fs.showFilePickerAndReadFile();
    if (data) onBarCodeRead({ data });
    setIsLoading(false);
  };

  const onShowImagePickerButtonPress = () => {
    if (!isLoading) {
      setIsLoading(true);
      fs.showImagePickerAndReadImage()
        .then(data => {
          if (data) onBarCodeRead({ data });
        })
        .finally(() => setIsLoading(false));
    }
  };

  const dismiss = () => {
    navigation.goBack();
  };

  const handleReadCode = (event: any) => {
    onBarCodeRead({ data: event?.nativeEvent?.codeStringValue });
  };

  const handleBackdoorOkPress = () => {
    setBackdoorVisible(false);
    setBackdoorText('');
    if (backdoorText) onBarCodeRead({ data: backdoorText });
  };

  // this is an invisible backdoor button on bottom left screen corner
  // tapping it 10 times fires prompt dialog asking for a string thats gona be passed to onBarCodeRead.
  // this allows to mock and test QR scanning in e2e tests
  const handleInvisibleBackdoorPress = async () => {
    setBackdoorPressed(backdoorPressed + 1);
    if (backdoorPressed < 5) return;
    setBackdoorPressed(0);
    setBackdoorVisible(true);
  };

  const render = isLoading ? (
    <MalinLoading />
  ) : (
    <View>
      {cameraStatusGranted === false ? (
        <View style={[styles.openSettingsContainer, stylesHook.openSettingsContainer]}>
          <MalinText>{loc.send.permission_camera_message}</MalinText>
          <MalinSpacing40 />
          <Button title={loc.send.open_settings} onPress={openPrivacyDesktopSettings} />
          <MalinSpacing40 />
          {showFileImportButton && <Button title={loc.wallets.import_file} onPress={showFilePicker} />}
          <MalinSpacing40 />
          <Button title={loc.wallets.list_long_choose} onPress={onShowImagePickerButtonPress} />
          <MalinSpacing40 />
          <Button title={loc._.cancel} onPress={dismiss} />
        </View>
      ) : isFocused && cameraStatusGranted ? (
        <CameraScreen
          onReadCode={handleReadCode}
          showFilePickerButton={showFileImportButton}
          showImagePickerButton={true}
          onFilePickerButtonPress={showFilePicker}
          onImagePickerButtonPress={onShowImagePickerButtonPress}
          onCancelButtonPress={dismiss}
        />
      ) : null}
      {urTotal > 0 && (
        <View style={[styles.progressWrapper, stylesHook.progressWrapper]} testID="UrProgressBar">
          <MalinText>{loc.wallets.please_continue_scanning}</MalinText>
          <MalinText>
            {urHave} / {urTotal}
          </MalinText>
        </View>
      )}
      {backdoorVisible && (
        <View style={styles.backdoorInputWrapper}>
          <MalinText>Provide QR code contents manually:</MalinText>
          <TextInput
            testID="scanQrBackdoorInput"
            multiline
            underlineColorAndroid="transparent"
            style={[styles.backdoorInput, stylesHook.backdoorInput]}
            autoCorrect={false}
            autoCapitalize="none"
            spellCheck={false}
            selectTextOnFocus={false}
            keyboardType={Platform.OS === 'android' ? 'visible-password' : 'default'}
            value={backdoorText}
            onChangeText={setBackdoorText}
          />
          <Button title="OK" testID="scanQrBackdoorOkButton" onPress={handleBackdoorOkPress} />
        </View>
      )}
      <TouchableOpacity
        accessibilityRole="button"
        accessibilityLabel={loc._.qr_custom_input_button}
        testID="ScanQrBackdoorButton"
        style={styles.backdoorButton}
        onPress={handleInvisibleBackdoorPress}
      />
    </View>
  );

  return <SafeArea style={styles.root}>{render}</SafeArea>;
};

export default ScanQRCode;


================================================
FILE: ./screen/send/SendDetails.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import { RouteProp, useFocusEffect, useRoute, useLocale } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { Icon } from '@rneui/themed';
import assert from 'assert';
import BigNumber from 'bignumber.js';
import { TOptions } from 'bip21';
import * as bitcoin from 'bitcoinjs-lib';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Dimensions,
  findNodeHandle,
  FlatList,
  Keyboard,
  LayoutAnimation,
  NativeScrollEvent,
  NativeSyntheticEvent,
  Platform,
  StyleSheet,
  Text,
  TextInput,
  Pressable,
  View,
} from 'react-native';
import RNFS from 'react-native-fs';
import { btcToSatoshi, fiatToBTC } from '../../malin_modules/currency';
import * as fs from '../../malin_modules/fs';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinText } from '../../MalinComponents';
import { HDSegwitBech32Wallet, MultisigHDWallet, WatchOnlyWallet } from '../../class';
import { ContactList } from '../../class/contact-list';
import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import { AbstractHDElectrumWallet } from '../../class/wallets/abstract-hd-electrum-wallet';
import { CreateTransactionTarget, CreateTransactionUtxo, TWallet } from '../../class/wallets/types';
import AddressInput from '../../components/AddressInput';
import presentAlert from '../../components/Alert';
import * as AmountInput from '../../components/AmountInput';
import Button from '../../components/Button';
import CoinsSelected from '../../components/CoinsSelected';
import { DismissKeyboardInputAccessory, DismissKeyboardInputAccessoryViewID } from '../../components/DismissKeyboardInputAccessory';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import InputAccessoryAllFunds, { InputAccessoryAllFundsAccessoryViewID } from '../../components/InputAccessoryAllFunds';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import { Action } from '../../components/types';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useKeyboard } from '../../hooks/useKeyboard';
import loc, { formatBalance, formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import NetworkTransactionFees, { NetworkTransactionFee, NetworkTransactionFeeType } from '../../models/networkTransactionFees';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList';
import { CommonToolTipActions, ToolTipAction } from '../../typings/CommonToolTipActions';
import ActionSheet from '../ActionSheet';
import { isCancel, pickTransaction } from '../../malin_modules/fs';
import { Measure } from '../../class/measure';

interface IPaymentDestinations {
  address: string; // btc address or payment code
  amountSats?: number | string;
  amount?: string | number | 'MAX';
  key: string; // random id to look up this record
  unit: BitcoinUnit;
}

export interface IFee {
  current: number | null;
  slowFee: number | null;
  mediumFee: number | null;
  fastestFee: number | null;
}
type NavigationProps = NativeStackNavigationProp<SendDetailsStackParamList, 'SendDetails'>;
type RouteProps = RouteProp<SendDetailsStackParamList, 'SendDetails'>;

const SendDetails = () => {
  const { wallets, sleep, txMetadata, saveToDisk } = useStorage();
  const navigation = useExtendedNavigation<NavigationProps>();
  const { direction } = useLocale();
  const selectedDataProcessor = useRef<ToolTipAction | undefined>();
  const setParams = navigation.setParams;
  const route = useRoute<RouteProps>();
  const feeUnit = route.params?.feeUnit ?? BitcoinUnit.BTC;
  const amountUnit = route.params?.amountUnit ?? BitcoinUnit.BTC;
  const frozenBalance = route.params?.frozenBalance ?? 0;
  const transactionMemo = route.params?.transactionMemo;
  const utxos = route.params?.utxos;
  const payjoinUrl = route.params?.payjoinUrl;
  const isTransactionReplaceable = route.params?.isTransactionReplaceable;
  const routeParams = route.params;
  const scrollView = useRef<FlatList<any>>(null);
  const scrollIndex = useRef(0);
  const { colors } = useTheme();

  // state
  const [dimensions, setDimensions] = useState({ width: Dimensions.get('window').width, height: 0 });
  const [isLoading, setIsLoading] = useState(false);
  const [wallet, setWallet] = useState<TWallet | null>(null);
  const { isVisible } = useKeyboard();
  const [addresses, setAddresses] = useState<IPaymentDestinations[]>([{ address: '', key: String(Math.random()), unit: amountUnit }]);
  const [networkTransactionFees, setNetworkTransactionFees] = useState(new NetworkTransactionFee(3, 2, 1));
  const [networkTransactionFeesIsLoading, setNetworkTransactionFeesIsLoading] = useState(false);
  const [customFee, setCustomFee] = useState<string | null>(null);
  const [selectedPresetFeeRate, setSelectedPresetFeeRate] = useState<string | null>(null);
  const [feePrecalc, setFeePrecalc] = useState<IFee>({ current: null, slowFee: null, mediumFee: null, fastestFee: null });
  const [changeAddress, setChangeAddress] = useState<string | null>(null);
  const [dumb, setDumb] = useState(false);
  const { isEditable } = routeParams;
  // if utxo is limited we use it to calculate available balance
  const balance: number = utxos ? utxos.reduce((prev, curr) => prev + curr.value, 0) : (wallet?.getBalance() ?? 0);
  const allBalance = formatBalanceWithoutSuffix(balance, BitcoinUnit.BTC, true);

  // if cutomFee is not set, we need to choose highest possible fee for wallet balance
  // if there are no funds for even Slow option, use 1 sat/vbyte fee
  const feeRate = useMemo(() => {
    console.log('SendDetails: feeRate useMemo - customFee:', customFee);
    console.log('SendDetails: feeRate useMemo - selectedPresetFeeRate:', selectedPresetFeeRate);
    console.log('SendDetails: feeRate useMemo - feePrecalc:', feePrecalc);
    console.log('SendDetails: feeRate useMemo - networkTransactionFees:', networkTransactionFees);

    if (customFee) {
      console.log('SendDetails: Using customFee:', customFee);
      return customFee;
    }

    if (selectedPresetFeeRate) {
      console.log('SendDetails: Using selectedPresetFeeRate:', selectedPresetFeeRate);
      return selectedPresetFeeRate;
    }

    // If we have precalculated fees, use them to determine the default fee
    if (feePrecalc.slowFee !== null) {
      let initialFee;
      if (feePrecalc.fastestFee !== null) {
        initialFee = String(networkTransactionFees.fastestFee);
        console.log('SendDetails: Using fastestFee:', initialFee);
      } else if (feePrecalc.mediumFee !== null) {
        initialFee = String(networkTransactionFees.mediumFee);
        console.log('SendDetails: Using mediumFee:', initialFee);
      } else {
        initialFee = String(networkTransactionFees.slowFee);
        console.log('SendDetails: Using slowFee:', initialFee);
      }
      console.log('SendDetails: Final feeRate:', initialFee);
      return initialFee;
    }

    // If no precalc fees yet, default to fastestFee from network fees
    const defaultFee = String(networkTransactionFees.fastestFee);
    console.log('SendDetails: No precalc fees yet, using default networkTransactionFees.fastestFee:', defaultFee);
    return defaultFee;
  }, [customFee, selectedPresetFeeRate, feePrecalc, networkTransactionFees]);

  useEffect(() => {
    // decode route params
    const currentAddress = addresses[scrollIndex.current];
    if (routeParams.uri) {
      try {
        const { address, amount, memo, payjoinUrl: pjUrl } = DeeplinkSchemaMatch.decodeBitcoinUri(routeParams.uri);

        setAddresses(addrs => {
          addrs[scrollIndex.current].unit = BitcoinUnit.BTC;
          return [...addrs];
        });

        setAddresses(addrs => {
          if (currentAddress) {
            currentAddress.address = address;
            if (Number(amount) > 0) {
              currentAddress.amount = amount!;
              currentAddress.amountSats = btcToSatoshi(amount!);
            }
            addrs[scrollIndex.current] = currentAddress;
            return [...addrs];
          } else {
            return [...addrs, { address, amount, amountSats: btcToSatoshi(amount!), key: String(Math.random()), unit: amountUnit }];
          }
        });

        if (memo?.trim().length > 0) {
          setParams({ transactionMemo: memo });
        }
        setParams({ payjoinUrl: pjUrl, amountUnit: BitcoinUnit.BTC });
      } catch (error) {
        console.log(error);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ title: loc.errors.error, message: loc.send.details_error_decode });
      }
    } else if (routeParams.address) {
      // screen was called with `address` parameter, so we just prefill it
      setAddresses(prevAddresses => {
        const updatedAddresses = [...prevAddresses];
        updatedAddresses[0] = {
          ...updatedAddresses[0],
          address: routeParams.address!,
          amount: 0,
          amountSats: 0,
        };
        return updatedAddresses;
      });
    } else if (routeParams.addRecipientParams) {
      // used to add a recipient, mainly from contacts aka paymentcodes screen
      const index = addresses.length === 0 ? 0 : scrollIndex.current;
      const { address, amount } = routeParams.addRecipientParams;

      setAddresses(prevAddresses => {
        const updatedAddresses = [...prevAddresses];
        if (address) {
          updatedAddresses[index] = {
            ...updatedAddresses[index],
            address,
            amount: amount ?? updatedAddresses[index].amount,
            amountSats: amount ? btcToSatoshi(amount) : updatedAddresses[index].amountSats,
          };
        }
        return updatedAddresses;
      });

      // @ts-ignore: Fix later
      setParams(prevParams => ({ ...prevParams, addRecipientParams: undefined }));
    } else {
      setAddresses([{ address: '', key: String(Math.random()), unit: amountUnit }]); // key is for the FlatList
    }
    // this effect only to run once when screen is mounted or params change
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [routeParams.uri, routeParams.address, routeParams.addRecipientParams]);

  useEffect(() => {
    // check if we have a suitable wallet
    const suitable = wallets.filter(w => w.chain === Chain.ONCHAIN && w.allowSend());
    if (suitable.length === 0) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ title: loc.errors.error, message: loc.send.details_wallet_before_tx });
      navigation.goBack();
      return;
    }
    const newWallet = (routeParams.walletID && wallets.find(w => w.getID() === routeParams.walletID)) || suitable[0];
    setWallet(newWallet);
    setParams({ feeUnit: newWallet.getPreferredBalanceUnit(), amountUnit: newWallet.getPreferredBalanceUnit() });

    // we are ready!
    setIsLoading(false);

    // load cached fees
    AsyncStorage.getItem(NetworkTransactionFee.StorageKey)
      .then(res => {
        if (!res) return;
        const fees = JSON.parse(res);
        if (!fees?.fastestFee) return;
        setNetworkTransactionFees(fees);
      })
      .catch(e => console.log('loading cached recommendedFees error', e));

    // load fresh fees from servers

    setNetworkTransactionFeesIsLoading(true);
    NetworkTransactionFees.recommendedFees()
      .then(async fees => {
        if (!fees?.fastestFee) return;
        setNetworkTransactionFees(fees);
        await AsyncStorage.setItem(NetworkTransactionFee.StorageKey, JSON.stringify(fees));
      })
      .catch(e => console.log('loading recommendedFees error', e))
      .finally(() => {
        setNetworkTransactionFeesIsLoading(false);
      });
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  // change header and reset state on wallet change
  useEffect(() => {
    if (!wallet) return;

    // reset other values
    setChangeAddress(null);
    setParams({
      utxos: null,
      isTransactionReplaceable: wallet.type === HDSegwitBech32Wallet.type && !routeParams.isTransactionReplaceable ? true : undefined,
    });
    // update wallet UTXO
    wallet
      .fetchUtxo()
      .then(() => {
        // we need to re-calculate fees
        setDumb(v => !v);
      })
      .catch(e => console.log('fetchUtxo error', e));
  }, [wallet]); // eslint-disable-line react-hooks/exhaustive-deps

  // recalc fees in effect so we don't block render
  useEffect(() => {
    if (!wallet) return; // wait for it
    const fees = networkTransactionFees;
    const requestedSatPerByte = Number(feeRate);
    const m = new Measure('getUtxo');
    const lutxo = utxos || wallet.getUtxo();
    m.end();
    let frozen = 0;
    if (!utxos) {
      // if utxo is not limited search for frozen outputs and calc it's balance
      frozen = wallet
        .getUtxo(true)
        .filter(o => !lutxo.some(i => i.txid === o.txid && i.vout === o.vout))
        .reduce((prev, curr) => prev + curr.value, 0);
    }

    const options = [
      { key: 'current', fee: requestedSatPerByte },
      { key: 'slowFee', fee: fees.slowFee },
      { key: 'mediumFee', fee: fees.mediumFee },
      { key: 'fastestFee', fee: fees.fastestFee },
    ] as const;

    const newFeePrecalc: /* Record<string, any> */ IFee = { ...feePrecalc };

    let targets = [];
    for (const transaction of addresses) {
      if (transaction.amount === BitcoinUnit.MAX) {
        // single output with MAX
        targets = [{ address: transaction.address }];
        break;
      }
      const value = transaction.amountSats;
      if (Number(value) > 0) {
        targets.push({ address: transaction.address, value });
      } else if (transaction.amount) {
        if (btcToSatoshi(transaction.amount) > 0) {
          targets.push({ address: transaction.address, value: btcToSatoshi(transaction.amount) });
        }
      }
    }

    // if targets is empty, insert dust
    if (targets.length === 0) {
      targets.push({ address: '36JxaUrpDzkEerkTf1FzwHNE1Hb7cCjgJV', value: 546 });
    }

    // replace wrong addresses with dump
    targets = targets.map(t => {
      if (!wallet.isAddressValid(t.address)) {
        return { ...t, address: '36JxaUrpDzkEerkTf1FzwHNE1Hb7cCjgJV' };
      } else {
        return t;
      }
    });

    for (const opt of options) {
      let flag = false;
      while (true) {
        try {
          const { fee } = wallet.coinselect(lutxo, targets, opt.fee);
          newFeePrecalc[opt.key] = fee;
          break;
        } catch (e: any) {
          if (e.message.includes('Not enough') && !flag) {
            flag = true;
            targets = targets.map((t, index) => (index > 0 ? { ...t, value: 546 } : { address: t.address }));
            continue;
          }
          newFeePrecalc[opt.key] = null;
          break;
        }
      }
    }

    setFeePrecalc(newFeePrecalc);
    setParams({ frozenBalance: frozen });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [wallet, networkTransactionFees, utxos, addresses, feeRate, dumb]);

  // we need to re-calculate fees if user opens-closes coin control
  useFocusEffect(
    useCallback(() => {
      setIsLoading(false);
      setDumb(v => !v);
      return () => {};
    }, []),
  );

  const handleLayout = (event: any) => {
    const { width, height } = event.nativeEvent.layout;
    setDimensions({ width, height });
  };

  const getChangeAddressAsync = async () => {
    if (changeAddress) return changeAddress; // cache

    let change;
    if (WatchOnlyWallet.type === wallet?.type && !wallet.isHd()) {
      // plain watchonly - just get the address
      change = wallet.getAddress();
    } else {
      // otherwise, lets call widely-used getChangeAddressAsync()
      try {
        change = await Promise.race([sleep(2000), wallet?.getChangeAddressAsync()]);
      } catch (_) {}

      if (!change) {
        // either sleep expired or getChangeAddressAsync threw an exception
        if (wallet instanceof AbstractHDElectrumWallet) {
          change = wallet._getInternalAddressByIndex(wallet.getNextFreeChangeAddressIndex());
        } else {
          // legacy wallets
          change = wallet?.getAddress();
        }
      }
    }

    if (change) setChangeAddress(change); // cache

    return change;
  };
  /**
   * TODO: refactor this mess, get rid of regexp, use https://github.com/bitcoinjs/bitcoinjs-lib/issues/890 etc etc
   *
   * @param data {String} Can be address or `bitcoin:xxxxxxx` uri scheme, or invalid garbage
   */

  const processAddressData = useCallback(
    (data: string | { data?: any }) => {
      assert(wallet, 'Internal error: wallet not set');
      if (typeof data !== 'string') {
        data = String(data.data);
      }
      const currentIndex = scrollIndex.current;
      setIsLoading(true);
      if (!data.replace) {
        // user probably scanned PSBT and got an object instead of string..?
        setIsLoading(false);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        return presentAlert({ title: loc.errors.error, message: loc.send.details_address_field_is_not_valid });
      }

      const cl = new ContactList();

      const dataWithoutSchema = data.replace('bitcoin:', '').replace('BITCOIN:', '');
      if (wallet.isAddressValid(dataWithoutSchema) || cl.isPaymentCodeValid(dataWithoutSchema)) {
        setAddresses(addrs => {
          addrs[scrollIndex.current].address = dataWithoutSchema;
          return [...addrs];
        });
        setIsLoading(false);
        setTimeout(() => scrollView.current?.scrollToIndex({ index: currentIndex, animated: false }), 50);
        return;
      }

      let address = '';
      let options: TOptions;
      try {
        if (!data.toLowerCase().startsWith('bitcoin:')) data = `bitcoin:${data}`;
        const decoded = DeeplinkSchemaMatch.bip21decode(data);
        address = decoded.address;
        options = decoded.options;
      } catch (error) {
        data = data.replace(/(amount)=([^&]+)/g, '').replace(/(amount)=([^&]+)&/g, '');
        const decoded = DeeplinkSchemaMatch.bip21decode(data);
        decoded.options.amount = 0;
        address = decoded.address;
        options = decoded.options;
      }

      console.log('options', options);
      if (wallet.isAddressValid(address)) {
        setAddresses(addrs => {
          addrs[scrollIndex.current].address = address;
          addrs[scrollIndex.current].amount = options?.amount ?? 0;
          addrs[scrollIndex.current].amountSats = new BigNumber(options?.amount ?? 0).multipliedBy(100000000).toNumber();
          return [...addrs];
        });
        setAddresses(addrs => {
          addrs[scrollIndex.current].unit = BitcoinUnit.BTC;
          return [...addrs];
        });
        setParams({ transactionMemo: options.label || '', amountUnit: BitcoinUnit.BTC, payjoinUrl: options.pj || '' }); // there used to be `options.message` here as well. bug?
        // RN Bug: contentOffset gets reset to 0 when state changes. Remove code once this bug is resolved.
        setTimeout(() => scrollView.current?.scrollToIndex({ index: currentIndex, animated: false }), 50);
      }

      setIsLoading(false);
    },
    [setParams, wallet],
  );

  const createTransaction = async () => {
    assert(wallet, 'Internal error: wallet is not set');
    Keyboard.dismiss();
    setIsLoading(true);
    const requestedSatPerByte = feeRate;
    for (const [index, transaction] of addresses.entries()) {
      let error;
      if (!transaction.amount || Number(transaction.amount) < 0 || parseFloat(String(transaction.amount)) === 0) {
        error = loc.send.details_amount_field_is_not_valid;
        console.log('validation error');
      } else if (parseFloat(String(transaction.amountSats)) <= 500) {
        error = loc.send.details_amount_field_is_less_than_minimum_amount_sat;
        console.log('validation error');
      } else if (!requestedSatPerByte || parseFloat(requestedSatPerByte) < 0) {
        error = loc.send.details_fee_field_is_not_valid;
        console.log('validation error');
      } else if (!transaction.address) {
        error = loc.send.details_address_field_is_not_valid;
        console.log('validation error');
      } else if (balance - Number(transaction.amountSats) < 0) {
        // first sanity check is that sending amount is not bigger than available balance
        error = frozenBalance > 0 ? loc.send.details_total_exceeds_balance_frozen : loc.send.details_total_exceeds_balance;
        console.log('validation error');
      } else if (transaction.address) {
        const address = transaction.address.trim().toLowerCase();
        if (address.startsWith('lnb') || address.startsWith('lightning:lnb')) {
          error = loc.send.provided_address_is_invoice;
          console.log('validation error');
        }
      }

      if (!error) {
        const cl = new ContactList();
        if (!wallet.isAddressValid(transaction.address) && !cl.isPaymentCodeValid(transaction.address)) {
          console.log('validation error');
          error = loc.send.details_address_field_is_not_valid;
        }
      }

      // validating payment codes, if any
      if (!error) {
        if (transaction.address.startsWith('sp1')) {
          if (!wallet.allowSilentPaymentSend()) {
            console.log('validation error');
            error = loc.send.cant_send_to_silentpayment_adress;
          }
        }

        if (transaction.address.startsWith('PM')) {
          if (!wallet.allowBIP47()) {
            console.log('validation error');
            error = loc.send.cant_send_to_bip47;
          } else if (!(wallet as unknown as AbstractHDElectrumWallet).getBIP47NotificationTransaction(transaction.address)) {
            console.log('validation error');
            error = loc.send.cant_find_bip47_notification;
          } else {
            // BIP47 is allowed, notif tx is in place, lets sync joint addresses with the receiver
            await (wallet as unknown as AbstractHDElectrumWallet).syncBip47ReceiversAddresses(transaction.address);
          }
        }
      }

      if (error) {
        // Scroll to the recipient that caused the error with animation
        scrollView.current?.scrollToIndex({ index, animated: true });
        setIsLoading(false);
        presentAlert({
          title:
            addresses.length > 1
              ? loc.formatString(loc.send.details_recipient_title, { number: index + 1, total: addresses.length })
              : undefined,
          message: error,
        });
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        return;
      }
    }

    try {
      await createPsbtTransaction();
    } catch (Err: any) {
      setIsLoading(false);
      presentAlert({ title: loc.errors.error, message: Err.message });
      console.log(Err);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
    }
  };
  const navigateToQRCodeScanner = useCallback(() => {
    navigation.navigate('ScanQRCode', {
      showFileImportButton: true,
    });
  }, [navigation]);

  const createPsbtTransaction = async () => {
    if (!wallet) return;
    const change = await getChangeAddressAsync();
    assert(change, 'Could not get change address');
    const requestedSatPerByte = Number(feeRate);
    const lutxo: CreateTransactionUtxo[] = utxos || (wallet?.getUtxo() ?? []);
    console.log({ requestedSatPerByte, lutxo: lutxo.length });

    const targets: CreateTransactionTarget[] = [];
    for (const transaction of addresses) {
      if (transaction.amount === BitcoinUnit.MAX) {
        // output with MAX
        targets.push({ address: transaction.address });
        continue;
      }
      const value = parseInt(String(transaction.amountSats), 10);
      if (value > 0) {
        targets.push({ address: transaction.address, value });
      } else if (transaction.amount) {
        if (btcToSatoshi(transaction.amount) > 0) {
          targets.push({ address: transaction.address, value: btcToSatoshi(transaction.amount) });
        }
      }
    }

    const targetsOrig = JSON.parse(JSON.stringify(targets));
    // preserving original since it will be mutated

    // without forcing `HDSegwitBech32Wallet` i had a weird ts error, complaining about last argument (fp)
    const { tx, outputs, psbt, fee } = (wallet as HDSegwitBech32Wallet)?.createTransaction(
      lutxo,
      targets,
      requestedSatPerByte,
      change,
      isTransactionReplaceable ? HDSegwitBech32Wallet.defaultRBFSequence : HDSegwitBech32Wallet.finalRBFSequence,
      false,
      0,
    );

    if (tx && routeParams.launchedBy && psbt) {
      console.warn('navigating back to ', routeParams.launchedBy);

      // @ts-ignore idk how to fix FIXME?

      navigation.navigate(routeParams.launchedBy, { psbt });
    }

    if (wallet?.type === WatchOnlyWallet.type) {
      // watch-only wallets with enabled HW wallet support have different flow. we have to show PSBT to user as QR code
      // so he can scan it and sign it. then we have to scan it back from user (via camera and QR code), and ask
      // user whether he wants to broadcast it
      navigation.navigate('PsbtWithHardwareWallet', {
        memo: transactionMemo,
        walletID: wallet.getID(),
        psbt,
        launchedBy: routeParams.launchedBy,
      });
      setIsLoading(false);
      return;
    }

    if (wallet?.type === MultisigHDWallet.type) {
      navigation.navigate('PsbtMultisig', {
        memo: transactionMemo,
        psbtBase64: psbt.toBase64(),
        walletID: wallet.getID(),
        launchedBy: routeParams.launchedBy,
      });
      setIsLoading(false);
      return;
    }

    assert(tx, 'createTRansaction failed');

    txMetadata[tx.getId()] = {
      memo: transactionMemo,
    };
    await saveToDisk();

    let recipients = outputs.filter(({ address }) => address !== change);

    if (recipients.length === 0) {
      // special case. maybe the only destination in this transaction is our own change address..?
      // (ez can be the case for single-address wallet when doing self-payment for consolidation)
      recipients = outputs;
    }

    navigation.navigate('Confirm', {
      fee: new BigNumber(fee).dividedBy(100000000).toNumber(),
      memo: transactionMemo,
      walletID: wallet.getID(),
      tx: tx.toHex(),
      targets: targetsOrig,
      recipients,
      satoshiPerByte: requestedSatPerByte,
      payjoinUrl,
      psbt,
    });
    setIsLoading(false);
  };

  useEffect(() => {
    const newWallet = wallets.find(w => w.getID() === routeParams.walletID);
    if (newWallet) {
      setWallet(newWallet);
    }
  }, [routeParams.walletID, wallets]);

  const setTransactionMemo = (memo: string) => {
    setParams({ transactionMemo: memo });
  };

  /**
   * same as `importTransaction`, but opens camera instead.
   *
   * @returns {Promise<void>}
   */
  const importQrTransaction = useCallback(async () => {
    if (wallet?.type !== WatchOnlyWallet.type) {
      return presentAlert({ title: loc.errors.error, message: 'Importing transaction in non-watchonly wallet (this should never happen)' });
    }

    navigateToQRCodeScanner();
  }, [navigateToQRCodeScanner, wallet?.type]);

  const importQrTransactionOnBarScanned = useCallback(
    (ret: any) => {
      if (!wallet) return;
      if (!ret.data) ret = { data: ret };
      if (ret.data.toUpperCase().startsWith('UR')) {
        presentAlert({ title: loc.errors.error, message: 'BC-UR not decoded. This should never happen' });
      } else if (ret.data.indexOf('+') === -1 && ret.data.indexOf('=') === -1 && ret.data.indexOf('=') === -1) {
        // this looks like NOT base64, so maybe its transaction's hex
        // we dont support it in this flow
      } else {
        // psbt base64?

        // we construct PSBT object and pass to next screen
        // so user can do smth with it:
        const psbt = bitcoin.Psbt.fromBase64(ret.data);

        navigation.navigate('PsbtWithHardwareWallet', {
          memo: transactionMemo,
          walletID: wallet.getID(),
          psbt,
        });

        setIsLoading(false);
      }
    },
    [navigation, transactionMemo, wallet],
  );

  /**
   * watch-only wallets with enabled HW wallet support have different flow. we have to show PSBT to user as QR code
   * so he can scan it and sign it. then we have to scan it back from user (via camera and QR code), and ask
   * user whether he wants to broadcast it.
   * alternatively, user can export psbt file, sign it externally and then import it
   *
   * @returns {Promise<void>}
   */
  const importTransaction = useCallback(async () => {
    if (wallet?.type !== WatchOnlyWallet.type) {
      return presentAlert({ title: loc.errors.error, message: 'Importing transaction in non-watchonly wallet (this should never happen)' });
    }

    try {
      const res = await pickTransaction();

      if (DeeplinkSchemaMatch.isPossiblySignedPSBTFile(res.uri)) {
        // we assume that transaction is already signed, so all we have to do is get txhex and pass it to next screen
        // so user can broadcast:
        const file = await RNFS.readFile(res.uri, 'ascii');
        const psbt = bitcoin.Psbt.fromBase64(file);
        const txhex = psbt.extractTransaction().toHex();
        navigation.navigate('PsbtWithHardwareWallet', { memo: transactionMemo, walletID: wallet.getID(), txhex });
        setIsLoading(false);

        return;
      }

      if (DeeplinkSchemaMatch.isPossiblyPSBTFile(res.uri)) {
        // looks like transaction is UNsigned, so we construct PSBT object and pass to next screen
        // so user can do smth with it:
        const file = await RNFS.readFile(res.uri, 'ascii');
        const psbt = bitcoin.Psbt.fromBase64(file);
        navigation.navigate('PsbtWithHardwareWallet', { memo: transactionMemo, walletID: wallet.getID(), psbt });
        setIsLoading(false);

        return;
      }

      if (DeeplinkSchemaMatch.isTXNFile(res.uri)) {
        // plain text file with txhex ready to broadcast
        const file = (await RNFS.readFile(res.uri, 'ascii')).replace('\n', '').replace('\r', '');
        navigation.navigate('PsbtWithHardwareWallet', { memo: transactionMemo, walletID: wallet.getID(), txhex: file });
        setIsLoading(false);

        return;
      }

      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ title: loc.errors.error, message: loc.send.details_unrecognized_file_format });
    } catch (err) {
      if (!isCancel(err)) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ title: loc.errors.error, message: loc.send.details_no_signed_tx });
      }
    }
  }, [navigation, setIsLoading, transactionMemo, wallet]);

  const askCosignThisTransaction = async () => {
    return new Promise(resolve => {
      Alert.alert(
        '',
        loc.multisig.cosign_this_transaction,
        [
          {
            text: loc._.no,
            style: 'cancel',
            onPress: () => resolve(false),
          },
          {
            text: loc._.yes,
            onPress: () => resolve(true),
          },
        ],
        { cancelable: false },
      );
    });
  };

  const _importTransactionMultisig = useCallback(
    async (base64arg: string | false) => {
      try {
        const base64 = base64arg || (await fs.openSignedTransaction());
        if (!base64) return;
        const psbt = bitcoin.Psbt.fromBase64(base64); // if it doesnt throw - all good, its valid

        if ((wallet as MultisigHDWallet)?.howManySignaturesCanWeMake() > 0 && (await askCosignThisTransaction())) {
          setIsLoading(true);
          await sleep(100);
          (wallet as MultisigHDWallet).cosignPsbt(psbt);
          setIsLoading(false);
          await sleep(100);
        }

        if (wallet) {
          navigation.navigate('PsbtMultisig', {
            memo: transactionMemo,
            psbtBase64: psbt.toBase64(),
            walletID: wallet.getID(),
          });
        }
      } catch (error: any) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ title: loc.send.problem_with_psbt, message: error.message });
      }
      setIsLoading(false);
    },
    [navigation, sleep, transactionMemo, wallet],
  );

  const importTransactionMultisig = useCallback(() => {
    return _importTransactionMultisig(false);
  }, [_importTransactionMultisig]);

  const onBarScanned = useCallback(
    (ret: any) => {
      if (!ret.data) ret = { data: ret };
      if (ret.data.toUpperCase().startsWith('UR')) {
        presentAlert({ title: loc.errors.error, message: 'BC-UR not decoded. This should never happen' });
      } else if (ret.data.indexOf('+') === -1 && ret.data.indexOf('=') === -1 && ret.data.indexOf('=') === -1) {
        // this looks like NOT base64, so maybe its transaction's hex
        // we dont support it in this flow
      } else {
        // psbt base64?
        return _importTransactionMultisig(ret.data);
      }
    },
    [_importTransactionMultisig],
  );

  const handlePsbtSign = useCallback(
    async (psbtBase64: string) => {
      let tx;
      let psbt;
      try {
        psbt = bitcoin.Psbt.fromBase64(psbtBase64);
        tx = (wallet as MultisigHDWallet).cosignPsbt(psbt).tx;
      } catch (e: any) {
        console.log(e);
        presentAlert({ title: loc.errors.error, message: e.message });
        return;
      } finally {
        setIsLoading(false);
      }

      if (!tx || !wallet) return setIsLoading(false);

      // we need to remove change address from recipients, so that Confirm screen show more accurate info
      const changeAddresses: string[] = [];
      // @ts-ignore hacky
      for (let c = 0; c < wallet.next_free_change_address_index + wallet.gap_limit; c++) {
        // @ts-ignore hacky
        changeAddresses.push(wallet._getInternalAddressByIndex(c));
      }
      const recipients = psbt.txOutputs
        .filter(({ address }) => !changeAddresses.includes(String(address)))
        .map(recipient => ({ ...recipient, value: Number(recipient.value) }));

      navigation.navigate('CreateTransaction', {
        fee: Number(new BigNumber(psbt.getFee()).dividedBy(100000000).toNumber()),
        feeSatoshi: Number(psbt.getFee()),
        tx: tx.toHex(),
        recipients,
        satoshiPerByte: psbt.getFeeRate(),
        showAnimatedQr: true,
        psbt,
      });
    },
    [navigation, wallet],
  );

  useEffect(() => {
    const data = routeParams.onBarScanned;
    if (data) {
      if (selectedDataProcessor.current) {
        console.debug('SendDetails - selectedDataProcessor:', selectedDataProcessor.current);
        switch (selectedDataProcessor.current) {
          case CommonToolTipActions.ImportTransactionQR:
            importQrTransactionOnBarScanned(data);
            break;
          case CommonToolTipActions.SignPSBT:
            handlePsbtSign(data);
            break;
          case CommonToolTipActions.CoSignTransaction:
          case CommonToolTipActions.ImportTransactionMultsig:
            _importTransactionMultisig(data);
            break;
          case CommonToolTipActions.ImportTransaction:
            processAddressData(data);
            break;
          default:
            console.debug('Unknown selectedDataProcessor:', selectedDataProcessor.current);
        }
      } else {
        processAddressData(data);
      }
    }
    selectedDataProcessor.current = undefined;
    setParams({ onBarScanned: undefined });
  }, [
    importQrTransactionOnBarScanned,
    onBarScanned,
    routeParams.onBarScanned,
    setParams,
    processAddressData,
    _importTransactionMultisig,
    handlePsbtSign,
  ]);

  const handleAddRecipient = useCallback(() => {
    // Check if any recipient is incomplete (missing address or amount)
    const incompleteIndex = addresses.findIndex(item => !item.address || !item.amount);
    if (incompleteIndex !== -1) {
      scrollIndex.current = incompleteIndex;
      scrollView.current?.scrollToIndex({ index: incompleteIndex, animated: true });
      presentAlert({
        title: loc.send.please_complete_recipient_title,
        message: loc.formatString(loc.send.please_complete_recipient_details, { number: incompleteIndex + 1 }),
      });
      return;
    }
    // Add new recipient as usual if all recipients are complete
    setAddresses(prevAddresses => [...prevAddresses, { address: '', key: String(Math.random()), unit: amountUnit }]);
    // Wait for the state to update before scrolling
    setTimeout(() => {
      scrollIndex.current = addresses.length; // New index at the end
      scrollView.current?.scrollToIndex({
        index: scrollIndex.current,
        animated: true,
      });
    }, 0);
  }, [addresses, amountUnit]);

  const onRemoveAllRecipientsConfirmed = useCallback(() => {
    setAddresses([{ address: '', key: String(Math.random()), unit: amountUnit }]);
  }, [amountUnit]);

  const handleRemoveAllRecipients = useCallback(() => {
    Alert.alert(loc.send.details_recipients_title, loc.send.details_add_recc_rem_all_alert_description, [
      {
        text: loc._.cancel,
        onPress: () => {},
        style: 'cancel',
      },
      {
        text: loc._.ok,
        onPress: onRemoveAllRecipientsConfirmed,
      },
    ]);
  }, [onRemoveAllRecipientsConfirmed]);

  const handleRemoveRecipient = useCallback(() => {
    if (addresses.length > 1) {
      const newAddresses = [...addresses];
      newAddresses.splice(scrollIndex.current, 1);

      // Adjust the current index if the last item was removed
      const newIndex = scrollIndex.current >= newAddresses.length ? newAddresses.length - 1 : scrollIndex.current;

      setAddresses(newAddresses);

      // Wait for the state to update before scrolling
      setTimeout(() => {
        scrollView.current?.scrollToIndex({
          index: newIndex,
          animated: true,
        });
      }, 0);

      // Update the scroll index reference
      scrollIndex.current = newIndex;
    }
  }, [addresses]);

  const handleCoinControl = useCallback(() => {
    if (!wallet) return;
    navigation.navigate('CoinControl', {
      walletID: wallet?.getID(),
    });
  }, [navigation, wallet]);

  const handleInsertContact = useCallback(() => {
    if (!wallet) return;
    navigation.navigate('PaymentCodeList', { walletID: wallet.getID() });
  }, [navigation, wallet]);

  const onReplaceableFeeSwitchValueChanged = useCallback(
    (value: boolean) => {
      setParams({ isTransactionReplaceable: value });
    },
    [setParams],
  );

  const onUseAllPressed = useCallback(() => {
    triggerHapticFeedback(HapticFeedbackTypes.NotificationWarning);
    const message = frozenBalance > 0 ? loc.send.details_adv_full_sure_frozen : loc.send.details_adv_full_sure;

    const anchor = findNodeHandle(scrollView.current);
    const options = {
      title: loc.send.details_adv_full,
      message,
      options: [loc._.cancel, loc._.ok],
      cancelButtonIndex: 0,
      anchor: anchor ?? undefined,
    };

    ActionSheet.showActionSheetWithOptions(options, buttonIndex => {
      if (buttonIndex === 1) {
        Keyboard.dismiss();
        setAddresses(addrs => {
          addrs[scrollIndex.current].amount = BitcoinUnit.MAX;
          addrs[scrollIndex.current].amountSats = BitcoinUnit.MAX;
          return [...addrs];
        });
        setAddresses(addrs => {
          addrs[scrollIndex.current].unit = BitcoinUnit.BTC;
          return [...addrs];
        });
      }
    });
  }, [frozenBalance]);
  // Header Right Button

  const headerRightOnPress = useCallback(
    (id: string) => {
      Keyboard.dismiss();
      if (id === CommonToolTipActions.AddRecipient.id) {
        handleAddRecipient();
      } else if (id === CommonToolTipActions.RemoveRecipient.id) {
        handleRemoveRecipient();
      } else if (id === CommonToolTipActions.SignPSBT.id) {
        selectedDataProcessor.current = CommonToolTipActions.SignPSBT;
        navigateToQRCodeScanner();
      } else if (id === CommonToolTipActions.SendMax.id) {
        onUseAllPressed();
      } else if (id === CommonToolTipActions.AllowRBF.id) {
        onReplaceableFeeSwitchValueChanged(!isTransactionReplaceable);
      } else if (id === CommonToolTipActions.ImportTransaction.id) {
        selectedDataProcessor.current = CommonToolTipActions.ImportTransaction;
        importTransaction();
      } else if (id === CommonToolTipActions.ImportTransactionQR.id) {
        selectedDataProcessor.current = CommonToolTipActions.ImportTransactionQR;
        importQrTransaction();
      } else if (id === CommonToolTipActions.ImportTransactionMultsig.id) {
        selectedDataProcessor.current = CommonToolTipActions.ImportTransactionMultsig;
        importTransactionMultisig();
      } else if (id === CommonToolTipActions.CoSignTransaction.id) {
        selectedDataProcessor.current = CommonToolTipActions.CoSignTransaction;
        navigateToQRCodeScanner();
      } else if (id === CommonToolTipActions.CoinControl.id) {
        handleCoinControl();
      } else if (id === CommonToolTipActions.InsertContact.id) {
        handleInsertContact();
      } else if (id === CommonToolTipActions.RemoveAllRecipients.id) {
        handleRemoveAllRecipients();
      }
    },
    [
      handleAddRecipient,
      handleRemoveRecipient,
      navigateToQRCodeScanner,
      onUseAllPressed,
      onReplaceableFeeSwitchValueChanged,
      isTransactionReplaceable,
      importTransaction,
      importQrTransaction,
      importTransactionMultisig,
      handleCoinControl,
      handleInsertContact,
      handleRemoveAllRecipients,
    ],
  );

  const headerRightActions = useCallback(() => {
    if (!wallet) return [];

    const walletActions: Action[][] = [];

    const recipientActions: Action[] = [
      CommonToolTipActions.AddRecipient,
      {
        ...CommonToolTipActions.RemoveRecipient,
        hidden: addresses.length <= 1,
      },
      {
        ...CommonToolTipActions.RemoveAllRecipients,
        hidden: !(addresses.length > 1),
      },
    ];
    walletActions.push(recipientActions);

    const isSendMaxUsed = addresses.some(element => element.amount === BitcoinUnit.MAX);
    const sendMaxAction: Action[] = [
      {
        ...CommonToolTipActions.SendMax,
        disabled: wallet.getBalance() === 0 || isSendMaxUsed,
        hidden: !isEditable || !(Number(wallet.getBalance()) > 0),
      },
    ];
    walletActions.push(sendMaxAction);

    const rbfAction: Action[] = [
      {
        ...CommonToolTipActions.AllowRBF,
        menuState: isTransactionReplaceable,
        hidden: !(wallet.type === HDSegwitBech32Wallet.type && isTransactionReplaceable !== undefined),
      },
    ];
    walletActions.push(rbfAction);

    const transactionActions: Action[] = [
      {
        ...CommonToolTipActions.ImportTransaction,
        hidden: !(wallet.type === WatchOnlyWallet.type && wallet.isHd()),
      },
      {
        ...CommonToolTipActions.ImportTransactionQR,
        hidden: !(wallet.type === WatchOnlyWallet.type && wallet.isHd()),
      },
      {
        ...CommonToolTipActions.ImportTransactionMultsig,
        hidden: !(wallet.type === MultisigHDWallet.type),
      },
      {
        ...CommonToolTipActions.CoSignTransaction,
        hidden: !(wallet.type === MultisigHDWallet.type && wallet.howManySignaturesCanWeMake() > 0),
      },
      {
        ...CommonToolTipActions.SignPSBT,
        hidden: !(wallet as MultisigHDWallet)?.allowCosignPsbt(),
      },
    ];
    walletActions.push(transactionActions);

    const specificWalletActions: Action[] = [
      {
        ...CommonToolTipActions.InsertContact,
        hidden: !(isEditable && wallet.allowBIP47() && wallet.isBIP47Enabled()),
      },
      CommonToolTipActions.CoinControl,
    ];
    walletActions.push(specificWalletActions);

    return walletActions;
  }, [addresses, isEditable, wallet, isTransactionReplaceable]);

  const HeaderRight = useCallback(
    () => <HeaderMenuButton disabled={isLoading} onPressMenuItem={headerRightOnPress} actions={headerRightActions()} />,
    [headerRightOnPress, isLoading, headerRightActions],
  );

  const setHeaderRightOptions = useCallback(() => {
    navigation.setOptions({
      headerRight: HeaderRight,
    });
  }, [HeaderRight, navigation]);

  useEffect(() => {
    console.log('send/details - useEffect');
    if (wallet) {
      setHeaderRightOptions();
    }
  }, [colors, wallet, isTransactionReplaceable, balance, addresses, isEditable, isLoading, setHeaderRightOptions]);

  // Handle selectedFeeRate and selectedFeeType returned from SelectFeeScreen
  useEffect(() => {
    const selectedFeeRate = routeParams.selectedFeeRate;
    const selectedFeeType = routeParams.selectedFeeType;

    console.log('SendDetails: Fee selection useEffect triggered');
    console.log('SendDetails: selectedFeeRate:', selectedFeeRate);
    console.log('SendDetails: selectedFeeType:', selectedFeeType);
    console.log('SendDetails: current customFee:', customFee);
    console.log('SendDetails: current selectedPresetFeeRate:', selectedPresetFeeRate);
    console.log('SendDetails: networkTransactionFees:', networkTransactionFees);

    if (selectedFeeRate !== undefined || selectedFeeType !== undefined) {
      console.log('SendDetails: Processing fee selection...');

      if (selectedFeeType === NetworkTransactionFeeType.CUSTOM) {
        console.log('SendDetails: CUSTOM fee selected, setting customFee to:', selectedFeeRate);
        // Custom fee was selected - set the custom fee rate and clear preset
        setCustomFee(selectedFeeRate || null);
        setSelectedPresetFeeRate(null);
      } else if (
        selectedFeeType === NetworkTransactionFeeType.FAST ||
        selectedFeeType === NetworkTransactionFeeType.MEDIUM ||
        selectedFeeType === NetworkTransactionFeeType.SLOW
      ) {
        console.log('SendDetails: Preset fee selected:', selectedFeeType);
        console.log('SendDetails: Setting selectedPresetFeeRate to:', selectedFeeRate);
        // Preset fee was selected - set the preset fee rate and clear custom fee
        setSelectedPresetFeeRate(selectedFeeRate || null);
        setCustomFee(null);
      }

      console.log('SendDetails: Clearing route params...');
      // Clear the parameters to prevent re-processing
      setParams({ selectedFeeRate: undefined, selectedFeeType: undefined });
    }
  }, [routeParams.selectedFeeRate, routeParams.selectedFeeType, networkTransactionFees, setParams, customFee, selectedPresetFeeRate]);

  const handleRecipientsScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {
    const contentOffset = e.nativeEvent.contentOffset;
    const viewSize = e.nativeEvent.layoutMeasurement;
    const index = Math.floor(contentOffset.x / viewSize.width);
    scrollIndex.current = index;
  };

  const formatFee = (fee: number) => formatBalance(fee, feeUnit!, true);

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    selectLabel: {
      color: colors.buttonTextColor,
    },
    of: {
      color: colors.feeText,
    },
    memo: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    feeLabel: {
      color: colors.feeText,
    },
    feeRow: {
      backgroundColor: colors.feeLabel,
    },
    feeValue: {
      color: colors.feeValue,
    },
    warningContainer: {
      backgroundColor: colors.changeBackground,
    },
    warningText: {
      color: colors.changeText,
    },
  });

  const calculateTotalAmount = () => {
    const totalAmount = addresses.reduce((total, item) => total + Number(item.amountSats || 0), 0);
    const totalWithFee = totalAmount + (feePrecalc.current || 0);
    return totalWithFee;
  };

  const renderCreateButton = () => {
    const totalWithFee = calculateTotalAmount();
    const isDisabled = totalWithFee === 0 || totalWithFee > balance || balance === 0 || isLoading || addresses.length === 0;

    return (
      <View style={styles.createButton}>
        {isLoading ? (
          <ActivityIndicator />
        ) : (
          <Button onPress={createTransaction} disabled={isDisabled} title={loc.send.details_next} testID="CreateTransactionButton" />
        )}
      </View>
    );
  };

  const renderWalletSelectionOrCoinsSelected = () => {
    if (isVisible) return null;
    if (utxos && utxos?.length > 0) {
      return (
        <View style={styles.select}>
          <CoinsSelected
            number={utxos.length}
            onContainerPress={handleCoinControl}
            onClose={() => {
              LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
              setParams({ utxos: null });
            }}
          />
        </View>
      );
    }

    return (
      <View style={styles.select}>
        {!isLoading && isEditable && (
          <Pressable
            accessibilityRole="button"
            style={({ pressed }) => [pressed && styles.pressed, styles.selectTouch]}
            onPress={() => {
              navigation.navigate('SelectWallet', { chainType: Chain.ONCHAIN, selectedWalletID: wallet?.getID() });
            }}
          >
            <Text style={styles.selectText}>{loc.wallets.select_wallet.toLowerCase()}</Text>
            <Icon name={direction === 'rtl' ? 'angle-left' : 'angle-right'} size={18} type="font-awesome" color="#9aa0aa" />
          </Pressable>
        )}
        <View style={styles.selectWrap}>
          <Pressable
            accessibilityRole="button"
            style={({ pressed }) => [pressed && styles.pressed, styles.selectTouch]}
            onPress={() => {
              navigation.navigate('SelectWallet', { chainType: Chain.ONCHAIN, selectedWalletID: wallet?.getID() });
            }}
            disabled={!isEditable || isLoading}
          >
            <Text style={[styles.selectLabel, stylesHook.selectLabel]}>{wallet?.getLabel()}</Text>
          </Pressable>
        </View>
      </View>
    );
  };

  const renderBitcoinTransactionInfoFields = (params: { item: IPaymentDestinations; index: number }) => {
    const { item, index } = params;
    return (
      <View style={[styles.transactionItemContainer, { width: dimensions.width }]} testID={'Transaction' + index}>
        <View style={styles.amountInputContainer}>
          <AmountInput.AmountInput
            isLoading={isLoading}
            amount={item.amount ? item.amount.toString() : undefined}
            onAmountUnitChange={(unit: BitcoinUnit) => {
              setAddresses(addrs => {
                const addr = addrs[index];

                switch (unit) {
                  case BitcoinUnit.SATS:
                    addr.amountSats = parseInt(String(addr.amount), 10);
                    break;
                  case BitcoinUnit.BTC:
                    addr.amountSats = btcToSatoshi(String(addr.amount));
                    break;
                  case BitcoinUnit.LOCAL_CURRENCY:
                    // also accounting for cached fiat->sat conversion to avoid rounding error
                    addr.amountSats = AmountInput.getCachedSatoshis(String(addr.amount)) || btcToSatoshi(fiatToBTC(Number(addr.amount)));
                    break;
                }

                addrs[index] = addr;
                return [...addrs];
              });
              setAddresses(addrs => {
                addrs[index].unit = unit;
                return [...addrs];
              });
            }}
            onChangeText={(text: string) => {
              setAddresses(addrs => {
                item.amount = text;
                switch (item.unit || amountUnit) {
                  case BitcoinUnit.BTC:
                    item.amountSats = btcToSatoshi(item.amount);
                    break;
                  case BitcoinUnit.LOCAL_CURRENCY:
                    item.amountSats = btcToSatoshi(fiatToBTC(Number(item.amount)));
                    break;
                  case BitcoinUnit.SATS:
                  default:
                    item.amountSats = parseInt(text, 10);
                    break;
                }
                addrs[index] = item;
                return [...addrs];
              });
            }}
            unit={item.unit || amountUnit}
            editable={isEditable}
            disabled={!isEditable}
            inputAccessoryViewID={InputAccessoryAllFundsAccessoryViewID}
          />
        </View>

        {frozenBalance > 0 && (
          <Pressable
            accessibilityRole="button"
            style={({ pressed }) => [pressed && styles.pressed, styles.frozenContainer]}
            onPress={handleCoinControl}
          >
            <MalinText>
              {loc.formatString(loc.send.details_frozen, { amount: formatBalanceWithoutSuffix(frozenBalance, BitcoinUnit.BTC, true) })}
            </MalinText>
          </Pressable>
        )}

        <View style={styles.addressInputContainer}>
          <AddressInput
            onChangeText={text => {
              const { address, amount, memo, payjoinUrl: pjUrl } = DeeplinkSchemaMatch.decodeBitcoinUri(text.trim());
              setAddresses(addrs => {
                item.address = address || text.trim();
                item.amount = amount || item.amount;
                addrs[index] = item;
                return [...addrs];
              });
              if (memo) {
                setParams({ transactionMemo: memo });
              }
              setIsLoading(false);
              setParams({ payjoinUrl: pjUrl });
            }}
            address={item.address}
            isLoading={isLoading}
            inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
            editable={isEditable}
            style={styles.fullWidthInput}
          />
        </View>

        {addresses.length > 1 && (
          <Text style={[styles.of, stylesHook.of, styles.ofMargin]}>
            {loc.formatString(loc._.of, { number: index + 1, total: addresses.length })}
          </Text>
        )}
      </View>
    );
  };

  const renderCustomFeeWarning = () => {
    if (!customFee || Number(customFee) >= 1) return;

    return (
      <View style={[styles.warningContainer, stylesHook.warningContainer]}>
        <Text style={[styles.warningHeader, stylesHook.warningText]}>{loc.transactions.custom_fee_warning_title}</Text>
        <Text style={stylesHook.warningText}>{loc.transactions.custom_fee_warning_description}</Text>
      </View>
    );
  };

  const getItemLayout = (_: any, index: number) => ({
    length: dimensions.width,
    offset: dimensions.width * index,
    index,
  });

  return (
    <SafeArea style={[styles.root, stylesHook.root]}>
      <View>
        <FlatList
          onLayout={handleLayout}
          keyboardShouldPersistTaps="always"
          scrollEnabled={addresses.length > 1}
          data={addresses}
          renderItem={renderBitcoinTransactionInfoFields}
          horizontal
          ref={scrollView}
          automaticallyAdjustKeyboardInsets
          pagingEnabled
          removeClippedSubviews={false}
          onMomentumScrollBegin={Keyboard.dismiss}
          onScroll={handleRecipientsScroll}
          scrollEventThrottle={16}
          scrollIndicatorInsets={styles.scrollViewIndicator}
          contentContainerStyle={styles.scrollViewContent}
          getItemLayout={getItemLayout}
        />
        <View style={[styles.memo, stylesHook.memo]}>
          <TextInput
            onChangeText={setTransactionMemo}
            placeholder={loc.send.details_note_placeholder}
            placeholderTextColor="#81868e"
            value={transactionMemo}
            numberOfLines={1}
            style={styles.memoText}
            editable={!isLoading}
            onSubmitEditing={Keyboard.dismiss}
            inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
          />
        </View>
        <Pressable
          testID="chooseFee"
          accessibilityRole="button"
          onPress={() => {
            Keyboard.dismiss();
            navigation.navigate('SelectFee', {
              networkTransactionFees,
              feePrecalc,
              feeRate,
              feeUnit,
              walletID: wallet?.getID() || '',
              customFee,
            });
          }}
          disabled={isLoading}
          style={({ pressed }) => [pressed && styles.pressed, styles.fee]}
        >
          <Text style={[styles.feeLabel, stylesHook.feeLabel]}>{loc.send.create_fee}</Text>

          {networkTransactionFeesIsLoading ? (
            <ActivityIndicator />
          ) : (
            <View style={[styles.feeRow, stylesHook.feeRow]}>
              <Text style={stylesHook.feeValue}>
                {feePrecalc.current ? formatFee(feePrecalc.current) : feeRate + ' ' + loc.units.sat_vbyte}
              </Text>
            </View>
          )}
        </Pressable>
        {renderCustomFeeWarning()}
        {renderCreateButton()}
      </View>
      <DismissKeyboardInputAccessory />
      {Platform.select({
        ios: <InputAccessoryAllFunds canUseAll={balance > 0} onUseAllPressed={onUseAllPressed} balance={String(allBalance)} />,
        android: isVisible && (
          <InputAccessoryAllFunds canUseAll={balance > 0} onUseAllPressed={onUseAllPressed} balance={String(allBalance)} />
        ),
      })}

      {renderWalletSelectionOrCoinsSelected()}
    </SafeArea>
  );
};

export default SendDetails;

const styles = StyleSheet.create({
  root: {
    flex: 1,
    justifyContent: 'space-between',
  },
  scrollViewContent: {
    flexDirection: 'row',
  },
  scrollViewIndicator: {
    top: 0,
    left: 8,
    bottom: 0,
    right: 8,
  },
  createButton: {
    marginVertical: 16,
    marginHorizontal: 16,
    alignContent: 'center',
    minHeight: 44,
  },
  select: {
    marginBottom: 24,
    marginHorizontal: 24,
    alignItems: 'center',
  },
  selectTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectText: {
    color: '#9aa0aa',
    fontSize: 14,
    marginRight: 8,
  },
  selectWrap: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  selectLabel: {
    fontSize: 14,
  },
  of: {
    alignSelf: 'flex-end',
    marginRight: 18,
    marginVertical: 8,
  },
  ofMargin: {
    marginTop: 4,
  },
  memo: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    marginHorizontal: 16,
    alignItems: 'center',
    marginVertical: 8,
    borderRadius: 4,
  },
  memoText: {
    flex: 1,
    marginHorizontal: 8,
    minHeight: 33,
    color: '#81868e',
  },
  fee: {
    flexDirection: 'row',
    marginHorizontal: 16,
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  feeLabel: {
    fontSize: 14,
  },
  feeRow: {
    minWidth: 40,
    height: 25,
    borderRadius: 4,
    justifyContent: 'space-between',
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
  },
  frozenContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginVertical: 4,
  },
  transactionItemContainer: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  amountInputContainer: {
    marginBottom: 8,
  },
  addressInputContainer: {
    marginTop: 8,
  },
  fullWidthInput: {
    width: '100%',
  },
  pressed: {
    opacity: 0.6,
  },
  warningContainer: {
    flexDirection: 'column',
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginHorizontal: 16,
    borderRadius: 4,
    marginTop: 12,
  },
  warningHeader: {
    fontWeight: 'bold',
  },
});


================================================
FILE: ./screen/send/success.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect } from 'react';
import { RouteProp, useRoute } from '@react-navigation/native';
import BigNumber from 'bignumber.js';
import LottieView from 'lottie-react-native';
import { StyleSheet, View } from 'react-native';
import { Text } from '@rneui/themed';
import { MalinCard } from '../../MalinComponents';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import HandOffComponent from '../../components/HandOffComponent';
import { HandOffActivityType } from '../../components/types';
import { useSettings } from '../../hooks/context/useSettings';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList.ts';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation.ts';

type RouteProps = RouteProp<SendDetailsStackParamList, 'Success'>;

const Success = () => {
  const navigation = useExtendedNavigation();
  const { colors } = useTheme();
  const { selectedBlockExplorer } = useSettings();
  const route = useRoute<RouteProps>();
  const { amount, fee, amountUnit = BitcoinUnit.BTC, invoiceDescription = '', txid } = route.params || {};
  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    amountValue: {
      color: colors.alternativeTextColor2,
    },
    amountUnit: {
      color: colors.alternativeTextColor2,
    },
  });

  const onDonePressed = () => {
    // @ts-ignore idk
    navigation?.getParent().pop();
  };

  useEffect(() => {
    console.log('send/success - useEffect');
  }, []);

  return (
    <SafeArea style={[styles.root, stylesHook.root]}>
      <SuccessView amount={amount} amountUnit={amountUnit} fee={fee} invoiceDescription={invoiceDescription} />
      <View style={styles.buttonContainer}>
        <Button onPress={onDonePressed} title={loc.send.success_done} />
      </View>
      {txid && (
        <HandOffComponent
          title={loc.transactions.details_title}
          type={HandOffActivityType.ViewInBlockExplorer}
          url={`${selectedBlockExplorer.url}/tx/${txid}`}
        />
      )}
    </SafeArea>
  );
};

export default Success;

interface SuccessViewParam {
  amount?: number;
  amountUnit?: BitcoinUnit;
  fee?: number;
  invoiceDescription?: string;
  shouldAnimate?: boolean;
}

export const SuccessView = ({ amount, amountUnit, fee, invoiceDescription, shouldAnimate = true }: SuccessViewParam) => {
  const { colors } = useTheme();

  let unit: string = '';
  switch (amountUnit) {
    case BitcoinUnit.BTC:
    case BitcoinUnit.SATS:
      unit = loc.units[amountUnit];
      break;
  }

  const stylesHook = StyleSheet.create({
    amountValue: {
      color: colors.alternativeTextColor2,
    },
    amountUnit: {
      color: colors.alternativeTextColor2,
    },
  });

  return (
    <View style={styles.root}>
      {amount || (fee ?? 0) > 0 ? (
        <MalinCard style={styles.amount}>
          <View style={styles.view}>
            {amount ? (
              <>
                <Text style={[styles.amountValue, stylesHook.amountValue]}>{amount}</Text>
                <Text style={[styles.amountUnit, stylesHook.amountUnit]}>{' ' + unit}</Text>
              </>
            ) : null}
          </View>
          {(fee ?? 0) > 0 && (
            <Text style={styles.feeText}>
              {loc.send.create_fee}: {new BigNumber(fee ?? 0).toFixed(8)} {loc.units[BitcoinUnit.BTC]}
            </Text>
          )}
          <Text numberOfLines={0} style={styles.feeText}>
            {invoiceDescription}
          </Text>
        </MalinCard>
      ) : null}

      <View style={styles.ready}>
        <LottieView
          style={styles.lottie}
          source={require('../../img/malinnice.json')}
          autoPlay={shouldAnimate}
          loop={false}
          progress={shouldAnimate ? 0 : 1}
          colorFilters={[
            {
              keypath: 'spark',
              color: colors.success,
            },
            {
              keypath: 'circle',
              color: colors.success,
            },
            {
              keypath: 'Oval',
              color: colors.successCheck,
            },
          ]}
          resizeMode="center"
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
    paddingTop: 19,
  },
  buttonContainer: {
    paddingHorizontal: 58,
    paddingBottom: 16,
  },
  amount: {
    alignItems: 'center',
  },
  view: {
    flexDirection: 'row',
    justifyContent: 'center',
  },
  amountValue: {
    fontSize: 36,
    fontWeight: '600',
  },
  amountUnit: {
    fontSize: 16,
    marginHorizontal: 4,
    paddingBottom: 6,
    fontWeight: '600',
    alignSelf: 'flex-end',
  },
  feeText: {
    color: '#37c0a1',
    fontSize: 14,
    marginHorizontal: 4,
    paddingVertical: 6,
    fontWeight: '500',
    alignSelf: 'center',
  },
  ready: {
    width: 120,
    height: 120,
    borderRadius: 60,
    alignSelf: 'center',
    alignItems: 'center',
    marginBottom: 53,
  },
  lottie: {
    width: 200,
    height: 200,
  },
});


================================================
FILE: ./screen/send/Confirm.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useMemo, useReducer } from 'react';
import { ActivityIndicator, FlatList, TouchableOpacity, StyleSheet, Switch, View } from 'react-native';
import { Text } from '@rneui/themed';
import { PayjoinClient } from 'payjoin-client';
import BigNumber from 'bignumber.js';
import * as bitcoin from 'bitcoinjs-lib';
import { MalinText, MalinCard } from '../../MalinComponents';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import loc, { formatBalance, formatBalanceWithoutSuffix } from '../../loc';
import { useRoute, RouteProp } from '@react-navigation/native';
import presentAlert from '../../components/Alert';
import { useTheme } from '../../components/themes';
import Button from '../../components/Button';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import SafeArea from '../../components/SafeArea';
import { satoshiToBTC, satoshiToLocalCurrency } from '../../malin_modules/currency';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import { TWallet, CreateTransactionTarget } from '../../class/wallets/types';
import PayjoinTransaction from '../../class/payjoin-transaction';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { ContactList } from '../../class/contact-list';
import { useStorage } from '../../hooks/context/useStorage';
import { HDSegwitBech32Wallet } from '../../class';
import { useSettings } from '../../hooks/context/useSettings';
import { majorTomToGroundControl } from '../../malin_modules/notifications';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

enum ActionType {
  SET_LOADING = 'SET_LOADING',
  SET_PAYJOIN_ENABLED = 'SET_PAYJOIN_ENABLED',
  SET_BUTTON_DISABLED = 'SET_BUTTON_DISABLED',
}

type Action =
  | { type: ActionType.SET_LOADING; payload: boolean }
  | { type: ActionType.SET_PAYJOIN_ENABLED; payload: boolean }
  | { type: ActionType.SET_BUTTON_DISABLED; payload: boolean };

interface State {
  isLoading: boolean;
  isPayjoinEnabled: boolean;
  isButtonDisabled: boolean;
}

const initialState: State = {
  isLoading: false,
  isPayjoinEnabled: false,
  isButtonDisabled: false,
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case ActionType.SET_LOADING:
      return { ...state, isLoading: action.payload };
    case ActionType.SET_PAYJOIN_ENABLED:
      return { ...state, isPayjoinEnabled: action.payload };
    case ActionType.SET_BUTTON_DISABLED:
      return { ...state, isButtonDisabled: action.payload };
    default:
      return state;
  }
};

type ConfirmRouteProp = RouteProp<SendDetailsStackParamList, 'Confirm'>;
type ConfirmNavigationProp = NativeStackNavigationProp<SendDetailsStackParamList, 'Confirm'>;

const Confirm: React.FC = () => {
  const { wallets, fetchAndSaveWalletTransactions, counterpartyMetadata } = useStorage();
  const { isElectrumDisabled } = useSettings();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();
  const navigation = useExtendedNavigation<ConfirmNavigationProp>();
  const route = useRoute<ConfirmRouteProp>(); // Get the route and its params
  const { recipients, targets, walletID, fee, memo, tx, satoshiPerByte, psbt, payjoinUrl } = route.params; // Destructure params

  const [state, dispatch] = useReducer(reducer, initialState);
  const { navigate, setOptions, goBack } = navigation;
  const wallet = wallets.find((w: TWallet) => w.getID() === walletID) as TWallet;
  const feeSatoshi = new BigNumber(fee).multipliedBy(100000000).toNumber();
  const { colors } = useTheme();

  useEffect(() => {
    if (!wallet) {
      goBack();
    }
  }, [wallet, goBack]);

  const stylesHook = StyleSheet.create({
    transactionDetailsTitle: {
      color: colors.foregroundColor,
    },
    transactionDetailsSubtitle: {
      color: colors.feeText,
    },
    transactionAmountFiat: {
      color: colors.feeText,
    },
    txDetails: {
      backgroundColor: colors.lightButton,
    },
    valueValue: {
      color: colors.alternativeTextColor2,
    },
    valueUnit: {
      color: colors.buttonTextColor,
    },
    root: {
      backgroundColor: colors.elevated,
    },
    payjoinWrapper: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
  });

  const HeaderRightButton = useMemo(
    () => (
      <TouchableOpacity
        accessibilityRole="button"
        testID="TransactionDetailsButton"
        style={[styles.txDetails, stylesHook.txDetails]}
        onPress={async () => {
          if (await isBiometricUseCapableAndEnabled()) {
            if (!(await unlockWithBiometrics())) {
              return;
            }
          }
          navigate('CreateTransaction', {
            fee,
            recipients,
            memo,
            tx,
            satoshiPerByte,
            feeSatoshi,
          });
        }}
      >
        <Text style={[styles.txText, stylesHook.valueUnit]}>{loc.send.create_details}</Text>
      </TouchableOpacity>
    ),
    [
      stylesHook.txDetails,
      stylesHook.valueUnit,
      isBiometricUseCapableAndEnabled,
      navigate,
      fee,
      recipients,
      memo,
      tx,
      satoshiPerByte,
      feeSatoshi,
    ],
  );

  useEffect(() => {
    console.log('send/confirm - useEffect');
    console.log('address = ', recipients);
  }, [recipients]);

  useEffect(() => {
    setOptions({
      headerRight: () => HeaderRightButton,
    });
  }, [HeaderRightButton, colors, fee, feeSatoshi, memo, recipients, satoshiPerByte, setOptions, tx, wallet]);

  const getPaymentScript = (): Uint8Array | undefined => {
    if (!(recipients.length > 0) || !recipients[0].address) {
      return undefined;
    }
    return bitcoin.address.toOutputScript(recipients[0].address, bitcoin.networks.bitcoin);
  };

  const handleSendTransaction = async () => {
    dispatch({ type: ActionType.SET_BUTTON_DISABLED, payload: true });
    dispatch({ type: ActionType.SET_LOADING, payload: true });
    try {
      // Perform biometric authentication first
      if (await isBiometricUseCapableAndEnabled()) {
        if (!(await unlockWithBiometrics())) {
          // Stop execution if biometric unlock fails
          dispatch({ type: ActionType.SET_LOADING, payload: false });
          dispatch({ type: ActionType.SET_BUTTON_DISABLED, payload: false });
          return;
        }
      }

      const txidsToWatch = [];
      if (!state.isPayjoinEnabled) {
        // Only broadcast the transaction after biometrics pass
        const result = await broadcastTransaction(tx);
        if (!result) {
          dispatch({ type: ActionType.SET_LOADING, payload: false });
          dispatch({ type: ActionType.SET_BUTTON_DISABLED, payload: false });
          return;
        }
      } else {
        const payJoinWallet = new PayjoinTransaction(psbt, (txHex: string) => broadcastTransaction(txHex), wallet as HDSegwitBech32Wallet);
        const paymentScript = getPaymentScript();
        if (!paymentScript) {
          throw new Error('Invalid payment script');
        }
        const payjoinClient = new PayjoinClient({
          paymentScript: Buffer.from(uint8ArrayToHex(paymentScript), 'hex'),
          wallet: payJoinWallet.getPayjoinPsbt(),
          payjoinUrl: payjoinUrl as string,
        });
        await payjoinClient.run();
        const payjoinPsbt = payJoinWallet.getPayjoinPsbt();
        if (payjoinPsbt) {
          const txToWatch = payjoinPsbt.extractTransaction();
          txidsToWatch.push(txToWatch.getId());
        }
      }

      const txid = bitcoin.Transaction.fromHex(tx).getId();
      txidsToWatch.push(txid);
      majorTomToGroundControl([], [], txidsToWatch);
      let amount = 0;
      for (const recipient of recipients) {
        if (recipient.value) {
          amount += recipient.value;
        }
      }

      amount = Number(formatBalanceWithoutSuffix(amount, BitcoinUnit.BTC, false));
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      navigate('Success', {
        fee: Number(fee),
        amount,
        txid,
      });

      dispatch({ type: ActionType.SET_LOADING, payload: false });

      await new Promise(resolve => setTimeout(resolve, 3000)); // sleep to make sure network propagates
      fetchAndSaveWalletTransactions(walletID);
    } catch (error: any) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      dispatch({ type: ActionType.SET_LOADING, payload: false });
      dispatch({ type: ActionType.SET_BUTTON_DISABLED, payload: false });
      presentAlert({ message: error.message });
    }
  };

  const broadcastTransaction = async (transaction: string) => {
    await MalinElectrum.ping();
    await MalinElectrum.waitTillConnected();

    const result = await wallet.broadcastTx(transaction);
    if (!result) {
      throw new Error(loc.errors.broadcast);
    }

    return result;
  };

  const shortenContactName = (name: string): string => {
    if (name.length < 20) return name;
    return name.substr(0, 10) + '...' + name.substr(name.length - 10, 10);
  };

  const renderItem = ({ index, item }: { index: number; item: CreateTransactionTarget }) => {
    // first, trying to find if this destination is to a PaymentCode, and if it is - get its local alias
    let contact: string = '';
    try {
      const cl = new ContactList();
      if (targets?.[index]?.address && cl.isPaymentCodeValid(targets[index].address!)) {
        // this is why we need `targets` in this screen.
        // in case address was a payment code, and it got turned into a regular address, we need to display the PC as well
        contact = targets[index].address!;
        if (counterpartyMetadata?.[contact].label) {
          contact = counterpartyMetadata?.[contact].label;
        }

        contact = shortenContactName(contact);
      }
    } catch (_) {}

    return (
      <>
        <View style={styles.valueWrap}>
          <Text testID="TransactionValue" style={[styles.valueValue, stylesHook.valueValue]}>
            {item.value && satoshiToBTC(item.value)}
          </Text>
          <Text style={[styles.valueUnit, stylesHook.valueValue]}>{' ' + loc.units[BitcoinUnit.BTC]}</Text>
        </View>
        <Text style={[styles.transactionAmountFiat, stylesHook.transactionAmountFiat]}>
          {item.value && satoshiToLocalCurrency(item.value)}
        </Text>
        <MalinCard>
          <Text style={[styles.transactionDetailsTitle, stylesHook.transactionDetailsTitle]}>{loc.send.create_to}</Text>
          <Text testID="TransactionAddress" style={[styles.transactionDetailsSubtitle, stylesHook.transactionDetailsSubtitle]}>
            {item.address}
          </Text>
          {contact ? <Text style={[styles.transactionDetailsSubtitle, stylesHook.transactionDetailsSubtitle]}>[{contact}]</Text> : null}
        </MalinCard>
        {recipients.length > 1 && (
          <MalinText style={styles.valueOf}>{loc.formatString(loc._.of, { number: index + 1, total: recipients.length })}</MalinText>
        )}
      </>
    );
  };

  const renderSeparator = () => {
    return <View style={styles.separator} />;
  };

  return (
    <SafeArea style={[styles.root, stylesHook.root]}>
      <View style={styles.cardTop}>
        <FlatList<CreateTransactionTarget>
          scrollEnabled={recipients.length > 1}
          extraData={recipients}
          data={recipients}
          renderItem={renderItem}
          keyExtractor={(_item, index) => `${index}`}
          ItemSeparatorComponent={renderSeparator}
        />
        {!!payjoinUrl && (
          <View style={styles.cardContainer}>
            <MalinCard>
              <View style={[styles.payjoinWrapper, stylesHook.payjoinWrapper]}>
                <Text style={styles.payjoinText}>Payjoin</Text>
                <Switch
                  testID="PayjoinSwitch"
                  value={state.isPayjoinEnabled}
                  onValueChange={value => dispatch({ type: ActionType.SET_PAYJOIN_ENABLED, payload: value })}
                />
              </View>
            </MalinCard>
          </View>
        )}
      </View>
      <View style={styles.cardBottom}>
        <MalinCard>
          <Text style={styles.cardText} testID="TransactionFee">
            {loc.send.create_fee}: {formatBalance(feeSatoshi, BitcoinUnit.BTC)} ({satoshiToLocalCurrency(feeSatoshi)})
          </Text>
          {state.isLoading ? (
            <ActivityIndicator />
          ) : (
            <Button
              disabled={isElectrumDisabled || state.isButtonDisabled}
              onPress={handleSendTransaction}
              title={loc.send.confirm_sendNow}
            />
          )}
        </MalinCard>
      </View>
    </SafeArea>
  );
};

export default Confirm;

const styles = StyleSheet.create({
  transactionDetailsTitle: {
    fontWeight: '500',
    fontSize: 17,
    marginBottom: 2,
  },
  transactionDetailsSubtitle: {
    fontWeight: '500',
    fontSize: 15,
    marginBottom: 20,
  },
  transactionAmountFiat: {
    fontWeight: '500',
    fontSize: 15,
    marginVertical: 8,
    textAlign: 'center',
  },
  valueWrap: {
    flexDirection: 'row',
    justifyContent: 'center',
  },
  valueValue: {
    fontSize: 36,
    fontWeight: '700',
  },
  valueUnit: {
    fontSize: 16,
    marginHorizontal: 4,
    paddingBottom: 6,
    fontWeight: '600',
    alignSelf: 'flex-end',
  },
  valueOf: {
    alignSelf: 'flex-end',
    marginRight: 18,
    marginVertical: 8,
  },
  separator: {
    height: 0.5,
    margin: 16,
  },
  root: {
    paddingTop: 19,
    justifyContent: 'space-between',
  },
  cardTop: {
    flexGrow: 8,
    marginTop: 16,
    alignItems: 'center',
    maxHeight: '70%',
  },
  cardBottom: {
    flexGrow: 2,
    justifyContent: 'flex-end',
    alignItems: 'center',
  },
  cardContainer: {
    flexGrow: 1,
    width: '100%',
  },
  cardText: {
    flexDirection: 'row',
    color: '#37c0a1',
    fontSize: 14,
    marginVertical: 8,
    marginHorizontal: 24,
    paddingBottom: 6,
    fontWeight: '500',
    alignSelf: 'center',
  },
  txDetails: {
    alignItems: 'center',
    justifyContent: 'center',
    width: 80,
    borderRadius: 8,
    height: 38,
  },
  txText: {
    fontSize: 15,
    fontWeight: '600',
  },
  payjoinWrapper: {
    flexDirection: 'row',
    padding: 8,
    borderRadius: 6,
    width: '100%',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  payjoinText: {
    color: '#81868e',
    fontSize: 15,
    fontWeight: 'bold',
  },
});


================================================
FILE: ./screen/send/create.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import Clipboard from '@react-native-clipboard/clipboard';
import { useNavigation, useRoute } from '@react-navigation/native';
import BigNumber from 'bignumber.js';
import * as bitcoin from 'bitcoinjs-lib';
import PropTypes from 'prop-types';
import React, { useCallback, useEffect } from 'react';
import { Alert, FlatList, Linking, Platform, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { Icon } from '@rneui/themed';
import RNFS from 'react-native-fs';
import { PERMISSIONS, request, RESULTS } from 'react-native-permissions';
import Share from 'react-native-share';
import { satoshiToBTC } from '../../malin_modules/currency';
import { isDesktop } from '../../malin_modules/environment';
import { MalinText } from '../../MalinComponents';
import presentAlert from '../../components/Alert';
import { DynamicQRCode } from '../../components/DynamicQRCode';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { useSettings } from '../../hooks/context/useSettings';
import { useScreenProtect } from '../../hooks/useScreenProtect';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const SendCreate = () => {
  const { fee, recipients, memo = '', satoshiPerByte, psbt, showAnimatedQr, tx } = useRoute().params;
  const transaction = bitcoin.Transaction.fromHex(tx);
  const size = transaction.virtualSize();
  const { isPrivacyBlurEnabled } = useSettings();
  const { colors } = useTheme();
  const { setOptions } = useNavigation();

  const styleHooks = StyleSheet.create({
    transactionDetailsTitle: {
      color: colors.feeText,
    },
    transactionDetailsSubtitle: {
      color: colors.foregroundColor,
    },
    separator: {
      backgroundColor: colors.inputBorderColor,
    },
    root: {
      backgroundColor: colors.elevated,
    },
    cardText: {
      color: colors.foregroundColor,
    },
  });

  const { enableScreenProtect, disableScreenProtect } = useScreenProtect();

  useEffect(() => {
    console.log('send/create - useEffect');
    if (isPrivacyBlurEnabled) {
      enableScreenProtect();
    }
    return () => {
      disableScreenProtect();
    };
  }, [isPrivacyBlurEnabled, enableScreenProtect, disableScreenProtect]);

  const exportTXN = useCallback(async () => {
    const fileName = `${Date.now()}.txn`;
    if (Platform.OS === 'ios') {
      const filePath = RNFS.TemporaryDirectoryPath + `/${fileName}`;
      await RNFS.writeFile(filePath, tx);
      Share.open({
        url: 'file://' + filePath,
        saveToFiles: isDesktop,
      })
        .catch(error => {
          console.log(error);
        })
        .finally(() => {
          RNFS.unlink(filePath);
        });
    } else if (Platform.OS === 'android') {
      const granted = await request(PERMISSIONS.ANDROID.WRITE_EXTERNAL_STORAGE);
      if (granted === RESULTS.GRANTED) {
        console.log('Storage Permission: Granted');
        const filePath = RNFS.DownloadDirectoryPath + `/${fileName}`;
        try {
          await RNFS.writeFile(filePath, tx);
          presentAlert({ message: loc.formatString(loc.send.txSaved, { filePath }) });
        } catch (e) {
          console.log(e);
          presentAlert({ message: e.message });
        }
      } else {
        console.log('Storage Permission: Denied');
        Alert.alert(loc.send.permission_storage_title, loc.send.permission_storage_denied_message, [
          {
            text: loc.send.open_settings,
            onPress: () => {
              Linking.openSettings();
            },
            style: 'default',
          },
          { text: loc._.cancel, onPress: () => {}, style: 'cancel' },
        ]);
      }
    }
  }, [tx]);

  useEffect(() => {
    setOptions({
      // eslint-disable-next-line react/no-unstable-nested-components
      headerRight: () => (
        <TouchableOpacity accessibilityRole="button" onPress={exportTXN}>
          <Icon size={22} name="share-alternative" type="entypo" color={colors.foregroundColor} />
        </TouchableOpacity>
      ),
    });
  }, [colors, exportTXN, setOptions]);

  const _renderItem = ({ index, item }) => {
    return (
      <>
        <View>
          <Text style={[styles.transactionDetailsTitle, styleHooks.transactionDetailsTitle]}>{loc.send.create_to}</Text>
          <Text style={[styles.transactionDetailsSubtitle, styleHooks.transactionDetailsSubtitle]}>{item.address}</Text>
          <Text style={[styles.transactionDetailsTitle, styleHooks.transactionDetailsTitle]}>{loc.send.create_amount}</Text>
          <Text style={[styles.transactionDetailsSubtitle, styleHooks.transactionDetailsSubtitle]}>
            {satoshiToBTC(item.value)} {BitcoinUnit.BTC}
          </Text>
          {recipients.length > 1 && (
            <MalinText style={styles.itemOf}>{loc.formatString(loc._.of, { number: index + 1, total: recipients.length })}</MalinText>
          )}
        </View>
      </>
    );
  };
  _renderItem.propTypes = {
    index: PropTypes.number,
    item: PropTypes.shape({
      address: PropTypes.string,
      value: PropTypes.number,
    }),
  };

  const renderSeparator = () => {
    return <View style={[styles.separator, styleHooks.separator]} />;
  };

  const ListHeaderComponent = (
    <View>
      {showAnimatedQr && psbt ? (
        <>
          <MalinSpacing20 />
          <DynamicQRCode value={psbt.toHex()} />
          <MalinSpacing20 />
        </>
      ) : null}
      <MalinText style={[styles.cardText, styleHooks.cardText]}>{loc.send.create_this_is_hex}</MalinText>
      <TextInput testID="TxhexInput" style={styles.cardTx} height={72} multiline editable={false} value={tx} />

      <TouchableOpacity accessibilityRole="button" style={styles.actionTouch} onPress={() => Clipboard.setString(tx)}>
        <Text style={styles.actionText}>{loc.send.create_copy}</Text>
      </TouchableOpacity>
      <TouchableOpacity
        accessibilityRole="button"
        style={styles.actionTouch}
        onPress={() => Linking.openURL('https://coinb.in/?verify=' + tx)}
      >
        <Text style={styles.actionText}>{loc.send.create_verify}</Text>
      </TouchableOpacity>
    </View>
  );

  const ListFooterComponent = (
    <View>
      <Text style={[styles.transactionDetailsTitle, styleHooks.transactionDetailsTitle]}>{loc.send.create_fee}</Text>
      <Text style={[styles.transactionDetailsSubtitle, styleHooks.transactionDetailsSubtitle]}>
        {new BigNumber(fee).toFixed()} {BitcoinUnit.BTC}
      </Text>
      <Text style={[styles.transactionDetailsTitle, styleHooks.transactionDetailsTitle]}>{loc.send.create_tx_size}</Text>
      <Text style={[styles.transactionDetailsSubtitle, styleHooks.transactionDetailsSubtitle]}>{size} vbytes</Text>
      <Text style={[styles.transactionDetailsTitle, styleHooks.transactionDetailsTitle]}>{loc.send.create_satoshi_per_vbyte}</Text>
      <Text style={[styles.transactionDetailsSubtitle, styleHooks.transactionDetailsSubtitle]}>{satoshiPerByte} Sat/vB</Text>
      {memo?.length > 0 && (
        <>
          <Text style={[styles.transactionDetailsTitle, styleHooks.transactionDetailsTitle]}>{loc.send.create_memo}</Text>
          <Text style={[styles.transactionDetailsSubtitle, styleHooks.transactionDetailsSubtitle]}>{memo}</Text>
        </>
      )}
    </View>
  );

  return (
    <FlatList
      contentContainerStyle={[styles.root, styleHooks.root]}
      extraData={recipients}
      data={recipients}
      renderItem={_renderItem}
      keyExtractor={(_item, index) => `${index}`}
      ItemSeparatorComponent={renderSeparator}
      ListHeaderComponent={ListHeaderComponent}
      ListFooterComponent={ListFooterComponent}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
    />
  );
};

export default SendCreate;

const styles = StyleSheet.create({
  transactionDetailsTitle: {
    fontWeight: '500',
    fontSize: 17,
    marginBottom: 2,
  },
  root: {
    paddingHorizontal: 20,
  },
  transactionDetailsSubtitle: {
    fontWeight: '500',
    fontSize: 15,
    marginBottom: 20,
  },
  itemOf: {
    alignSelf: 'flex-end',
  },
  separator: {
    height: 0.5,
    marginVertical: 16,
  },
  cardText: {
    fontWeight: '500',
  },
  cardTx: {
    borderColor: '#ebebeb',
    backgroundColor: '#d2f8d6',
    borderRadius: 4,
    marginTop: 20,
    color: '#37c0a1',
    fontWeight: '500',
    fontSize: 14,
    paddingHorizontal: 16,
    paddingBottom: 16,
    paddingTop: 16,
  },
  actionTouch: {
    marginVertical: 24,
  },
  actionText: {
    color: '#9aa0aa',
    fontSize: 15,
    fontWeight: '500',
    alignSelf: 'center',
  },
});


================================================
FILE: ./screen/send/PsbtMultisigQRCode.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp, StackActions, useIsFocused, useRoute } from '@react-navigation/native';
import * as bitcoin from 'bitcoinjs-lib';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { ActivityIndicator, ScrollView, StyleSheet, View } from 'react-native';
import presentAlert from '../../components/Alert';
import { DynamicQRCode } from '../../components/DynamicQRCode';
import SaveFileButton from '../../components/SaveFileButton';
import { SquareButton } from '../../components/SquareButton';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import TipBox from '../../components/TipBox';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { SendDetailsStackParamList } from '../../navigation/SendDetailsStackParamList';
import { MalinSpacing20 } from '../../components/MalinSpacing';

interface BarcodeScanResult {
  data?: string;
}

type RouteParams = RouteProp<SendDetailsStackParamList, 'PsbtMultisigQRCode'>;

const PsbtMultisigQRCode: React.FC = () => {
  const navigation = useExtendedNavigation();
  const { colors } = useTheme();
  const openScannerButton = useRef<any>(null);
  const { params } = useRoute<RouteParams>();
  const { psbtBase64, isShowOpenScanner } = params;
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const dynamicQRCode = useRef<DynamicQRCode>(null);
  const isFocused = useIsFocused();

  const psbt = bitcoin.Psbt.fromBase64(psbtBase64);
  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    modalContentShort: {
      backgroundColor: colors.elevated,
    },
    exportButton: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
  });
  const fileName = `${Date.now()}.psbt`;

  useEffect(() => {
    if (isFocused) {
      dynamicQRCode.current?.startAutoMove();
    } else {
      dynamicQRCode.current?.stopAutoMove();
    }
  }, [isFocused]);

  const onBarScanned = useCallback(
    (ret: BarcodeScanResult | any) => {
      const result = typeof ret === 'string' || ret instanceof String ? { data: ret } : ret;
      const data = result.data || '';

      if (data.toUpperCase().startsWith('UR')) {
        presentAlert({ message: 'BC-UR not decoded. This should never happen' });
      } else if (data.indexOf('+') === -1 && data.indexOf('=') === -1) {
        presentAlert({ message: loc.wallets.import_error });
        // this looks like NOT base64, so maybe its transaction's hex
        // we dont support it in this flow
      } else {
        // psbt base64?
        const popToAction = StackActions.popTo('PsbtMultisig', { receivedPSBTBase64: data, ...params }, { merge: true });
        navigation.dispatch(popToAction);
      }
    },
    [navigation, params],
  );

  useEffect(() => {
    const data = params.onBarScanned;
    if (data) {
      navigation.setParams({ onBarScanned: undefined });
      onBarScanned({ data });
    }
  }, [onBarScanned, params.onBarScanned, navigation]);

  const openScanner = () => {
    navigation.navigate('ScanQRCode', {
      showFileImportButton: true,
    });
  };

  const saveFileButtonBeforeOnPress = async (): Promise<void> => {
    dynamicQRCode.current?.stopAutoMove();
    setIsLoading(true);
  };

  const saveFileButtonAfterOnPress = () => {
    setIsLoading(false);
    dynamicQRCode.current?.startAutoMove();
  };

  return (
    <ScrollView
      centerContent
      testID="PsbtMultisigQRCodeScrollView"
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior="automatic"
      style={stylesHook.root}
      contentContainerStyle={[styles.scrollViewContent, stylesHook.root, styles.modalContentShort, stylesHook.modalContentShort]}
    >
      <TipBox
        number="1"
        title={loc.multisig.provide_signature}
        description={loc.multisig.provide_signature_details}
        additionalDescription={`${loc.multisig.provide_signature_details_malinwallet} ${loc.multisig.co_sign_transaction}`}
      />
      <DynamicQRCode value={psbt.toHex()} ref={dynamicQRCode} />
      {!isLoading && (
        <>
          <MalinSpacing20 />
          <View style={styles.divider} />
          <TipBox
            number="2"
            title={loc.multisig.provide_signature_next_steps}
            description={loc.multisig.provide_signature_next_steps_details}
          />
        </>
      )}
      {!isShowOpenScanner && (
        <>
          <SquareButton
            testID="CosignedScanOrImportFile"
            style={[styles.exportButton, stylesHook.exportButton]}
            onPress={openScanner}
            ref={openScannerButton}
            title={loc.multisig.scan_or_import_file}
          />
        </>
      )}
      <MalinSpacing20 />

      {isLoading ? (
        <ActivityIndicator />
      ) : (
        <SaveFileButton
          fileName={fileName}
          fileContent={psbt.toBase64()}
          beforeOnPress={saveFileButtonBeforeOnPress}
          afterOnPress={saveFileButtonAfterOnPress}
          style={[styles.exportButton, stylesHook.exportButton]}
        >
          <SquareButton title={loc.multisig.share} />
        </SaveFileButton>
      )}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  scrollViewContent: {
    justifyContent: 'space-between',
  },
  modalContentShort: {
    paddingHorizontal: 20,
  },
  divider: {
    height: 0.5,
    backgroundColor: '#d2d2d2',
    marginVertical: 20,
  },
  exportButton: {
    height: 48,
    borderRadius: 8,
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 16,
  },
});

export default PsbtMultisigQRCode;


================================================
FILE: ./screen/UnlockWith.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useReducer, useRef } from 'react';
import {
  ActivityIndicator,
  Image,
  Keyboard,
  KeyboardAvoidingView,
  LayoutAnimation,
  Platform,
  StyleSheet,
  TouchableWithoutFeedback,
  View,
} from 'react-native';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import { MalinTextCentered } from '../MalinComponents';
import Button from '../components/Button';
import SafeArea from '../components/SafeArea';
import { BiometricType, unlockWithBiometrics, useBiometrics } from '../hooks/useBiometrics';
import loc from '../loc';
import { useStorage } from '../hooks/context/useStorage';
import { PasswordInput, PasswordInputHandle } from '../components/PasswordInput';

enum AuthType {
  Encrypted,
  Biometrics,
  None,
  BiometricsUnavailable,
}

type State = {
  auth: {
    type: AuthType;
    detail: keyof typeof BiometricType | undefined;
  };
  isAuthenticating: boolean;
  showPasswordInput: boolean;
  password: string;
  isSuccess: boolean;
};

const SET_AUTH = 'SET_AUTH';
const SET_IS_AUTHENTICATING = 'SET_IS_AUTHENTICATING';
const SET_SHOW_PASSWORD_INPUT = 'SET_SHOW_PASSWORD_INPUT';
const SET_PASSWORD = 'SET_PASSWORD';
const SET_SUCCESS = 'SET_SUCCESS';

type Action =
  | { type: typeof SET_AUTH; payload: { type: AuthType; detail: keyof typeof BiometricType | undefined } }
  | { type: typeof SET_IS_AUTHENTICATING; payload: boolean }
  | { type: typeof SET_SHOW_PASSWORD_INPUT; payload: boolean }
  | { type: typeof SET_PASSWORD; payload: string }
  | { type: typeof SET_SUCCESS; payload: boolean };

const initialState: State = {
  auth: {
    type: AuthType.None,
    detail: undefined,
  },
  isAuthenticating: false,
  showPasswordInput: false,
  password: '',
  isSuccess: false,
};

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case SET_AUTH:
      return { ...state, auth: action.payload };
    case SET_IS_AUTHENTICATING:
      return { ...state, isAuthenticating: action.payload };
    case SET_SHOW_PASSWORD_INPUT:
      return { ...state, showPasswordInput: action.payload };
    case SET_PASSWORD:
      return { ...state, password: action.payload };
    case SET_SUCCESS:
      return { ...state, isSuccess: action.payload };
    default:
      return state;
  }
}

const UnlockWith: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const isUnlockingWallets = useRef(false);
  const passwordInputRef = useRef<PasswordInputHandle>(null);
  const passwordResolveRef = useRef<((password: string | undefined) => void) | null>(null);
  const { setWalletsInitialized, isStorageEncrypted, startAndDecrypt } = useStorage();
  const { deviceBiometricType, isBiometricUseCapableAndEnabled, isBiometricUseEnabled } = useBiometrics();

  useEffect(() => {
    setWalletsInitialized(false);
  }, [setWalletsInitialized]);

  const successfullyAuthenticated = useCallback(() => {
    setWalletsInitialized(true);
    isUnlockingWallets.current = false;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const unlockUsingBiometrics = useCallback(async () => {
    if (isUnlockingWallets.current || state.isAuthenticating) return;
    isUnlockingWallets.current = true;
    dispatch({ type: SET_IS_AUTHENTICATING, payload: true });

    if (await unlockWithBiometrics()) {
      await startAndDecrypt();
      successfullyAuthenticated();
    }

    dispatch({ type: SET_IS_AUTHENTICATING, payload: false });
    isUnlockingWallets.current = false;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state.isAuthenticating]);

  const promptForPassword = useCallback(async (): Promise<string | undefined> => {
    return new Promise(resolve => {
      passwordResolveRef.current = resolve;
      dispatch({ type: SET_SHOW_PASSWORD_INPUT, payload: true });
      // Focus the input after a delay to ensure it's fully rendered
      setTimeout(() => {
        passwordInputRef.current?.focus();
      }, 300);
    });
  }, []);

  const handlePasswordSubmit = useCallback(async (password: string) => {
    if (!passwordResolveRef.current) return;

    const resolve = passwordResolveRef.current;
    passwordResolveRef.current = null;

    // Let startAndDecrypt try the password
    resolve(password);

    // We'll get the result through the unlockWithKey callback
  }, []);

  const unlockWithKey = useCallback(
    async (isRetry = false) => {
      if (isUnlockingWallets.current || state.isAuthenticating) return;
      isUnlockingWallets.current = true;
      dispatch({ type: SET_IS_AUTHENTICATING, payload: true });

      const result = await startAndDecrypt(isRetry, promptForPassword);

      if (result) {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        dispatch({ type: SET_SUCCESS, payload: true });
        passwordInputRef.current?.showSuccess();
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        // Wait a bit to show success animation
        setTimeout(() => {
          successfullyAuthenticated();
        }, 800);
      } else {
        // Wrong password - show error and retry
        passwordInputRef.current?.showError();
        dispatch({ type: SET_IS_AUTHENTICATING, payload: false });
        isUnlockingWallets.current = false;
        // Wait for shake animation to complete, then retry
        setTimeout(() => {
          unlockWithKey(true);
        }, 500); // After shake animation completes (320ms) + small delay
      }
    },
    [state.isAuthenticating, startAndDecrypt, successfullyAuthenticated, promptForPassword],
  );

  useEffect(() => {
    const startUnlock = async () => {
      const storageIsEncrypted = await isStorageEncrypted();
      const biometricUseCapableAndEnabled = await isBiometricUseCapableAndEnabled();
      const biometricsUseEnabled = await isBiometricUseEnabled();
      const biometricType = biometricUseCapableAndEnabled ? deviceBiometricType : undefined;

      if (storageIsEncrypted) {
        dispatch({ type: SET_AUTH, payload: { type: AuthType.Encrypted, detail: undefined } });
        unlockWithKey();
      } else if (biometricUseCapableAndEnabled) {
        dispatch({ type: SET_AUTH, payload: { type: AuthType.Biometrics, detail: biometricType } });
        unlockUsingBiometrics();
      } else if (biometricsUseEnabled && biometricType === undefined) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        dispatch({ type: SET_AUTH, payload: { type: AuthType.BiometricsUnavailable, detail: undefined } });
      } else {
        dispatch({ type: SET_AUTH, payload: { type: AuthType.None, detail: undefined } });
        unlockWithKey();
      }
    };

    startUnlock();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const onUnlockPressed = () => {
    if (state.auth.type === AuthType.Biometrics) {
      unlockUsingBiometrics();
    } else {
      unlockWithKey();
    }
  };

  const renderUnlockOptions = () => {
    if (state.isAuthenticating && !state.showPasswordInput) {
      return <ActivityIndicator />;
    }

    if (state.showPasswordInput) {
      return (
        <View style={styles.passwordContainer}>
          <PasswordInput
            ref={passwordInputRef}
            onSubmit={handlePasswordSubmit}
            placeholder={loc._.enter_password}
            disabled={state.isAuthenticating}
            onChangeText={text => {
              dispatch({ type: SET_PASSWORD, payload: text });
            }}
          />
          {!state.isSuccess && (
            <>
              <View style={styles.buttonSpacing} />
              <Button
                onPress={() => {
                  const password = passwordInputRef.current?.getValue() || '';
                  handlePasswordSubmit(password);
                }}
                title={loc._.unlock}
                disabled={state.password.length === 0}
              />
            </>
          )}
        </View>
      );
    }

    switch (state.auth.type) {
      case AuthType.Biometrics:
      case AuthType.Encrypted:
        return <Button onPress={onUnlockPressed} title={loc._.unlock} />;
      case AuthType.BiometricsUnavailable:
        return <MalinTextCentered>{loc.settings.biometrics_no_longer_available}</MalinTextCentered>;
      default:
        return null;
    }
  };

  return (
    <SafeArea style={styles.root}>
      <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
        <KeyboardAvoidingView style={styles.keyboardAvoidingView} behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
          <View style={styles.contentContainer}>
            <View style={styles.logoContainer}>
              <Image source={require('../img/icon.png')} style={styles.logoImage} resizeMode="contain" />
            </View>
            <View style={styles.biometricRow}>{renderUnlockOptions()}</View>
          </View>
        </KeyboardAvoidingView>
      </TouchableWithoutFeedback>
    </SafeArea>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  contentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  logoContainer: {
    marginBottom: 40,
    alignItems: 'center',
  },
  biometricRow: {
    justifyContent: 'center',
    flexDirection: 'row',
    width: 300,
    minHeight: 60,
    alignSelf: 'center',
    paddingHorizontal: 20,
  },
  logoImage: {
    width: 100,
    height: 75,
  },
  passwordContainer: {
    width: '100%',
    maxWidth: 300,
    alignSelf: 'center',
  },
  buttonSpacing: {
    height: 16,
  },
});

export default UnlockWith;


================================================
FILE: ./screen/ActionSheet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// ActionSheet.ts
import { Alert, InteractionManager } from 'react-native';

import { ActionSheetOptions, CompletionCallback } from './ActionSheet.common';

export default class ActionSheet {
  static showActionSheetWithOptions(options: ActionSheetOptions, completion: CompletionCallback): void {
    InteractionManager.runAfterInteractions(() => {
      const alertOptions = options.options.map((option, index) => {
        let style: 'default' | 'cancel' | 'destructive' = 'default';
        if (index === options.destructiveButtonIndex) {
          style = 'destructive';
        } else if (index === options.cancelButtonIndex) {
          style = 'cancel';
        }

        return {
          text: option,
          onPress: () => completion(index),
          style,
        };
      });

      Alert.alert(options.title || '', options.message || '', alertOptions, { cancelable: !!options.cancelButtonIndex });
    });
  }
}


================================================
FILE: ./screen/PlausibleDeniability.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useReducer, useRef } from 'react';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../MalinComponents';
import presentAlert from '../components/Alert';
import Button from '../components/Button';
import loc from '../loc';
import { useStorage } from '../hooks/context/useStorage';
import PromptPasswordConfirmationModal, {
  PromptPasswordConfirmationModalHandle,
  MODAL_TYPES,
} from '../components/PromptPasswordConfirmationModal';
import { useExtendedNavigation } from '../hooks/useExtendedNavigation';
import { StackActions } from '@react-navigation/native';
import SafeAreaScrollView from '../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../components/MalinSpacing';
import { MalinLoading } from '../components/MalinLoading';

// Action Types
const SET_LOADING = 'SET_LOADING';
const SET_MODAL_TYPE = 'SET_MODAL_TYPE';

// Defining State and Action Types
type State = {
  isLoading: boolean;
  modalType: keyof typeof MODAL_TYPES;
};

type Action = { type: typeof SET_LOADING; payload: boolean } | { type: typeof SET_MODAL_TYPE; payload: keyof typeof MODAL_TYPES };

// Initial State
const initialState: State = {
  isLoading: false,
  modalType: MODAL_TYPES.CREATE_FAKE_STORAGE,
};

// Reducer Function
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case SET_LOADING:
      return { ...state, isLoading: action.payload };
    case SET_MODAL_TYPE:
      return { ...state, modalType: action.payload };
    default:
      return state;
  }
}

// Component
const PlausibleDeniability: React.FC = () => {
  const { cachedPassword, isPasswordInUse, createFakeStorage, resetWallets } = useStorage();
  const [state, dispatch] = useReducer(reducer, initialState);
  const navigation = useExtendedNavigation();
  const promptRef = useRef<PromptPasswordConfirmationModalHandle>(null);

  const handleOnCreateFakeStorageButtonPressed = async () => {
    dispatch({ type: SET_LOADING, payload: true });
    dispatch({ type: SET_MODAL_TYPE, payload: MODAL_TYPES.CREATE_FAKE_STORAGE });
    await promptRef.current?.present();
  };

  const handleConfirmationSuccess = async (password: string) => {
    let success = false;
    const isProvidedPasswordInUse = password === cachedPassword || (await isPasswordInUse(password));
    if (isProvidedPasswordInUse) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ message: loc.plausibledeniability.password_should_not_match });
      return false;
    }

    try {
      await createFakeStorage(password);
      resetWallets();
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);

      // Set the modal type to SUCCESS to show the success animation instead of the alert
      dispatch({ type: SET_MODAL_TYPE, payload: MODAL_TYPES.SUCCESS });

      success = true;
      setTimeout(async () => {
        const popToTop = StackActions.popToTop();
        navigation.dispatch(popToTop);
      }, 3000);
    } catch {
      success = false;
      dispatch({ type: SET_LOADING, payload: false });
    }

    return success;
  };

  const handleConfirmationFailure = () => {
    dispatch({ type: SET_LOADING, payload: false });
  };

  return (
    <SafeAreaScrollView centerContent={state.isLoading}>
      {state.isLoading ? (
        <MalinLoading />
      ) : (
        <MalinCard>
          <MalinText>{loc.plausibledeniability.help}</MalinText>
          <MalinText />
          <MalinText>{loc.plausibledeniability.help2}</MalinText>
          <MalinSpacing20 />
          <Button
            testID="CreateFakeStorageButton"
            title={loc.plausibledeniability.create_fake_storage}
            onPress={handleOnCreateFakeStorageButtonPressed}
            disabled={state.isLoading}
          />
        </MalinCard>
      )}
      <PromptPasswordConfirmationModal
        ref={promptRef}
        modalType={state.modalType}
        onConfirmationSuccess={handleConfirmationSuccess}
        onConfirmationFailure={handleConfirmationFailure}
      />
    </SafeAreaScrollView>
  );
};

export default PlausibleDeniability;


================================================
FILE: ./screen/settings/NotificationSettings.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useState } from 'react';
import { Linking, StyleSheet, TextInput, View, Pressable, AppState } from 'react-native';
import { Button as ButtonRNElements } from '@rneui/themed';
import {
  getDefaultUri,
  getPushToken,
  getSavedUri,
  getStoredNotifications,
  saveUri,
  isNotificationsEnabled,
  setLevels,
  tryToObtainPermissions,
  cleanUserOptOutFlag,
  isGroundControlUriValid,
  checkPermissions,
  checkNotificationPermissionStatus,
  NOTIFICATIONS_NO_AND_DONT_ASK_FLAG,
} from '../../malin_modules/notifications';
import { MalinCard, MalinText } from '../../MalinComponents';
import presentAlert from '../../components/Alert';
import { Button } from '../../components/Button';
import CopyToClipboardButton from '../../components/CopyToClipboardButton';
import ListItem, { PressableWrapper } from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { Divider } from '@rneui/base';
import { openSettings } from 'react-native-permissions';
import AsyncStorage from '@react-native-async-storage/async-storage';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';
import { useLocale } from '@react-navigation/native';

const NotificationSettings: React.FC = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [isNotificationsEnabledState, setNotificationsEnabledState] = useState<boolean | undefined>(undefined);
  const [tokenInfo, setTokenInfo] = useState('<empty>');
  const { direction } = useLocale();
  const [URI, setURI] = useState<string | undefined>();
  const [tapCount, setTapCount] = useState(0);
  const { colors } = useTheme();
  const stylesWithThemeHook = StyleSheet.create({
    scroll: {
      backgroundColor: colors.background,
    },

    uri: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    buttonStyles: { flexDirection: direction === 'rtl' ? 'row-reverse' : 'row' },
  });
  const handleTap = () => {
    setTapCount(prevCount => prevCount + 1);
  };

  const showNotificationPermissionAlert = () => {
    presentAlert({
      title: loc.settings.notifications,
      message: loc.notifications.permission_denied_message,
      buttons: [
        {
          text: loc._.ok,
          style: 'cancel',
        },
        {
          text: loc.settings.header,
          onPress: onSystemSettings,
          style: 'default',
        },
      ],
    });
  };

  const onNotificationsSwitch = async (value: boolean) => {
    if (value) {
      const currentStatus = await checkNotificationPermissionStatus();
      if (currentStatus === 'blocked') {
        // If permissions are denied/blocked, show alert and reset the toggle
        showNotificationPermissionAlert();
        setNotificationsEnabledState(false);
        return;
      }
    }

    try {
      setNotificationsEnabledState(value);
      if (value) {
        await cleanUserOptOutFlag();
        const permissionsGranted = await tryToObtainPermissions();
        if (permissionsGranted) {
          await setLevels(true);
          await AsyncStorage.removeItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG);
        } else {
          showNotificationPermissionAlert();
          setNotificationsEnabledState(false);
        }
      } else {
        await setLevels(false);
        await AsyncStorage.setItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG, 'true');
        setNotificationsEnabledState(false);
      }

      setNotificationsEnabledState(await isNotificationsEnabled());
    } catch (error) {
      console.error(error);
      presentAlert({ message: (error as Error).message });
      setNotificationsEnabledState(false);
    }
  };

  const updateNotificationStatus = async () => {
    try {
      const currentStatus = await checkNotificationPermissionStatus();
      const isEnabled = await isNotificationsEnabled();
      const isDisabledByUser = (await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG)) === 'true';

      if (!isDisabledByUser) {
        setNotificationsEnabledState(currentStatus === 'granted' && isEnabled);
      } else {
        setNotificationsEnabledState(false);
      }
    } catch (error) {
      console.log('Error updating notification status:', error);
    }
  };

  useEffect(() => {
    (async () => {
      try {
        const isDisabledByUser = (await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG)) === 'true';

        if (isDisabledByUser) {
          console.debug('Notifications were disabled by the user. Skipping auto-activation.');
          setNotificationsEnabledState(false);
        } else {
          await updateNotificationStatus();
        }

        setURI((await getSavedUri()) ?? getDefaultUri());
        setTokenInfo(
          'token: ' +
            JSON.stringify(await getPushToken()) +
            ' permissions: ' +
            JSON.stringify(await checkPermissions()) +
            ' stored notifications: ' +
            JSON.stringify(await getStoredNotifications()),
        );
      } catch (e) {
        console.error(e);
        presentAlert({ message: (e as Error).message });
      } finally {
        setIsLoading(false);
      }
    })();

    const appStateListener = AppState.addEventListener('change', nextAppState => {
      if (nextAppState === 'active') {
        setTimeout(async () => {
          const isDisabledByUser = (await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG)) === 'true';
          if (!isDisabledByUser) {
            updateNotificationStatus();
          }
        }, 300);
      }
    });

    return () => {
      appStateListener.remove();
    };
  }, []);

  const save = useCallback(async () => {
    setIsLoading(true);
    try {
      if (URI) {
        if (await isGroundControlUriValid(URI)) {
          await saveUri(URI);
          presentAlert({ message: loc.settings.saved });
        } else {
          presentAlert({ message: loc.settings.not_a_valid_uri });
        }
      } else {
        await saveUri('');
        presentAlert({ message: loc.settings.saved });
      }
    } catch (error) {
      console.error('Error saving URI:', error);
    }
    setIsLoading(false);
  }, [URI]);

  const onSystemSettings = () => {
    openSettings('notifications');
  };

  return (
    <SafeAreaScrollView style={stylesWithThemeHook.scroll} automaticallyAdjustContentInsets contentInsetAdjustmentBehavior="automatic">
      <ListItem
        Component={PressableWrapper}
        title={loc.settings.notifications}
        subtitle={loc.notifications.notifications_subtitle}
        disabled={isLoading}
        isLoading={isNotificationsEnabledState === undefined}
        switch={{ onValueChange: onNotificationsSwitch, value: isNotificationsEnabledState, testID: 'NotificationsSwitch' }}
      />

      <Pressable onPress={handleTap}>
        <MalinCard>
          <MalinText style={styles.multilineText}>{loc.settings.push_notifications_explanation}</MalinText>
        </MalinCard>
      </Pressable>

      {tapCount >= 10 && (
        <>
          <Divider />
          <MalinCard>
            <MalinText>{loc.settings.groundcontrol_explanation}</MalinText>
          </MalinCard>

          <ButtonRNElements
            icon={{
              name: 'github',
              type: 'font-awesome',
              color: colors.foregroundColor,
            }}
            onPress={() => Linking.openURL('https://github.com/MalinWallet/GroundControl')}
            titleStyle={{ color: colors.buttonAlternativeTextColor }}
            title="github.com/MalinWallet/GroundControl"
            color={colors.buttonTextColor}
            buttonStyle={[styles.buttonStyle, stylesWithThemeHook.buttonStyles]}
          />

          <MalinCard>
            <View style={[styles.uri, stylesWithThemeHook.uri]}>
              <TextInput
                placeholder={getDefaultUri()}
                value={URI}
                onChangeText={setURI}
                numberOfLines={1}
                style={styles.uriText}
                placeholderTextColor="#81868e"
                editable={!isLoading}
                textContentType="URL"
                autoCapitalize="none"
                underlineColorAndroid="transparent"
              />
            </View>

            <MalinSpacing20 />
            <MalinText style={styles.centered} onPress={() => setTapCount(tapCount + 1)}>
               Ground Control to Major Tom 
            </MalinText>
            <MalinText style={styles.centered} onPress={() => setTapCount(tapCount + 1)}>
               Commencing countdown, engines on 
            </MalinText>

            <View>
              <CopyToClipboardButton stringToCopy={tokenInfo} displayText={tokenInfo} />
            </View>

            <MalinSpacing20 />
            <Button onPress={save} title={loc.settings.save} />
          </MalinCard>
        </>
      )}
      <MalinSpacing40 />
      <ListItem title={loc.settings.privacy_system_settings} onPress={onSystemSettings} chevron />
    </SafeAreaScrollView>
  );
};

const styles = StyleSheet.create({
  uri: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    borderRadius: 4,
  },
  centered: {
    textAlign: 'center',
  },
  uriText: {
    flex: 1,
    color: '#81868e',
    marginHorizontal: 8,
    minHeight: 36,
    height: 36,
  },
  buttonStyle: {
    backgroundColor: 'transparent',
  },
  multilineText: {
    textAlign: 'left',
    lineHeight: 20,
    paddingBottom: 10,
  },
});

export default NotificationSettings;


================================================
FILE: ./screen/settings/SelfTest.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory from 'bip32';
import bip38 from 'bip38';
import * as bip39 from 'bip39';
import * as bitcoin from 'bitcoinjs-lib';
import React, { Component } from 'react';
import { Linking, ScrollView, StyleSheet, View } from 'react-native';
// @ts-ignore theres no type declaration for this
import MalinCrypto from 'react-native-malin-crypto';
import wif from 'wif';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import * as encryption from '../../malin_modules/encryption';
import * as fs from '../../malin_modules/fs';
import ecc from '../../malin_modules/noble_ecc';
import { MalinText } from '../../MalinComponents';
import {
  HDAezeedWallet,
  HDSegwitBech32Wallet,
  HDSegwitP2SHWallet,
  LegacyWallet,
  SegwitP2SHWallet,
  SLIP39LegacyP2PKHWallet,
  TaprootWallet,
} from '../../class';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import SaveFileButton from '../../components/SaveFileButton';
import loc from '../../loc';
import { CreateTransactionUtxo } from '../../class/wallets/types.ts';
import { MalinSpacing20 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading.tsx';
import { LightningArkWallet } from '../../class/wallets/lightning-ark-wallet.ts';

const bip32 = BIP32Factory(ecc);

type TState = {
  isLoading?: boolean;
  isOk?: boolean;
  errorMessage?: string;
};

function assertStrictEqual<T>(actual: T, expected: T, message?: string) {
  if (expected !== actual) {
    throw new Error(
      message ||
        'Assertion failed that ' +
          JSON.stringify(expected) +
          ' equals ' +
          JSON.stringify(actual)
    );
  }
}

const styles = StyleSheet.create({
  center: {
    alignItems: 'center',
  },
})

export default class SelfTest extends Component {
  state: TState;

  constructor (props: any) {
    super(props);
    this.state = {
      isLoading: true,
    }
  }

  onPressImportDocument = async () => {
    try {
      fs.showFilePickerAndReadFile().then((file) => {
        if (file && file.data && file.data.length > 0) {
          presentAlert({ message: file.data });
        } else {
          presentAlert({ message: 'Error reading file' });
        }
      });
    } catch (err) {
      console.log(err);
    }
  };

  async componentDidMount() {
    console.debug('SelfTest - componentDidMount');
    let errorMessage = '';
    let isOk = true;

    try {
      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        const uniqs: Record<string, 1> = {};
        const w = new SegwitP2SHWallet();
        for (let c = 0; c < 1000; c++) {
          await w.generate();
          if (uniqs[w.getSecret()]) {
            throw new Error('failed to generate unique private key');
          }
          uniqs[w.getSecret()] = 1;
        }
      } else {
        // skipping RN-specific test
      }

      //

      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        const spkw = new LightningArkWallet();
        spkw.setSecret(
          'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
        )
        await spkw.init();
        assertStrictEqual(
          await spkw.getArkAddress(),
          'ark1qq4hfssprtcgnjzf8qlw2f78yvjau5kldfugg29k34y7j96q2w4t59s7u3fgnd3lyjda00ycjq53mgxl6wsxspe4s72t5dss3q6w5clv0xpgal',
          'Ark failed',
        );
      } else {
        // skipping RN-specific test
      }

      //

      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        await MalinElectrum.ping();
        await MalinElectrum.waitTillConnected();
        const addr4elect = '3GCvDBAktgQQtsbN6x5DYiQCMmgZ9Yk8BK';
        const electrumBalance =
          await MalinElectrum.getBalanceByAddress(addr4elect);
        if (electrumBalance.confirmed !== 51432) {
          throw new Error('MalinElectrum getBalanceByAddress failure, got ' + JSON.stringify(electrumBalance))
        }

        const electrumTxs =
          await MalinElectrum.getTransactionsByAddress(addr4elect);
        if (electrumTxs.length !== 1)
          {throw new Error(
            "MalinElectrum getTransactionsByAddress failure, got " +
              JSON.stringify(electrumTxs),
          );}
      } else {
        // skipping RN-specific test'
      }

      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        const aezeed = new HDAezeedWallet();
        aezeed.setSecret(
          'abstract rhythm weird food attract treat mosquito sight royal actor surround ride strike remove guilt catch filter summer mushroom protect poverty cruel chaos pattern',
        );
        assertStrictEqual(
          await aezeed.validateMnemonicAsync(),
          true,
          'Aezeed failed',
        )
        assertStrictEqual(
          aezeed._getExternalAddressByIndex(0),
          'bc1qdjj7lhj9lnjye7xq3dzv3r4z0cta294xy78txn',
          'Aezeed failed',
        )
      } else {
        // skipping RN-specific test
      }

      let l: LegacyWallet | SegwitP2SHWallet | TaprootWallet =
        new LegacyWallet();
      l.setSecret('L4ccWrPMmFDZw4kzAKFqJNxgHANjdy6b7YKNXMwB4xac4FLF3Tov');
      assertStrictEqual(l.getAddress(), '14YZ6iymQtBVQJk6gKnLCk49UScJK7SH4M');
      let utxos: CreateTransactionUtxo[] = [
        {
          txid: 'cc44e933a094296d9fe424ad7306f16916253a3d154d52e4f1a757c18242cec4',
          vout: 0,
          value: 100000,
          txhex:
            '0200000000010161890cd52770c150da4d7d190920f43b9f88e7660c565a5a5ad141abb6de09de00000000000000008002a0860100000000001976a91426e01119d265aa980390c49eece923976c218f1588ac3e17000000000000160014c1af8c9dd85e0e55a532a952282604f820746fcd02473044022072b3f28808943c6aa588dd7a4e8f29fad7357a2814e05d6c5d767eb6b307b4e6022067bc6a8df2dbee43c87b8ce9ddd9fe678e00e0f7ae6690d5cb81eca6170c47e8012102e8fba5643e15ab70ec79528833a2c51338c1114c4eebc348a235b1a3e13ab07100000000',
        },
      ]

      let txNew = l.createTransaction(
        utxos,
        [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }],
        1,
        String(l.getAddress()),
        0xffffffff,
        false,
        0,
      )
      const txBitcoin = bitcoin.Transaction.fromHex(txNew.tx!.toHex());
      assertStrictEqual(
        txNew.tx!.toHex(),
        '0200000001c4ce4282c157a7f1e4524d153d3a251669f10673ad24e49f6d2994a033e944cc000000006b48304502210091e58bd2021f2eeea8d39d7f7b053c9ccc52a747b60f1c3584ba33285e2d150602205b2d35a2536cbe157015e8c54a26f5fc350cc7c72b5ca80b9e548917993f652201210337c09b3cb889801638078fd4e6998218b28c92d338ea2602720a88847aedceb3ffffffff02905f0100000000001976a914aa381cd428a4e91327fd4434aa0a08ff131f1a5a88ac2e260000000000001976a91426e01119d265aa980390c49eece923976c218f1588ac00000000',
      );
      assertStrictEqual(txBitcoin.ins.length, 1);
      assertStrictEqual(txBitcoin.outs.length, 2);
      assertStrictEqual(
        '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB',
        bitcoin.address.fromOutputScript(txBitcoin.outs[0].script)
      ); // to address
      assertStrictEqual(
        l.getAddress(),
        bitcoin.address.fromOutputScript(txBitcoin.outs[1].script)
      ); // change address

      //

      l = new SegwitP2SHWallet();
      l.setSecret('Kxr9tQED9H44gCmp6HAdmemAzU3n84H3dGkuWTKvE23JgHMW8gct');
      if (l.getAddress() !== '34AgLJhwXrvmkZS1o5TrcdeevMt22Nar53') {
        throw new Error('failed to generate segwit P2SH address from WIF');
      }

      //

      const wallet = new SegwitP2SHWallet();
      wallet.setSecret('Ky1vhqYGCiCbPd8nmbUeGfwLdXB1h5aGwxHwpXrzYRfY5cTZPDo4');
      assertStrictEqual(
        wallet.getAddress(),
        '3CKN8HTCews4rYJYsyub5hjAVm5g5VFdQJ',
      )

      utxos = [
        {
          txid: 'a56b44080cb606c0bd90e77fcd4fb34c863e68e5562e75b4386e611390eb860c',
          vout: 0,
          value: 300000,
        }
      ]

      txNew = wallet.createTransaction(
        utxos,
        [{ value: 90000, address: '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB' }],
        1,
        String(wallet.getAddress()),
        0xffffffff,
        false,
        0,
      )
      const tx = bitcoin.Transaction.fromHex(txNew.tx!.toHex());
      assertStrictEqual(
        txNew.tx!.toHex(),
        '020000000001010c86eb9013616e38b4752e56e5683e864cb34fcd7fe790bdc006b60c08446ba50000000017160014139dc70d73097f9d775f8a3280ba3e3435515641ffffffff02905f0100000000001976a914aa381cd428a4e91327fd4434aa0a08ff131f1a5a88aca73303000000000017a914749118baa93fb4b88c28909c8bf0a8202a0484f4870248304502210080545d30e3d30dff272ab11c91fd6150170b603239b48c3d56a3fa66bf240085022003762404e1b45975adc89f61ec1569fa19d6d4a8d405e060897754c489ebeade012103a5de146762f84055db3202c1316cd9008f16047f4f408c1482fdb108217eda0800000000',
      );
      assertStrictEqual(tx.ins.length, 1);
      assertStrictEqual(tx.outs.length, 2);
      assertStrictEqual(
        '1GX36PGBUrF8XahZEGQqHqnJGW2vCZteoB',
        bitcoin.address.fromOutputScript(tx.outs[0].script)
      ); // to address
      assertStrictEqual(
        bitcoin.address.fromOutputScript(tx.outs[1].script),
        wallet.getAddress()
      ); // change address

      //

      l = new TaprootWallet();
      l.setSecret('L4PKRVk1Peaar5WuH5LiKfkTygWtFfGrFeH2g2t3YVVqiwpJjMoF');
      if (
        l.getAddress() !==
        'bc1pm6lqlel3qxefsx0v39nshtghasvvp6ghn3e5hd5q280j5m9h7csqrkzssu'
      ) {
        throw new Error('failed to generate Taproot address from WIF');
      }

      //

      const txNewTaproot = l.createTransaction(
        [
          {
            value: 10000,
            address:
              'bc1pm6lqlel3qxefsx0v39nshtghasvvp6ghn3e5hd5q280j5m9h7csqrkzssu',
            txid: '4dc4c9a03dd7005310a313c5ef1754e5e53888d587073f01a5a662501c12ac3b',
            vout: 0,
          }
        ],
        [{ address: '13HaCAB4jf7FYSZexJxoczyDDnutzZigjS' }],
        1,
        String(l.getAddress()),
        0xffffffff,
        false,
        0,
      )
      if (!txNewTaproot.tx) {
        throw new Error('failed to create Taproot tx');
      }

      //

      const data2encrypt = 'really long data string';
      const crypted = encryption.encrypt(data2encrypt, 'password');
      const decrypted = encryption.decrypt(crypted, 'password');

      if (decrypted !== data2encrypt) {
        throw new Error('encryption lib is not ok');
      }

      //
      const mnemonic =
        'honey risk juice trip orient galaxy win situate shoot anchor bounce remind horse traffic exotic since escape mimic ramp skin judge owner topple erode';
      const seed = bip39.mnemonicToSeedSync(mnemonic);
      const root = bip32.fromSeed(seed);

      const path = "m/49'/0'/0'/0/0";
      const child = root.derivePath(path);
      const address = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2wpkh({
          pubkey: child.publicKey,
          network: bitcoin.networks.bitcoin,
        }),
        network: bitcoin.networks.bitcoin,
      }).address;

      if (address !== '3GcKN7q7gZuZ8eHygAhHrvPa5zZbG5Q1rK') {
        throw new Error('bip49 is not ok');
      }

      //
      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        const hd = new HDSegwitP2SHWallet();
        const hashmap: Record<string, 1> = {};
        for (let c = 0; c < 1000; c++) {
          await hd.generate();
          const secret = hd.getSecret();
          if (hashmap[secret]) {
            throw new Error('Duplicate secret generated!');
          }
          hashmap[secret] = 1;
          if (
            secret.split(' ').length !== 12 &&
            secret.split(' ').length !== 24
          ) {
            throw new Error('mnemonic phrase not ok');
          }
        }

        const hd2 = new HDSegwitP2SHWallet();
        hd2.setSecret(hd.getSecret());
        if (!hd2.validateMnemonic()) {
          throw new Error('mnemonic phrase validation not ok');
        }

        //

        const hd4 = new HDSegwitBech32Wallet();
        hd4._xpub =
          'zpub6r7jhKKm7BAVx3b3nSnuadY1WnshZYkhK8gKFoRLwK9rF3Mzv28BrGcCGA3ugGtawi1WLb2vyjQAX9ZTDGU5gNk2bLdTc3iEXr6tzR1ipNP';
        await hd4.fetchBalance();
        if (hd4.getBalance() !== 200000)
          {throw new Error("Could not fetch HD Bech32 balance");}
        await hd4.fetchTransactions();
        if (hd4.getTransactions().length !== 4)
          {throw new Error("Could not fetch HD Bech32 transactions");}
      } else {
        // skipping RN-specific test
      }

      // MalinCrypto test
      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        const hex = await MalinCrypto.scrypt(
          '717765727479',
          '4749345a22b23cf3',
          64,
          8,
          8,
          32
        ); // using non-default parameters to speed it up (not-bip38 compliant)
        if (
          hex.toUpperCase() !==
          'F36AB2DC12377C788D61E6770126D8A01028C8F6D8FE01871CE0489A1F696A90'
        ) {
          throw new Error('react-native-malin-crypto is not ok')
        }
      }

      // bip38 test
      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        let callbackWasCalled = false;
        const decryptedKey = await bip38.decryptAsync(
          '6PnU5voARjBBykwSddwCdcn6Eu9EcsK24Gs5zWxbJbPZYW7eiYQP8XgKbN',
          'qwerty',
          () => (callbackWasCalled = true),
        )
        assertStrictEqual(
          wif.encode(0x80, decryptedKey.privateKey, decryptedKey.compressed),
          'KxqRtpd9vFju297ACPKHrGkgXuberTveZPXbRDiQ3MXZycSQYtjc',
          'bip38 failed',
        );
        // bip38 with MalinCrypto doesn't support progress callback
        assertStrictEqual(
          callbackWasCalled,
          false,
          "bip38 doesn't use MalinCrypto"
        );
      }

      // slip39 test
      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        const w = new SLIP39LegacyP2PKHWallet();
        w.setSecret(
          'shadow pistol academic always adequate wildlife fancy gross oasis cylinder mustang wrist rescue view short owner flip making coding armed\n' +
            'shadow pistol academic acid actress prayer class unknown daughter sweater depict flip twice unkind craft early superior advocate guest smoking',
        );
        assertStrictEqual(
          w._getExternalAddressByIndex(0),
          '18pvMjy7AJbCDtv4TLYbGPbR7SzGzjqUpj',
          'SLIP39 failed',
        )
      }

      //

      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative'
      ) {
        assertStrictEqual(
          await Linking.canOpenURL('https://malinwallet.io/'),
          true,
          'Linking can not open https url',
        )
      } else {
        // skipping RN-specific test'
      }

      //

      assertStrictEqual(
        Buffer.from('00ff0f', 'hex').reverse().toString('hex'),
        '0fff00',
      )

    } catch (Err) {
      console.log(Err);
      errorMessage += Err;
      isOk = false;
    }

    this.setState({
      isLoading: false,
      isOk,
      errorMessage,
    })
  }

  render() {
    return (
      <ScrollView
        automaticallyAdjustContentInsets
        contentInsetAdjustmentBehavior='automatic'
      >
        <MalinSpacing20 />

        {this.state.isLoading ? (
  <MalinLoading testID="SelfTestLoading" />
            ) : (
              (() => {
                if (this.state.isOk) {
                  return (
                <View style={styles.center}>
                  <MalinText testID="SelfTestOk" h4>
                    OK
                  </MalinText>
                  <MalinSpacing20 />
                  <MalinText>{loc.settings.about_selftest_ok}</MalinText>
                </View>
                  );
                } else {
                  return (
                <View style={styles.center}>
                  <MalinText h4 numberOfLines={0}>
                    {this.state.errorMessage}
                  </MalinText>
                </View>
                  );
                }
              })()
            )}
        <MalinSpacing20 />
        <SaveFileButton
          fileName='malinwallet-selftest.txt'
          fileContent={'Success on ' + new Date().toUTCString()}
        >
          <Button title="Test Save to Storage" />
        </SaveFileButton>
        <MalinSpacing20 />
        <Button title="Test File Import" onPress={this.onPressImportDocument} />
      </ScrollView>
    );
  }
}


================================================
FILE: ./screen/settings/GeneralSettings.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import React from 'react';
import { Platform, StyleSheet } from 'react-native';
import ListItem, { PressableWrapper } from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { useSettings } from '../../hooks/context/useSettings';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';

type NavigationProp = NativeStackNavigationProp<DetailViewStackParamList, 'GeneralSettings'>;

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
});

const GeneralSettings: React.FC = () => {
  const { wallets } = useStorage();
  const { isHandOffUseEnabled, setIsHandOffUseEnabledAsyncStorage, isLegacyURv1Enabled, setIsLegacyURv1EnabledStorage } = useSettings();
  const { navigate } = useNavigation<NavigationProp>();
  const { colors } = useTheme();

  const navigateToPrivacy = () => {
    navigate('SettingsPrivacy');
  };

  const onHandOffUseEnabledChange = async (value: boolean) => {
    await setIsHandOffUseEnabledAsyncStorage(value);
  };

  const stylesWithThemeHook = {
    root: {
      backgroundColor: colors.background,
    },
  };

  return (
    <SafeAreaScrollView
      style={[styles.root, stylesWithThemeHook.root]}
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior="automatic"
    >
      {wallets.length > 0 && (
        <>
          <ListItem onPress={() => navigate('DefaultView')} title={loc.settings.default_title} chevron />
        </>
      )}
      <ListItem title={loc.settings.privacy} onPress={navigateToPrivacy} testID="SettingsPrivacy" chevron />
      {Platform.OS === 'ios' ? (
        <>
          <ListItem
            title={loc.settings.general_continuity}
            Component={PressableWrapper}
            switch={{ onValueChange: onHandOffUseEnabledChange, value: isHandOffUseEnabled }}
            subtitle={loc.settings.general_continuity_e}
          />
        </>
      ) : null}
      <ListItem
        Component={PressableWrapper}
        title="Legacy URv1 QR"
        switch={{ onValueChange: setIsLegacyURv1EnabledStorage, value: isLegacyURv1Enabled }}
      />
      <MalinSpacing20 />
    </SafeAreaScrollView>
  );
};

export default GeneralSettings;


================================================
FILE: ./screen/settings/NetworkSettings.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { isNotificationsCapable } from '../../malin_modules/notifications';
import ListItem from '../../components/ListItem';
import loc from '../../loc';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';

const NetworkSettings: React.FC = () => {
  const navigation = useExtendedNavigation();

  const navigateToElectrumSettings = () => {
    navigation.navigate('ElectrumSettings');
  };

  const navigateToLightningSettings = () => {
    navigation.navigate('LightningSettings');
  };

  const navigateToBlockExplorerSettings = () => {
    navigation.navigate('SettingsBlockExplorer');
  };

  return (
    <SafeAreaScrollView contentInsetAdjustmentBehavior="automatic" automaticallyAdjustContentInsets>
      <ListItem title={loc.settings.block_explorer} onPress={navigateToBlockExplorerSettings} testID="BlockExplorerSettings" chevron />
      <ListItem title={loc.settings.network_electrum} onPress={navigateToElectrumSettings} testID="ElectrumSettings" chevron />
      <ListItem title={loc.settings.lightning_settings} onPress={navigateToLightningSettings} testID="LightningSettings" chevron />
      {isNotificationsCapable && (
        <ListItem
          title={loc.settings.notifications}
          onPress={() => navigation.navigate('NotificationSettings')}
          testID="NotificationSettings"
          chevron
        />
      )}
    </SafeAreaScrollView>
  );
};

export default NetworkSettings;


================================================
FILE: ./screen/settings/Language.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useLayoutEffect, useState } from 'react';
import presentAlert from '../../components/Alert';
import ListItem from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc from '../../loc';
import { AvailableLanguages, TLanguage } from '../../loc/languages';
import { useSettings } from '../../hooks/context/useSettings';
import SafeAreaFlatList from '../../components/SafeAreaFlatList';
import { Keyboard, NativeSyntheticEvent, StyleSheet } from 'react-native';

const Language = () => {
  const { setLanguageStorage, language } = useSettings();
  const { setOptions } = useExtendedNavigation();
  const { colors } = useTheme();
  const [search, setSearch] = useState('');
  const stylesHook = StyleSheet.create({
    content: {
      backgroundColor: colors.background,
    },
  });

  useLayoutEffect(() => {
    setOptions({
      headerSearchBarOptions: {
        onChangeText: (event: NativeSyntheticEvent<{ text: string }>) => setSearch(event.nativeEvent.text),
      },
    });
  }, [setOptions]);

  useEffect(() => {
    setOptions({ title: loc.settings.language });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [language]);

  const onLanguageSelect = (item: TLanguage) => {
    Keyboard.dismiss();
    const currentLanguage = AvailableLanguages.find(l => l.value === language);
    setLanguageStorage(item.value).then(() => {
      if (currentLanguage?.isRTL !== item.isRTL) {
        presentAlert({ message: loc.settings.language_isRTL });
      }
    });
  };

  const renderItem = ({ item }: { item: TLanguage }) => {
    return (
      <ListItem
        disabled={language === item.value}
        title={item.label}
        checkmark={language === item.value}
        onPress={() => onLanguageSelect(item)}
        containerStyle={[styles.row, stylesHook.content]}
      />
    );
  };

  return (
    <SafeAreaFlatList
      style={styles.flex}
      contentContainerStyle={stylesHook.content}
      keyExtractor={(_item, index) => `${index}`}
      data={AvailableLanguages.filter(l => l.label.toLowerCase().includes(search.toLowerCase()))}
      renderItem={renderItem}
      initialNumToRender={25}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
    />
  );
};

export default Language;

const styles = StyleSheet.create({
  flex: {
    flex: 1,
  },
  row: { minHeight: 60 },
});


================================================
FILE: ./screen/settings/About.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import Clipboard from '@react-native-clipboard/clipboard';
import {
  Alert,
  Image,
  Linking,
  Platform,
  Pressable,
  StyleSheet,
  Text,
  useWindowDimensions,
  View
} from 'react-native';
import {
  getApplicationName,
  getBuildNumber,
  getBundleId,
  getUniqueIdSync,
  getVersion,
  hasGmsSync
} from 'react-native-device-info';
import { Icon } from '@rneui/themed';
import Rate, { AndroidMarket } from 'react-native-rate';
import A from '../../malin_modules/analytics';
import { MalinCard, MalinTextCentered } from '../../MalinComponents';
import { HDSegwitBech32Wallet } from '../../class';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import ListItem from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import loc, { formatStringAddTwoWhiteSpaces } from '../../loc';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useSettings } from '../../hooks/context/useSettings';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const branch = require('../../current-branch.json');

const About: React.FC = () => {
  const { navigate } = useExtendedNavigation();
  const { colors } = useTheme();
  const { width, height } = useWindowDimensions();
  const { isElectrumDisabled } = useSettings();

  const stylesHook = StyleSheet.create({
    textBackup: {
      color: colors.foregroundColor,
    },
    buildWith: {
      backgroundColor: colors.inputBackgroundColor,
    },
    buttonLink: {
      backgroundColor: colors.lightButton,
    },
    textLink: {
      color: colors.foregroundColor,
    }
  });

  const handleOnReleaseNotesPress = () => {
    navigate('ReleaseNotes');
  };

  const handleOnSelfTestPress = () => {
    if (isElectrumDisabled) {
      presentAlert({ message: loc.settings.about_selftest_electrum_disabled });
    } else {
      navigate('SelfTest');
    }
  };

  const handleOnLicensingPress = () => {
    navigate('Licensing');
  };

  const handleOnTwitterPress = () => {
    Linking.openURL('https://twitter.com/malinwallet');
  };

  const handleOnTelegramPress = () => {
    Linking.openURL('https://t.me/malinwallet');
  };

  const handleOnGithubPress = () => {
    Linking.openURL('https://github.com/MalinWallet/MalinWallet-wallet');
  };

  const handleOnRatePress = () => {
    const options = {
      AppleAppID: '1376878040',
      GooglePackageName: 'com.malinwallet.app',
      preferredAndroidMarket: AndroidMarket.Google,
      preferInApp: Platform.OS !== 'android',
      openAppStoreIfInAppFails: true,
      fallbackPlatformURL: 'https://malinwallet.io',
    };
    Rate.rate(options, (success) => {
      if (success) {
        console.log('User Rated.');
      }
    });
  }

  return (
    <SafeAreaScrollView
      testID='AboutScrollView'
      contentInsetAdjustmentBehavior='automatic'
      automaticallyAdjustContentInsets
    >
      <MalinCard>
        <View style={styles.center}>
          <Image
            style={styles.logo}
            source={require('../../img/malinbeast.png')}
          />
          <Text style={styles.textFree}>{loc.settings.about_free}</Text>
          <Text style={[styles.textBackup, stylesHook.textBackup]}>
            {formatStringAddTwoWhiteSpaces(loc.settings.about_backup)}
          </Text>
          {((Platform.OS === 'android' && hasGmsSync()) ||
            Platform.OS !== 'android') && (
              <Button
              onPress={handleOnRatePress}
              title={loc.settings.about_review + ' '}
            />
          )}
        </View>
      </MalinCard>
      <ListItem
        leftIcon={{
          name: 'twitter',
          type: 'font-awesome',
          color: '#1da1f2',
        }}
        onPress={handleOnTwitterPress}
        title={loc.settings.about_sm_twitter}
      />
      <ListItem
        leftIcon={{
          name: 'telegram',
          type: 'font-awesome',
          color: '#0088cc',
        }}
        onPress={handleOnTelegramPress}
        title={loc.settings.about_sm_telegram}
      />
      <MalinCard>
        <View style={[styles.buildWith, stylesHook.buildWith]}>
          <MalinSpacing20 />
          <MalinTextCentered>{loc.settings.about_awesome} </MalinTextCentered>
          <MalinSpacing20 />
          <MalinTextCentered>React Native</MalinTextCentered>
          <MalinTextCentered>bitcoinjs-lib</MalinTextCentered>
          <MalinTextCentered>Nodejs</MalinTextCentered>
          <MalinTextCentered>Electrum server</MalinTextCentered>
          <MalinSpacing20 />
          <MalinTextCentered>Inspired by AlphaWallet, Mycelium</MalinTextCentered>
          <MalinSpacing20 />
          <Pressable
            accessibilityRole="button"
            onPress={handleOnGithubPress}
            android_ripple={{ color: colors.androidRippleColor }}
            style={({ pressed }) => [
              Platform.OS === 'ios' && pressed ? styles.pressed : null,
              styles.buttonLink,
              stylesHook.buttonLink
            ]}
          >
            <Icon
              size={22}
              name='github'
              type='font-awesome-5'
              color={colors.foregroundColor}
            />
            <Text style={[styles.textLink, stylesHook.textLink]}>
              {formatStringAddTwoWhiteSpaces(loc.settings.about_sm_github)}
            </Text>
          </Pressable>
        </View>
      </MalinCard>
      <ListItem
        leftIcon={{
          name: 'book',
          type: 'font-awesome',
          color: '#9AA0AA',
        }}
        chevron
        onPress={handleOnReleaseNotesPress}
        title={loc.settings.about_release_notes}
      />
      <ListItem
        leftIcon={{
          name: 'balance-scale',
          type: 'font-awesome',
          color: colors.foregroundColor,
        }}
        chevron
        onPress={handleOnLicensingPress}
        title={loc.settings.about_license}
      />
      <ListItem
        leftIcon={{
          name: 'flask',
          type: 'font-awesome',
          color: '#FC0D44',
        }}
        chevron
        onPress={handleOnSelfTestPress}
        testID="RunSelfTestButton"
        title={loc.settings.about_selftest}
      />
      <ListItem
        leftIcon={{
          name: 'flask',
          type: 'font-awesome',
          color: '#FC0D44',
        }}
        chevron
        onPress={async () => {
          const secret =
            'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';
          const w = new HDSegwitBech32Wallet();
          w.setSecret(secret);

          const start = Date.now();
          let num;
          for (num = 0; num < 1000; num++) {
            w._getExternalAddressByIndex(num);
            if (Date.now() - start > 10 * 1000) {
              break;
            }
          }

          Alert.alert(
            loc.formatString(loc.settings.performance_score, { num })
          );
        }}
        title={loc.settings.run_performance_test}
      />
      <MalinSpacing20 />
      <MalinSpacing20 />
      <MalinTextCentered>
        {getApplicationName()} ver {getVersion()} (build{' '}
        {getBuildNumber() + ' ' + branch})
      </MalinTextCentered>
      <MalinTextCentered>
        {new Date(Number(getBuildNumber()) * 1000).toUTCString()}
      </MalinTextCentered>
      <MalinTextCentered>{getBundleId()}</MalinTextCentered>
      <MalinTextCentered>
        w, h = {width}, {height}
      </MalinTextCentered>
      <MalinTextCentered>Unique ID: {getUniqueIdSync()}</MalinTextCentered>
      <View style={styles.copyToClipboard}>
        <Pressable
          accessibilityRole="button"
          onPress={() => {
            const stringToCopy = 'userId:' + getUniqueIdSync();
            A.logError('copied unique id');
            Clipboard.setString(stringToCopy);
          }}
          style={({ pressed }) => [pressed && styles.pressed]}
        >
          <Text style={styles.copyToClipboardText}>
            {loc.transactions.details_copy}
          </Text>
        </Pressable>
      </View>
      <MalinSpacing20 />
      <MalinSpacing20 />
    </SafeAreaScrollView>
  );
}

export default About;

const styles = StyleSheet.create({
  copyToClipboard: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  copyToClipboardText: {
    fontSize: 13,
    fontWeight: '400',
    color: '#68bbe1',
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 54,
  },
  logo: {
    width: 102,
    height: 124,
  },
  textFree: {
    maxWidth: 260,
    marginVertical: 24,
    color: '#9AA0AA',
    fontSize: 15,
    textAlign: 'center',
    fontWeight: '500',
  },
  textBackup: {
    maxWidth: 260,
    marginBottom: 40,
    fontSize: 15,
    textAlign: 'center',
    fontWeight: '500',
  },
  buildWith: {
    padding: 16,
    paddingTop: 0,
    borderRadius: 8,
  },
  buttonLink: {
    borderRadius: 12,
    justifyContent: 'center',
    padding: 8,
    flexDirection: 'row',
  },
  textLink: {
    marginLeft: 8,
    fontWeight: '600',
  },
  pressed: {
    opacity: 0.6,
  }
});


================================================
FILE: ./screen/settings/Licensing.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { ScrollView } from 'react-native';

import { MalinCard, MalinText } from '../../MalinComponents';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const Licensing = () => {
  return (
    <ScrollView contentInsetAdjustmentBehavior="automatic" automaticallyAdjustContentInsets>
      <MalinCard>
        <MalinText>MIT License</MalinText>
        <MalinSpacing20 />
        <MalinText>Copyright (c) 2018-2024 MalinWallet developers</MalinText>
        <MalinSpacing20 />
        <MalinText>
          Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
          (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
          merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
          furnished to do so, subject to the following conditions:
        </MalinText>
        <MalinSpacing20 />

        <MalinText>
          The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        </MalinText>
        <MalinSpacing20 />

        <MalinText>
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
          LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
          CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        </MalinText>
      </MalinCard>
    </ScrollView>
  );
};

export default Licensing;


================================================
FILE: ./screen/settings/Currency.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import dayjs from 'dayjs';
import calendar from 'dayjs/plugin/calendar';
import React, { useCallback, useEffect, useLayoutEffect, useMemo, useState } from 'react';
import { NativeSyntheticEvent, StyleSheet, View, LayoutAnimation, UIManager, Platform, Keyboard } from 'react-native';

import {
  CurrencyRate,
  getPreferredCurrency,
  initCurrencyDaemon,
  mostRecentFetchedRate,
  setPreferredCurrency,
} from '../../malin_modules/currency';
import { MalinCard, MalinText } from '../../MalinComponents';
import presentAlert from '../../components/Alert';
import ListItem from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc from '../../loc';
import { FiatUnit, FiatUnitSource, FiatUnitType, getFiatRate } from '../../models/fiatUnit';
import { useSettings } from '../../hooks/context/useSettings';
import SafeAreaFlatList from '../../components/SafeAreaFlatList';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';

dayjs.extend(calendar);

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const ITEM_HEIGHT = 60;

const Currency: React.FC = () => {
  const { setPreferredFiatCurrencyStorage } = useSettings();
  const [isSavingNewPreferredCurrency, setIsSavingNewPreferredCurrency] = useState<FiatUnitType | undefined>();
  const [selectedCurrency, setSelectedCurrency] = useState<FiatUnitType>(FiatUnit.USD);
  const [currencyRate, setCurrencyRate] = useState<CurrencyRate>({ LastUpdated: null, Rate: null });
  const [isSearchFocused, setIsSearchFocused] = useState(false);
  const { colors } = useTheme();
  const { setOptions } = useExtendedNavigation();
  const [search, setSearch] = useState('');

  const stylesHook = StyleSheet.create({
    flex: {
      backgroundColor: colors.background,
    },
  });

  const data = useMemo(() => {
    if (search.length > 0) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }

    const searchLower = search.toLowerCase();
    return Object.values(FiatUnit).filter(
      item => item.endPointKey.toLowerCase().includes(searchLower) || item.country.toLowerCase().includes(searchLower),
    );
  }, [search]);

  const fetchCurrency = useCallback(async () => {
    let preferredCurrency;
    try {
      preferredCurrency = await getPreferredCurrency();
      if (preferredCurrency === null) {
        throw Error();
      }
      setSelectedCurrency(preferredCurrency);
    } catch (_error) {
      setSelectedCurrency(FiatUnit.USD);
    }
    const mostRecentFetchedRateValue = await mostRecentFetchedRate();
    setCurrencyRate(mostRecentFetchedRateValue);
  }, []);

  useEffect(() => {
    fetchCurrency();
  }, [fetchCurrency]);

  const handleSearchChange = useCallback((event: NativeSyntheticEvent<{ text: string }>) => {
    setSearch(event.nativeEvent.text);
  }, []);

  useLayoutEffect(() => {
    setOptions({
      headerSearchBarOptions: {
        onChangeText: handleSearchChange,
        onFocus: () => setIsSearchFocused(true),
        onBlur: () => setIsSearchFocused(false),
      },
    });
  }, [setOptions, handleSearchChange]);

  const getItemLayout = useCallback(
    (_data: unknown, index: number) => ({
      length: ITEM_HEIGHT,
      offset: ITEM_HEIGHT * index,
      index,
    }),
    [],
  );

  const renderItem = useCallback(
    // eslint-disable-next-line react/no-unused-prop-types
    ({ item }: { item: FiatUnitType }) => {
      const isSelected = selectedCurrency.endPointKey === item.endPointKey;
      const isDisabled = isSavingNewPreferredCurrency === item || isSelected;
      const isLoading = isSavingNewPreferredCurrency === item;

      return (
        <ListItem
          disabled={isDisabled}
          title={`${item.endPointKey} (${item.symbol})`}
          containerStyle={StyleSheet.flatten([styles.flex, stylesHook.flex, { height: ITEM_HEIGHT }])}
          checkmark={isSelected}
          isLoading={isLoading}
          subtitle={item.country}
          onPress={async () => {
            if (isDisabled) return;

            Keyboard.dismiss();
            setIsSavingNewPreferredCurrency(item);
            try {
              await getFiatRate(item.endPointKey);
              await setPreferredCurrency(item);
              await initCurrencyDaemon(true);
              await fetchCurrency();
              setSelectedCurrency(item);
              setPreferredFiatCurrencyStorage(FiatUnit[item.endPointKey]);
            } catch (error: any) {
              console.log(error);
              presentAlert({
                message: error.message ? `${loc.settings.currency_fetch_error}: ${error.message}` : loc.settings.currency_fetch_error,
              });
            } finally {
              setIsSavingNewPreferredCurrency(undefined);
            }
          }}
        />
      );
    },
    [isSavingNewPreferredCurrency, selectedCurrency, stylesHook.flex, fetchCurrency, setPreferredFiatCurrencyStorage],
  );

  const selectedCurrencyVisible = useMemo(
    () => data.some(item => item.endPointKey === selectedCurrency.endPointKey),
    [data, selectedCurrency.endPointKey],
  );

  const CurrencyInfo = useMemo(() => {
    if (isSearchFocused && !selectedCurrencyVisible) return null;

    return (
      <MalinCard>
        <MalinText>
          {loc.settings.currency_source} {selectedCurrency?.source ?? FiatUnitSource.CoinDesk}
        </MalinText>
        <MalinSpacing10 />
        <MalinText>
          {loc.settings.rate}: {currencyRate.Rate ?? loc._.never}
        </MalinText>
        <MalinSpacing10 />
        <MalinText>
          {loc.settings.last_updated}: {dayjs(currencyRate.LastUpdated).calendar() ?? loc._.never}
        </MalinText>
        <MalinSpacing20 />
      </MalinCard>
    );
  }, [isSearchFocused, selectedCurrencyVisible, selectedCurrency?.source, currencyRate]);

  const keyExtractor = useCallback((item: FiatUnitType) => `${item.endPointKey}-${item.locale}`, []);

  return (
    <View style={[styles.flex, stylesHook.flex]}>
      <SafeAreaFlatList
        contentInsetAdjustmentBehavior="automatic"
        automaticallyAdjustContentInsets
        automaticallyAdjustKeyboardInsets
        keyExtractor={keyExtractor}
        data={data}
        extraData={selectedCurrency}
        initialNumToRender={10}
        maxToRenderPerBatch={10}
        windowSize={10}
        updateCellsBatchingPeriod={50}
        removeClippedSubviews={true}
        getItemLayout={getItemLayout}
        renderItem={renderItem}
      />
      {CurrencyInfo}
    </View>
  );
};

export default Currency;

const styles = StyleSheet.create({
  flex: {
    flex: 1,
  },
});


================================================
FILE: ./screen/settings/IsItMyAddress.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useRef, useState, useEffect } from 'react';
import { Keyboard, StyleSheet, TextInput, View, ScrollView, Pressable, Text } from 'react-native';
import { MalinButtonLink, MalinCard, MalinText } from '../../MalinComponents';
import Button from '../../components/Button';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { TWallet } from '../../class/wallets/types';
import { WalletCarouselItem } from '../../components/WalletsCarousel';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { Divider } from '@rneui/themed';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import presentAlert from '../../components/Alert';
import { scanQrHelper } from '../../helpers/scan-qr.ts';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation.ts';
import SafeAreaScrollView from '../../components/SafeAreaScrollView.tsx';
import { MalinSpacing10, MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';

const IsItMyAddress: React.FC = () => {
  const { navigate } = useExtendedNavigation();
  const { wallets } = useStorage();
  const { colors } = useTheme();
  const scrollViewRef = useRef<ScrollView>(null);
  const firstWalletRef = useRef<View>(null);

  const [address, setAddress] = useState<string>('');
  const [matchingWallets, setMatchingWallets] = useState<TWallet[] | undefined>();
  const [resultCleanAddress, setResultCleanAddress] = useState<string | undefined>();

  const stylesHooks = StyleSheet.create({
    input: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const handleUpdateAddress = (nextValue: string) => setAddress(nextValue);

  const clearAddressInput = () => {
    setAddress('');
    setResultCleanAddress(undefined);
    setMatchingWallets(undefined);
  };

  const checkAddress = () => {
    Keyboard.dismiss();
    const cleanAddress = address.replace('bitcoin:', '').replace('BITCOIN:', '').replace('bitcoin=', '').split('?')[0];
    const matching: TWallet[] = [];

    for (const w of wallets) {
      if (w.weOwnAddress(cleanAddress)) {
        matching.push(w);
      }
    }

    if (matching.length > 0) {
      setMatchingWallets(matching);
      setResultCleanAddress(cleanAddress);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    } else {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({
        message: loc.is_it_my_address.no_wallet_owns_address,
        buttons: [
          {
            text: loc.receive.reset,
            onPress: () => {
              clearAddressInput();
            },
            style: 'destructive',
          },
          {
            text: loc._.ok,
            onPress: () => {},
            style: 'cancel',
          },
        ],
        options: { cancelable: true },
      });
      setMatchingWallets([]);
      setResultCleanAddress(undefined);
    }
  };

  const importScan = async () => {
    const value = await scanQrHelper();
    const cleanAddress = value.replace(/^bitcoin(:|=)/i, '').split('?')[0];
    setAddress(value);
    setResultCleanAddress(cleanAddress);
  };

  const viewQRCode = () => {
    if (!resultCleanAddress) return;
    navigate('ReceiveDetails', {
      address: resultCleanAddress,
    });
  };

  const isCheckAddressDisabled = address.trim().length === 0;

  useEffect(() => {
    if (matchingWallets && matchingWallets.length > 0 && scrollViewRef.current && firstWalletRef.current) {
      firstWalletRef.current.measureLayout(scrollViewRef.current.getInnerViewNode(), (x, y) => {
        scrollViewRef.current?.scrollTo({ x: 0, y: y - 20, animated: true });
      });
    }
  }, [matchingWallets]);

  const renderFormattedText = (text: string, values: { [key: string]: string }) => {
    const regex = /\{(\w+)\}/g;
    const parts = [];
    let lastIndex = 0;
    let match;
    let index = 0;

    while ((match = regex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        parts.push(<Text key={`text-${index++}`}>{text.substring(lastIndex, match.index)}</Text>);
      }
      const value = values[match[1]];
      if (value) {
        parts.push(
          <Text key={`bold-${index++}`} style={styles.boldText} selectable>
            {value}
          </Text>,
        );
      }
      lastIndex = regex.lastIndex;
    }
    if (lastIndex < text.length) {
      parts.push(<Text key={`text-${index++}`}>{text.substring(lastIndex)}</Text>);
    }
    return parts;
  };

  return (
    <SafeAreaScrollView
      ref={scrollViewRef}
      contentContainerStyle={styles.wrapper}
      automaticallyAdjustContentInsets
      automaticallyAdjustKeyboardInsets
      contentInsetAdjustmentBehavior="automatic"
    >
      <MalinCard style={styles.mainCard}>
        <View style={[styles.input, stylesHooks.input]}>
          <TextInput
            style={styles.textInput}
            multiline
            editable
            placeholder={loc.is_it_my_address.enter_address}
            placeholderTextColor={colors.placeholderTextColor}
            value={address}
            onChangeText={handleUpdateAddress}
            testID="AddressInput"
          />
          {address.length > 0 && (
            <Pressable onPress={clearAddressInput} style={styles.clearButton}>
              <Icon name="close" size={20} color="#81868e" />
            </Pressable>
          )}
        </View>

        <MalinSpacing10 />
        <MalinButtonLink title={loc.wallets.import_scan_qr} onPress={importScan} />
        <MalinSpacing20 />
        {resultCleanAddress && (
          <>
            <Button title={loc.is_it_my_address.view_qrcode} onPress={viewQRCode} />
            <MalinSpacing20 />
          </>
        )}
        <Button disabled={isCheckAddressDisabled} title={loc.is_it_my_address.check_address} onPress={checkAddress} testID="CheckAddress" />
        <MalinSpacing40 />

        {matchingWallets !== undefined && matchingWallets.length > 0 && (
          <>
            <Divider />
            <MalinSpacing40 />
          </>
        )}
        {matchingWallets !== undefined &&
          matchingWallets.length > 0 &&
          matchingWallets.map((wallet, index) => (
            <View key={wallet.getID()} ref={index === 0 ? firstWalletRef : undefined} style={styles.walletContainer}>
              <MalinText selectable style={styles.resultText}>
                {resultCleanAddress &&
                  renderFormattedText(loc.is_it_my_address.owns, {
                    label: wallet.getLabel(),
                    address: resultCleanAddress,
                  })}
              </MalinText>
              <MalinSpacing10 />
              <WalletCarouselItem
                item={wallet}
                onPress={item => {
                  navigate('WalletTransactions', {
                    walletID: item.getID(),
                    walletType: item.type,
                  });
                }}
              />
              <MalinSpacing20 />
            </View>
          ))}
      </MalinCard>
    </SafeAreaScrollView>
  );
};

export default IsItMyAddress;

const styles = StyleSheet.create({
  wrapper: {
    alignItems: 'center',
  },
  mainCard: {
    padding: 0,
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'flex-start',
    width: '100%',
  },
  input: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    alignItems: 'center',
    borderRadius: 4,
    width: '100%',
  },
  textInput: {
    flex: 1,
    padding: 8,
    minHeight: 100,
    color: '#81868e',
  },
  clearButton: {
    padding: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  boldText: {
    fontWeight: 'bold',
  },
  resultText: {
    marginVertical: 10,
    textAlign: 'center',
  },
  walletContainer: {
    width: '100%',
    alignItems: 'center',
  },
});


================================================
FILE: ./screen/settings/EncryptStorage.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useReducer, useRef } from 'react';
import { Alert, Platform, StyleSheet, Text, TouchableWithoutFeedback, View } from 'react-native';
import ListItem, { TouchableOpacityWrapper } from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import loc from '../../loc';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { useStorage } from '../../hooks/context/useStorage';
import PromptPasswordConfirmationModal, {
  MODAL_TYPES,
  PromptPasswordConfirmationModalHandle,
} from '../../components/PromptPasswordConfirmationModal';
import presentAlert from '../../components/Alert';
import { Header } from '../../components/Header';
import { StackActions } from '@react-navigation/native';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';

enum ActionType {
  SetLoading = 'SET_LOADING',
  SetStorageEncryptedSwitch = 'SET_STORAGE_ENCRYPTED_SWITCH',
  SetDeviceBiometricCapable = 'SET_DEVICE_BIOMETRIC_CAPABLE',
  SetCurrentLoadingSwitch = 'SET_CURRENT_LOADING_SWITCH',
  SetModalType = 'SET_MODAL_TYPE',
}

interface Action {
  type: ActionType;
  payload?: any;
}

interface State {
  isLoading: boolean;
  storageIsEncryptedSwitchEnabled: boolean;
  deviceBiometricCapable: boolean;
  currentLoadingSwitch: string | null;
  modalType: keyof typeof MODAL_TYPES;
}

const initialState: State = {
  isLoading: true,
  storageIsEncryptedSwitchEnabled: false,
  deviceBiometricCapable: false,
  currentLoadingSwitch: null,
  modalType: MODAL_TYPES.ENTER_PASSWORD,
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case ActionType.SetLoading:
      return { ...state, isLoading: action.payload };
    case ActionType.SetStorageEncryptedSwitch:
      return { ...state, storageIsEncryptedSwitchEnabled: action.payload };
    case ActionType.SetDeviceBiometricCapable:
      return { ...state, deviceBiometricCapable: action.payload };
    case ActionType.SetCurrentLoadingSwitch:
      return { ...state, currentLoadingSwitch: action.payload };
    case ActionType.SetModalType:
      return { ...state, modalType: action.payload };
    default:
      return state;
  }
};

const EncryptStorage = () => {
  const { isStorageEncrypted, encryptStorage, decryptStorage, saveToDisk } = useStorage();
  const { isDeviceBiometricCapable, biometricEnabled, setBiometricUseEnabled, deviceBiometricType } = useBiometrics();
  const [state, dispatch] = useReducer(reducer, initialState);
  const navigation = useExtendedNavigation();
  const { colors } = useTheme();
  const promptRef = useRef<PromptPasswordConfirmationModalHandle>(null);

  const styleHooks = StyleSheet.create({
    root: {
      backgroundColor: colors.background,
    },
  });

  const initializeState = useCallback(async () => {
    const isStorageEncryptedSwitchEnabled = await isStorageEncrypted();
    const isDeviceBiometricCapableSync = await isDeviceBiometricCapable();
    dispatch({ type: ActionType.SetStorageEncryptedSwitch, payload: isStorageEncryptedSwitchEnabled });
    dispatch({ type: ActionType.SetDeviceBiometricCapable, payload: isDeviceBiometricCapableSync });
    dispatch({ type: ActionType.SetLoading, payload: false });
  }, [isStorageEncrypted, isDeviceBiometricCapable]);

  useEffect(() => {
    initializeState();
  }, [initializeState]);

  const handleDecryptStorage = async () => {
    dispatch({ type: ActionType.SetModalType, payload: MODAL_TYPES.ENTER_PASSWORD });
    promptRef.current?.present();
  };

  const onEncryptStorageSwitch = async (value: boolean) => {
    dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: 'encrypt' });
    dispatch({ type: ActionType.SetLoading, payload: true });

    if (value) {
      dispatch({ type: ActionType.SetModalType, payload: MODAL_TYPES.CREATE_PASSWORD });
      promptRef.current?.present();
    } else {
      Alert.alert(
        loc.settings.encrypt_decrypt,
        loc.settings.encrypt_decrypt_q,
        [
          {
            text: loc._.cancel,
            style: 'cancel',
            onPress: () => {
              dispatch({ type: ActionType.SetLoading, payload: false });
              dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: null });
            },
          },
          {
            text: loc._.ok,
            style: 'destructive',
            onPress: handleDecryptStorage,
          },
        ],
        { cancelable: false },
      );
    }
  };

  const onUseBiometricSwitch = async (value: boolean) => {
    dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: 'biometric' });
    if (await unlockWithBiometrics()) {
      setBiometricUseEnabled(value);
      dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: null });
    } else {
      dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: null });
    }
  };

  const navigateToPlausibleDeniability = () => {
    navigation.navigate('PlausibleDeniability');
  };

  const popToTop = () => {
    const action = StackActions.popToTop();
    navigation.dispatch(action);
  };

  return (
    <SafeAreaScrollView>
      <View style={styles.paddingTop} />
      {state.deviceBiometricCapable && (
        <>
          <Header leftText={loc.settings.biometrics} />
          <ListItem
            title={loc.formatString(loc.settings.encrypt_use, { type: deviceBiometricType! })}
            Component={TouchableWithoutFeedback}
            switch={{
              value: biometricEnabled,
              onValueChange: onUseBiometricSwitch,
              disabled: state.currentLoadingSwitch !== null,
            }}
            isLoading={state.currentLoadingSwitch === 'biometric' && state.isLoading}
            containerStyle={[styles.row, styleHooks.root]}
            subtitle={
              <>
                <Text style={styles.subtitleText}>{loc.formatString(loc.settings.encrypt_use_expl, { type: deviceBiometricType! })}</Text>
                {Platform.OS === 'android' && Platform.Version >= 30 && (
                  <Text style={styles.subtitleText}>{loc.formatString(loc.settings.biometrics_fail, { type: deviceBiometricType! })}</Text>
                )}
              </>
            }
          />
        </>
      )}
      <MalinSpacing20 />
      <Header leftText={loc.settings.encrypt_tstorage} />
      <ListItem
        testID="EncyptedAndPasswordProtected"
        title={loc.settings.encrypt_enc_and_pass}
        Component={TouchableWithoutFeedback}
        switch={{
          onValueChange: onEncryptStorageSwitch,
          value: state.storageIsEncryptedSwitchEnabled,
          disabled: state.currentLoadingSwitch !== null,
          testID: 'EncyptedAndPasswordProtectedSwitch',
        }}
        isLoading={state.currentLoadingSwitch === 'encrypt' && state.isLoading}
        containerStyle={[styles.row, styleHooks.root]}
      />
      {state.storageIsEncryptedSwitchEnabled && (
        <ListItem
          onPress={navigateToPlausibleDeniability}
          title={loc.settings.plausible_deniability}
          chevron
          testID="PlausibleDeniabilityButton"
          Component={TouchableOpacityWrapper}
          containerStyle={[styles.row, styleHooks.root]}
        />
      )}
      <PromptPasswordConfirmationModal
        ref={promptRef}
        modalType={state.modalType}
        onConfirmationSuccess={async (password: string) => {
          let success = false;
          if (state.modalType === MODAL_TYPES.CREATE_PASSWORD) {
            try {
              await encryptStorage(password);
              await saveToDisk();
              dispatch({ type: ActionType.SetModalType, payload: MODAL_TYPES.SUCCESS });
              success = true;
            } catch (error) {
              presentAlert({ message: (error as Error).message });
              success = false;
            }
          } else if (state.modalType === MODAL_TYPES.ENTER_PASSWORD) {
            try {
              await decryptStorage(password);
              await saveToDisk();
              popToTop();
              return true;
            } catch (error) {
              success = false;
            }
          }
          dispatch({ type: ActionType.SetLoading, payload: false });
          dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: null });
          initializeState();
          return success;
        }}
        onConfirmationFailure={() => {
          dispatch({ type: ActionType.SetLoading, payload: false });
          dispatch({ type: ActionType.SetCurrentLoadingSwitch, payload: null });
        }}
      />
    </SafeAreaScrollView>
  );
};

const styles = StyleSheet.create({
  paddingTop: { paddingTop: 19 },
  row: { minHeight: 60 },
  subtitleText: {
    fontSize: 14,
    marginTop: 5,
  },
});

export default EncryptStorage;


================================================
FILE: ./screen/settings/Settings.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import ListItem from '../../components/ListItem';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc from '../../loc';
import { useSettings } from '../../hooks/context/useSettings';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';

const Settings = () => {
  const { navigate } = useExtendedNavigation();
  // By simply having it here, it'll re-render the UI if language is changed
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { language } = useSettings();

  return (
    <SafeAreaScrollView>
      <ListItem title={loc.settings.general} onPress={() => navigate('GeneralSettings')} testID="GeneralSettings" chevron />
      <ListItem title={loc.settings.currency} onPress={() => navigate('Currency')} testID="Currency" chevron />
      <ListItem title={loc.settings.language} onPress={() => navigate('Language')} testID="Language" chevron />
      <ListItem title={loc.settings.encrypt_title} onPress={() => navigate('EncryptStorage')} testID="SecurityButton" chevron />
      <ListItem title={loc.settings.network} onPress={() => navigate('NetworkSettings')} testID="NetworkSettings" chevron />
      <ListItem title={loc.settings.tools} onPress={() => navigate('ToolsScreen')} testID="Tools" chevron />
      <ListItem title={loc.settings.about} onPress={() => navigate('About')} testID="AboutButton" chevron />
    </SafeAreaScrollView>
  );
};

export default Settings;


================================================
FILE: ./screen/settings/DefaultView.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import React, { useEffect, useReducer } from 'react';
import { TouchableWithoutFeedback, View } from 'react-native';
import { TWallet } from '../../class/wallets/types';
import ListItem from '../../components/ListItem';
import useOnAppLaunch from '../../hooks/useOnAppLaunch';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';

type RootStackParamList = {
  SelectWallet: { onWalletSelect: (wallet: TWallet) => void; onChainRequireSend: boolean };
};

type DefaultViewNavigationProp = NativeStackNavigationProp<RootStackParamList, 'SelectWallet'>;

const enum ActionType {
  SetDefaultWalletLabel = 'SET_DEFAULT_WALLET_LABEL',
  SetViewAllWalletsSwitch = 'SET_VIEW_ALL_WALLETS_SWITCH',
}

type State = {
  defaultWalletLabel: string;
  isViewAllWalletsSwitchEnabled: boolean;
};

type Action = { type: ActionType.SetDefaultWalletLabel; payload: string } | { type: ActionType.SetViewAllWalletsSwitch; payload: boolean };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case ActionType.SetDefaultWalletLabel:
      return { ...state, defaultWalletLabel: action.payload };
    case ActionType.SetViewAllWalletsSwitch:
      return { ...state, isViewAllWalletsSwitchEnabled: action.payload };
    default:
      return state;
  }
};

const DefaultView: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, {
    defaultWalletLabel: '',
    isViewAllWalletsSwitchEnabled: true,
  });

  const { navigate, pop } = useNavigation<DefaultViewNavigationProp>();
  const { wallets } = useStorage();
  const { isViewAllWalletsEnabled, getSelectedDefaultWallet, setSelectedDefaultWallet, setViewAllWalletsEnabled } = useOnAppLaunch();

  useEffect(() => {
    (async () => {
      const newViewAllWalletsEnabled: boolean = await isViewAllWalletsEnabled();
      let newDefaultWalletLabel: string = '';
      const walletID = await getSelectedDefaultWallet();

      if (walletID) {
        const w = wallets.find(wallet => wallet.getID() === walletID);
        if (w) newDefaultWalletLabel = w.getLabel();
      }
      dispatch({ type: ActionType.SetDefaultWalletLabel, payload: newDefaultWalletLabel });
      dispatch({ type: ActionType.SetViewAllWalletsSwitch, payload: newViewAllWalletsEnabled });
    })();
  }, [wallets, getSelectedDefaultWallet, isViewAllWalletsEnabled]);

  const onViewAllWalletsSwitchValueChanged = async (value: boolean) => {
    await setViewAllWalletsEnabled(value);
    dispatch({ type: ActionType.SetViewAllWalletsSwitch, payload: value });

    if (!value && wallets.length === 1) {
      // Automatically select the wallet if there is only one
      const selectedWallet = wallets[0];
      await setSelectedDefaultWallet(selectedWallet.getID());
      dispatch({ type: ActionType.SetDefaultWalletLabel, payload: selectedWallet.getLabel() });
    } else if (!value) {
      const selectedWalletID = await getSelectedDefaultWallet();
      const selectedWallet = wallets.find(wallet => wallet.getID() === selectedWalletID);
      if (selectedWallet) {
        dispatch({ type: ActionType.SetDefaultWalletLabel, payload: selectedWallet.getLabel() });
      }
    }
  };

  const selectWallet = () => {
    navigate('SelectWallet', { onWalletSelect: onWalletSelectValueChanged, onChainRequireSend: false });
  };

  const onWalletSelectValueChanged = async (wallet: TWallet) => {
    await setViewAllWalletsEnabled(false);
    await setSelectedDefaultWallet(wallet.getID());
    dispatch({ type: ActionType.SetDefaultWalletLabel, payload: wallet.getLabel() });
    dispatch({ type: ActionType.SetViewAllWalletsSwitch, payload: false });
    pop();
  };

  return (
    <SafeAreaScrollView automaticallyAdjustContentInsets={false} contentInsetAdjustmentBehavior="automatic">
      <View>
        <ListItem
          title={loc.settings.default_wallets}
          Component={TouchableWithoutFeedback}
          switch={{
            onValueChange: onViewAllWalletsSwitchValueChanged,
            value: state.isViewAllWalletsSwitchEnabled,
            disabled: wallets.length <= 0,
          }}
          subtitle={loc.settings.default_desc}
        />

        {!state.isViewAllWalletsSwitchEnabled && (
          <ListItem
            title={loc.settings.default_info}
            onPress={selectWallet}
            rightTitle={state.defaultWalletLabel}
            chevron
            disabled={wallets.length <= 1}
          />
        )}
      </View>
    </SafeAreaScrollView>
  );
};

export default DefaultView;


================================================
FILE: ./screen/settings/tools.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import ListItem from '../../components/ListItem';
import loc from '../../loc';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation.ts';

const ToolsScreen = () => {
  const { navigate } = useExtendedNavigation();

  const navigateToIsItMyAddress = () => {
    navigate('IsItMyAddress');
  };

  const navigateToBroadcast = () => {
    navigate('Broadcast');
  };

  const navigateToGenerateWord = () => {
    navigate('GenerateWord');
  };

  return (
    <SafeAreaScrollView>
      <ListItem title={loc.is_it_my_address.title} onPress={navigateToIsItMyAddress} testID="IsItMyAddress" chevron />
      <ListItem title={loc.settings.network_broadcast} onPress={navigateToBroadcast} testID="Broadcast" chevron />
      <ListItem title={loc.autofill_word.title} onPress={navigateToGenerateWord} testID="GenerateWord" chevron />
    </SafeAreaScrollView>
  );
};

export default ToolsScreen;


================================================
FILE: ./screen/settings/SettingsPrivacy.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect, useState } from 'react';
import { Platform, StyleSheet, Text, TouchableWithoutFeedback, View } from 'react-native';
import { openSettings } from 'react-native-permissions';
import A from '../../malin_modules/analytics';
import { Header } from '../../components/Header';
import ListItem, { PressableWrapper } from '../../components/ListItem';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import { useStorage } from '../../hooks/context/useStorage';
import { useSettings } from '../../hooks/context/useSettings';
import { isDesktop } from '../../malin_modules/environment';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';

enum SettingsPrivacySection {
  None,
  All,
  ReadClipboard,
  QuickActions,
  Widget,
  TemporaryScreenshots,
  TotalBalance,
}

const SettingsPrivacy: React.FC = () => {
  const { colors } = useTheme();
  const { isStorageEncrypted, wallets } = useStorage();
  const {
    isDoNotTrackEnabled,
    setDoNotTrackStorage,
    isPrivacyBlurEnabled,
    setIsPrivacyBlurEnabled,
    isWidgetBalanceDisplayAllowed,
    setIsWidgetBalanceDisplayAllowedStorage,
    isClipboardGetContentEnabled,
    setIsClipboardGetContentEnabledStorage,
    isQuickActionsEnabled,
    setIsQuickActionsEnabledStorage,
    isTotalBalanceEnabled,
    setIsTotalBalanceEnabledStorage,
  } = useSettings();
  const [isLoading, setIsLoading] = useState<number>(SettingsPrivacySection.All);

  const [storageIsEncrypted, setStorageIsEncrypted] = useState<boolean>(true);
  const styleHooks = StyleSheet.create({
    root: {
      backgroundColor: colors.background,
    },
  });

  useEffect(() => {
    (async () => {
      try {
        setStorageIsEncrypted(await isStorageEncrypted());
      } catch (e) {
        console.log(e);
      }
      setIsLoading(SettingsPrivacySection.None);
    })();
  }, [isStorageEncrypted]);

  const onDoNotTrackValueChange = async (value: boolean) => {
    setIsLoading(SettingsPrivacySection.All);
    try {
      setDoNotTrackStorage(value);
      A.setOptOut(value);
    } catch (e) {
      console.debug('onDoNotTrackValueChange catch', e);
    }
    setIsLoading(SettingsPrivacySection.None);
  };

  const onQuickActionsValueChange = async (value: boolean) => {
    setIsLoading(SettingsPrivacySection.QuickActions);
    try {
      setIsQuickActionsEnabledStorage(value);
    } catch (e) {
      console.debug('onQuickActionsValueChange catch', e);
    }
    setIsLoading(SettingsPrivacySection.None);
  };

  const onWidgetsTotalBalanceValueChange = async (value: boolean) => {
    setIsLoading(SettingsPrivacySection.Widget);
    try {
      setIsWidgetBalanceDisplayAllowedStorage(value);
    } catch (e) {
      console.debug('onWidgetsTotalBalanceValueChange catch', e);
    }
    setIsLoading(SettingsPrivacySection.None);
  };

  const onTotalBalanceEnabledValueChange = async (value: boolean) => {
    setIsLoading(SettingsPrivacySection.TotalBalance);
    try {
      setIsTotalBalanceEnabledStorage(value);
    } catch (e) {
      console.debug('onTotalBalanceEnabledValueChange catch', e);
    }
    setIsLoading(SettingsPrivacySection.None);
  };

  const onTemporaryScreenshotsValueChange = (value: boolean) => {
    setIsLoading(SettingsPrivacySection.TemporaryScreenshots);
    setIsPrivacyBlurEnabled(!value);
    setIsLoading(SettingsPrivacySection.None);
  };

  const openApplicationSettings = () => {
    openSettings();
  };

  return (
    <SafeAreaScrollView style={[styles.root, styleHooks.root]} contentInsetAdjustmentBehavior="automatic" automaticallyAdjustContentInsets>
      {Platform.OS === 'android' ? (
        <View style={styles.headerContainer}>
          <Header leftText={loc.settings.general} />
        </View>
      ) : null}

      <ListItem
        title={loc.settings.privacy_read_clipboard}
        Component={TouchableWithoutFeedback}
        switch={{
          onValueChange: setIsClipboardGetContentEnabledStorage,
          value: isClipboardGetContentEnabled,
          disabled: isLoading === SettingsPrivacySection.All,
          testID: 'ClipboardSwitch',
        }}
        subtitle={loc.settings.privacy_clipboard_explanation}
      />

      <ListItem
        title={loc.settings.privacy_quickactions}
        Component={TouchableWithoutFeedback}
        switch={{
          onValueChange: onQuickActionsValueChange,
          value: storageIsEncrypted ? false : isQuickActionsEnabled,
          disabled: isLoading === SettingsPrivacySection.All || storageIsEncrypted,
          testID: 'QuickActionsSwitch',
        }}
        subtitle={
          <>
            <Text style={styles.subtitleText}>{loc.settings.privacy_quickactions_explanation}</Text>
            {storageIsEncrypted && <Text style={styles.subtitleText}>{loc.settings.encrypted_feature_disabled}</Text>}
          </>
        }
      />

      <ListItem
        title={loc.total_balance_view.title}
        Component={PressableWrapper}
        switch={{
          onValueChange: onTotalBalanceEnabledValueChange,
          value: isTotalBalanceEnabled,
          disabled: isLoading === SettingsPrivacySection.All || wallets.length < 2,
          testID: 'TotalBalanceSwitch',
        }}
        subtitle={<Text style={styles.subtitleText}>{loc.total_balance_view.explanation}</Text>}
      />

      {!isDesktop && (
        <ListItem
          title={loc.settings.privacy_temporary_screenshots}
          Component={TouchableWithoutFeedback}
          switch={{
            onValueChange: onTemporaryScreenshotsValueChange,
            value: !isPrivacyBlurEnabled,
            disabled: isLoading === SettingsPrivacySection.All,
          }}
          subtitle={<Text style={styles.subtitleText}>{loc.settings.privacy_temporary_screenshots_instructions}</Text>}
        />
      )}

      <ListItem
        title={loc.settings.privacy_do_not_track}
        Component={TouchableWithoutFeedback}
        switch={{
          onValueChange: onDoNotTrackValueChange,
          value: isDoNotTrackEnabled,
          disabled: isLoading === SettingsPrivacySection.All,
        }}
        subtitle={<Text style={styles.subtitleText}>{loc.settings.privacy_do_not_track_explanation}</Text>}
      />

      {Platform.OS === 'ios' && (
        <>
          <MalinSpacing20 />
          <Header leftText={loc.settings.widgets} />
          <ListItem
            title={loc.settings.total_balance}
            Component={TouchableWithoutFeedback}
            switch={{
              onValueChange: onWidgetsTotalBalanceValueChange,
              value: storageIsEncrypted ? false : isWidgetBalanceDisplayAllowed,
              disabled: isLoading === SettingsPrivacySection.All || storageIsEncrypted,
            }}
            subtitle={
              <>
                <Text style={styles.subtitleText}>{loc.settings.total_balance_explanation}</Text>
                {storageIsEncrypted && <Text style={styles.subtitleText}>{loc.settings.encrypted_feature_disabled}</Text>}
              </>
            }
          />
        </>
      )}

      <ListItem title={loc.settings.privacy_system_settings} chevron onPress={openApplicationSettings} testID="PrivacySystemSettings" />
    </SafeAreaScrollView>
  );
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },

  headerContainer: {
    paddingVertical: 16,
  },
  subtitleText: {
    fontSize: 14,
    marginTop: 5,
  },
});

export default SettingsPrivacy;


================================================
FILE: ./screen/settings/ReleaseNotes.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { ScrollView } from 'react-native';

import { MalinCard, MalinText } from '../../MalinComponents';

const ReleaseNotes: React.FC = () => {
  const notes = require('../../release-notes');

  return (
    <ScrollView contentInsetAdjustmentBehavior="automatic" automaticallyAdjustContentInsets>
      <MalinCard>
        <MalinText>{notes}</MalinText>
      </MalinCard>
    </ScrollView>
  );
};

export default ReleaseNotes;


================================================
FILE: ./screen/settings/SettingsBlockExplorer.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useRef, useCallback, useState, useEffect } from 'react';
import { StyleSheet, TextInput, SectionListRenderItemInfo, SectionListData, View, LayoutAnimation } from 'react-native';
import ListItem from '../../components/ListItem';
import loc from '../../loc';
import { useTheme } from '../../components/themes';
import {
  getBlockExplorersList,
  BlockExplorer,
  isValidUrl,
  normalizeUrl,
  BLOCK_EXPLORERS,
  removeBlockExplorer,
} from '../../models/blockExplorer';
import presentAlert from '../../components/Alert';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { useSettings } from '../../hooks/context/useSettings';
import SettingsBlockExplorerCustomUrlItem from '../../components/SettingsBlockExplorerCustomUrlListItem';
import { Header } from '../../components/Header';
import SafeAreaSectionList from '../../components/SafeAreaSectionList';

type BlockExplorerItem = BlockExplorer | string;

interface SectionData extends SectionListData<BlockExplorerItem> {
  title?: string;
  data: BlockExplorerItem[];
}

const SettingsBlockExplorer: React.FC = () => {
  const { colors } = useTheme();
  const { selectedBlockExplorer, setBlockExplorerStorage } = useSettings();
  const customUrlInputRef = useRef<TextInput>(null);
  const [customUrl, setCustomUrl] = useState<string>(selectedBlockExplorer.key === 'custom' ? selectedBlockExplorer.url : '');
  const [isCustomEnabled, setIsCustomEnabled] = useState<boolean>(selectedBlockExplorer.key === 'custom');
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

  const predefinedExplorers = getBlockExplorersList().filter(explorer => explorer.key !== 'custom');

  const sections: SectionData[] = [
    {
      title: loc._.suggested,
      data: predefinedExplorers,
    },
    {
      title: loc.wallets.details_advanced,
      data: ['custom'],
    },
  ];

  const handleExplorerPress = useCallback(
    async (explorer: BlockExplorer) => {
      const success = await setBlockExplorerStorage(explorer);
      if (success) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        setIsCustomEnabled(false);
      } else {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: loc.settings.block_explorer_error_saving_custom });
      }
    },
    [setBlockExplorerStorage],
  );

  const handleCustomUrlChange = useCallback((url: string) => {
    setCustomUrl(url);
  }, []);

  const handleSubmitCustomUrl = useCallback(async () => {
    if (isSubmitting) return;
    setIsSubmitting(true);
    const customUrlNormalized = normalizeUrl(customUrl);

    if (!isValidUrl(customUrlNormalized)) {
      presentAlert({ message: loc.settings.block_explorer_invalid_custom_url });
      customUrlInputRef.current?.focus();
      setIsSubmitting(false);
      return;
    }

    const customExplorer: BlockExplorer = {
      key: 'custom',
      name: 'Custom',
      url: customUrlNormalized,
    };

    const success = await setBlockExplorerStorage(customExplorer);

    if (success) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    } else {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ message: loc.settings.block_explorer_error_saving_custom });
    }
    setIsSubmitting(false);
  }, [customUrl, setBlockExplorerStorage, isSubmitting]);

  const handleCustomSwitchToggle = useCallback(
    async (value: boolean) => {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setIsCustomEnabled(value);
      if (value) {
        await removeBlockExplorer();
        customUrlInputRef.current?.focus();
      } else {
        const defaultExplorer = BLOCK_EXPLORERS.default;
        const success = await setBlockExplorerStorage(defaultExplorer);
        if (success) {
          triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        } else {
          triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
          if (!isSubmitting) {
            presentAlert({ message: loc.settings.block_explorer_error_saving_custom });
          }
        }
      }
    },
    [setBlockExplorerStorage, isSubmitting],
  );

  useEffect(() => {
    return () => {
      if (isCustomEnabled) {
        const customUrlNormalized = normalizeUrl(customUrl);
        if (!isValidUrl(customUrlNormalized)) {
          (async () => {
            const success = await setBlockExplorerStorage(BLOCK_EXPLORERS.default);
            if (!success) {
              triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
              presentAlert({ message: loc.settings.block_explorer_error_saving_custom });
            }
          })();
        }
      }
    };
  }, [customUrl, isCustomEnabled, setBlockExplorerStorage]);

  const renderItem = useCallback(
    ({ item, section }: SectionListRenderItemInfo<BlockExplorerItem, SectionData>) => {
      if (section.title === loc._.suggested) {
        const explorer = item as BlockExplorer;
        const isSelected = !isCustomEnabled && normalizeUrl(selectedBlockExplorer.url || '') === normalizeUrl(explorer.url || '');
        return (
          <ListItem
            title={explorer.name}
            onPress={() => handleExplorerPress(explorer)}
            checkmark={isSelected}
            disabled={isCustomEnabled}
            containerStyle={[{ backgroundColor: colors.background }, styles.rowHeight]}
          />
        );
      } else {
        return (
          <SettingsBlockExplorerCustomUrlItem
            isCustomEnabled={isCustomEnabled}
            onSwitchToggle={handleCustomSwitchToggle}
            customUrl={customUrl}
            onCustomUrlChange={handleCustomUrlChange}
            onSubmitCustomUrl={handleSubmitCustomUrl}
            inputRef={customUrlInputRef}
          />
        );
      }
    },
    [
      selectedBlockExplorer,
      isCustomEnabled,
      handleExplorerPress,
      colors.background,
      handleCustomSwitchToggle,
      customUrl,
      handleCustomUrlChange,
      handleSubmitCustomUrl,
    ],
  );

  // @ts-ignore: renderSectionHeader type is not correct
  const renderSectionHeader = useCallback(({ section }) => {
    const { title } = section;
    if (title) {
      return (
        <View style={styles.container}>
          <Header leftText={title} />
        </View>
      );
    }
    return null;
  }, []);

  return (
    <SafeAreaSectionList<BlockExplorerItem, SectionData>
      sections={sections}
      keyExtractor={(item, index) => {
        if (typeof item === 'string') {
          return `custom-${index}`;
        } else {
          return item.key;
        }
      }}
      renderItem={renderItem}
      renderSectionHeader={renderSectionHeader}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
      style={[styles.root, { backgroundColor: colors.background }]}
      stickySectionHeadersEnabled={false}
    />
  );
};

export default SettingsBlockExplorer;

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
  container: {
    paddingTop: 24,
  },
  rowHeight: {
    minHeight: 60,
  },
});


================================================
FILE: ./screen/settings/LightningSettings.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useState } from 'react';
import { RouteProp, useRoute, useLocale } from '@react-navigation/native';
import { Alert, Linking, StyleSheet } from 'react-native';
import { Button as ButtonRNElements } from '@rneui/themed';
import DefaultPreference from 'react-native-default-preference';
import { MalinCard, MalinText } from '../../MalinComponents';
import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import { LightningCustodianWallet } from '../../class/wallets/lightning-custodian-wallet';
import presentAlert, { AlertType } from '../../components/Alert';
import { Button } from '../../components/Button';
import { useTheme } from '../../components/themes';
import loc from '../../loc';
import triggerHapticFeedback, {
  HapticFeedbackTypes
} from '../../malin_modules/hapticFeedback';
import { GROUP_IO_MALINWALLET } from '../../malin_modules/currency';
import { clearLNDHub, getLNDHub, setLNDHub } from '../../helpers/lndHub';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import AddressInput from '../../components/AddressInput';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing40 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';

type LightingSettingsRouteProps = RouteProp<
  DetailViewStackParamList,
  'LightningSettings'
>;

const LightningSettings: React.FC = () => {
  const params = useRoute<LightingSettingsRouteProps>().params;
  const { direction } = useLocale();
  const [isLoading, setIsLoading] = useState(true);
  const [URI, setURI] = useState<string>();
  const { colors } = useTheme();
  const { setParams } = useExtendedNavigation();

  const stylesHook = StyleSheet.create({
    buttonStyle: {
      backgroundColor: 'transparent',
      flexDirection: direction === 'rtl' ? 'row-reverse' : 'row',
    },
  })

  useEffect(() => {
    const fetchURI = async () => {
      try {
        // Try fetching from DefaultPreference first as DefaultPreference uses truly native storage
        const value = await getLNDHub();
        setURI(value ?? undefined);
      } catch (error) {
        console.log(error);
      }
    };

    const initialize = async () => {
      setIsLoading(true);
      await fetchURI().finally(() => {
        setIsLoading(false);
        if (params?.url) {
          Alert.alert(
            loc.formatString(loc.settings.set_lndhub_as_default, {
              url: params.url
            }) as string,
            '',
            [
              {
                text: loc._.ok,
                onPress: () => {
                  params?.url && setLndhubURI(params.url);
                },
                style: 'default',
              },
              { text: loc._.cancel, onPress: () => {}, style: 'cancel' },
            ],
            { cancelable: false },
          )
        }
      });
    }

    // Call the initialize function
    initialize();
  }, [params?.url]);

  const setLndhubURI = (value: string) => {
    // in case user scans a QR with a deeplink like `malinwallet:setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com`
    const setLndHubUrl =
      DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction(value);

    setURI(
      typeof setLndHubUrl === 'string' ? setLndHubUrl.trim() : value.trim()
    );
  };
  const save = useCallback(async () => {
    setIsLoading(true);
    let normalizedURI;
    try {
      await DefaultPreference.setName(GROUP_IO_MALINWALLET);
      if (URI) {
        normalizedURI = new URL(URI.replace(/([^:]\/)\/+/g, '$1')).toString();
        await LightningCustodianWallet.isValidNodeAddress(normalizedURI);

        await setLNDHub(normalizedURI);
      } else {
        await clearLNDHub();
      }

      presentAlert({
        message: loc.settings.lightning_saved,
        type: AlertType.Toast
      });
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    } catch (error) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({
        message: normalizedURI?.endsWith('.onion')
          ? loc.settings.lightning_error_lndhub_uri_tor
          : loc.settings.lightning_error_lndhub_uri,
      })
      console.log(error);
    }
    setIsLoading(false);
  }, [URI]);

  useEffect(() => {
    const data = params?.onBarScanned;
    if (data) {
      setLndhubURI(data);
      setParams({ onBarScanned: undefined });
    }
  }, [params?.onBarScanned, setParams]);

  return (
    <SafeAreaScrollView
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior='automatic'
    >
      <MalinCard>
        <MalinText>{loc.settings.lightning_settings_explain}</MalinText>
      </MalinCard>

      <ButtonRNElements
        icon={{
          name: 'github',
          type: 'font-awesome',
          color: colors.foregroundColor,
        }}
        onPress={() => Linking.openURL('https://github.com/MalinWallet/LndHub')}
        titleStyle={{ color: colors.buttonAlternativeTextColor }}
        title="github.com/MalinWallet/LndHub"
        // TODO: looks like there's no `color` prop on `Button`, does this make any sense?
        // color={colors.buttonTextColor}
        buttonStyle={stylesHook.buttonStyle}
      />

      <MalinCard>
        <AddressInput
          isLoading={isLoading}
          address={URI}
          placeholder={loc.formatString(loc.settings.lndhub_uri, {
            example: 'https://10.20.30.40:3000',
          })}
          onChangeText={setLndhubURI}
          testID="URIInput"
          editable={!isLoading}
        />
        <MalinSpacing40 />
        {isLoading
? (
          <MalinLoading />
        )
: (
              <Button testID='Save' onPress={save} title={loc.settings.save} />
        )}
      </MalinCard>
    </SafeAreaScrollView>
  );
}

export default LightningSettings;


================================================
FILE: ./screen/settings/ElectrumSettings.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { Alert, Keyboard, LayoutAnimation, Platform, StyleSheet, Switch, TextInput, View } from 'react-native';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import triggerHapticFeedback, { HapticFeedbackTypes, triggerSelectionHapticFeedback } from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import presentAlert from '../../components/Alert';
import Button from '../../components/Button';
import loc from '../../loc';
import {
  DoneAndDismissKeyboardInputAccessory,
  DoneAndDismissKeyboardInputAccessoryViewID,
} from '../../components/DoneAndDismissKeyboardInputAccessory';
import DefaultPreference from 'react-native-default-preference';
import { DismissKeyboardInputAccessory, DismissKeyboardInputAccessoryViewID } from '../../components/DismissKeyboardInputAccessory';
import { useTheme } from '../../components/themes';
import { RouteProp, useRoute } from '@react-navigation/native';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { Divider } from '@rneui/themed';
import { Header } from '../../components/Header';
import AddressInput from '../../components/AddressInput';
import { GROUP_IO_MALINWALLET } from '../../malin_modules/currency';
import { Action } from '../../components/types';
import ListItem, { PressableWrapper } from '../../components/ListItem';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import { useSettings } from '../../hooks/context/useSettings';
import { suggestedServers, hardcodedPeers, presentResetToDefaultsAlert } from '../../malin_modules/MalinElectrum';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';

type RouteProps = RouteProp<DetailViewStackParamList, 'ElectrumSettings'>;

export interface ElectrumServerItem {
  host: string;
  tcp?: number;
  ssl?: number;
}

const SET_PREFERRED_PREFIX = 'set_preferred_';

const ElectrumSettings: React.FC = () => {
  const { colors } = useTheme();
  const params = useRoute<RouteProps>().params;
  const { server } = params;
  const navigation = useExtendedNavigation();
  const [isLoading, setIsLoading] = useState(true);
  const [serverHistory, setServerHistory] = useState<Set<ElectrumServerItem>>(new Set());
  const [config, setConfig] = useState<{ connected?: number; host?: string; port?: string }>({});
  const [host, setHost] = useState<string>('');
  const [port, setPort] = useState<number | undefined>();
  const [sslPort, setSslPort] = useState<number | undefined>(undefined);
  const [isAndroidNumericKeyboardFocused, setIsAndroidNumericKeyboardFocused] = useState(false);
  const [isAndroidAddressKeyboardVisible, setIsAndroidAddressKeyboardVisible] = useState(false);
  const { setIsElectrumDisabled, isElectrumDisabled } = useSettings();
  const [savedServer, setSavedServer] = useState<{ host: string; tcp: string; ssl: string }>({
    host: '',
    tcp: '',
    ssl: '',
  });

  const stylesHook = StyleSheet.create({
    inputWrap: {
      borderColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    containerConnected: {
      backgroundColor: colors.feeLabel,
    },
    containerDisconnected: {
      backgroundColor: colors.redBG,
    },
    textConnected: {
      color: colors.feeValue,
    },
    textDisconnected: {
      color: colors.redText,
    },
    hostname: {
      color: colors.foregroundColor,
    },
    inputText: {
      color: colors.foregroundColor,
    },
    usePort: {
      color: colors.foregroundColor,
    },
  });

  const configIntervalRef = React.useRef<NodeJS.Timeout | null>(null);

  const fetchData = useCallback(async () => {
    console.log('Fetching data...');
    const preferredServer = await MalinElectrum.getPreferredServer();
    const savedHost = preferredServer?.host;
    const savedPort = preferredServer?.tcp ? Number(preferredServer.tcp) : undefined;
    const savedSslPort = preferredServer?.ssl ? Number(preferredServer.ssl) : undefined;
    const serverHistoryStr = (await DefaultPreference.get(MalinElectrum.ELECTRUM_SERVER_HISTORY)) as string;

    console.log('Preferred server:', preferredServer);
    console.log('Server history string:', serverHistoryStr);

    const parsedServerHistory: ElectrumServerItem[] = serverHistoryStr ? JSON.parse(serverHistoryStr) : [];

    // Allow duplicates for same host if ssl/tcp differs. Only skip if host, ssl, and tcp are all the same:
    const newServerHistoryArray: ElectrumServerItem[] = [];
    for (const item of parsedServerHistory) {
      const existing = newServerHistoryArray.find(s => s.host === item.host && s.tcp === item.tcp && s.ssl === item.ssl);
      if (!existing) {
        newServerHistoryArray.push(item);
      }
    }

    const filteredServerHistory = new Set(
      newServerHistoryArray.filter(
        v =>
          v.host &&
          (v.tcp || v.ssl) &&
          !suggestedServers.some(s => s.host === v.host && s.tcp === v.tcp && s.ssl === v.ssl) &&
          !hardcodedPeers.some(peer => peer.host === v.host && peer.tcp === v.tcp && peer.ssl === v.ssl),
      ),
    );

    console.log('Filtered server history:', filteredServerHistory);

    setHost(savedHost || '');
    setPort(savedPort);
    setSslPort(savedSslPort);
    setServerHistory(filteredServerHistory);

    setConfig(await MalinElectrum.getConfig());
    configIntervalRef.current = setInterval(async () => {
      setConfig(await MalinElectrum.getConfig());
    }, 500);

    setSavedServer({
      host: savedHost || '',
      tcp: savedPort ? savedPort.toString() : '',
      ssl: savedSslPort ? savedSslPort.toString() : '',
    });

    setIsLoading(false);

    return () => {
      if (configIntervalRef.current) clearInterval(configIntervalRef.current);
    };
  }, []);

  useEffect(() => {
    fetchData();
    return () => {
      if (configIntervalRef.current) clearInterval(configIntervalRef.current);
    };
  }, [fetchData]);

  useEffect(() => {
    if (server) {
      triggerHapticFeedback(HapticFeedbackTypes.ImpactHeavy);
      Alert.alert(
        loc.formatString(loc.settings.set_electrum_server_as_default, { server: (server as ElectrumServerItem).host }),
        '',
        [
          {
            text: loc._.ok,
            onPress: () => {
              onBarScanned(JSON.stringify(server));
            },
            style: 'default',
          },
          { text: loc._.cancel, onPress: () => {}, style: 'cancel' },
        ],
        { cancelable: false },
      );
    }
  }, [server]);

  const save = useCallback(
    async (v?: ElectrumServerItem) => {
      Keyboard.dismiss();
      setIsLoading(true);

      try {
        const serverHost = v?.host || host;
        const serverPort = v?.tcp ? v.tcp.toString() : port?.toString() || '';
        const serverSslPort = v?.ssl ? v.ssl.toString() : sslPort?.toString() || '';

        if (serverHost && (serverPort || serverSslPort)) {
          const testConnect = await MalinElectrum.testConnection(serverHost, Number(serverPort), Number(serverSslPort));
          if (!testConnect) {
            return presentAlert({
              message: serverHost.endsWith('.onion') ? loc.settings.electrum_error_connect_tor : loc.settings.electrum_error_connect,
            });
          }
          await DefaultPreference.setName(GROUP_IO_MALINWALLET);

          // Clear current data for the preferred host
          console.log('Clearing current data for the preferred host');
          await DefaultPreference.clear(MalinElectrum.ELECTRUM_HOST);
          await DefaultPreference.clear(MalinElectrum.ELECTRUM_TCP_PORT);
          await DefaultPreference.clear(MalinElectrum.ELECTRUM_SSL_PORT);

          // Save the new preferred host
          console.log('Saving new preferred host');
          await DefaultPreference.set(MalinElectrum.ELECTRUM_HOST, serverHost);
          await DefaultPreference.set(MalinElectrum.ELECTRUM_TCP_PORT, serverPort);
          await DefaultPreference.set(MalinElectrum.ELECTRUM_SSL_PORT, serverSslPort);

          const serverExistsInHistory = Array.from(serverHistory).some(
            s => s.host === serverHost && s.tcp === Number(serverPort) && s.ssl === Number(serverSslPort),
          );

          if (!serverExistsInHistory && (serverPort || serverSslPort) && !hardcodedPeers.some(peer => peer.host === serverHost)) {
            const newServerHistory = new Set(serverHistory);
            newServerHistory.add({ host: serverHost, tcp: Number(serverPort), ssl: Number(serverSslPort) });
            await DefaultPreference.set(MalinElectrum.ELECTRUM_SERVER_HISTORY, JSON.stringify(Array.from(newServerHistory)));
            setServerHistory(newServerHistory);
          }
        } else {
          throw new Error(loc.settings.electrum_error_connect);
        }

        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        presentAlert({ message: loc.settings.electrum_saved });

        await fetchData();
      } catch (error) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: (error as Error).message });
      } finally {
        setIsLoading(false);
      }
    },
    [host, port, sslPort, fetchData, serverHistory],
  );

  const selectServer = useCallback(
    (value: string) => {
      const parsedServer = JSON.parse(value) as ElectrumServerItem;
      setHost(parsedServer.host);
      setPort(parsedServer.tcp);
      setSslPort(parsedServer.ssl);
      save(parsedServer);
    },
    [save],
  );

  const presentSelectServerAlert = useCallback(
    (value: ElectrumServerItem) => {
      triggerHapticFeedback(HapticFeedbackTypes.ImpactHeavy);
      Alert.alert(
        loc.settings.electrum_preferred_server,
        loc.formatString(loc.settings.set_as_preferred_electrum, { host: value.host, port: String(value.ssl ?? value.tcp) }),
        [
          {
            text: loc._.ok,
            onPress: () => {
              selectServer(JSON.stringify(value));
            },
            style: 'default',
          },
          { text: loc._.cancel, onPress: () => {}, style: 'cancel' },
        ],
        { cancelable: false },
      );
    },
    [selectServer],
  );

  const onPressMenuItem = useCallback(
    (id: string) => {
      if (id.startsWith(SET_PREFERRED_PREFIX)) {
        const rawServer = JSON.parse(id.replace(SET_PREFERRED_PREFIX, ''));
        presentSelectServerAlert(rawServer);
      } else {
        switch (id) {
          case CommonToolTipActions.ResetToDefault.id:
            presentResetToDefaultsAlert().then(reset => {
              if (reset) {
                triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
                presentAlert({ message: loc.settings.electrum_saved });
                fetchData();
              }
            });
            break;
          default:
            try {
              selectServer(id);
            } catch (error) {
              console.warn('Unknown menu item selected:', id);
            }
            break;
        }
      }
    },
    [presentSelectServerAlert, fetchData, selectServer],
  );

  const isPreferred = useCallback(
    (value: ElectrumServerItem) => {
      return value.host === host && ((sslPort !== undefined && value.ssl === sslPort) || (sslPort === undefined && value.tcp === port));
    },
    [host, port, sslPort],
  );

  type TCreateServerActionParameters = {
    value: ElectrumServerItem;
    seenHosts: Set<string>;
    isPreferred?: boolean;
    isConnectedTo?: boolean;
    isSuggested?: boolean;
  };
  const createServerAction = useCallback(
    ({ value, seenHosts, isPreferred: _unused, isConnectedTo = false, isSuggested = false }: TCreateServerActionParameters) => {
      const hostKey = `${value.host}:${value.tcp ?? ''}:${value.ssl ?? ''}`;

      seenHosts.add(hostKey);
      return {
        id: `${SET_PREFERRED_PREFIX}${JSON.stringify(value)}`,
        text: Platform.OS === 'android' ? `${value.host}:${value.ssl ?? value.tcp}` : value.host,
        icon: isPreferred(value) ? { iconValue: Platform.OS === 'ios' ? 'star.fill' : 'star_off' } : undefined,
        menuState: isConnectedTo,
        disabled: isPreferred(value),
        subtitle: value.ssl ? `${loc._.ssl_port}: ${value.ssl}` : `${loc._.port}: ${value.tcp}`,
      } as Action;
    },
    [isPreferred],
  );

  const generateToolTipActions = useCallback(() => {
    const determineConnectedServer = (): string | null => {
      const allServers = [...suggestedServers, ...Array.from(serverHistory)];
      for (const value of allServers) {
        const isThisConnected = config?.host === value.host && (config.port === value.tcp || config.port === value.ssl);
        if (isThisConnected && isPreferred(value)) return JSON.stringify(value);
      }
      for (const value of allServers) {
        const isThisConnected = config?.host === value.host && (config.port === value.tcp || config.port === value.ssl);
        if (isThisConnected) return JSON.stringify(value);
      }
      return null;
    };

    const connectedServer = config?.connected ? determineConnectedServer() : null;

    const seenHosts = new Set<string>();
    let preferredServerFound = false;
    let connectedServerFound = false;

    const mapServers = (servers: ElectrumServerItem[], isSuggested: boolean) => {
      return servers
        .map(value => {
          const isConnectedTo = !connectedServerFound && connectedServer === JSON.stringify(value);
          if (isConnectedTo) connectedServerFound = true;

          const isPreferredServer = !preferredServerFound && isPreferred(value);
          if (isPreferredServer) preferredServerFound = true;

          return createServerAction({
            value,
            seenHosts,
            isPreferred: isPreferredServer,
            isConnectedTo,
            isSuggested,
          });
        })
        .filter((action): action is Action => action !== null);
    };

    const suggestedServersAction: Action = {
      id: 'suggested_servers',
      text: loc._.suggested,
      displayInline: true,
      subtitle: loc.settings.electrum_suggested_description,
      subactions: mapServers(suggestedServers, true),
    };

    const actions: Action[] = [];
    actions.push(suggestedServersAction);

    if (serverHistory.size > 0) {
      const serverSubactions: Action[] = mapServers(Array.from(serverHistory), false);

      actions.push({
        id: 'server_history',
        text: loc.settings.electrum_history,
        displayInline: serverHistory.size <= 5 && serverHistory.size > 0,
        subactions: serverSubactions,
        hidden: serverHistory.size === 0,
      });
    }

    const resetToDefaults = { ...CommonToolTipActions.ResetToDefault };
    resetToDefaults.hidden = !host && serverHistory.size === 0;
    actions.push(resetToDefaults);

    return actions;
  }, [config?.connected, config?.host, config.port, createServerAction, host, isPreferred, serverHistory]);

  const HeaderRight = useMemo(
    () => <HeaderMenuButton actions={generateToolTipActions()} onPressMenuItem={onPressMenuItem} />,
    [onPressMenuItem, generateToolTipActions],
  );

  useEffect(() => {
    navigation.setOptions({
      headerRight: isElectrumDisabled ? null : () => HeaderRight,
    });
  }, [HeaderRight, isElectrumDisabled, navigation]);

  const checkServer = async () => {
    setIsLoading(true);
    try {
      const features = await MalinElectrum.serverFeatures();
      triggerHapticFeedback(HapticFeedbackTypes.NotificationWarning);
      presentAlert({ message: JSON.stringify(features, null, 2) });
    } catch (error) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ message: (error as Error).message });
    }
    setIsLoading(false);
  };

  const onBarScanned = (value: string) => {
    let v = value;
    if (value && DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(value)) {
      v = DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(value) as string;
    }
    const [scannedHost, scannedPort, type] = v?.split(':') ?? [];
    setHost(scannedHost);
    if (type === 's') {
      setSslPort(Number(scannedPort));
      setPort(undefined);
    } else {
      setPort(Number(scannedPort));
      setSslPort(undefined);
    }
  };

  useEffect(() => {
    const data = params.onBarScanned;
    if (data) {
      onBarScanned(data);
      navigation.setParams({ onBarScanned: undefined });
    }
  }, [navigation, params.onBarScanned]);

  const onSSLPortChange = (value: boolean) => {
    Keyboard.dismiss();
    if (value) {
      // Move the current port to sslPort
      setSslPort(port);
      setPort(undefined);
    } else {
      // Move the current sslPort to port
      setPort(sslPort);
      setSslPort(undefined);
    }
  };

  const onElectrumConnectionEnabledSwitchChange = async (value: boolean) => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    try {
      triggerSelectionHapticFeedback();
      await MalinElectrum.setDisabled(value);
      setIsElectrumDisabled(value);
    } catch (error) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      presentAlert({ message: (error as Error).message });
    }
  };

  const preferredServerIsEmpty = !host || (!port && !sslPort);
  const saveDisabled: boolean =
    preferredServerIsEmpty ||
    (host === savedServer.host &&
      ((savedServer.tcp !== '' && port?.toString() === savedServer.tcp) ||
        (savedServer.ssl !== '' && sslPort?.toString() === savedServer.ssl)));

  const renderElectrumSettings = () => {
    return (
      <>
        <Divider />
        <MalinSpacing20 />
        <Header leftText={loc.settings.electrum_status} />
        <MalinSpacing20 />

        <MalinCard>
          <View style={styles.connectWrap}>
            <View style={[styles.container, config.connected === 1 ? stylesHook.containerConnected : stylesHook.containerDisconnected]}>
              <MalinText
                style={[styles.textConnectionStatus, config.connected === 1 ? stylesHook.textConnected : stylesHook.textDisconnected]}
              >
                {config.connected === 1 ? loc.settings.electrum_connected : loc.settings.electrum_connected_not}
              </MalinText>
            </View>
          </View>
          <MalinSpacing10 />
          <MalinText style={[styles.hostname, stylesHook.hostname]} onPress={checkServer} selectable>
            {config.host}:{config.port}
          </MalinText>
        </MalinCard>
        <MalinSpacing20 />

        <Divider />
        <MalinSpacing10 />
        <MalinSpacing20 />

        <Header leftText={loc.settings.electrum_preferred_server} />
        <MalinCard>
          <MalinText>{loc.settings.electrum_preferred_server_description}</MalinText>
          <MalinSpacing20 />
          <AddressInput
            testID="HostInput"
            placeholder={loc.formatString(loc.settings.electrum_host, { example: '10.20.30.40' })}
            address={host}
            onChangeText={text => setHost(text.trim())}
            editable={!isLoading}
            keyboardType="default"
            onBlur={() => setIsAndroidAddressKeyboardVisible(false)}
            onFocus={() => setIsAndroidAddressKeyboardVisible(true)}
            inputAccessoryViewID={DoneAndDismissKeyboardInputAccessoryViewID}
            isLoading={isLoading}
          />
          <MalinSpacing20 />
          <View style={styles.portWrap}>
            <View style={[styles.inputWrap, stylesHook.inputWrap]}>
              <TextInput
                placeholder={loc.formatString(loc.settings.electrum_port, { example: '50001' })}
                value={sslPort?.toString() === '' || sslPort === undefined ? port?.toString() || '' : sslPort?.toString() || ''}
                onChangeText={text => {
                  const parsed = Number(text.trim());
                  if (Number.isNaN(parsed)) {
                    // Handle invalid input
                    sslPort === undefined ? setPort(undefined) : setSslPort(undefined);
                    return;
                  }
                  sslPort === undefined ? setPort(parsed) : setSslPort(parsed);
                }}
                numberOfLines={1}
                style={[styles.inputText, stylesHook.inputText]}
                editable={!isLoading}
                placeholderTextColor="#81868e"
                underlineColorAndroid="transparent"
                autoCorrect={false}
                autoCapitalize="none"
                keyboardType="number-pad"
                inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
                testID="PortInput"
                onFocus={() => setIsAndroidNumericKeyboardFocused(true)}
                onBlur={() => setIsAndroidNumericKeyboardFocused(false)}
              />
            </View>
            <MalinText style={[styles.usePort, stylesHook.usePort]}>{loc.settings.use_ssl}</MalinText>
            <Switch
              testID="SSLPortInput"
              value={sslPort !== undefined}
              onValueChange={onSSLPortChange}
              disabled={host?.endsWith('.onion') || isLoading || host === '' || (port === undefined && sslPort === undefined)}
            />
          </View>
        </MalinCard>
        <MalinCard>
          <MalinSpacing20 />
          <Button disabled={saveDisabled} testID="Save" onPress={save} title={loc.settings.save} />
        </MalinCard>

        {Platform.select({
          ios: <DismissKeyboardInputAccessory />,
          android: isAndroidNumericKeyboardFocused && <DismissKeyboardInputAccessory />,
        })}

        {Platform.select({
          ios: (
            <DoneAndDismissKeyboardInputAccessory
              onClearTapped={() => setHost('')}
              onPasteTapped={text => {
                setHost(text);
                Keyboard.dismiss();
              }}
            />
          ),
          android: isAndroidAddressKeyboardVisible && (
            <DoneAndDismissKeyboardInputAccessory
              onClearTapped={() => {
                setHost('');
                Keyboard.dismiss();
              }}
              onPasteTapped={text => {
                setHost(text);
                Keyboard.dismiss();
              }}
            />
          ),
        })}
      </>
    );
  };

  return (
    <SafeAreaScrollView
      keyboardShouldPersistTaps="always"
      automaticallyAdjustContentInsets
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustKeyboardInsets
      testID="ElectrumSettingsScrollView"
    >
      <ListItem
        Component={PressableWrapper}
        title={loc.settings.electrum_offline_mode}
        switch={{
          onValueChange: onElectrumConnectionEnabledSwitchChange,
          value: isElectrumDisabled,
          testID: 'ElectrumConnectionEnabledSwitch',
        }}
        bottomDivider={false}
        subtitle={loc.settings.electrum_offline_description}
      />

      {!isElectrumDisabled && renderElectrumSettings()}
    </SafeAreaScrollView>
  );
};

const styles = StyleSheet.create({
  connectWrap: {
    width: 'auto',
    height: 34,
    flexWrap: 'wrap',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  hostname: {
    textAlign: 'center',
  },
  container: {
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    borderRadius: 20,
  },
  inputWrap: {
    flex: 1,
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    borderRadius: 4,
  },
  portWrap: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  inputText: {
    flex: 1,
    marginHorizontal: 8,
    minHeight: 36,
    height: 36,
  },
  textConnectionStatus: {
    fontWeight: 'bold',
  },
  usePort: {
    marginHorizontal: 16,
  },
});

export default ElectrumSettings;


================================================
FILE: ./screen/ActionSheet.ios.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// ActionSheet.ios.ts
import { ActionSheetIOS, InteractionManager } from 'react-native';

import { ActionSheetOptions, CompletionCallback } from './ActionSheet.common';

export default class ActionSheet {
  static showActionSheetWithOptions(options: ActionSheetOptions, completion: CompletionCallback): void {
    InteractionManager.runAfterInteractions(() => {
      const iosOptions = {
        ...options,
      };
      if (options.anchor) {
        iosOptions.anchor = options.anchor;
      }
      ActionSheetIOS.showActionSheetWithOptions(iosOptions, completion);
    });
  }
}


================================================
FILE: ./screen/Swap.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState } from 'react';
import { StyleSheet, View, TextInput, Text, SafeAreaView, ActivityIndicator, Alert } from 'react-native';
import { useTheme } from '../components/themes';
import Button from '../components/Button';
import { SwapService } from '../class/services/swap-service';

const Swap: React.FC = () => {
  const { colors } = useTheme();
  const [sellAmount, setSellAmount] = useState('');
  const [sellToken, setSellToken] = useState('WETH');
  const [buyToken, setBuyToken] = useState('USDC');
  const [quote, setQuote] = useState<any>(null);
  const [loading, setLoading] = useState(false);

  const handleGetQuote = async () => {
    if (!sellAmount) return;
    setLoading(true);
    try {
      const q = await SwapService.getQuote({
          buyToken: buyToken,
          sellToken: sellToken,
          sellAmount: (Number(sellAmount) * 1e18).toString(), // simplified wei conversion
      });
      setQuote(q);
    } catch (e: any) {
        Alert.alert('Error', e.message);
    } finally {
        setLoading(false);
    }
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <View style={styles.content}>
        <Text style={[styles.title, { color: colors.foregroundColor }]}>Swap</Text>

        <TextInput
          style={[styles.input, { color: colors.foregroundColor, backgroundColor: colors.inputBackgroundColor }]}
          value={sellAmount}
          onChangeText={setSellAmount}
          placeholder="Amount"
          placeholderTextColor={colors.buttonDisabledTextColor}
          keyboardType="numeric"
        />

        {/* Inputs for testing other pairs */}
        <TextInput
          style={[styles.input, { color: colors.foregroundColor, backgroundColor: colors.inputBackgroundColor }]}
          value={sellToken}
          onChangeText={setSellToken}
          placeholder="Sell Token (e.g. WETH)"
          placeholderTextColor={colors.buttonDisabledTextColor}
          autoCapitalize="characters"
        />
        <TextInput
          style={[styles.input, { color: colors.foregroundColor, backgroundColor: colors.inputBackgroundColor }]}
          value={buyToken}
          onChangeText={setBuyToken}
          placeholder="Buy Token (e.g. USDC)"
          placeholderTextColor={colors.buttonDisabledTextColor}
          autoCapitalize="characters"
        />

        <Button title="Get Quote" onPress={handleGetQuote} disabled={loading} />

        {loading && <ActivityIndicator style={{ marginTop: 20 }} />}

        {quote && (
            <View style={styles.result}>
                <Text style={{ color: colors.foregroundColor }}>
                    Buy Amount: {quote.buyAmount ? (Number(quote.buyAmount) / 1e6).toFixed(2) : '0'} USDC
                </Text>
                 <Text style={{ color: colors.foregroundColor }}>
                    Price: {quote.price}
                </Text>
                 <Text style={{ color: colors.foregroundColor, fontSize: 10, marginTop: 10 }}>
                    1% Fee included for MalinWallet
                </Text>
            </View>
        )}
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    marginBottom: 20,
    fontWeight: 'bold',
  },
  input: {
    height: 50,
    borderRadius: 8,
    paddingHorizontal: 10,
    marginBottom: 20,
  },
  result: {
      marginTop: 20,
      padding: 10,
      borderWidth: 1,
      borderColor: '#ccc',
      borderRadius: 8
  }
});

export default Swap;


================================================
FILE: ./screen/receive/AztecoRedeem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp, useRoute } from '@react-navigation/native';
import { Icon } from '@rneui/themed';
import React, { useEffect, useState } from 'react';
import { I18nManager, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

import { MalinText } from '../../MalinComponents';
import Azteco from '../../class/azteco';
import { TWallet } from '../../class/wallets/types';
import presentAlert from '../../components/Alert';
import { MalinLoading } from '../../components/MalinLoading';
import { MalinSpacing } from '../../components/MalinSpacing';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc from '../../loc';
import { Chain } from '../../models/bitcoinUnits';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';

type RouteProps = RouteProp<DetailViewStackParamList, 'AztecoRedeem'>;

const AztecoRedeem = () => {
  const navigation = useExtendedNavigation();
  const { wallets } = useStorage();
  const { colors } = useTheme();
  const route = useRoute<RouteProps>();
  const { aztecoVoucher } = route.params;

  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [wallet, setWallet] = useState<undefined | TWallet>(undefined);

  useEffect(() => {
    const suitable = wallets.filter(w => w.chain === Chain.ONCHAIN);
    if (suitable.length === 0) {
      presentAlert({ message: loc.azteco.errorBeforeRefeem });
      navigation.goBack();
      return;
    }
    setWallet(suitable[0]);

    // only run once on mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleRedeem = async (): Promise<void> => {
    if (!wallet) {
      presentAlert({ message: loc.azteco.errorSomething });
      return;
    }

    setIsLoading(true);
    const address = await wallet.getAddressAsync();
    if (!address) {
      navigation.goBack();
      presentAlert({ message: loc.receive.address_not_found });
      return;
    }
    const result = await Azteco.redeem(aztecoVoucher, address);
    if (!result) {
      presentAlert({ message: loc.azteco.errorSomething });
      setIsLoading(false);
    } else {
      navigation.goBack();
      presentAlert({ title: loc.azteco.success, message: loc.azteco.successMessage });
    }
  };

  const handleSelectWallet = (): void => {
    const onWalletSelect = (toWallet: TWallet): void => {
      setWallet(toWallet);
      navigation.goBack();
    };

    navigation.navigate('SelectWallet', {
      onWalletSelect,
      availableWallets: wallets,
    });
  };

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.elevated,
    },
    text: {
      color: colors.foregroundColor,
    },
  });

  if (isLoading || !wallet) {
    return (
      <View style={styles.loading}>
        <MalinLoading />
      </View>
    );
  }

  return (
    <SafeArea style={[styles.root, stylesHook.root]}>
      <View style={styles.root}>
        <Text style={stylesHook.text}>{loc.azteco.codeIs}</Text>
        <MalinText testID="AztecoCode" style={[styles.code, stylesHook.text]}>
          {aztecoVoucher.c1}-{aztecoVoucher.c2}-{aztecoVoucher.c3}-{aztecoVoucher.c4}
        </MalinText>

        <View style={styles.selectWallet1}>
          <TouchableOpacity accessibilityRole="button" style={styles.selectTouch} onPress={handleSelectWallet}>
            <Text style={[styles.selectText, stylesHook.text]}>{loc.azteco.redeem}</Text>
            <Icon name={I18nManager.isRTL ? 'angle-left' : 'angle-right'} size={18} type="font-awesome" color="#9aa0aa" />
          </TouchableOpacity>
          <View style={styles.selectWallet2}>
            <TouchableOpacity accessibilityRole="button" style={styles.selectTouch} onPress={handleSelectWallet}>
              <Text style={[styles.selectWalletLabel, stylesHook.text]}>{wallet.getLabel()}</Text>
            </TouchableOpacity>
          </View>
        </View>

        <Button onPress={handleRedeem} title={loc.azteco.redeemButton} />
        <MalinSpacing />
      </View>
    </SafeArea>
  );
};

export default AztecoRedeem;

const styles = StyleSheet.create({
  loading: {
    flex: 1,
    paddingTop: 20,
  },
  root: {
    alignItems: 'center',
    alignContent: 'flex-end',
    paddingTop: 66,
  },
  code: {
    fontSize: 20,
    marginTop: 20,
    marginBottom: 90,
  },
  selectWallet1: {
    marginBottom: 24,
    alignItems: 'center',
  },
  selectTouch: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectText: {
    fontSize: 14,
    marginRight: 8,
  },
  selectWallet2: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  selectWalletLabel: {
    fontSize: 14,
  },
});


================================================
FILE: ./screen/receive/ReceiveDetails.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { RouteProp, useFocusEffect, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { BackHandler, InteractionManager, LayoutAnimation, Platform, StyleSheet, Text, TextInput, View } from 'react-native';
import Share from 'react-native-share';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { fiatToBTC, satoshiToBTC } from '../../malin_modules/currency';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { majorTomToGroundControl, tryToObtainPermissions } from '../../malin_modules/notifications';
import { MalinButtonLink, MalinCard, MalinText } from '../../MalinComponents';
import DeeplinkSchemaMatch from '../../class/deeplink-schema-match';
import presentAlert from '../../components/Alert';
import * as AmountInput from '../../components/AmountInput';
import BottomModal, { BottomModalHandle } from '../../components/BottomModal';
import Button from '../../components/Button';
import CopyTextToClipboard from '../../components/CopyTextToClipboard';
import HandOffComponent from '../../components/HandOffComponent';
import HeaderMenuButton from '../../components/HeaderMenuButton';
import QRCodeComponent from '../../components/QRCodeComponent';
import SegmentedControl from '../../components/SegmentControl';
import { useTheme } from '../../components/themes';
import TipBox from '../../components/TipBox';
import { TransactionPendingIconBig } from '../../components/TransactionPendingIconBig';
import { HandOffActivityType } from '../../components/types';
import { useSettings } from '../../hooks/context/useSettings';
import { useStorage } from '../../hooks/context/useStorage';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc, { formatBalance } from '../../loc';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { ReceiveDetailsStackParamList } from '../../navigation/ReceiveDetailsStackParamList';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { SuccessView } from '../send/success';
import { MalinSpacing20, MalinSpacing40 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';

const segmentControlValues = [loc.wallets.details_address, loc.bip47.payment_code];
const HORIZONTAL_PADDING = 20;

type StickyHeaderProps = {
  wallet: any;
  isBIP47Enabled: boolean;
  tabValues: string[];
  currentTab: string;
  setCurrentTab: (tab: string) => void;
  backgroundColor: string;
};

const StickyHeader = React.memo(({ wallet, isBIP47Enabled, tabValues, currentTab, setCurrentTab, backgroundColor }: StickyHeaderProps) => {
  if (!wallet || !isBIP47Enabled) return null;

  return (
    <View style={[styles.tabsContainer, { backgroundColor }]}>
      <SegmentedControl
        values={tabValues}
        selectedIndex={tabValues.findIndex(tab => tab === currentTab)}
        onChange={index => {
          setCurrentTab(tabValues[index]);
        }}
      />
    </View>
  );
});

type NavigationProps = NativeStackNavigationProp<ReceiveDetailsStackParamList, 'ReceiveDetails'>;
type RouteProps = RouteProp<ReceiveDetailsStackParamList, 'ReceiveDetails'>;

const ReceiveDetails = () => {
  const { walletID, address } = useRoute<RouteProps>().params;
  const { wallets, saveToDisk, sleep, fetchAndSaveWalletTransactions } = useStorage();
  const { isElectrumDisabled } = useSettings();
  const { colors } = useTheme();
  const [customLabel, setCustomLabel] = useState('');
  const [customAmount, setCustomAmount] = useState('');
  const [customUnit, setCustomUnit] = useState<BitcoinUnit>(BitcoinUnit.BTC);
  const [bip21encoded, setBip21encoded] = useState('');
  const [isCustom, setIsCustom] = useState(false);
  const [tempCustomLabel, setTempCustomLabel] = useState('');
  const [tempCustomAmount, setTempCustomAmount] = useState('');
  const [tempCustomUnit, setTempCustomUnit] = useState<BitcoinUnit>(BitcoinUnit.BTC);
  const [showPendingBalance, setShowPendingBalance] = useState(false);
  const [showConfirmedBalance, setShowConfirmedBalance] = useState(false);
  const [showAddress, setShowAddress] = useState(false);
  const [currentTab, setCurrentTab] = useState(segmentControlValues[0]);
  const { goBack, setParams, setOptions } = useExtendedNavigation<NavigationProps>();
  const bottomModalRef = useRef<BottomModalHandle | null>(null);
  const [intervalMs, setIntervalMs] = useState(5000);
  const [eta, setEta] = useState('');
  const [initialConfirmed, setInitialConfirmed] = useState(0);
  const [initialUnconfirmed, setInitialUnconfirmed] = useState(0);
  const [displayBalance, setDisplayBalance] = useState('');
  const [qrCodeSize, setQRCodeSize] = useState(90);

  const wallet = walletID ? wallets.find(w => w.getID() === walletID) : undefined;
  const isBIP47Enabled = wallet?.isBIP47Enabled();

  const stylesHook = StyleSheet.create({
    customAmount: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    customAmountText: {
      color: colors.foregroundColor,
    },
    root: {
      backgroundColor: colors.elevated,
    },
    amount: {
      color: colors.foregroundColor,
    },
    label: {
      color: colors.foregroundColor,
    },
    modalButton: {
      backgroundColor: colors.modalButton,
    },
  });

  const setAddressBIP21Encoded = useCallback(
    (addr: string) => {
      const newBip21encoded = DeeplinkSchemaMatch.bip21encode(addr);
      setParams({ address: addr });
      setBip21encoded(newBip21encoded);
      setShowAddress(true);
    },
    [setParams],
  );

  const obtainWalletAddress = useCallback(async () => {
    console.debug('ReceiveDetails - componentDidMount');
    // this function should only be called when wallet exists
    if (!wallet) {
      console.warn('Wallet not found');
      return;
    }
    if (address) {
      setAddressBIP21Encoded(address);
      try {
        await tryToObtainPermissions();
        majorTomToGroundControl([address], [], []);
      } catch (error) {
        console.error('Error obtaining notifications permissions:', error);
      }
      return;
    }

    let newAddress;
    if (wallet.chain === Chain.ONCHAIN) {
      try {
        if (!isElectrumDisabled) newAddress = await Promise.race([wallet.getAddressAsync(), sleep(1000)]);
      } catch (error) {
        console.warn('Error fetching wallet address (ONCHAIN):', error);
      }
      if (newAddress === undefined) {
        if ('_getExternalAddressByIndex' in wallet) {
          newAddress = wallet._getExternalAddressByIndex(wallet.getNextFreeAddressIndex());
        } else {
          newAddress = wallet.getAddress();
        }
      } else {
        saveToDisk(); // caching whatever getAddressAsync() generated internally
      }
    } else {
      try {
        await Promise.race([wallet.getAddressAsync(), sleep(1000)]);
        newAddress = wallet.getAddress();
      } catch (error) {
        console.warn('Error fetching wallet address (OFFCHAIN):', error);
      }
      if (newAddress === undefined) {
        console.warn('either sleep expired or getAddressAsync threw an exception');
        newAddress = wallet.getAddress();
      } else {
        saveToDisk(); // caching whatever getAddressAsync() generated internally
      }
    }

    if (!newAddress) {
      presentAlert({ title: loc.errors.error, message: loc.receive.address_not_found });
      return;
    }

    setAddressBIP21Encoded(newAddress);

    try {
      await tryToObtainPermissions();
      majorTomToGroundControl([newAddress], [], []);
    } catch (error) {
      console.error('Error obtaining notifications permissions:', error);
    }
  }, [wallet, saveToDisk, address, setAddressBIP21Encoded, isElectrumDisabled, sleep]);

  const onEnablePaymentsCodeSwitchValue = useCallback(() => {
    if (wallet && wallet.allowBIP47()) {
      wallet.switchBIP47(!wallet.isBIP47Enabled());
    }
    saveToDisk();
    obtainWalletAddress();
  }, [wallet, saveToDisk, obtainWalletAddress]);

  useEffect(() => {
    if (showConfirmedBalance) {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
    }
  }, [showConfirmedBalance]);

  useEffect(() => {
    if (address) {
      setAddressBIP21Encoded(address);
    }
  }, [address, setAddressBIP21Encoded]);

  const toolTipActions = useMemo(() => {
    const action = { ...CommonToolTipActions.PaymentsCode };
    action.menuState = isBIP47Enabled;
    return [action];
  }, [isBIP47Enabled]);

  const onPressMenuItem = useCallback(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    onEnablePaymentsCodeSwitchValue();
  }, [onEnablePaymentsCodeSwitchValue]);

  const HeaderRight = useMemo(
    () => <HeaderMenuButton actions={toolTipActions} onPressMenuItem={onPressMenuItem} />,
    [onPressMenuItem, toolTipActions],
  );

  useEffect(() => {
    wallet?.allowBIP47() &&
      setOptions({
        headerRight: () => HeaderRight,
      });
  }, [HeaderRight, colors.foregroundColor, setOptions, wallet]);

  // re-fetching address balance periodically
  useEffect(() => {
    console.debug('receive/details - useEffect');

    const intervalId = setInterval(async () => {
      try {
        const decoded = DeeplinkSchemaMatch.bip21decode(bip21encoded);
        const addressToUse = address || decoded.address;
        if (!addressToUse) return;

        console.debug('checking address', addressToUse, 'for balance...');
        const balance = await MalinElectrum.getBalanceByAddress(addressToUse);
        console.debug('...got', balance);

        if (balance.unconfirmed > 0) {
          if (initialConfirmed === 0 && initialUnconfirmed === 0) {
            setInitialConfirmed(balance.confirmed);
            setInitialUnconfirmed(balance.unconfirmed);
            setIntervalMs(25000);
            triggerHapticFeedback(HapticFeedbackTypes.ImpactHeavy);
          }

          const txs = await MalinElectrum.getMempoolTransactionsByAddress(addressToUse);
          const tx = txs.pop();
          if (tx) {
            const rez = await MalinElectrum.multiGetTransactionByTxid([tx.tx_hash], true, 10);
            if (rez[tx.tx_hash] && rez[tx.tx_hash].vsize) {
              const satPerVbyte = Math.round(tx.fee / rez[tx.tx_hash].vsize);
              const fees = await MalinElectrum.estimateFees();
              if (satPerVbyte >= fees.fast) {
                setEta(loc.formatString(loc.transactions.eta_10m));
              } else if (satPerVbyte >= fees.medium) {
                setEta(loc.formatString(loc.transactions.eta_3h));
              } else {
                setEta(loc.formatString(loc.transactions.eta_1d));
              }
            }
          }

          setDisplayBalance(
            loc.formatString(loc.transactions.pending_with_amount, {
              amt1: formatBalance(balance.unconfirmed, BitcoinUnit.LOCAL_CURRENCY, true).toString(),
              amt2: formatBalance(balance.unconfirmed, BitcoinUnit.BTC, true).toString(),
            }),
          );
          setShowPendingBalance(true);
          setShowAddress(false);
        } else if (balance.unconfirmed === 0 && initialUnconfirmed !== 0) {
          // now, handling a case when unconfirmed == 0, but in past it wasnt (i.e. it changed while user was
          // staring at the screen)
          const balanceToShow = balance.confirmed - initialConfirmed;

          if (balanceToShow > 0) {
            // address has actually more coins than initially, so we definitely gained something
            setShowConfirmedBalance(true);
            setShowPendingBalance(false);
            setShowAddress(false);
            setDisplayBalance(
              loc.formatString(loc.transactions.received_with_amount, {
                amt1: formatBalance(balanceToShow, BitcoinUnit.LOCAL_CURRENCY, true).toString(),
                amt2: formatBalance(balanceToShow, BitcoinUnit.BTC, true).toString(),
              }),
            );
            if (walletID) {
              fetchAndSaveWalletTransactions(walletID);
            }
          } else {
            // rare case, but probable. transaction evicted from mempool (maybe cancelled by the sender)
            setShowConfirmedBalance(false);
            setShowPendingBalance(false);
            setShowAddress(true);
          }
        }
      } catch (error) {
        console.debug('Error checking balance:', error);
      }
    }, intervalMs);

    return () => clearInterval(intervalId);
  }, [bip21encoded, address, initialConfirmed, initialUnconfirmed, intervalMs, fetchAndSaveWalletTransactions, walletID]);

  useEffect(() => {
    const handleBackButton = () => {
      goBack();
      return true;
    };

    const subscription = BackHandler.addEventListener('hardwareBackPress', handleBackButton);
    return () => subscription.remove();
  }, [goBack]);

  const renderConfirmedBalance = () => {
    return (
      <View style={styles.scrollBody}>
        {isCustom && (
          <MalinText style={[styles.label, stylesHook.label]} numberOfLines={1}>
            {customLabel}
          </MalinText>
        )}
        <SuccessView />
        <MalinText style={[styles.label, stylesHook.label]} numberOfLines={1}>
          {displayBalance}
        </MalinText>
      </View>
    );
  };

  const renderPendingBalance = () => {
    return (
      <View style={styles.scrollBody}>
        {isCustom && (
          <MalinText style={[styles.label, stylesHook.label]} numberOfLines={1}>
            {customLabel}
          </MalinText>
        )}
        <TransactionPendingIconBig />
        <MalinSpacing40 />
        <MalinText style={[styles.label, stylesHook.label]} numberOfLines={1}>
          {displayBalance}
        </MalinText>
        <MalinText style={[styles.label, stylesHook.label]} numberOfLines={1}>
          {eta}
        </MalinText>
      </View>
    );
  };

  const onLayout = useCallback((e: { nativeEvent: { layout: { height: number; width: number } } }) => {
    const { height, width } = e.nativeEvent.layout;

    const isPortrait = height > width;
    const maxQRSize = 500;

    if (isPortrait) {
      const heightBasedSize = Math.min(height * 0.6, maxQRSize);
      const widthBasedSize = width * 0.85 - HORIZONTAL_PADDING * 2;
      setQRCodeSize(Math.min(heightBasedSize, widthBasedSize));
    } else {
      const heightBasedSize = Math.min(height * 0.7, maxQRSize);
      const widthBasedSize = width * 0.45;
      setQRCodeSize(Math.min(heightBasedSize, widthBasedSize));
    }
  }, []);

  const renderTabContent = () => {
    if (currentTab === segmentControlValues[0]) {
      return (
        <View style={styles.container}>
          {address && (
            <View style={styles.scrollBody}>
              {isCustom && (
                <>
                  {getDisplayAmount() && (
                    <MalinText testID="BitcoinAmountText" style={[styles.amount, stylesHook.amount]} numberOfLines={1}>
                      {getDisplayAmount()}
                    </MalinText>
                  )}
                  {customLabel?.length > 0 && (
                    <MalinText testID="CustomAmountDescriptionText" style={[styles.label, stylesHook.label]} numberOfLines={1}>
                      {customLabel}
                    </MalinText>
                  )}
                </>
              )}
              <View style={styles.qrCodeContainer}>
                <QRCodeComponent value={bip21encoded} size={qrCodeSize} />
              </View>
              <CopyTextToClipboard text={isCustom ? bip21encoded : address} />
            </View>
          )}
        </View>
      );
    } else if (wallet && isBIP47Enabled) {
      // wallet is always defined here
      const qrValue =
        'getBIP47PaymentCode' in wallet && typeof wallet.getBIP47PaymentCode === 'function' ? wallet.getBIP47PaymentCode() : undefined;
      return (
        <View style={styles.container}>
          {qrValue ? (
            <>
              <TipBox description={loc.receive.bip47_explanation} containerStyle={styles.tip} />
              <View style={styles.qrCodeContainer}>
                <QRCodeComponent value={qrValue} size={qrCodeSize} />
              </View>
              <CopyTextToClipboard text={qrValue} truncated={false} />
            </>
          ) : (
            <Text>{loc.bip47.not_found}</Text>
          )}
        </View>
      );
    } else {
      return null;
    }
  };

  useFocusEffect(
    useCallback(() => {
      const task = InteractionManager.runAfterInteractions(async () => {
        try {
          if (wallet) {
            await obtainWalletAddress();
          } else if (!wallet && address) {
            setAddressBIP21Encoded(address);
          }
        } catch (error) {
          console.error('Error during focus effect:', error);
        }
      });
      return () => {
        task.cancel();
      };
    }, [wallet, address, obtainWalletAddress, setAddressBIP21Encoded]),
  );

  const showCustomAmountModal = useCallback(() => {
    setTempCustomLabel(customLabel);
    setTempCustomAmount(customAmount);
    setTempCustomUnit(customUnit);
    bottomModalRef.current?.present();
  }, [customLabel, customAmount, customUnit]);

  const createCustomAmountAddress = () => {
    bottomModalRef.current?.dismiss();
    setIsCustom(true);
    let amount = tempCustomAmount;
    const amountNumber = Number(amount);
    switch (tempCustomUnit) {
      case BitcoinUnit.BTC:
        // nop
        break;
      case BitcoinUnit.SATS:
        amount = satoshiToBTC(amountNumber);
        break;
      case BitcoinUnit.LOCAL_CURRENCY:
        if (AmountInput.conversionCache[amount + BitcoinUnit.LOCAL_CURRENCY]) {
          // cache hit! we reuse old value that supposedly doesnt have rounding errors
          amount = satoshiToBTC(Number(AmountInput.conversionCache[amount + BitcoinUnit.LOCAL_CURRENCY]));
        } else {
          amount = fiatToBTC(amountNumber);
        }
        break;
    }
    setCustomLabel(tempCustomLabel);
    setCustomAmount(tempCustomAmount);
    setCustomUnit(tempCustomUnit);
    // address is always defined here
    setBip21encoded(DeeplinkSchemaMatch.bip21encode(address!, { amount, label: tempCustomLabel }));
    setShowAddress(true);
  };

  const resetCustomAmount = () => {
    setTempCustomLabel('');
    setTempCustomAmount('');
    setTempCustomUnit(wallet?.getPreferredBalanceUnit() || BitcoinUnit.BTC);
    setCustomLabel('');
    setCustomAmount('');
    setCustomUnit(wallet?.getPreferredBalanceUnit() || BitcoinUnit.BTC);
    // address is always defined here
    setBip21encoded(DeeplinkSchemaMatch.bip21encode(address!));
    setShowAddress(true);
    bottomModalRef.current?.dismiss();
  };

  /**
   * @returns {string} BTC amount, accounting for current `customUnit` and `customUnit`
   */
  const getDisplayAmount = (): string | null => {
    const number = Number(customAmount);
    if (number > 0) {
      switch (customUnit) {
        case BitcoinUnit.BTC:
          return customAmount + ' BTC';
        case BitcoinUnit.SATS:
          return satoshiToBTC(number) + ' BTC';
        case BitcoinUnit.LOCAL_CURRENCY:
          return fiatToBTC(number) + ' BTC';
      }
      return customAmount + ' ' + customUnit;
    } else {
      return null;
    }
  };

  const handleShareButtonPressed = () => {
    let message: string | false = false;
    if (currentTab === segmentControlValues[0]) {
      message = bip21encoded;
    } else {
      message = (wallet && 'getBIP47PaymentCode' in wallet && wallet.getBIP47PaymentCode()) ?? false;
    }

    if (!message) {
      presentAlert({ title: loc.errors.error, message: loc.bip47.not_found });
      return;
    }

    Share.open({ message }).catch(error => console.debug('Error sharing:', error));
  };

  return (
    <View style={[styles.flex, stylesHook.root]}>
      <SafeAreaScrollView
        centerContent
        contentInsetAdjustmentBehavior="automatic"
        automaticallyAdjustsScrollIndicatorInsets
        automaticallyAdjustKeyboardInsets
        testID="ReceiveDetailsScrollView"
        style={stylesHook.root}
        contentContainerStyle={[styles.root, stylesHook.root]}
        keyboardShouldPersistTaps="always"
        onLayout={onLayout}
        stickyHeaderIndices={wallet && isBIP47Enabled ? [0] : []}
      >
        {wallet && isBIP47Enabled && (
          <StickyHeader
            wallet={wallet}
            isBIP47Enabled={isBIP47Enabled}
            tabValues={segmentControlValues}
            currentTab={currentTab}
            setCurrentTab={setCurrentTab}
            backgroundColor={colors.elevated}
          />
        )}
        {showAddress && renderTabContent()}
        {showAddress && address !== undefined && (
          <HandOffComponent title={loc.send.details_address} type={HandOffActivityType.ReceiveOnchain} userInfo={{ address }} />
        )}
        {showConfirmedBalance && renderConfirmedBalance()}
        {showPendingBalance && renderPendingBalance()}

        {!showAddress && !showPendingBalance && !showConfirmedBalance && (
          <View style={styles.loadingContainer}>
            <MalinLoading />
          </View>
        )}

        <View style={styles.share}>
          <MalinCard>
            {showAddress && currentTab === loc.wallets.details_address && (
              <MalinButtonLink
                style={styles.link}
                testID="SetCustomAmountButton"
                title={loc.receive.details_setAmount}
                onPress={showCustomAmountModal}
              />
            )}
            <Button
              onPress={handleShareButtonPressed}
              title={loc.receive.details_share}
              disabled={!bip21encoded && !(currentTab === segmentControlValues[1] && isBIP47Enabled)}
            />
          </MalinCard>
        </View>
      </SafeAreaScrollView>

      <BottomModal
        ref={bottomModalRef}
        contentContainerStyle={styles.modalContainerJustify}
        backgroundColor={colors.modal}
        footer={
          <View style={styles.modalButtonContainer}>
            <Button
              testID="CustomAmountResetButton"
              style={[styles.modalButton, stylesHook.modalButton]}
              title={loc.receive.reset}
              onPress={resetCustomAmount}
            />
            <View style={styles.modalButtonSpacing} />
            <Button
              testID="CustomAmountSaveButton"
              style={[styles.modalButton, stylesHook.modalButton]}
              title={loc.receive.details_create}
              onPress={createCustomAmountAddress}
            />
          </View>
        }
      >
        <AmountInput.AmountInput
          unit={tempCustomUnit}
          amount={tempCustomAmount || ''}
          onChangeText={setTempCustomAmount}
          onAmountUnitChange={setTempCustomUnit}
        />
        <View style={[styles.customAmount, stylesHook.customAmount]}>
          <TextInput
            onChangeText={setTempCustomLabel}
            placeholderTextColor="#81868e"
            placeholder={loc.receive.details_label}
            value={tempCustomLabel || ''}
            numberOfLines={1}
            style={[styles.customAmountText, stylesHook.customAmountText]}
            testID="CustomAmountDescription"
          />
        </View>
        <MalinSpacing20 />

        <MalinSpacing20 />
      </BottomModal>
    </View>
  );
};

const styles = StyleSheet.create({
  modalContainerJustify: {
    alignContent: 'center',
    padding: 22,
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  customAmount: {
    flexDirection: 'row',
    borderWidth: 1.0,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    marginHorizontal: 20,
    alignItems: 'center',
    marginVertical: 8,
    borderRadius: 4,
  },
  root: {
    flexGrow: 1,
    justifyContent: 'space-between',
  },
  flex: {
    flex: 1,
  },
  tabsContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: Platform.OS === 'ios' ? 'transparent' : undefined,
  },
  scrollBody: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  share: {
    width: '100%',
    paddingHorizontal: 32,
    marginBottom: 16,
  },
  link: {
    marginVertical: 16,
    paddingHorizontal: 32,
  },
  amount: {
    fontWeight: '600',
    fontSize: 36,
    textAlign: 'center',
  },
  label: {
    fontWeight: '600',
    textAlign: 'center',
    paddingBottom: 12,
  },
  modalButton: {
    paddingVertical: 14,
    borderRadius: 50,
    fontWeight: '700',
    flex: 0.5,
    alignItems: 'center',
  },
  modalButtonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingBottom: 34,
  },
  modalButtonSpacing: {
    width: 16,
  },
  customAmountText: {
    flex: 1,
    marginHorizontal: 8,
    minHeight: 33,
  },
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  tip: {
    marginHorizontal: 16,
    borderRadius: 12,
    padding: 16,
  },
  qrCodeContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
});

export default ReceiveDetails;


================================================
FILE: ./screen/transactions/RBFBumpFee.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import PropTypes from 'prop-types';
import { ActivityIndicator, ScrollView, StyleSheet, View } from 'react-native';
import { MalinText } from '../../MalinComponents';
import { HDSegwitBech32Transaction, HDSegwitBech32Wallet } from '../../class';
import presentAlert from '../../components/Alert';
import SafeArea from '../../components/SafeArea';
import loc from '../../loc';
import CPFP from './CPFP';
import { StorageContext } from '../../components/Context/StorageProvider';
import { MalinSpacing20 } from '../../components/MalinSpacing';

const styles = StyleSheet.create({
  root: {
    flex: 1,
    paddingTop: 16,
  },
});

export default class RBFBumpFee extends CPFP {
  static contextType = StorageContext;

  async componentDidMount() {
    console.log('transactions/RBFBumpFee - componentDidMount');
    this.setState({
      isLoading: true,
      newFeeRate: '',
      nonReplaceable: false,
    });
    await this.checkPossibilityOfRBFBumpFee();
  }

  async checkPossibilityOfRBFBumpFee() {
    if (this.state.wallet.type !== HDSegwitBech32Wallet.type) {
      return this.setState({ nonReplaceable: true, isLoading: false });
    }

    const tx = new HDSegwitBech32Transaction(null, this.state.txid, this.state.wallet);
    if ((await tx.isOurTransaction()) && (await tx.getRemoteConfirmationsNum()) === 0 && (await tx.isSequenceReplaceable())) {
      const info = await tx.getInfo();
      return this.setState({ nonReplaceable: false, feeRate: info.feeRate + 1, isLoading: false, tx });
      // 1 sat makes a lot of difference, since sometimes because of rounding created tx's fee might be insufficient
    } else {
      return this.setState({ nonReplaceable: true, isLoading: false });
    }
  }

  async createTransaction() {
    const newFeeRate = parseInt(this.state.newFeeRate, 10);
    if (newFeeRate > this.state.feeRate) {
      /** @type {HDSegwitBech32Transaction} */
      const tx = this.state.tx;
      this.setState({ isLoading: true });
      try {
        const { tx: newTx } = await tx.createRBFbumpFee(newFeeRate);
        this.setState({ stage: 2, txhex: newTx.toHex(), newTxid: newTx.getId() });
        this.setState({ isLoading: false });
      } catch (_) {
        this.setState({ isLoading: false });
        presentAlert({ message: loc.errors.error + ': ' + _.message });
      }
    }
  }

  onSuccessBroadcast() {
    // porting memo from old tx:
    if (this.context.txMetadata[this.state.txid]) {
      this.context.txMetadata[this.state.newTxid] = this.context.txMetadata[this.state.txid];
    }
    this.context.sleep(4000).then(() => this.context.fetchAndSaveWalletTransactions(this.state.wallet.getID()));
    this.props.navigation.navigate('Success', { amount: undefined });
  }

  render() {
    if (this.state.isLoading) {
      return (
        <View style={styles.root}>
          <ActivityIndicator />
        </View>
      );
    }

    if (this.state.stage === 2) {
      return this.renderStage2();
    }

    if (this.state.nonReplaceable) {
      return (
        <SafeArea style={styles.root}>
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />

          <MalinText h4>{loc.transactions.cpfp_no_bump}</MalinText>
        </SafeArea>
      );
    }

    return (
      <SafeArea style={styles.root}>
        <ScrollView
          automaticallyAdjustContentInsets
          automaticallyAdjustKeyboardInsets
          automaticallyAdjustsScrollIndicatorInsets
          contentInsetAdjustmentBehavior="automatic"
        >
          {this.renderStage1(loc.transactions.rbf_explain)}
        </ScrollView>
      </SafeArea>
    );
  }
}

RBFBumpFee.propTypes = {
  navigation: PropTypes.shape({
    navigate: PropTypes.func,
    state: PropTypes.shape({
      params: PropTypes.shape({
        txid: PropTypes.string,
        wallet: PropTypes.object,
      }),
    }),
  }),
};


================================================
FILE: ./screen/transactions/TransactionStatus.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';
import { RouteProp, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { ActivityIndicator, BackHandler, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { Icon } from '@rneui/themed';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import { HDSegwitBech32Transaction, HDSegwitBech32Wallet } from '../../class';
import { Transaction, TWallet } from '../../class/wallets/types';
import Button from '../../components/Button';
import HandOffComponent from '../../components/HandOffComponent';
import TransactionIncomingIcon from '../../components/icons/TransactionIncomingIcon';
import TransactionOutgoingIcon from '../../components/icons/TransactionOutgoingIcon';
import TransactionPendingIcon from '../../components/icons/TransactionPendingIcon';
import SafeArea from '../../components/SafeArea';
import { useTheme } from '../../components/themes';
import loc, { formatBalanceWithoutSuffix } from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { useStorage } from '../../hooks/context/useStorage';
import { HandOffActivityType } from '../../components/types';
import HeaderRightButton from '../../components/HeaderRightButton';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useSettings } from '../../hooks/context/useSettings';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { MalinSpacing10, MalinSpacing20 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';
import useWalletSubscribe from '../../hooks/useWalletSubscribe';

enum ButtonStatus {
  Possible,
  Unknown,
  NotPossible,
}

type RouteProps = RouteProp<DetailViewStackParamList, 'TransactionStatus'>;
type NavigationProps = NativeStackNavigationProp<DetailViewStackParamList, 'TransactionStatus'>;

enum ActionType {
  SetCPFPPossible,
  SetRBFBumpFeePossible,
  SetRBFCancelPossible,
  SetTransaction,
  SetLoading,
  SetEta,
  SetIntervalMs,
  SetAllButtonStatus,
  SetWallet,
  SetLoadingError,
}

interface State {
  isCPFPPossible: ButtonStatus;
  isRBFBumpFeePossible: ButtonStatus;
  isRBFCancelPossible: ButtonStatus;
  tx: any;
  isLoading: boolean;
  eta: string;
  intervalMs: number;
  wallet: TWallet | null;
  loadingError: boolean;
}

const initialState: State = {
  isCPFPPossible: ButtonStatus.Unknown,
  isRBFBumpFeePossible: ButtonStatus.Unknown,
  isRBFCancelPossible: ButtonStatus.Unknown,
  tx: undefined,
  isLoading: true,
  eta: '',
  intervalMs: 1000,
  wallet: null,
  loadingError: false,
};

const reducer = (state: State, action: { type: ActionType; payload?: any }): State => {
  switch (action.type) {
    case ActionType.SetCPFPPossible:
      return { ...state, isCPFPPossible: action.payload };
    case ActionType.SetRBFBumpFeePossible:
      return { ...state, isRBFBumpFeePossible: action.payload };
    case ActionType.SetRBFCancelPossible:
      return { ...state, isRBFCancelPossible: action.payload };
    case ActionType.SetTransaction:
      return { ...state, tx: action.payload };
    case ActionType.SetLoading:
      return { ...state, isLoading: action.payload };
    case ActionType.SetEta:
      return { ...state, eta: action.payload };
    case ActionType.SetIntervalMs:
      return { ...state, intervalMs: action.payload };
    case ActionType.SetAllButtonStatus:
      return { ...state, isCPFPPossible: action.payload, isRBFBumpFeePossible: action.payload, isRBFCancelPossible: action.payload };
    case ActionType.SetWallet:
      return { ...state, wallet: action.payload };
    case ActionType.SetLoadingError:
      return { ...state, loadingError: action.payload };
    default:
      return state;
  }
};

type TransactionStatusProps = {
  transaction?: {
    amount?: number;
    value?: number;
    confirmations?: number;
  };
  txid?: string;
};

const TransactionStatus: React.FC<TransactionStatusProps> = ({ transaction, txid }) => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const { isCPFPPossible, isRBFBumpFeePossible, isRBFCancelPossible, tx, isLoading, eta, intervalMs, wallet, loadingError } = state;
  const { wallets, txMetadata, counterpartyMetadata, fetchAndSaveWalletTransactions } = useStorage();
  const { hash, walletID } = useRoute<RouteProps>().params;
  const subscribedWallet = useWalletSubscribe(walletID!);
  const { navigate, setOptions, goBack } = useExtendedNavigation<NavigationProps>();
  const { colors } = useTheme();
  const { selectedBlockExplorer } = useSettings();
  const fetchTxInterval = useRef<NodeJS.Timeout>();
  const stylesHook = StyleSheet.create({
    value: {
      color: colors.alternativeTextColor2,
    },
    valueUnit: {
      color: colors.alternativeTextColor2,
    },
    iconRoot: {
      backgroundColor: colors.success,
    },
  });

  const setTX = (value: any) => {
    dispatch({ type: ActionType.SetTransaction, payload: value });
  };

  const setIntervalMs = (ms: number) => {
    dispatch({ type: ActionType.SetIntervalMs, payload: ms });
  };

  const setEta = (value: string) => {
    dispatch({ type: ActionType.SetEta, payload: value });
  };

  const setAllButtonStatus = (status: ButtonStatus) => {
    dispatch({ type: ActionType.SetAllButtonStatus, payload: status });
  };

  const setIsLoading = (value: boolean) => {
    dispatch({ type: ActionType.SetLoading, payload: value });
  };

  const setIsCPFPPossible = (status: ButtonStatus) => {
    dispatch({ type: ActionType.SetCPFPPossible, payload: status });
  };

  const setIsRBFBumpFeePossible = (status: ButtonStatus) => {
    dispatch({ type: ActionType.SetRBFBumpFeePossible, payload: status });
  };

  const setIsRBFCancelPossible = (status: ButtonStatus) => {
    dispatch({ type: ActionType.SetRBFCancelPossible, payload: status });
  };

  const navigateToTransactionDetails = useCallback(() => {
    if (walletID && tx && tx.hash) {
      navigate('TransactionDetails', { tx, hash, walletID });
    } else {
      console.error('Cannot navigate to TransactionDetails: Missing tx or hash.');
    }
  }, [hash, navigate, tx, walletID]);

  const DetailsButton = useMemo(
    () => (
      <HeaderRightButton
        testID="TransactionDetailsButton"
        disabled={loadingError || isLoading || !tx || !wallet}
        title={loc.send.create_details}
        onPress={navigateToTransactionDetails}
      />
    ),
    [navigateToTransactionDetails, loadingError, isLoading, tx, wallet],
  );

  useEffect(() => {
    setOptions({
      headerRight: () => DetailsButton,
    });
  }, [DetailsButton, colors, hash, setOptions]);

  useEffect(() => {
    if (subscribedWallet) {
      const transactions = subscribedWallet.getTransactions();
      const newTx = transactions.find((t: Transaction) => t.hash === hash);
      if (newTx) {
        setTX(newTx);
      }
    }
  }, [hash, subscribedWallet]);

  useEffect(() => {
    dispatch({ type: ActionType.SetWallet, payload: subscribedWallet });
  }, [subscribedWallet]);

  // re-fetching tx status periodically
  useEffect(() => {
    console.debug('transactionStatus - useEffect');

    if (!tx || tx?.confirmations) return;
    if (!hash) return;

    if (fetchTxInterval.current) {
      // interval already exists, lets cleanup it and recreate, so theres no duplicate intervals
      clearInterval(fetchTxInterval.current);
      fetchTxInterval.current = undefined;
    }

    console.debug('setting up interval to check tx...');
    fetchTxInterval.current = setInterval(async () => {
      try {
        setIntervalMs(31000); // upon first execution we increase poll interval;

        console.debug('checking tx', hash, 'for confirmations...');
        const transactions = await MalinElectrum.multiGetTransactionByTxid([hash], true, 10);
        const txFromElectrum = transactions[hash];
        if (!txFromElectrum) {
          console.error(`Transaction from Electrum with hash ${hash} not found.`);
          return;
        }

        console.debug('got txFromElectrum=', txFromElectrum);

        const address = txFromElectrum.vout?.[0]?.scriptPubKey?.addresses?.pop();
        if (!address) {
          console.error('Address not found in txFromElectrum.');
          return;
        }

        if (!txFromElectrum.confirmations && txFromElectrum.vsize) {
          const txsM = await MalinElectrum.getMempoolTransactionsByAddress(address);
          let txFromMempool;
          // searching for a correct tx in case this address has several pending txs:
          for (const tempTxM of txsM) {
            if (tempTxM?.tx_hash === hash) {
              txFromMempool = tempTxM;
              break;
            }
          }
          if (!txFromMempool) {
            console.error(`Transaction from mempool with hash ${hash} not found.`);
            return;
          }

          console.debug('txFromMempool=', txFromMempool);

          const satPerVbyte = txFromMempool.fee && txFromElectrum.vsize ? Math.round(txFromMempool.fee / txFromElectrum.vsize) : 0;
          const fees = await MalinElectrum.estimateFees();
          console.debug('fees=', fees, 'satPerVbyte=', satPerVbyte);
          if (satPerVbyte >= fees.fast) {
            setEta(loc.formatString(loc.transactions.eta_10m));
          }
          if (satPerVbyte >= fees.medium && satPerVbyte < fees.fast) {
            setEta(loc.formatString(loc.transactions.eta_3h));
          }
          if (satPerVbyte < fees.medium) {
            setEta(loc.formatString(loc.transactions.eta_1d));
          }
        } else if (txFromElectrum.confirmations && txFromElectrum.confirmations > 0) {
          // now, handling a case when tx became confirmed!
          triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
          setEta('');
          if (tx) {
            setTX((prevState: any) => {
              return Object.assign({}, prevState, { confirmations: txFromElectrum.confirmations });
            });
          } else {
            console.error('Cannot set confirmations: tx is undefined.');
          }
          clearInterval(fetchTxInterval.current);
          fetchTxInterval.current = undefined;
          if (wallet?.getID()) {
            fetchAndSaveWalletTransactions(wallet.getID());
          } else {
            console.error('Cannot fetch and save wallet transactions: wallet ID is undefined.');
          }
        }
      } catch (error) {
        console.error('Error in fetchTxInterval:', error);
      }
    }, intervalMs);

    return () => {
      clearInterval(fetchTxInterval.current);
      fetchTxInterval.current = undefined;
    };
  }, [hash, intervalMs, tx, fetchAndSaveWalletTransactions, wallet]);

  useEffect(() => {
    const subscription = BackHandler.addEventListener('hardwareBackPress', () => {
      goBack();
      return true;
    });

    return () => {
      subscription.remove();
      clearInterval(fetchTxInterval.current);
      fetchTxInterval.current = undefined;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const initialButtonsState = async () => {
    try {
      await checkPossibilityOfCPFP();
      await checkPossibilityOfRBFBumpFee();
      await checkPossibilityOfRBFCancel();
    } catch (e) {
      console.error('Error in initialButtonsState:', e);
      setAllButtonStatus(ButtonStatus.NotPossible);
    }
    setIsLoading(false);
  };

  useEffect(() => {
    initialButtonsState().catch(error => console.error('Unhandled error in initialButtonsState:', error));

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tx, wallets]);

  useEffect(() => {}, [tx, wallets]);

  useEffect(() => {
    console.debug('transactionStatus - useEffect');
  }, []);

  const checkPossibilityOfCPFP = async () => {
    if (!wallet?.allowRBF()) {
      return setIsCPFPPossible(ButtonStatus.NotPossible);
    }

    if (wallet) {
      const cpfbTx = new HDSegwitBech32Transaction(null, tx.hash, wallet as HDSegwitBech32Wallet);
      if ((await cpfbTx.isToUsTransaction()) && (await cpfbTx.getRemoteConfirmationsNum()) === 0) {
        return setIsCPFPPossible(ButtonStatus.Possible);
      } else {
        return setIsCPFPPossible(ButtonStatus.NotPossible);
      }
    }
    return setIsCPFPPossible(ButtonStatus.NotPossible);
  };

  const checkPossibilityOfRBFBumpFee = async () => {
    if (!wallet?.allowRBF()) {
      return setIsRBFBumpFeePossible(ButtonStatus.NotPossible);
    }

    const rbfTx = new HDSegwitBech32Transaction(null, tx.hash, wallet as HDSegwitBech32Wallet);
    if (
      (await rbfTx.isOurTransaction()) &&
      (await rbfTx.getRemoteConfirmationsNum()) === 0 &&
      (await rbfTx.isSequenceReplaceable()) &&
      (await rbfTx.canBumpTx())
    ) {
      return setIsRBFBumpFeePossible(ButtonStatus.Possible);
    } else {
      return setIsRBFBumpFeePossible(ButtonStatus.NotPossible);
    }
  };

  const checkPossibilityOfRBFCancel = async () => {
    if (!wallet?.allowRBF()) {
      return setIsRBFCancelPossible(ButtonStatus.NotPossible);
    }

    const rbfTx = new HDSegwitBech32Transaction(null, tx.hash, wallet as HDSegwitBech32Wallet);
    if (
      (await rbfTx.isOurTransaction()) &&
      (await rbfTx.getRemoteConfirmationsNum()) === 0 &&
      (await rbfTx.isSequenceReplaceable()) &&
      (await rbfTx.canCancelTx())
    ) {
      return setIsRBFCancelPossible(ButtonStatus.Possible);
    } else {
      return setIsRBFCancelPossible(ButtonStatus.NotPossible);
    }
  };

  const navigateToRBFBumpFee = () => {
    navigate('RBFBumpFee', {
      txid: tx.hash,
      wallet,
    });
  };

  const navigateToRBFCancel = () => {
    navigate('RBFCancel', {
      txid: tx.hash,
      wallet,
    });
  };

  const navigateToCPFP = () => {
    navigate('CPFP', {
      txid: tx.hash,
      wallet,
    });
  };

  const renderCPFP = () => {
    if (isCPFPPossible === ButtonStatus.Unknown) {
      return (
        <>
          <ActivityIndicator />
          <MalinSpacing20 />
        </>
      );
    } else if (isCPFPPossible === ButtonStatus.Possible) {
      return (
        <>
          <Button onPress={navigateToCPFP} title={loc.transactions.status_bump} />
          <MalinSpacing10 />
        </>
      );
    }
  };

  const renderRBFCancel = () => {
    if (isRBFCancelPossible === ButtonStatus.Unknown) {
      return (
        <>
          <ActivityIndicator />
        </>
      );
    } else if (isRBFCancelPossible === ButtonStatus.Possible) {
      return (
        <>
          <TouchableOpacity accessibilityRole="button" style={styles.cancel}>
            <Text onPress={navigateToRBFCancel} style={styles.cancelText}>
              {loc.transactions.status_cancel}
            </Text>
          </TouchableOpacity>
          <MalinSpacing10 />
        </>
      );
    }
  };

  const renderRBFBumpFee = () => {
    if (isRBFBumpFeePossible === ButtonStatus.Unknown) {
      return (
        <>
          <ActivityIndicator />
          <MalinSpacing20 />
        </>
      );
    } else if (isRBFBumpFeePossible === ButtonStatus.Possible) {
      return (
        <>
          <Button onPress={navigateToRBFBumpFee} title={loc.transactions.status_bump} />
          <MalinSpacing10 />
        </>
      );
    }
  };

  const shortenCounterpartyName = (addr: string): string => {
    if (addr.length < 20) return addr;
    return addr.substr(0, 10) + '...' + addr.substr(addr.length - 10, 10);
  };

  const renderTXMetadata = () => {
    if (txMetadata[tx.hash]) {
      if (txMetadata[tx.hash].memo) {
        return (
          <View style={styles.memo}>
            <Text selectable style={styles.memoText}>
              {txMetadata[tx.hash].memo}
            </Text>
          </View>
        );
      }
    }
  };

  const renderTXCounterparty = () => {
    if (!tx.counterparty) return; // no BIP47 counterparty for this tx, return early

    // theres a counterparty. lets lookup if theres an alias for him
    let counterparty = counterpartyMetadata?.[tx.counterparty]?.label ?? tx.counterparty;
    counterparty = shortenCounterpartyName(counterparty);

    return (
      <View style={styles.memo}>
        <Text selectable style={styles.memoText}>
          {tx.value < 0
            ? loc.formatString(loc.transactions.to, {
                counterparty,
              })
            : loc.formatString(loc.transactions.from, {
                counterparty,
              })}
        </Text>
        <MalinSpacing20 />
      </View>
    );
  };

  useEffect(() => {
    if (!tx && txid) {
      // Fetch transaction details using txid
      const fetchTransaction = async () => {
        try {
          const transactions = await MalinElectrum.multiGetTransactionByTxid([txid], true, 10);
          const fetchedTx = transactions[txid];
          if (fetchedTx) {
            setTX(fetchedTx);
          } else {
            console.error(`Transaction with txid ${txid} not found.`);
            dispatch({ type: ActionType.SetLoadingError, payload: true });
            dispatch({ type: ActionType.SetLoading, payload: false });
          }
        } catch (error) {
          console.error('Error fetching transaction:', error);
          dispatch({ type: ActionType.SetLoadingError, payload: true });
          dispatch({ type: ActionType.SetLoading, payload: false });
        }
      };
      fetchTransaction().catch(error => console.error('Unhandled error in fetchTransaction:', error));
    }
  }, [tx, txid]);

  useEffect(() => {
    if (isLoading) {
      let isComponentMounted = true;
      const loadingTimeout = setTimeout(() => {
        if (isComponentMounted && isLoading) {
          dispatch({ type: ActionType.SetLoadingError, payload: true });
          dispatch({ type: ActionType.SetLoading, payload: false });
          console.error('Loading timed out. There was an issue fetching the transaction.');
        }
      }, 10000);

      return () => {
        isComponentMounted = false;
        clearTimeout(loadingTimeout);
      };
    }
  }, [isLoading]);

  return (
    <SafeArea>
      {loadingError ? (
        <MalinCard>
          <MalinText>{loc.transactions.transaction_loading_error}</MalinText>
        </MalinCard>
      ) : isLoading || !tx || wallet === undefined ? (
        <MalinLoading />
      ) : !transaction && !tx ? (
        <MalinText>{loc.transactions.transaction_not_available}</MalinText>
      ) : (
        <>
          <HandOffComponent
            title={loc.transactions.details_title}
            type={HandOffActivityType.ViewInBlockExplorer}
            url={`${selectedBlockExplorer.url}/tx/${tx.hash}`}
          />

          <View style={styles.container}>
            <MalinCard>
              <View style={styles.center}>
                <Text style={[styles.value, stylesHook.value]} selectable>
                  {wallet && formatBalanceWithoutSuffix(tx.value, wallet.preferredBalanceUnit, true)}
                  {` `}
                  {wallet?.preferredBalanceUnit !== BitcoinUnit.LOCAL_CURRENCY && wallet && (
                    <Text style={[styles.valueUnit, stylesHook.valueUnit]}>{wallet.preferredBalanceUnit}</Text>
                  )}
                </Text>
              </View>

              {renderTXMetadata()}
              {renderTXCounterparty()}

              <View style={[styles.iconRoot, stylesHook.iconRoot]}>
                <View>
                  <Icon name="check" size={50} type="font-awesome" color={colors.successCheck} />
                </View>
                <View style={[styles.iconWrap, styles.margin]}>
                  {(() => {
                    if (!tx.confirmations) {
                      return (
                        <View style={styles.icon}>
                          <TransactionPendingIcon />
                        </View>
                      );
                    } else if (tx.value < 0) {
                      return (
                        <View style={styles.icon}>
                          <TransactionOutgoingIcon />
                        </View>
                      );
                    } else {
                      return (
                        <View style={styles.icon}>
                          <TransactionIncomingIcon />
                        </View>
                      );
                    }
                  })()}
                </View>
              </View>

              {tx.fee && (
                <View style={styles.fee}>
                  <MalinText style={styles.feeText}>
                    {`${loc.send.create_fee.toLowerCase()} `}
                    {formatBalanceWithoutSuffix(tx.fee, wallet?.preferredBalanceUnit ?? BitcoinUnit.BTC, true)}
                    {wallet?.preferredBalanceUnit !== BitcoinUnit.LOCAL_CURRENCY && wallet?.preferredBalanceUnit}
                  </MalinText>
                </View>
              )}

              <View style={styles.confirmations}>
                <Text style={styles.confirmationsText}>
                  {loc.formatString(loc.transactions.confirmations_lowercase, {
                    confirmations: tx.confirmations > 6 ? '6+' : tx.confirmations,
                  })}
                </Text>
              </View>
              {eta ? (
                <View style={styles.eta}>
                  <MalinSpacing10 />
                  <Text style={styles.confirmationsText}>{eta}</Text>
                </View>
              ) : null}
            </MalinCard>

            <View style={styles.actions}>
              {renderCPFP()}
              {renderRBFBumpFee()}
              {renderRBFCancel()}
            </View>
          </View>
        </>
      )}
    </SafeArea>
  );
};

export default TransactionStatus;
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'space-between',
  },
  center: {
    alignItems: 'center',
  },
  value: {
    fontSize: 36,
    fontWeight: '600',
  },
  valueUnit: {
    fontSize: 16,
    fontWeight: '600',
  },
  memo: {
    alignItems: 'center',
    marginVertical: 8,
  },
  memoText: {
    color: '#9aa0aa',
    fontSize: 14,
  },
  iconRoot: {
    width: 120,
    height: 120,
    borderRadius: 60,
    alignSelf: 'center',
    justifyContent: 'center',
    marginTop: 43,
    marginBottom: 53,
  },
  iconWrap: {
    minWidth: 30,
    minHeight: 30,
    alignItems: 'center',
    justifyContent: 'center',
    alignSelf: 'flex-end',
    borderRadius: 15,
  },
  margin: {
    marginBottom: -40,
  },
  icon: {
    width: 25,
  },
  fee: {
    marginTop: 15,
    marginBottom: 13,
  },
  feeText: {
    fontSize: 11,
    fontWeight: '500',
    marginBottom: 4,
    color: '#00c49f',
    alignSelf: 'center',
  },
  confirmations: {
    alignSelf: 'center',
    alignItems: 'center',
    justifyContent: 'center',
  },
  confirmationsText: {
    color: '#9aa0aa',
    fontSize: 13,
  },
  eta: {
    alignSelf: 'center',
    alignItems: 'center',
    justifyContent: 'center',
  },
  actions: {
    alignSelf: 'center',
    justifyContent: 'center',
  },
  cancel: {
    marginVertical: 16,
  },
  cancelText: {
    color: '#d0021b',
    fontSize: 15,
    fontWeight: '500',
    textAlign: 'center',
  },
});


================================================
FILE: ./screen/transactions/RBFCancel.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import PropTypes from 'prop-types';
import { ActivityIndicator, ScrollView, View } from 'react-native';
import { MalinText } from '../../MalinComponents';
import { HDSegwitBech32Transaction, HDSegwitBech32Wallet } from '../../class';
import presentAlert from '../../components/Alert';
import SafeArea from '../../components/SafeArea';
import loc from '../../loc';
import CPFP from './CPFP';
import { StorageContext } from '../../components/Context/StorageProvider';
import { MalinSpacing20 } from '../../components/MalinSpacing';

export default class RBFCancel extends CPFP {
  static contextType = StorageContext;
  async componentDidMount() {
    console.log('transactions/RBFCancel - componentDidMount');
    this.setState({
      isLoading: true,
      newFeeRate: '',
      nonReplaceable: false,
    });
    await this.checkPossibilityOfRBFCancel();
  }

  async checkPossibilityOfRBFCancel() {
    if (this.state.wallet.type !== HDSegwitBech32Wallet.type) {
      return this.setState({ nonReplaceable: true, isLoading: false });
    }

    const tx = new HDSegwitBech32Transaction(null, this.state.txid, this.state.wallet);
    if (
      (await tx.isOurTransaction()) &&
      (await tx.getRemoteConfirmationsNum()) === 0 &&
      (await tx.isSequenceReplaceable()) &&
      (await tx.canCancelTx())
    ) {
      const info = await tx.getInfo();
      console.log({ info });
      return this.setState({ nonReplaceable: false, feeRate: info.feeRate + 1, isLoading: false, tx });
      // 1 sat makes a lot of difference, since sometimes because of rounding created tx's fee might be insufficient
    } else {
      return this.setState({ nonReplaceable: true, isLoading: false });
    }
  }

  async createTransaction() {
    const newFeeRate = parseInt(this.state.newFeeRate, 10);
    if (newFeeRate > this.state.feeRate) {
      /** @type {HDSegwitBech32Transaction} */
      const tx = this.state.tx;
      this.setState({ isLoading: true });
      try {
        const { tx: newTx } = await tx.createRBFcancelTx(newFeeRate);
        this.setState({ stage: 2, txhex: newTx.toHex(), newTxid: newTx.getId() });
        this.setState({ isLoading: false });
      } catch (_) {
        this.setState({ isLoading: false });
        presentAlert({ message: loc.errors.error + ': ' + _.message });
      }
    }
  }

  onSuccessBroadcast() {
    // porting metadata, if any
    this.context.txMetadata[this.state.newTxid] = this.context.txMetadata[this.state.txid] || {};

    // porting tx memo
    if (this.context.txMetadata[this.state.newTxid].memo) {
      this.context.txMetadata[this.state.newTxid].memo = 'Cancelled: ' + this.context.txMetadata[this.state.newTxid].memo;
    } else {
      this.context.txMetadata[this.state.newTxid].memo = 'Cancelled transaction';
    }
    this.context.sleep(4000).then(() => this.context.fetchAndSaveWalletTransactions(this.state.wallet.getID()));
    this.props.navigation.navigate('Success', { amount: undefined });
  }

  render() {
    if (this.state.isLoading) {
      return (
        <View>
          <ActivityIndicator />
        </View>
      );
    }

    if (this.state.stage === 2) {
      return this.renderStage2();
    }

    if (this.state.nonReplaceable) {
      return (
        <SafeArea>
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />

          <MalinText h4>{loc.transactions.cancel_no}</MalinText>
        </SafeArea>
      );
    }

    return (
      <SafeArea>
        <ScrollView
          automaticallyAdjustContentInsets
          automaticallyAdjustKeyboardInsets
          automaticallyAdjustsScrollIndicatorInsets
          contentInsetAdjustmentBehavior="automatic"
        >
          {this.renderStage1(loc.transactions.cancel_explain)}
        </ScrollView>
      </SafeArea>
    );
  }
}

RBFCancel.propTypes = {
  navigation: PropTypes.shape({
    navigate: PropTypes.func,
    state: PropTypes.shape({
      params: PropTypes.shape({
        txid: PropTypes.string,
        wallet: PropTypes.object,
      }),
    }),
  }),
};


================================================
FILE: ./screen/transactions/TransactionDetails.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useState } from 'react';
import Clipboard from '@react-native-clipboard/clipboard';
import { RouteProp, useFocusEffect, usePreventRemove, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import assert from 'assert';
import dayjs from 'dayjs';
import { InteractionManager, Linking, StyleSheet, Text, TextInput, View } from 'react-native';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import { Transaction, TWallet } from '../../class/wallets/types';
import presentAlert from '../../components/Alert';
import CopyToClipboardButton from '../../components/CopyToClipboardButton';
import HandOffComponent from '../../components/HandOffComponent';
import { useTheme } from '../../components/themes';
import ToolTipMenu from '../../components/TooltipMenu';
import loc from '../../loc';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useStorage } from '../../hooks/context/useStorage';
import { HandOffActivityType } from '../../components/types';
import { useSettings } from '../../hooks/context/useSettings';
import SafeAreaScrollView from '../../components/SafeAreaScrollView';
import { MalinSpacing20 } from '../../components/MalinSpacing';
import { MalinLoading } from '../../components/MalinLoading';

const actionKeys = {
  CopyToClipboard: 'copyToClipboard',
  GoToWallet: 'goToWallet',
};

const actionIcons = {
  Clipboard: {
    iconValue: 'doc.on.doc',
  },
  GoToWallet: {
    iconValue: 'wallet.pass',
  },
};

function onlyUnique(value: any, index: number, self: any[]) {
  return self.indexOf(value) === index;
}

function arrDiff(a1: any[], a2: any[]) {
  const ret = [];
  for (const v of a2) {
    if (a1.indexOf(v) === -1) {
      ret.push(v);
    }
  }
  return ret;
}

const toolTipMenuActions = [
  {
    id: actionKeys.CopyToClipboard,
    text: loc.transactions.copy_link,
    icon: actionIcons.Clipboard,
  },
];

type NavigationProps = NativeStackNavigationProp<DetailViewStackParamList, 'TransactionDetails'>;
type RouteProps = RouteProp<DetailViewStackParamList, 'TransactionDetails'>;

const TransactionDetails = () => {
  const { navigate } = useExtendedNavigation<NavigationProps>();
  const { hash, walletID } = useRoute<RouteProps>().params;
  const { saveToDisk, txMetadata, counterpartyMetadata, wallets, getTransactions } = useStorage();
  const { selectedBlockExplorer } = useSettings();
  const [from, setFrom] = useState<string[]>([]);
  const [to, setTo] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [tx, setTX] = useState<Transaction>();
  const [memo, setMemo] = useState<string>('');
  const [counterpartyLabel, setCounterpartyLabel] = useState<string>('');
  const [paymentCode, setPaymentCode] = useState<string>('');
  const [isCounterpartyLabelVisible, setIsCounterpartyLabelVisible] = useState<boolean>(false);
  const { colors } = useTheme();
  const stylesHooks = StyleSheet.create({
    memoTextInput: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    greyButton: {
      backgroundColor: colors.lightButton,
    },
    Link: {
      color: colors.buttonTextColor,
    },
  });

  const saveTransactionDetails = useCallback(() => {
    if (tx) {
      txMetadata[tx.hash] = { memo };
      if (counterpartyLabel && paymentCode) {
        counterpartyMetadata[paymentCode] = { label: counterpartyLabel };
      }
      saveToDisk();
    }
  }, [tx, txMetadata, memo, counterpartyLabel, paymentCode, saveToDisk, counterpartyMetadata]);

  usePreventRemove(false, () => {
    saveTransactionDetails();
  });

  useFocusEffect(
    useCallback(() => {
      const task = InteractionManager.runAfterInteractions(() => {
        let foundTx: Transaction | false = false;
        let newFrom: string[] = [];
        let newTo: string[] = [];
        for (const transaction of getTransactions(undefined, Infinity, true)) {
          if (transaction.hash === hash) {
            foundTx = transaction;
            for (const input of foundTx.inputs) {
              newFrom = newFrom.concat(input?.addresses ?? []);
            }
            for (const output of foundTx.outputs) {
              if (output?.scriptPubKey?.addresses) newTo = newTo.concat(output.scriptPubKey.addresses);
            }
          }
        }

        assert(foundTx, 'Internal error: could not find transaction');

        const wallet = wallets.find(w => w.getID() === walletID);
        assert(wallet, 'Internal error: could not find wallet');

        if (wallet.allowBIP47() && wallet.isBIP47Enabled() && 'getBip47CounterpartyByTxid' in wallet) {
          const foundPaymentCode = wallet.getBip47CounterpartyByTxid(hash);
          if (foundPaymentCode) {
            // okay, this txid _was_ with someone using payment codes, so we show the label edit dialog
            // and load user-defined alias for the pc if any

            setCounterpartyLabel(counterpartyMetadata ? (counterpartyMetadata[foundPaymentCode]?.label ?? '') : '');
            setIsCounterpartyLabelVisible(true);
            setPaymentCode(foundPaymentCode);
          }
        }

        setMemo(txMetadata[foundTx.hash]?.memo ?? '');
        setTX(foundTx);
        setFrom(newFrom);
        setTo(newTo);
        setIsLoading(false);
      });
      return () => {
        task.cancel();
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [hash, wallets]),
  );

  const handleMemoBlur = useCallback(() => {
    saveTransactionDetails();
  }, [saveTransactionDetails]);

  const handleOnOpenTransactionOnBlockExplorerTapped = () => {
    const url = `${selectedBlockExplorer.url}/tx/${tx?.hash}`;
    Linking.canOpenURL(url)
      .then(supported => {
        if (supported) {
          Linking.openURL(url).catch(e => {
            console.log('openURL failed in handleOnOpenTransactionOnBlockExplorerTapped');
            console.log(e.message);
            triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
            presentAlert({ message: e.message });
          });
        } else {
          console.log('canOpenURL supported is false in handleOnOpenTransactionOnBlockExplorerTapped');
          triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
          presentAlert({ message: loc.transactions.open_url_error });
        }
      })
      .catch(e => {
        console.log('canOpenURL failed in handleOnOpenTransactionOnBlockExplorerTapped');
        console.log(e.message);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: e.message });
      });
  };

  const handleCopyPress = (stringToCopy: string) => {
    Clipboard.setString(stringToCopy !== actionKeys.CopyToClipboard ? stringToCopy : `${selectedBlockExplorer.url}/tx/${tx?.hash}`);
  };

  if (isLoading || !tx) {
    return <MalinLoading />;
  }

  const weOwnAddress = (address: string): TWallet | null => {
    for (const w of wallets) {
      if (w.weOwnAddress(address)) {
        return w;
      }
    }
    return null;
  };

  const navigateToWallet = (wallet: TWallet) => {
    navigate('WalletTransactions', {
      walletID: wallet.getID(),
      walletType: wallet.type,
    });
  };

  const onPressMenuItem = (key: string) => {
    if (key === actionKeys.CopyToClipboard) {
      handleCopyPress(key);
    } else if (key === actionKeys.GoToWallet) {
      const wallet = weOwnAddress(key);
      if (wallet) {
        navigateToWallet(wallet);
      }
    }
  };

  const renderSection = (array: any[]) => {
    const fromArray = [];

    for (const [index, address] of array.entries()) {
      const actions = [];
      actions.push({
        id: actionKeys.CopyToClipboard,
        text: loc.transactions.details_copy,
        icon: actionIcons.Clipboard,
      });
      const isWeOwnAddress = weOwnAddress(address);
      if (isWeOwnAddress) {
        actions.push({
          id: actionKeys.GoToWallet,
          text: loc.formatString(loc.transactions.view_wallet, { walletLabel: isWeOwnAddress.getLabel() }),
          icon: actionIcons.GoToWallet,
        });
      }

      fromArray.push(
        <ToolTipMenu key={address} isButton title={address} isMenuPrimaryAction actions={actions} onPressMenuItem={onPressMenuItem}>
          <MalinText style={isWeOwnAddress ? [styles.rowValue, styles.weOwnAddress] : styles.rowValue}>
            {address}
            {index === array.length - 1 ? null : ','}
          </MalinText>
        </ToolTipMenu>,
      );
    }

    return fromArray;
  };

  return (
    <SafeAreaScrollView>
      <HandOffComponent
        title={loc.transactions.details_title}
        type={HandOffActivityType.ViewInBlockExplorer}
        url={`${selectedBlockExplorer.url}/tx/${tx.hash}`}
      />
      <MalinCard>
        <View>
          <TextInput
            placeholder={loc.send.details_note_placeholder}
            value={memo}
            placeholderTextColor="#81868e"
            clearButtonMode="while-editing"
            style={[styles.memoTextInput, stylesHooks.memoTextInput]}
            onChangeText={setMemo}
            onBlur={handleMemoBlur}
            testID="TransactionDetailsMemoInput"
          />
          {isCounterpartyLabelVisible ? (
            <View>
              <MalinSpacing20 />
              <TextInput
                placeholder={loc.send.counterparty_label_placeholder}
                value={counterpartyLabel}
                onBlur={handleMemoBlur}
                placeholderTextColor="#81868e"
                style={[styles.memoTextInput, stylesHooks.memoTextInput]}
                onChangeText={setCounterpartyLabel}
              />
              <MalinSpacing20 />
            </View>
          ) : null}
        </View>

        {from && (
          <>
            <View style={styles.rowHeader}>
              <MalinText style={styles.rowCaption}>{loc.transactions.details_from}</MalinText>
              <CopyToClipboardButton stringToCopy={from.filter(onlyUnique).join(', ')} />
            </View>
            {renderSection(from.filter(onlyUnique))}
            <View style={styles.marginBottom18} />
          </>
        )}

        {to && (
          <>
            <View style={styles.rowHeader}>
              <MalinText style={styles.rowCaption}>{loc.transactions.details_to}</MalinText>
              <CopyToClipboardButton stringToCopy={to.filter(onlyUnique).join(', ')} />
            </View>
            {renderSection(arrDiff(from, to.filter(onlyUnique)))}
            <View style={styles.marginBottom18} />
          </>
        )}

        {tx.hash && (
          <>
            <View style={styles.rowHeader}>
              <MalinText style={styles.txid}>{loc.transactions.txid}</MalinText>
              <CopyToClipboardButton stringToCopy={tx.hash} />
            </View>
            <MalinText style={styles.rowValue}>{tx.hash}</MalinText>
            <View style={styles.marginBottom18} />
          </>
        )}

        {tx.timestamp && (
          <>
            <MalinText style={styles.rowCaption}>{loc.transactions.details_received}</MalinText>
            <MalinText style={styles.rowValue}>{dayjs(tx.timestamp * 1000).format('LLL')}</MalinText>
            <View style={styles.marginBottom18} />
          </>
        )}

        {tx.inputs && (
          <>
            <MalinText style={styles.rowCaption}>{loc.transactions.details_inputs}</MalinText>
            <MalinText style={styles.rowValue}>{tx.inputs.length}</MalinText>
            <View style={styles.marginBottom18} />
          </>
        )}

        {tx.outputs?.length > 0 && (
          <>
            <MalinText style={styles.rowCaption}>{loc.transactions.details_outputs}</MalinText>
            <MalinText style={styles.rowValue}>{tx.outputs.length}</MalinText>
            <View style={styles.marginBottom18} />
          </>
        )}
        <ToolTipMenu
          isButton
          actions={toolTipMenuActions}
          onPressMenuItem={handleCopyPress}
          onPress={handleOnOpenTransactionOnBlockExplorerTapped}
          buttonStyle={StyleSheet.flatten([styles.greyButton, stylesHooks.greyButton])}
        >
          <Text style={[styles.Link, stylesHooks.Link]}>{loc.transactions.details_view_in_browser}</Text>
        </ToolTipMenu>
      </MalinCard>
    </SafeAreaScrollView>
  );
};

const styles = StyleSheet.create({
  rowHeader: {
    flex: 1,
    flexDirection: 'row',
    marginBottom: 4,
    justifyContent: 'space-between',
  },
  rowCaption: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  rowValue: {
    color: 'grey',
  },
  marginBottom18: {
    marginBottom: 18,
  },
  txid: {
    fontSize: 16,
    fontWeight: '500',
  },
  Link: {
    fontWeight: '600',
    fontSize: 15,
  },
  weOwnAddress: {
    fontWeight: '700',
  },
  memoTextInput: {
    flexDirection: 'row',
    borderWidth: 1,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    marginVertical: 8,
    borderRadius: 4,
    paddingHorizontal: 8,
    color: '#81868e',
  },
  greyButton: {
    borderRadius: 9,
    minHeight: 49,
    paddingHorizontal: 8,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
    alignSelf: 'auto',
    flexGrow: 1,
    marginHorizontal: 4,
  },
});

export default TransactionDetails;


================================================
FILE: ./screen/transactions/CPFP.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { Component } from 'react';
import {
  ActivityIndicator,
  Linking,
  ScrollView,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  View
} from 'react-native';
import Clipboard from '@react-native-clipboard/clipboard';
import PropTypes from 'prop-types';
import { Text } from '@rneui/themed';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import triggerHapticFeedback, {
  HapticFeedbackTypes
} from '../../malin_modules/hapticFeedback';
import { MalinCard, MalinText } from '../../MalinComponents';
import { HDSegwitBech32Transaction, HDSegwitBech32Wallet } from '../../class';
import presentAlert, { AlertType } from '../../components/Alert';
import Button from '../../components/Button';
import SafeArea from '../../components/SafeArea';
import { MalinCurrentTheme } from '../../components/themes';
import loc from '../../loc';
import { StorageContext } from '../../components/Context/StorageProvider';
import ReplaceFeeSuggestions from '../../components/ReplaceFeeSuggestions';
import { majorTomToGroundControl } from '../../malin_modules/notifications';
import { MalinSpacing, MalinSpacing20 } from '../../components/MalinSpacing';

const styles = StyleSheet.create({
  root: {
    flex: 1,
    paddingTop: 20,
  },
  explain: {
    paddingBottom: 16,
  },
  center: {
    alignItems: 'center',
    flex: 1,
  },
  hex: {
    color: MalinCurrentTheme.colors.buttonAlternativeTextColor,
    fontWeight: '500',
  },
  hexInput: {
    borderColor: '#ebebeb',
    backgroundColor: '#d2f8d6',
    borderRadius: 4,
    marginTop: 20,
    color: '#37c0a1',
    fontWeight: '500',
    fontSize: 14,
    paddingHorizontal: 16,
    paddingBottom: 16,
    paddingTop: 16,
  },
  action: {
    marginVertical: 24,
  },
  actionText: {
    color: '#9aa0aa',
    fontSize: 15,
    fontWeight: '500',
    alignSelf: 'center',
  },
})

export default class CPFP extends Component {
  static contextType = StorageContext;
  constructor (props) {
    super(props);
    let txid;
    let wallet;
    if (props.route.params) txid = props.route.params.txid;
    if (props.route.params) wallet = props.route.params.wallet;

    this.state = {
      isLoading: true,
      stage: 1,
      txid,
      wallet,
      isElectrumDisabled: true,
    }
  }

  broadcast = () => {
    this.setState({ isLoading: true }, async () => {
      try {
        await MalinElectrum.ping();
        await MalinElectrum.waitTillConnected();
        const result = await this.state.wallet.broadcastTx(this.state.txhex);
        if (result) {
          this.onSuccessBroadcast();
        } else {
          triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
          this.setState({ isLoading: false });
          presentAlert({ message: loc.errors.broadcast });
        }
      } catch (error) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        this.setState({ isLoading: false });
        presentAlert({ message: error.message, type: AlertType.Toast });
      }
    });
  }

  onSuccessBroadcast () {
    this.context.txMetadata[this.state.newTxid] = {
      memo: 'Child pays for parent (CPFP)',
    };
    majorTomToGroundControl([], [], [this.state.newTxid]);
    this.context
      .sleep(4000)
      .then(() =>
        this.context.fetchAndSaveWalletTransactions(this.state.wallet.getID())
      );
    this.props.navigation.navigate('Success', { amount: undefined });
  }

  async componentDidMount() {
    console.log('transactions/CPFP - componentDidMount');
    this.setState({
      isLoading: true,
      newFeeRate: '',
      nonReplaceable: false,
    })
    try {
      await this.checkPossibilityOfCPFP();
    } catch (_) {
      // if anything goes wrong we just show "this is not bumpable" message
      this.setState({ nonReplaceable: true, isLoading: false });
    }
  }

  async checkPossibilityOfCPFP() {
    if (this.state.wallet.type !== HDSegwitBech32Wallet.type) {
      return this.setState({ nonReplaceable: true, isLoading: false });
    }

    const tx = new HDSegwitBech32Transaction(
      null,
      this.state.txid,
      this.state.wallet
    );
    if (
      (await tx.isToUsTransaction()) &&
      (await tx.getRemoteConfirmationsNum()) === 0
    ) {
      const info = await tx.getInfo();
      return this.setState({
        nonReplaceable: false,
        feeRate: info.feeRate + 1,
        isLoading: false,
        tx
      });
      // 1 sat makes a lot of difference, since sometimes because of rounding created tx's fee might be insufficient
    } else {
      return this.setState({ nonReplaceable: true, isLoading: false });
    }
  }

  async createTransaction() {
    const newFeeRate = parseInt(this.state.newFeeRate, 10);
    if (newFeeRate > this.state.feeRate) {
      /** @type {HDSegwitBech32Transaction} */
      const tx = this.state.tx;
      this.setState({ isLoading: true });
      try {
        const { tx: newTx } = await tx.createCPFPbumpFee(newFeeRate);
        this.setState({
          stage: 2,
          txhex: newTx.toHex(),
          newTxid: newTx.getId()
        });
        this.setState({ isLoading: false });
      } catch (_) {
        this.setState({ isLoading: false });
        presentAlert({ message: loc.errors.error + ': ' + _.message });
      }
    }
  }

  renderStage1(text) {
    return (
      <SafeArea style={styles.root}>
        <MalinSpacing />
        <MalinCard style={styles.center}>
          <MalinText>{text}</MalinText>
          <MalinSpacing20 />
          <ReplaceFeeSuggestions
            onFeeSelected={(fee) => this.setState({ newFeeRate: fee })}
            transactionMinimum={this.state.feeRate}
          />
          <MalinSpacing />
          <Button
            disabled={this.state.newFeeRate <= this.state.feeRate}
            onPress={() => this.createTransaction()}
            title={loc.transactions.cpfp_create}
          />
        </MalinCard>
      </SafeArea>
    );
  }

  renderStage2() {
    return (
      <View style={styles.root}>
        <MalinCard style={styles.center}>
          <MalinText style={styles.hex}>{loc.send.create_this_is_hex}</MalinText>
          <TextInput
            style={styles.hexInput}
            height={112}
            multiline
            editable
            value={this.state.txhex}
          />

          <TouchableOpacity
            accessibilityRole='button'
            style={styles.action}
            onPress={() => Clipboard.setString(this.state.txhex)}
          >
            <Text style={styles.actionText}>{loc.send.create_copy}</Text>
          </TouchableOpacity>
          <TouchableOpacity
            accessibilityRole="button"
            style={styles.action}
            onPress={() =>
              Linking.openURL('https://coinb.in/?verify=' + this.state.txhex)}
          >
            <Text style={styles.actionText}>{loc.send.create_verify}</Text>
          </TouchableOpacity>
          <Button
            disabled={this.context.isElectrumDisabled}
            onPress={this.broadcast}
            title={loc.send.confirm_sendNow}
          />
        </MalinCard>
      </View>
    );
  }

  render() {
    if (this.state.isLoading) {
      return (
        <View style={styles.root}>
          <ActivityIndicator />
        </View>
      );
    }

    if (this.state.stage === 2) {
      return this.renderStage2();
    }

    if (this.state.nonReplaceable) {
      return (
        <SafeArea style={styles.root}>
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />
          <MalinSpacing20 />

          <MalinText h4>{loc.transactions.cpfp_no_bump}</MalinText>
        </SafeArea>
      );
    }

    return (
      <SafeArea style={styles.explain}>
        <ScrollView
          automaticallyAdjustContentInsets
          automaticallyAdjustKeyboardInsets
          automaticallyAdjustsScrollIndicatorInsets
          contentInsetAdjustmentBehavior="automatic"
        >
          {this.renderStage1(loc.transactions.cpfp_exp)}
        </ScrollView>
      </SafeArea>
    );
  }
}

CPFP.propTypes = {
  navigation: PropTypes.shape({
    popToTop: PropTypes.func,
    navigate: PropTypes.func,
  }),
  route: PropTypes.shape({
    params: PropTypes.shape({
      txid: PropTypes.string,
      wallet: PropTypes.object,
    })
  }),
}


================================================
FILE: ./screen/SelectFeeScreen.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useRef, useCallback, useReducer, useEffect, FC } from 'react';
import { View, Text, TouchableOpacity, TextInput, StyleSheet, Keyboard } from 'react-native';
import { useTheme } from '../components/themes';
import loc, { formatBalance } from '../loc';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { RouteProp, useFocusEffect, useNavigation, useRoute } from '@react-navigation/native';
import { SendDetailsStackParamList } from '../navigation/SendDetailsStackParamList';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { NetworkTransactionFeeType } from '../models/networkTransactionFees';

enum FeeScreenActions {
  SET_CUSTOM_FEE_VALUE = 'SET_CUSTOM_FEE_VALUE',
  SET_CUSTOM_FEE_FOCUSED = 'SET_CUSTOM_FEE_FOCUSED',
  SET_CUSTOM_FEE_BLURRED = 'SET_CUSTOM_FEE_BLURRED',
  CLEAR_CUSTOM_FEE = 'CLEAR_CUSTOM_FEE',
  SET_OPTIONS = 'SET_OPTIONS',
}

interface FeeOption {
  label: string;
  time: string;
  fee: number | null;
  rate: number;
  feeType: NetworkTransactionFeeType;
  active: boolean;
  disabled?: boolean;
}

interface FeeScreenState {
  customFeeValue: string;
  isCustomFeeFocused: boolean;
  options: FeeOption[];
  isCustomFeeSelected: boolean;
}

type FeeScreenAction =
  | { type: FeeScreenActions.SET_CUSTOM_FEE_VALUE; payload: string }
  | { type: FeeScreenActions.SET_CUSTOM_FEE_FOCUSED }
  | { type: FeeScreenActions.SET_CUSTOM_FEE_BLURRED }
  | { type: FeeScreenActions.CLEAR_CUSTOM_FEE }
  | { type: FeeScreenActions.SET_OPTIONS; payload: { options: FeeOption[]; currentFeeRate: number } };

const feeScreenReducer = (state: FeeScreenState, action: FeeScreenAction): FeeScreenState => {
  switch (action.type) {
    case FeeScreenActions.SET_CUSTOM_FEE_VALUE:
      return { ...state, customFeeValue: action.payload };
    case FeeScreenActions.SET_CUSTOM_FEE_FOCUSED:
      return {
        ...state,
        isCustomFeeFocused: true,
        isCustomFeeSelected: true,
        options: state.options.map(opt => ({ ...opt, active: false })),
      };
    case FeeScreenActions.SET_CUSTOM_FEE_BLURRED:
      return { ...state, isCustomFeeFocused: false };
    case FeeScreenActions.CLEAR_CUSTOM_FEE:
      return { ...state, customFeeValue: '' };
    case FeeScreenActions.SET_OPTIONS: {
      const { options, currentFeeRate } = action.payload;
      const matchesPresetOption = options.some(option => currentFeeRate === option.rate);
      const updatedOptions = options.map(option => ({
        ...option,
        active: !state.isCustomFeeFocused && currentFeeRate === option.rate,
      }));
      return {
        ...state,
        options: updatedOptions,
        isCustomFeeSelected: state.isCustomFeeFocused || !matchesPresetOption,
      };
    }
    default:
      return state;
  }
};

interface FeeOptionProps {
  label: string;
  time: string;
  fee: number | null;
  rate: number;
  active: boolean;
  disabled?: boolean;
  onPress: () => void;
  formatFee: (fee: number) => string;
  colors: any;
}

const FeeOption: FC<FeeOptionProps> = ({ label, time, fee, rate, active, disabled, onPress, formatFee, colors }) => {
  const stylesHook = StyleSheet.create({
    feeModalItemActiveBackground: {
      backgroundColor: colors.feeActive,
    },
    feeOptionText: {
      color: colors.successColor,
    },
    feeOptionTextDisabled: {
      color: colors.buttonDisabledTextColor,
    },
    feeTimeBackground: {
      backgroundColor: colors.successColor,
    },
    feeTimeBackgroundDisabled: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    feeTimeText: {
      color: colors.background,
    },
  });

  return (
    <TouchableOpacity
      accessibilityRole="button"
      disabled={disabled}
      onPress={onPress}
      style={[styles.feeModalItem, active && styles.feeModalItemActive, active && !disabled && stylesHook.feeModalItemActiveBackground]}
    >
      <View style={styles.feeModalRow}>
        <Text style={[styles.feeModalLabel, disabled ? stylesHook.feeOptionTextDisabled : stylesHook.feeOptionText]}>{label}</Text>
        <View style={[styles.feeModalTime, disabled ? stylesHook.feeTimeBackgroundDisabled : stylesHook.feeTimeBackground]}>
          <Text style={stylesHook.feeTimeText}>~{time}</Text>
        </View>
      </View>
      <View style={styles.feeModalRow}>
        <Text style={disabled ? stylesHook.feeOptionTextDisabled : stylesHook.feeOptionText}>{fee && formatFee(fee)}</Text>
        <Text style={disabled ? stylesHook.feeOptionTextDisabled : stylesHook.feeOptionText}>
          {rate} {loc.units.sat_vbyte}
        </Text>
      </View>
    </TouchableOpacity>
  );
};

type SelectFeeScreenNavigationProp = NativeStackNavigationProp<SendDetailsStackParamList, 'SelectFee'>;
type SelectFeeScreenRouteProp = RouteProp<SendDetailsStackParamList, 'SelectFee'>;

const SelectFeeScreen = () => {
  const navigation = useNavigation<SelectFeeScreenNavigationProp>();
  const route = useRoute<SelectFeeScreenRouteProp>();
  const { colors } = useTheme();

  const { networkTransactionFees, feePrecalc, feeRate, feeUnit = BitcoinUnit.BTC, walletID, customFee } = route.params;

  const [state, dispatch] = useReducer(feeScreenReducer, {
    customFeeValue: customFee || '',
    isCustomFeeFocused: false,
    options: [],
    isCustomFeeSelected: false,
  });

  const customFeeInputRef = useRef<TextInput>(null);
  const nf = networkTransactionFees;

  const stylesHook = StyleSheet.create({
    container: {
      backgroundColor: colors.elevated,
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    feeModalItemActiveBackground: {
      backgroundColor: colors.feeActive,
    },
    customLabelColor: {
      color: colors.successColor,
    },
    satVbyteText: {
      color: colors.successColor,
    },
    customFeeInputColors: {
      color: colors.successColor,
      borderColor: colors.formBorder,
    },
    feeTimeBackground: {
      backgroundColor: colors.successColor,
    },
    feeTimeBackgroundDisabled: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    feeTimeText: {
      color: colors.background,
    },
  });

  const formatFee = useCallback((fee: number) => formatBalance(fee, feeUnit, true), [feeUnit]);

  useEffect(() => {
    const options: FeeOption[] = [
      {
        label: loc.send.fee_fast,
        time: loc.send.fee_10m,
        fee: feePrecalc.fastestFee,
        rate: nf.fastestFee,
        feeType: NetworkTransactionFeeType.FAST,
        active: false,
      },
      {
        label: loc.send.fee_medium,
        time: loc.send.fee_3h,
        fee: feePrecalc.mediumFee,
        rate: nf.mediumFee,
        feeType: NetworkTransactionFeeType.MEDIUM,
        active: false,
        disabled: nf.mediumFee === nf.fastestFee,
      },
      {
        label: loc.send.fee_slow,
        time: loc.send.fee_1d,
        fee: feePrecalc.slowFee,
        rate: nf.slowFee,
        feeType: NetworkTransactionFeeType.SLOW,
        active: false,
        disabled: nf.slowFee === nf.mediumFee || nf.slowFee === nf.fastestFee,
      },
    ];
    dispatch({ type: FeeScreenActions.SET_OPTIONS, payload: { options, currentFeeRate: Number(feeRate) } });
  }, [feePrecalc, nf, feeRate]);

  const navigateWithFee = useCallback(
    (feeRateValue: string, feeType: NetworkTransactionFeeType) => {
      navigation.popTo('SendDetails', { walletID, selectedFeeRate: feeRateValue, selectedFeeType: feeType }, { merge: true });
    },
    [navigation, walletID],
  );

  const handleFeeOptionPress = useCallback(
    (rate: number, feeType: NetworkTransactionFeeType) => {
      navigateWithFee(rate.toString(), feeType);
    },
    [navigateWithFee],
  );

  const handleCustomFeeChange = useCallback((value: string) => {
    const cleanValue = value.replace(/[^\d.,]/g, '').replace(/([.,].*?)[.,]/g, '$1');
    dispatch({ type: FeeScreenActions.SET_CUSTOM_FEE_VALUE, payload: cleanValue });
  }, []);

  const handleCustomFeeSubmit = useCallback(() => {
    const numericValue = state.customFeeValue.replace(',', '.');
    if (numericValue && Number(numericValue) >= 0) {
      navigateWithFee(numericValue, NetworkTransactionFeeType.CUSTOM);
    }
  }, [state.customFeeValue, navigateWithFee]);

  const handleCustomFeeBlur = useCallback(() => {
    dispatch({ type: FeeScreenActions.SET_CUSTOM_FEE_BLURRED });
    const numericValue = Number(state.customFeeValue.replace(',', '.'));
    if (!state.customFeeValue || numericValue < 0) {
      dispatch({ type: FeeScreenActions.CLEAR_CUSTOM_FEE });
    }
  }, [state.customFeeValue]);

  const handleCustomFocus = useCallback(() => dispatch({ type: FeeScreenActions.SET_CUSTOM_FEE_FOCUSED }), []);
  const handleCustomPress = useCallback(() => customFeeInputRef.current?.focus(), []);

  useFocusEffect(
    useCallback(() => {
      Keyboard.dismiss();
      return () => Keyboard.dismiss();
    }, []),
  );

  return (
    <View style={[stylesHook.container, styles.screenContainer]}>
      <View style={styles.contentContainer}>
        {state.options.map(({ label, time, fee, rate, active, disabled, feeType }) => (
          <FeeOption
            key={label}
            label={label}
            time={time}
            fee={fee}
            rate={rate}
            active={active}
            disabled={disabled}
            onPress={() => handleFeeOptionPress(rate, feeType)}
            formatFee={formatFee}
            colors={colors}
          />
        ))}
        <TouchableOpacity
          accessibilityRole="button"
          testID="feeCustomContainerButton"
          onPress={handleCustomPress}
          style={[
            styles.feeModalItem,
            styles.customFeeButton,
            state.isCustomFeeSelected && styles.feeModalItemActive,
            state.isCustomFeeSelected && stylesHook.feeModalItemActiveBackground,
          ]}
        >
          <View style={styles.feeModalRow}>
            <Text style={[styles.feeModalLabel, stylesHook.customLabelColor]}>{loc.send.fee_custom}</Text>
            <View style={styles.customFeeContainer}>
              <TextInput
                ref={customFeeInputRef}
                style={[styles.customFeeInput, stylesHook.customFeeInputColors]}
                keyboardType="numeric"
                placeholder={loc.send.insert_custom_fee}
                value={state.customFeeValue}
                placeholderTextColor={colors.placeholderTextColor}
                onChangeText={handleCustomFeeChange}
                onSubmitEditing={handleCustomFeeSubmit}
                onFocus={handleCustomFocus}
                onBlur={handleCustomFeeBlur}
                enablesReturnKeyAutomatically
                returnKeyType="done"
                accessibilityLabel={loc.send.create_fee}
                testID="feeCustom"
              />
              {state.customFeeValue && /^\d+(\.\d+)?$/.test(state.customFeeValue) && Number(state.customFeeValue) > 0 && (
                <Text style={stylesHook.satVbyteText}>{loc.units.sat_vbyte}</Text>
              )}
            </View>
          </View>
        </TouchableOpacity>
      </View>
    </View>
  );
};

export default SelectFeeScreen;

const styles = StyleSheet.create({
  screenContainer: {
    minHeight: 300,
    maxHeight: 500,
  },
  contentContainer: {
    paddingTop: 16,
    paddingBottom: 32,
  },
  feeModalItem: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginBottom: 10,
  },
  feeModalItemActive: {
    borderRadius: 8,
  },
  feeModalRow: {
    justifyContent: 'space-between',
    flexDirection: 'row',
    alignItems: 'center',
  },
  feeModalLabel: {
    fontSize: 22,
    fontWeight: '600',
  },
  customFeeInput: {
    fontSize: 16,
    height: 36,
    textAlign: 'right',
    padding: 0,
    width: 70,
    marginRight: 4,
  },
  customFeeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  customFeeButton: {
    marginBottom: 44,
  },
  feeModalTime: {
    borderRadius: 5,
    paddingHorizontal: 6,
    paddingVertical: 3,
  },
});


================================================
FILE: ./screen/Browser.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState } from 'react';
import { StyleSheet, View, TextInput, TouchableOpacity, Text, SafeAreaView } from 'react-native';
import { WebView } from 'react-native-webview';
import { useTheme } from '../components/themes';
import { Icon } from '@rneui/themed';

const Browser: React.FC = () => {
  const { colors } = useTheme();
  const [url, setUrl] = useState('https://app.uniswap.org');
  const [inputUrl, setInputUrl] = useState('https://app.uniswap.org');

  const handleGo = () => {
    let newUrl = inputUrl;
    if (!newUrl.startsWith('http')) {
        newUrl = 'https://' + newUrl;
    }
    setUrl(newUrl);
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <View style={[styles.urlBar, { backgroundColor: colors.inputBackgroundColor }]}>
        <TextInput
          style={[styles.input, { color: colors.foregroundColor }]}
          value={inputUrl}
          onChangeText={setInputUrl}
          placeholder="Enter URL"
          placeholderTextColor={colors.buttonDisabledTextColor}
          autoCapitalize="none"
          autoCorrect={false}
        />
        <TouchableOpacity onPress={handleGo} style={styles.goButton}>
          <Icon name="arrow-forward" type="material" color={colors.foregroundColor} />
        </TouchableOpacity>
      </View>
      <WebView
        source={{ uri: url }}
        style={styles.webview}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  urlBar: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  input: {
    flex: 1,
    height: 40,
    paddingHorizontal: 10,
    borderRadius: 5,
  },
  goButton: {
    marginLeft: 10,
  },
  webview: {
    flex: 1,
  },
});

export default Browser;


================================================
FILE: ./loc/index.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import BigNumber from 'bignumber.js';
import dayjs from 'dayjs';
import localizedFormat from 'dayjs/plugin/localizedFormat';
import relativeTime from 'dayjs/plugin/relativeTime';
import Localization, { LocalizedStrings } from 'react-localization';
import { I18nManager } from 'react-native';
import * as RNLocalize from 'react-native-localize';

import { satoshiToLocalCurrency } from '../malin_modules/currency';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { AvailableLanguages } from './languages';
import enJson from './en.json';

export const STORAGE_KEY = 'lang';

dayjs.extend(relativeTime);
dayjs.extend(localizedFormat);

interface ILocalization1 extends LocalizedStrings<typeof enJson> {}

// overriding formatString to only return string
interface ILocalization extends Omit<ILocalization1, 'formatString'> {
  formatString: (...args: Parameters<ILocalization1['formatString']>) => string;
}

const setDateTimeLocale = async () => {
  let lang = (await AsyncStorage.getItem(STORAGE_KEY)) ?? '';
  let localeForDayJSAvailable = true;
  switch (lang) {
    case 'ar':
      require('dayjs/locale/ar');
      break;
    case 'be':
      require('dayjs/locale/be');
      break;
    case 'bg_bg':
      lang = 'bg';
      require('dayjs/locale/bg');
      break;
    case 'bqi':
      lang = 'fa';
      require('dayjs/locale/fa');
      break;
    case 'ca':
      require('dayjs/locale/ca');
      break;
    case 'cy':
      require('dayjs/locale/cy');
      break;
    case 'da_dk':
      require('dayjs/locale/da');
      break;
    case 'de_de':
      require('dayjs/locale/de');
      break;
    case 'el':
      require('dayjs/locale/el');
      break;
    case 'es':
      require('dayjs/locale/es');
      break;
    case 'es_419':
      // es-do it is the closes one to es_419
      lang = 'es-do';
      require('dayjs/locale/es-do');
      break;
    case 'et':
      require('dayjs/locale/et');
      break;
    case 'fi_fi':
      require('dayjs/locale/fi');
      break;
    case 'fa':
      require('dayjs/locale/fa');
      break;
    case 'fr_fr':
      require('dayjs/locale/fr');
      break;
    case 'he':
      require('dayjs/locale/he');
      break;
    case 'hr_hr':
      require('dayjs/locale/hr');
      break;
    case 'hu_hu':
      require('dayjs/locale/hu');
      break;
    case 'id_id':
      require('dayjs/locale/id');
      break;
    case 'it':
      require('dayjs/locale/it');
      break;
    case 'jp_jp':
      lang = 'ja';
      require('dayjs/locale/ja');
      break;
    case 'ko_kr':
      lang = 'ko';
      require('dayjs/locale/ko');
      break;
    case 'lrc':
      lang = 'fa';
      require('dayjs/locale/fa');
      break;
    case 'kn':
      require('dayjs/locale/kn');
      break;
    case 'ms':
      require('dayjs/locale/ms');
      break;
    case 'ne':
      require('dayjs/locale/ne');
      break;
    case 'nb_no':
      require('dayjs/locale/nb');
      break;
    case 'nl_nl':
      require('dayjs/locale/nl');
      break;
    case 'pt_br':
      lang = 'pt-br';
      require('dayjs/locale/pt-br');
      break;
    case 'pt_pt':
      lang = 'pt';
      require('dayjs/locale/pt');
      break;
    case 'pl':
      require('dayjs/locale/pl');
      break;
    case 'ro':
      require('dayjs/locale/ro');
      break;
    case 'ru':
      require('dayjs/locale/ru');
      break;
    case 'si_lk':
      require('dayjs/locale/si.js');
      break;
    case 'sk_sk':
      require('dayjs/locale/sk');
      break;
    case 'sl_si':
      require('dayjs/locale/sl');
      break;
    case 'sr_rs':
      lang = 'sr-cyrl';
      require('dayjs/locale/sr-cyrl');
      break;
    case 'sv_se':
      require('dayjs/locale/sv');
      break;
    case 'th_th':
      require('dayjs/locale/th');
      break;
    case 'tr_tr':
      require('dayjs/locale/tr');
      break;
    case 'vi_vn':
      require('dayjs/locale/vi');
      break;
    case 'zh_cn':
      lang = 'zh-cn';
      require('dayjs/locale/zh-cn');
      break;
    case 'zh_tw':
      lang = 'zh-tw';
      require('dayjs/locale/zh-tw');
      break;
    default:
      localeForDayJSAvailable = false;
      break;
  }
  if (localeForDayJSAvailable) {
    dayjs.locale(lang.split('_')[0]);
  } else {
    dayjs.locale('en');
  }
};

const init = async () => {
  // finding out whether lang preference was saved
  const lang = await AsyncStorage.getItem(STORAGE_KEY);
  if (lang) {
    await saveLanguage(lang);
    await loc.setLanguage(lang);
    if (process.env.JEST_WORKER_ID === undefined) {
      const foundLang = AvailableLanguages.find(language => language.value === lang);
      I18nManager.allowRTL(foundLang?.isRTL ?? false);
      I18nManager.forceRTL(foundLang?.isRTL ?? false);
    }
    await setDateTimeLocale();
  } else {
    const locales = RNLocalize.getLocales();
    if (Object.values(AvailableLanguages).some(language => language.value === locales[0].languageCode)) {
      await saveLanguage(locales[0].languageCode);
      await loc.setLanguage(locales[0].languageCode);
      if (process.env.JEST_WORKER_ID === undefined) {
        I18nManager.allowRTL(locales[0].isRTL ?? false);
        I18nManager.forceRTL(locales[0].isRTL ?? false);
      }
    } else {
      await saveLanguage('en');
      await loc.setLanguage('en');
      if (process.env.JEST_WORKER_ID === undefined) {
        I18nManager.allowRTL(false);
        I18nManager.forceRTL(false);
      }
    }
    await setDateTimeLocale();
  }
};
init();

const loc: ILocalization = new Localization({
  en: enJson,
  ar: require('./ar.json'),
  be: require('./be@tarask.json'),
  bg_bg: require('./bg_bg.json'),
  bqi: require('./bqi.json'),
  ca: require('./ca.json'),
  cy: require('./cy.json'),
  cs_cz: require('./cs_cz.json'),
  da_dk: require('./da_dk.json'),
  de_de: require('./de_de.json'),
  el: require('./el.json'),
  es: require('./es.json'),
  es_419: require('./es_419.json'),
  et: require('./et_EE.json'),
  fa: require('./fa.json'),
  fi_fi: require('./fi_fi.json'),
  fr_fr: require('./fr_fr.json'),
  he: require('./he.json'),
  hr_hr: require('./hr_hr.json'),
  hu_hu: require('./hu_hu.json'),
  id_id: require('./id_id.json'),
  it: require('./it.json'),
  jp_jp: require('./jp_jp.json'),
  ko_kr: require('./ko_KR.json'),
  lrc: require('./lrc.json'),
  ms: require('./ms.json'),
  kn: require('./kn.json'),
  ne: require('./ne.json'),
  nb_no: require('./nb_no.json'),
  nl_nl: require('./nl_nl.json'),
  pt_br: require('./pt_br.json'),
  pt_pt: require('./pt_pt.json'),
  pl: require('./pl.json'),
  ro: require('./ro.json'),
  ru: require('./ru.json'),
  si_lk: require('./si_LK.json'),
  sk_sk: require('./sk_sk.json'),
  sl_si: require('./sl_SI.json'),
  sr_rs: require('./sr_RS.json'),
  sv_se: require('./sv_se.json'),
  th_th: require('./th_th.json'),
  tr_tr: require('./tr_tr.json'),
  ua: require('./ua.json'),
  vi_vn: require('./vi_vn.json'),
  zar_afr: require('./zar_afr.json'),
  zar_xho: require('./zar_xho.json'),
  zh_cn: require('./zh_cn.json'),
  zh_tw: require('./zh_tw.json'),
});

export const saveLanguage = async (lang: string) => {
  await AsyncStorage.setItem(STORAGE_KEY, lang);
  loc.setLanguage(lang);
  // even tho it makes no effect changing it in this run, it will on the next run, so we are doign it here:
  if (process.env.JEST_WORKER_ID === undefined) {
    const foundLang = AvailableLanguages.find(language => language.value === lang);
    I18nManager.allowRTL(foundLang?.isRTL ?? false);
    I18nManager.forceRTL(foundLang?.isRTL ?? false);
  }
  await setDateTimeLocale();
};

export const transactionTimeToReadable = (time: number | string) => {
  if (time === -1) {
    return 'unknown';
  }
  if (+time < 1000000000000) {
    // converting timestamp to milliseconds timestamp
    // (we dont expect timestamps before September 9, 2001 so this conversion is fine)
    time = +time * 1000;
  }
  if (time === 0) {
    return loc._.never;
  }
  let ret;
  try {
    ret = dayjs(time).fromNow();
  } catch (_) {
    console.warn('incorrect locale set for dayjs');
    return String(time);
  }
  return ret;
};

export const removeTrailingZeros = (value: number | string): string => {
  let ret = value.toString();

  if (ret.indexOf('.') === -1) {
    return ret;
  }
  while ((ret.slice(-1) === '0' || ret.slice(-1) === '.') && ret.indexOf('.') !== -1) {
    ret = ret.substr(0, ret.length - 1);
  }
  return ret;
};

/**
 *
 * @param balance {number} Satoshis
 * @param toUnit {string} Value from models/bitcoinUnits.js
 * @param withFormatting {boolean} Works only with `BitcoinUnit.SATS`, makes spaces wetween groups of 000
 * @returns {string}
 */
export function formatBalance(balance: number, toUnit: string, withFormatting = false): string {
  if (toUnit === undefined) {
    return balance + ' ' + loc.units[BitcoinUnit.BTC];
  }
  if (toUnit === BitcoinUnit.BTC) {
    const value = new BigNumber(balance).dividedBy(100000000).toFixed(8);
    return removeTrailingZeros(value) + ' ' + loc.units[BitcoinUnit.BTC];
  } else if (toUnit === BitcoinUnit.SATS) {
    return (withFormatting ? new Intl.NumberFormat().format(balance).toString() : String(balance)) + ' ' + loc.units[BitcoinUnit.SATS];
  } else if (toUnit === BitcoinUnit.ETH) {
    const value = new BigNumber(balance).dividedBy(1e18).toFormat();
    return removeTrailingZeros(value) + ' ' + loc.units[BitcoinUnit.ETH];
  } else if (toUnit === BitcoinUnit.SOL) {
    const value = new BigNumber(balance).dividedBy(1e9).toFormat();
    return removeTrailingZeros(value) + ' ' + loc.units[BitcoinUnit.SOL];
  } else {
    return satoshiToLocalCurrency(balance);
  }
}

/**
 *
 * @param balance {number} Satoshis
 * @param toUnit {string} Value from models/bitcoinUnits.js, for example `BitcoinUnit.SATS`
 * @param withFormatting {boolean} Works only with `BitcoinUnit.SATS`, makes spaces wetween groups of 000
 * @returns {string}
 */
export function formatBalanceWithoutSuffix(balance = 0, toUnit: string, withFormatting = false): string | number {
  if (toUnit === undefined) {
    return balance;
  }
  if (toUnit === BitcoinUnit.BTC) {
    const value = new BigNumber(balance).dividedBy(100000000).toFixed(8);
    return removeTrailingZeros(value);
  } else if (toUnit === BitcoinUnit.SATS) {
    return withFormatting ? new Intl.NumberFormat().format(balance).toString() : String(balance);
  } else if (toUnit === BitcoinUnit.ETH) {
    const value = new BigNumber(balance).dividedBy(1e18).toFixed(18);
    return removeTrailingZeros(value);
  } else if (toUnit === BitcoinUnit.SOL) {
    const value = new BigNumber(balance).dividedBy(1e9).toFixed(9);
    return removeTrailingZeros(value);
  } else {
    return satoshiToLocalCurrency(balance);
  }
}

/**
 * Should be used when we need a simple string to be put in text input, for example
 *
 * @param  balance {number} Satoshis
 * @param toUnit {string} Value from models/bitcoinUnits.js, for example `BitcoinUnit.SATS`
 * @param withFormatting {boolean} Works only with `BitcoinUnit.SATS`, makes spaces wetween groups of 000
 * @returns {string}
 */
export function formatBalancePlain(balance = 0, toUnit: string, withFormatting = false) {
  const newInputValue = formatBalanceWithoutSuffix(balance, toUnit, withFormatting);
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return _leaveNumbersAndDots(newInputValue.toString());
}

export function _leaveNumbersAndDots(newInputValue: string) {
  newInputValue = newInputValue.replace(/[^\d.,-]/g, ''); // filtering, leaving only numbers, dots & commas
  if (newInputValue.endsWith('.00') || newInputValue.endsWith(',00')) newInputValue = newInputValue.substring(0, newInputValue.length - 3);

  if (newInputValue[newInputValue.length - 3] === ',') {
    // this is a fractional value, lets replace comma to dot so it represents actual fractional value for normal people
    newInputValue = newInputValue.substring(0, newInputValue.length - 3) + '.' + newInputValue.substring(newInputValue.length - 2);
  }
  newInputValue = newInputValue.replace(/,/gi, '');

  return newInputValue;
}

/**
 * @see https://github.com/MalinWallet/MalinWallet/issues/3466
 */
export function formatStringAddTwoWhiteSpaces(text: string): string {
  return `${text}  `;
}

export default loc;


================================================
FILE: ./loc/languages.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export const AvailableLanguages: Readonly<TLanguage[]> = Object.freeze([
  { label: 'English', value: 'en' },
  { label: 'Afrikaans (AFR)', value: 'zar_afr' },
  { label: ' (AR)', value: 'ar', isRTL: true },
  { label: ' (BG)', value: 'bg_bg' },
  { label: ' (BE)', value: 'be' },
  { label: 'Catal (CA)', value: 'ca' },
  { label: 'Chinese (TW)', value: 'zh_tw' },
  { label: 'Chinese (ZH)', value: 'zh_cn' },
  { label: 'Croatian (HR)', value: 'hr_hr' },
  { label: 'Cymraeg (CY)', value: 'cy' },
  { label: 'esky (CZ)', value: 'cs_cz' },
  { label: 'Danish (DK)', value: 'da_dk' },
  { label: 'Deutsch (DE)', value: 'de_de' },
  { label: 'Espaol (Spain) (es_ES)', value: 'es' },
  { label: 'Espaol (Latin America) (es_419)', value: 'es_419' },
  { label: 'Eesti (ET)', value: 'et' },
  { label: ' (EL)', value: 'el' },
  { label: ' (FA)', value: 'fa', isRTL: true },
  { label: '  (BQI)', value: 'bqi', isRTL: true },
  { label: '  (LRC)', value: 'lrc', isRTL: true },
  { label: 'Franais (FR)', value: 'fr_fr' },
  { label: ' (HE)', value: 'he', isRTL: true },
  { label: 'Italiano (IT)', value: 'it' },
  { label: 'Indonesia (ID)', value: 'id_id' },
  { label: ' (KK)', value: 'kk@Cyrl' },
  { label: 'Magyar (HU)', value: 'hu_hu' },
  { label: ' (JP)', value: 'jp_jp' },
  { label: ' (KO)', value: 'ko_kr' },
  { label: ' (KN)', value: 'kn' },
  { label: 'Bahasa Melayu (MS)', value: 'ms' },
  { label: 'Nederlands (NL)', value: 'nl_nl' },
  { label: 'Nigerian Pidgin (NG)', value: 'pcm' },
  { label: ' (NE)', value: 'ne' },
  { label: 'Norsk (NB)', value: 'nb_no' },
  { label: 'Polski (PL)', value: 'pl' },
  { label: 'Portugus (BR)', value: 'pt_br' },
  { label: 'Portugus (PT)', value: 'pt_pt' },
  { label: 'Romn (RO)', value: 'ro' },
  { label: ' (RU)', value: 'ru' },
  { label: ' (SI)', value: 'si_lk' },
  { label: ' (SR)', value: 'sr_rs' },
  { label: 'Slovensk (SK)', value: 'sk_sk' },
  { label: 'Slovenina (SL)', value: 'sl_si' },
  { label: 'Suomi (FI)', value: 'fi_fi' },
  { label: 'Svenska (SE)', value: 'sv_se' },
  { label: 'Thai (TH)', value: 'th_th' },
  { label: 'Vietnamese (VN)', value: 'vi_vn' },
  { label: ' (UA)', value: 'ua' },
  { label: 'Trke (TR)', value: 'tr_tr' },
  { label: 'Xhosa (XHO)', value: 'zar_xho' },
]);

export type TLanguage = {
  label: string;
  value: string;
  isRTL?: boolean;
};


================================================
FILE: ./models/itemTypes.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export enum ItemType {
  WalletSection = 'wallet',
  TransactionSection = 'transaction',
  AddressSection = 'address',
  WalletGroupSection = 'walletGroup',
}

export interface AddressItemData {
  address: string;
  walletID: string;
  index: number;
  isInternal: boolean;
}


================================================
FILE: ./models/blockExplorer.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// blockExplorer.ts
import DefaultPreference from 'react-native-default-preference';

export interface BlockExplorer {
  key: string;
  name: string;
  url: string;
}

export const BLOCK_EXPLORERS: { [key: string]: BlockExplorer } = {
  default: { key: 'default', name: 'Mempool.space', url: 'https://mempool.space' },
  blockchair: { key: 'blockchair', name: 'Blockchair', url: 'https://blockchair.com/bitcoin' },
  blockstream: { key: 'blockstream', name: 'Blockstream.info', url: 'https://blockstream.info' },
  custom: { key: 'custom', name: 'Custom', url: '' }, // Custom URL will be handled separately
};

export const getBlockExplorersList = (): BlockExplorer[] => {
  return Object.values(BLOCK_EXPLORERS);
};

export const normalizeUrl = (url: string): string => {
  return url.replace(/\/+$/, '');
};

export const isValidUrl = (url: string): boolean => {
  const pattern = /^(https?:\/\/)/;
  return pattern.test(url);
};

export const findMatchingExplorerByDomain = (url: string): BlockExplorer | null => {
  const domain = getDomain(url);
  for (const explorer of Object.values(BLOCK_EXPLORERS)) {
    if (getDomain(explorer.url) === domain) {
      return explorer;
    }
  }
  return null;
};

export const getDomain = (url: string): string => {
  try {
    const hostname = new URL(url).hostname;
    return hostname.replace(/^www\./, '');
  } catch {
    return '';
  }
};

const BLOCK_EXPLORER_STORAGE_KEY = 'blockExplorer';

export const saveBlockExplorer = async (url: string): Promise<boolean> => {
  try {
    await DefaultPreference.set(BLOCK_EXPLORER_STORAGE_KEY, url);
    return true;
  } catch (error) {
    console.error('Error saving block explorer:', error);
    return false;
  }
};

export const removeBlockExplorer = async (): Promise<boolean> => {
  try {
    await DefaultPreference.clear(BLOCK_EXPLORER_STORAGE_KEY);
    return true;
  } catch (error) {
    console.error('Error removing block explorer:', error);
    return false;
  }
};

export const getBlockExplorerUrl = async (): Promise<string> => {
  try {
    const url = (await DefaultPreference.get(BLOCK_EXPLORER_STORAGE_KEY)) as string | null;
    return url ?? BLOCK_EXPLORERS.default.url;
  } catch (error) {
    console.error('Error getting block explorer:', error);
    return BLOCK_EXPLORERS.default.url;
  }
};


================================================
FILE: ./models/networkTransactionFees.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as MalinElectrum from '../malin_modules/MalinElectrum';

export enum NetworkTransactionFeeType {
  FAST = 'Fast',
  MEDIUM = 'MEDIUM',
  SLOW = 'SLOW',
  CUSTOM = 'CUSTOM',
}

export class NetworkTransactionFee {
  static StorageKey = 'NetworkTransactionFee';

  public fastestFee: number;
  public mediumFee: number;
  public slowFee: number;

  constructor(fastestFee = 2, mediumFee = 1, slowFee = 1) {
    this.fastestFee = fastestFee;
    this.mediumFee = mediumFee;
    this.slowFee = slowFee;
  }
}

export default class NetworkTransactionFees {
  static async recommendedFees(): Promise<NetworkTransactionFee> {
    try {
      const isDisabled = await MalinElectrum.isDisabled();
      if (isDisabled) {
        throw new Error('Electrum is disabled. Dont attempt to fetch fees');
      }
      const response = await MalinElectrum.estimateFees();
      if (response.fast === response.medium) {
        // exception, if fees are equal lets bump priority fee + 1 so actual priority tx is above the rest
        return new NetworkTransactionFee(response.fast + 1, response.medium, response.slow);
      }
      return new NetworkTransactionFee(response.fast, response.medium, response.slow);
    } catch (err) {
      console.warn(err);
      return new NetworkTransactionFee(2, 1, 1);
    }
  }
}


================================================
FILE: ./models/fiatUnit.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { fetch } from '../util/fetch';
import untypedFiatUnit from './fiatUnits.json';

export const FiatUnitSource = {
  Coinbase: 'Coinbase',
  CoinDesk: 'CoinDesk',
  CoinGecko: 'CoinGecko',
  Kraken: 'Kraken',
  Yadio: 'Yadio',
  YadioConvert: 'YadioConvert',
  Exir: 'Exir',
  coinpaprika: 'coinpaprika',
  Bitstamp: 'Bitstamp',
  BNR: 'BNR',
} as const;

const handleError = (source: string, ticker: string, error: Error) => {
  throw new Error(
    `Could not update rate for ${ticker} from ${source}\n: ${error.message}. ` +
      `\nMake sure the network you're on has access to ${source}.`,
  );
};

const fetchRate = async (url: string): Promise<unknown> => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  return await response.json();
};

interface CoinbaseResponse {
  data: {
    amount: string;
  };
}

interface CoinDeskResponse {
  [ticker: string]: number;
}

interface CoinGeckoResponse {
  bitcoin: {
    [ticker: string]: number;
  };
}

interface BitstampResponse {
  last: string;
}

interface KrakenResponse {
  result: {
    [pair: string]: {
      c: [string];
    };
  };
}

interface YadioResponse {
  [ticker: string]: {
    price: number;
  };
}

interface YadioConvertResponse {
  rate: number;
}

interface ExirResponse {
  last: string;
}

interface CoinpaprikaResponse {
  quotes: {
    [ticker: string]: {
      price: number;
    };
  };
}

const RateExtractors = {
  Coinbase: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(`https://api.coinbase.com/v2/prices/BTC-${ticker.toUpperCase()}/buy`)) as CoinbaseResponse;
      const rate = Number(json?.data?.amount);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('Coinbase', ticker, error);
      return undefined as never;
    }
  },

  CoinDesk: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(
        `https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=${ticker.toUpperCase()}`,
      )) as CoinDeskResponse;
      const rate = json?.[ticker.toUpperCase()];
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('CoinDesk', ticker, error);
      return undefined as never;
    }
  },

  CoinGecko: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(
        `https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=${ticker.toLowerCase()}`,
      )) as CoinGeckoResponse;
      const rate = Number(json?.bitcoin?.[ticker.toLowerCase()]);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('CoinGecko', ticker, error);
      return undefined as never;
    }
  },

  Bitstamp: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(`https://www.bitstamp.net/api/v2/ticker/btc${ticker.toLowerCase()}`)) as BitstampResponse;
      const rate = Number(json?.last);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('Bitstamp', ticker, error);
      return undefined as never;
    }
  },

  Kraken: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(`https://api.kraken.com/0/public/Ticker?pair=XXBTZ${ticker.toUpperCase()}`)) as KrakenResponse;
      const rate = Number(json?.result?.[`XXBTZ${ticker.toUpperCase()}`]?.c?.[0]);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('Kraken', ticker, error);
      return undefined as never;
    }
  },

  BNR: async (): Promise<number> => {
    try {
      // Fetching USD to RON rate

      const xmlData = await (await fetch('https://www.bnr.ro/nbrfxrates.xml')).text();
      const matches = xmlData.match(/<Rate currency="USD">([\d.]+)<\/Rate>/);
      if (matches && matches[1]) {
        const usdToRonRate = parseFloat(matches[1]);
        const btcToUsdRate = await RateExtractors.CoinGecko('USD');
        // Convert BTC to RON using the USD to RON exchange rate
        return btcToUsdRate * usdToRonRate;
      }
      throw new Error('No valid USD to RON rate found');
    } catch (error: any) {
      handleError('BNR', 'RON', error);
      return undefined as never;
    }
  },

  Yadio: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(`https://api.yadio.io/json/${ticker}`)) as YadioResponse;
      const rate = Number(json?.[ticker]?.price);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('Yadio', ticker, error);
      return undefined as never;
    }
  },

  YadioConvert: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate(`https://api.yadio.io/convert/1/BTC/${ticker}`)) as YadioConvertResponse;
      const rate = Number(json?.rate);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('YadioConvert', ticker, error);
      return undefined as never;
    }
  },

  Exir: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate('https://api.exir.io/v1/ticker?symbol=btc-irt')) as ExirResponse;
      const rate = Number(json?.last);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('Exir', ticker, error);
      return undefined as never;
    }
  },

  coinpaprika: async (ticker: string): Promise<number> => {
    try {
      const json = (await fetchRate('https://api.coinpaprika.com/v1/tickers/btc-bitcoin?quotes=INR')) as CoinpaprikaResponse;
      const rate = Number(json?.quotes?.INR?.price);
      if (!(rate >= 0)) throw new Error('Invalid data received');
      return rate;
    } catch (error: any) {
      handleError('coinpaprika', ticker, error);
      return undefined as never;
    }
  },
} as const;

export type TFiatUnit = {
  endPointKey: string;
  symbol: string;
  locale: string;
  country: string;
  source: 'Coinbase' | 'CoinDesk' | 'Yadio' | 'Exir' | 'coinpaprika' | 'Bitstamp' | 'Kraken';
};

export type TFiatUnits = {
  [key: string]: TFiatUnit;
};

export const FiatUnit = untypedFiatUnit as TFiatUnits;

export type FiatUnitType = {
  endPointKey: string;
  symbol: string;
  locale: string;
  country: string;
  source: keyof typeof FiatUnitSource;
};

export async function getFiatRate(ticker: string): Promise<number> {
  return await RateExtractors[FiatUnit[ticker].source](ticker);
}


================================================
FILE: ./models/bitcoinUnits.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export const BitcoinUnit = {
  BTC: 'BTC',
  SATS: 'sats',
  ETH: 'ETH',
  SOL: 'SOL',
  LOCAL_CURRENCY: 'local_currency',
  MAX: 'MAX',
} as const;
export type BitcoinUnit = (typeof BitcoinUnit)[keyof typeof BitcoinUnit];

export const Chain = {
  ONCHAIN: 'ONCHAIN',
  OFFCHAIN: 'OFFCHAIN',
} as const;
export type Chain = (typeof Chain)[keyof typeof Chain];


================================================
FILE: ./util/expo-fetch-nodejs.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// Node.js polyfill for expo/fetch
// Minimal "expo/fetch" polyfill for Node.js using http/https modules
// - Streaming via Response.body.getReader() and async iteration (for SSE)
// - AbortController support
// - credentials ('include' / 'same-origin') support
// - Robust header normalization (Headers, arrays, Map, plain object)
// - ESM + CJS interop (default + named exports)
// - Throws only real Error instances

const http = require('http');
const https = require('https');
const { URL } = require('url');

class AbortError extends Error {
  constructor(message = 'Aborted') {
    super(message);
    this.name = 'AbortError';
  }
}

class SimpleHeaders {
  constructor(init) {
    this._map = new Map();
    if (!init) return;
    if (typeof init === 'string') {
      init.split(/\r?\n/).forEach(line => {
        const i = line.indexOf(':');
        if (i > 0) {
          const k = line.slice(0, i).trim();
          const v = line.slice(i + 1).trim();
          if (k) this._map.set(k.toLowerCase(), v);
        }
      });
    } else if (typeof init === 'object' && init !== null) {
      if (typeof init.forEach === 'function' && typeof init.entries === 'function') {
        // WHATWG Headers-like
        for (const [k, v] of init.entries()) this._map.set(String(k).toLowerCase(), String(v));
      } else if (Array.isArray(init)) {
        for (const [k, v] of init) this._map.set(String(k).toLowerCase(), String(v));
      } else if (init instanceof Map) {
        for (const [k, v] of init) this._map.set(String(k).toLowerCase(), String(v));
      } else {
        for (const [k, v] of Object.entries(init)) this._map.set(String(k).toLowerCase(), String(v));
      }
    }
  }

  get(name) {
    return this._map.get(String(name).toLowerCase()) ?? null;
  }

  has(name) {
    return this._map.has(String(name).toLowerCase());
  }

  forEach(cb) {
    for (const [k, v] of this._map) cb(v, k);
  }

  entries() {
    return this._map.entries();
  }

  set(name, value) {
    this._map.set(String(name).toLowerCase(), String(value));
  }

  delete(name) {
    this._map.delete(String(name).toLowerCase());
  }

  keys() {
    return this._map.keys();
  }

  values() {
    return this._map.values();
  }

  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  }
}

class StreamController {
  constructor() {
    this._q = [];
    this._pending = null;
    this._closed = false;
    this._err = null;
  }

  push(bytes) {
    if (this._closed || this._err) return;
    if (this._pending) {
      const r = this._pending;
      this._pending = null;
      r({ value: bytes, done: false });
    } else this._q.push(bytes);
  }

  close() {
    if (this._closed || this._err) return;
    this._closed = true;
    if (this._pending) {
      const r = this._pending;
      this._pending = null;
      r({ done: true });
    }
  }

  error(e) {
    if (this._closed || this._err) return;
    this._err = e instanceof Error ? e : new Error(String(e));
    if (this._pending) {
      const r = this._pending;
      this._pending = null;
      r({ done: true });
    }
  }

  getReader() {
    return {
      read: () => {
        if (this._err) return Promise.reject(this._err);
        if (this._q.length) return Promise.resolve({ value: this._q.shift(), done: false });
        if (this._closed) return Promise.resolve({ done: true });
        return new Promise(resolve => {
          this._pending = resolve;
        });
      },
      cancel: () => {
        this._q.length = 0;
        this.close();
        return Promise.resolve();
      },
    };
  }

  [Symbol.asyncIterator]() {
    const reader = this.getReader();
    return {
      next: () => reader.read(),
      return: () => reader.cancel().then(() => ({ done: true, value: undefined })),
      throw: e => {
        this.error(e);
        return Promise.resolve({ done: true, value: undefined });
      },
    };
  }
}

class SimpleResponse {
  constructor({ url, status, statusText, headers, body }) {
    this.url = url;
    this.status = status;
    this.statusText = statusText || '';
    this.ok = status >= 200 && status < 300;
    this.headers = headers;
    this.body = body;
    this._text = null;
    this._buf = null;
  }

  async arrayBuffer() {
    if (this._buf) return this._buf.buffer;
    const chunks = [];
    for await (const c of this.body) chunks.push(c);
    const total = chunks.reduce((s, c) => s + c.byteLength, 0);
    const out = new Uint8Array(total);
    let off = 0;
    for (const c of chunks) {
      out.set(c, off);
      off += c.byteLength;
    }
    this._buf = out;
    return out.buffer;
  }

  async text() {
    if (this._text != null) return this._text;
    const dec = new TextDecoder();
    let t = '';
    for await (const c of this.body) t += dec.decode(c, { stream: true });
    t += dec.decode();
    this._text = t;
    return t;
  }

  json() {
    return this.text().then(JSON.parse);
  }
}

function normalizeHeaders(h) {
  const out = {};
  if (!h) return out;
  if (typeof h === 'object' && h !== null) {
    if (typeof h.forEach === 'function' && typeof h.entries === 'function') {
      for (const [k, v] of h.entries()) out[k] = String(v);
    } else if (Array.isArray(h)) {
      for (const [k, v] of h) out[k] = String(v);
    } else if (h instanceof Map) {
      for (const [k, v] of h) out[k] = String(v);
    } else {
      for (const [k, v] of Object.entries(h)) out[k] = String(v);
    }
  }
  return out;
}

function fetchShim(input, init = {}) {
  return new Promise((resolve, reject) => {
    const url = typeof input === 'string' ? input : input?.toString?.();
    if (!url) {
      reject(new Error('Invalid request URL'));
      return;
    }

    let parsedUrl;
    try {
      parsedUrl = new URL(url);
    } catch (e) {
      reject(new Error(`Invalid URL: ${url}`));
      return;
    }

    const method = (init.method || 'GET').toUpperCase();
    const headers = normalizeHeaders(init.headers);
    const body = init.body ?? null;

    // Choose http or https module
    const client = parsedUrl.protocol === 'https:' ? https : http;

    const controller = new StreamController();
    let resolved = false;
    let req;

    const options = {
      method,
      hostname: parsedUrl.hostname,
      port: parsedUrl.port,
      path: parsedUrl.pathname + parsedUrl.search,
      headers,
    };

    // credentials support
    if (init.credentials === 'include' || init.credentials === 'same-origin') {
      // In Node.js, this would typically mean including cookies
      // For most SSE use cases, this is handled by the Cookie header
      // If needed, you can add agent configuration here
    }

    req = client.request(options, res => {
      // Build response headers
      const responseHeaders = new SimpleHeaders(res.headers);

      // Resolve with response immediately (like XHR readyState 2)
      const response = new SimpleResponse({
        url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: responseHeaders,
        body: controller,
      });

      resolve(response);
      resolved = true;

      // Stream response data
      res.on('data', chunk => {
        // Convert Buffer to Uint8Array
        const uint8 = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        controller.push(uint8);
      });

      res.on('end', () => {
        controller.close();
      });

      res.on('error', err => {
        const error = err instanceof Error ? err : new Error(String(err));
        controller.error(error);
      });
    });

    req.on('error', err => {
      const error = err instanceof Error ? err : new Error(String(err));
      controller.error(error);
      if (!resolved) reject(error);
    });

    // AbortController support
    if (init.signal) {
      if (init.signal.aborted) {
        req.destroy();
        const err = new AbortError();
        controller.error(err);
        if (!resolved) reject(err);
        return;
      } else {
        init.signal.addEventListener(
          'abort',
          () => {
            req.destroy();
            const err = new AbortError();
            controller.error(err);
            if (!resolved) reject(err);
          },
          { once: true },
        );
      }
    }

    // Send body
    try {
      if (body == null) {
        req.end();
      } else if (typeof body === 'string') {
        req.end(body);
      } else if (Buffer.isBuffer(body)) {
        req.end(body);
      } else if (body instanceof Uint8Array || ArrayBuffer.isView(body)) {
        req.end(Buffer.from(body.buffer, body.byteOffset, body.byteLength));
      } else if (body instanceof ArrayBuffer) {
        req.end(Buffer.from(body));
      } else {
        // Fallback: JSON
        const jsonBody = JSON.stringify(body);
        if (!headers['content-type']) {
          req.setHeader('Content-Type', 'application/json');
        }
        req.end(jsonBody);
      }
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      controller.error(err);
      if (!resolved) reject(err);
    }
  });
}

// ---- ESM exports
module.exports = fetchShim;
module.exports.default = fetchShim;
module.exports.fetch = fetchShim;
module.exports.Headers = SimpleHeaders;
module.exports.Response = SimpleResponse;
module.exports.AbortError = AbortError;



================================================
FILE: ./util/fetch.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const DEFAULT_TIMEOUT = 20_000; // default timeout in ms

// protection against calling itself recursively
const nativeFetch = globalThis.fetch.bind(globalThis);

export function fetch(input: RequestInfo | URL, init: RequestInit & { timeout?: number } = {}): Promise<Response> {
  if (__DEV__) {
    console.log('fetch wrapper: ', input, init);
  }
  const { timeout = DEFAULT_TIMEOUT, ...rest } = init;
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeout);
  return nativeFetch(input, { ...rest, signal: controller.signal }).finally(() => clearTimeout(timer));
}


================================================
FILE: ./util/expo-fetch.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// shim for expo-fetch
// vibe-coded with ChatGPT-5
//
// Minimal "expo/fetch" polyfill for bare React Native using XMLHttpRequest.
// - Streaming via Response.body.getReader() and async iteration
// - AbortController support
// - credentials ('include' / 'same-origin') via xhr.withCredentials
// - Robust header normalization (Headers, arrays, Map, plain object)
// - ESM + CJS interop (default + named exports)
// - Throws only real Error instances (Hermes-safe)

class AbortError extends Error {
  constructor(message = 'Aborted') {
    super(message);
    this.name = 'AbortError';
  }
}

class SimpleHeaders {
  constructor(init) {
    this._map = new Map();
    if (!init) return;
    if (typeof init === 'string') {
      init.split(/\r?\n/).forEach(line => {
        const i = line.indexOf(':');
        if (i > 0) {
          const k = line.slice(0, i).trim();
          const v = line.slice(i + 1).trim();
          if (k) this._map.set(k.toLowerCase(), v);
        }
      });
    } else if (typeof init.forEach === 'function' && typeof init.entries === 'function') {
      // WHATWG Headers-like
      for (const [k, v] of init.entries()) this._map.set(String(k).toLowerCase(), String(v));
    } else if (Array.isArray(init)) {
      for (const [k, v] of init) this._map.set(String(k).toLowerCase(), String(v));
    } else if (init instanceof Map) {
      for (const [k, v] of init) this._map.set(String(k).toLowerCase(), String(v));
    } else if (typeof init === 'object') {
      for (const [k, v] of Object.entries(init)) this._map.set(String(k).toLowerCase(), String(v));
    }
  }

  get(name) {
    return this._map.get(String(name).toLowerCase()) ?? null;
  }

  has(name) {
    return this._map.has(String(name).toLowerCase());
  }

  forEach(cb) {
    for (const [k, v] of this._map) cb(v, k);
  }

  entries() {
    return this._map.entries();
  }
}

class StreamController {
  constructor() {
    this._q = [];
    this._pending = null;
    this._closed = false;
    this._err = null;
  }

  push(bytes) {
    if (this._closed || this._err) return;
    if (this._pending) {
      const r = this._pending;
      this._pending = null;
      r({ value: bytes, done: false });
    } else this._q.push(bytes);
  }

  close() {
    if (this._closed || this._err) return;
    this._closed = true;
    if (this._pending) {
      const r = this._pending;
      this._pending = null;
      r({ done: true });
    }
  }

  error(e) {
    if (this._closed || this._err) return;
    this._err = e instanceof Error ? e : new Error(String(e));
    if (this._pending) {
      const r = this._pending;
      this._pending = null;
      r({ done: true });
    }
  }

  getReader() {
    return {
      read: () => {
        if (this._err) return Promise.reject(this._err);
        if (this._q.length) return Promise.resolve({ value: this._q.shift(), done: false });
        if (this._closed) return Promise.resolve({ done: true });
        return new Promise(resolve => {
          this._pending = resolve;
        });
      },
      cancel: () => {
        this._q.length = 0;
        this.close();
        return Promise.resolve();
      },
    };
  }

  [Symbol.asyncIterator]() {
    const reader = this.getReader();
    return {
      next: () => reader.read(),
      return: () => reader.cancel().then(() => ({ done: true, value: undefined })),
      throw: e => {
        this.error(e);
        return Promise.resolve({ done: true, value: undefined });
      },
    };
  }
}

class SimpleResponse {
  constructor({ url, status, headers, body }) {
    this.url = url;
    this.status = status;
    this.ok = status >= 200 && status < 300;
    this.headers = headers;
    this.body = body;
    this._text = null;
    this._buf = null;
  }

  async arrayBuffer() {
    if (this._buf) return this._buf.buffer;
    const chunks = [];
    for await (const c of this.body) chunks.push(c);
    const total = chunks.reduce((s, c) => s + c.byteLength, 0);
    const out = new Uint8Array(total);
    let off = 0;
    for (const c of chunks) {
      out.set(c, off);
      off += c.byteLength;
    }
    this._buf = out;
    return out.buffer;
  }

  async text() {
    if (this._text != null) return this._text;
    const dec = new TextDecoder();
    let t = '';
    for await (const c of this.body) t += dec.decode(c, { stream: true });
    t += dec.decode();
    this._text = t;
    return t;
  }

  json() {
    return this.text().then(JSON.parse);
  }
}

const _enc = new TextEncoder();

function normalizeHeaders(h) {
  const out = {};
  if (!h) return out;
  if (typeof h.forEach === 'function' && typeof h.entries === 'function') {
    for (const [k, v] of h.entries()) out[k] = String(v);
  } else if (Array.isArray(h)) {
    for (const [k, v] of h) out[k] = String(v);
  } else if (h instanceof Map) {
    for (const [k, v] of h) out[k] = String(v);
  } else if (typeof h === 'object') {
    for (const [k, v] of Object.entries(h)) out[k] = String(v);
  }
  return out;
}

function fetchShim(input, init = {}) {
  return new Promise((resolve, reject) => {
    const url = typeof input === 'string' ? input : input?.toString?.();
    if (!url) {
      reject(new Error('Invalid request URL'));
      return;
    }
    const method = (init.method || 'GET').toUpperCase();
    const headers = normalizeHeaders(init.headers);
    const body = init.body ?? null;

    const xhr = new XMLHttpRequest();
    xhr.open(method, url, true);
    xhr.responseType = 'text';

    // credentials support
    if (init.credentials === 'include' || init.credentials === 'same-origin') {
      try {
        xhr.withCredentials = true;
      } catch {}
    }

    for (const [k, v] of Object.entries(headers)) {
      try {
        xhr.setRequestHeader(k, v);
      } catch {}
    }

    let lastLen = 0;
    const controller = new StreamController();
    let resolved = false;

    const finalize = () => {
      if (resolved) return;
      const raw = xhr.getAllResponseHeaders?.() || '';
      const h = new SimpleHeaders(raw);
      resolve(new SimpleResponse({ url, status: xhr.status || 0, headers: h, body: controller }));
      resolved = true;
    };

    const pump = () => {
      const text = xhr.responseText ?? '';
      if (text.length > lastLen) {
        const chunk = text.slice(lastLen);
        lastLen = text.length;
        controller.push(_enc.encode(chunk));
      }
    };

    xhr.onreadystatechange = () => {
      if (xhr.readyState === 2) finalize();
      if (xhr.readyState === 3) pump();
      if (xhr.readyState === 4) {
        pump();
        controller.close();
      }
    };
    xhr.onprogress = pump;

    xhr.onerror = () => {
      const err = new Error(`Network error (${xhr.status || 0})`);
      controller.error(err);
      if (!resolved) reject(err);
    };

    xhr.onabort = () => {
      const err = new AbortError();
      controller.error(err);
      if (!resolved) reject(err);
    };

    if (init.signal) {
      if (init.signal.aborted) {
        try {
          xhr.abort();
        } catch {}
      } else
        init.signal.addEventListener(
          'abort',
          () => {
            try {
              xhr.abort();
            } catch {}
          },
          { once: true },
        );
    }

    try {
      if (body == null) {
        xhr.send();
      } else if (typeof body === 'string') {
        xhr.send(body);
      } else if (typeof body === 'object' && ('byteLength' in body || ArrayBuffer.isView(body))) {
        // ArrayBuffer or TypedArray
        xhr.send(body);
      } else {
        // Fallback: JSON
        try {
          xhr.setRequestHeader('Content-Type', 'application/json');
        } catch {}
        xhr.send(JSON.stringify(body));
      }
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      controller.error(err);
      if (!resolved) reject(err);
    }
  });
}

// ---- ESM exports
export default fetchShim;
export { fetchShim as fetch, SimpleHeaders as Headers, SimpleResponse as Response };

// ---- CJS interop (some deps use require('expo/fetch'), others expect .default or named)
try {
  Object.defineProperty(exports, '__esModule', { value: true });
  module.exports = fetchShim;
  module.exports.default = fetchShim;
  module.exports.fetch = fetchShim;
  module.exports.Headers = SimpleHeaders;
  module.exports.Response = SimpleResponse;
} catch {}


================================================
FILE: ./components/SquareEnumeratedWords.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

import { useTheme } from './themes';

type ContentAlignType = 'flex-start' | 'center' | 'flex-end';
export const SquareEnumeratedWordsContentAlign: Record<string, ContentAlignType> = Object.freeze({
  left: 'flex-start',
  center: 'center',
  right: 'flex-end',
});

interface SquareEnumeratedWordsProps {
  entries: string[];
  appendNumber: boolean;
  contentAlign: ContentAlignType;
}

const SquareEnumeratedWords: React.FC<SquareEnumeratedWordsProps> = ({ entries, appendNumber, contentAlign }) => {
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    entryTextContainer: {
      backgroundColor: colors.inputBackgroundColor,
    },
    entryText: {
      color: colors.labelText,
    },
    container: {
      justifyContent: contentAlign,
    },
  });

  const renderSecret = () => {
    const component = [];
    const entriesObject = entries.entries();
    for (const [index, secret] of entriesObject) {
      if (entries.length > 1) {
        const text = appendNumber ? `${index + 1}. ${secret}  ` : `${secret}  `;
        component.push(
          <View style={[styles.entryTextContainer, stylesHook.entryTextContainer]} key={`${secret}${index}`}>
            <Text textBreakStrategy="simple" style={[styles.entryText, stylesHook.entryText]}>
              {text}
            </Text>
          </View>,
        );
      } else {
        component.push(
          <TouchableOpacity
            accessibilityRole="button"
            style={[styles.entryTextContainer, stylesHook.entryTextContainer]}
            key={`${secret}${index}`}
          >
            <Text textBreakStrategy="simple" style={[styles.entryText, stylesHook.entryText]}>
              {secret}
            </Text>
          </TouchableOpacity>,
        );
      }
    }
    return component;
  };

  return <View style={[styles.container, stylesHook.container]}>{renderSecret()}</View>;
};

const styles = StyleSheet.create({
  entryTextContainer: {
    marginRight: 8,
    marginBottom: 8,
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 8,
    paddingRight: 8,
    borderRadius: 4,
  },
  entryText: {
    fontWeight: 'bold',
    textAlign: 'left',
  },
  container: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
});

export default SquareEnumeratedWords;


================================================
FILE: ./components/navigationStyle.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import React from 'react';
import { Image, Keyboard, Platform, StyleSheet, TouchableOpacity } from 'react-native';

import loc from '../loc';
import { Theme } from './themes';

const styles = StyleSheet.create({
  button: {
    minWidth: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonFormSheet: {
    justifyContent: 'center',
    alignItems: 'center',
    width: 30,
    height: 30,
    borderRadius: 15,
    marginLeft: 22,
  },
});

enum CloseButtonPosition {
  None = 'None',
  Left = 'Left',
  Right = 'Right',
}

type OptionsFormatter = (
  options: NativeStackNavigationOptions,
  deps: { theme: Theme; navigation: any; route: any },
) => NativeStackNavigationOptions;

export type NavigationOptionsGetter = (theme: Theme) => (deps: { navigation: any; route: any }) => NativeStackNavigationOptions;

const getCloseButtonPosition = (
  closeButtonPosition: CloseButtonPosition | undefined,
  isFirstRouteInStack: boolean,
  isModal: boolean,
): CloseButtonPosition => {
  if (closeButtonPosition !== undefined) {
    return closeButtonPosition;
  }
  if (isFirstRouteInStack && isModal) {
    return CloseButtonPosition.Right;
  }
  return CloseButtonPosition.None;
};

const getHandleCloseAction = (
  onCloseButtonPressed: ((args: { navigation: any; route: any }) => void) | undefined,
  navigation: any,
  route: any,
) => {
  if (onCloseButtonPressed) {
    return () => onCloseButtonPressed({ navigation, route });
  }
  return () => {
    Keyboard.dismiss();
    navigation.goBack(null);
  };
};

const navigationStyle = (
  {
    closeButtonPosition,
    onCloseButtonPressed,
    ...opts
  }: NativeStackNavigationOptions & {
    closeButtonPosition?: CloseButtonPosition;
    onCloseButtonPressed?: (deps: { navigation: any; route: any }) => void;
  },
  formatter?: OptionsFormatter,
): NavigationOptionsGetter => {
  return theme =>
    ({ navigation, route }) => {
      const isFirstRouteInStack = navigation.getState().index === 0;
      const isModal = route.params?.presentation === 'modal' || route.params?.presentation === 'transparentModal';
      const isFormSheet = route.params?.presentation === 'formSheet';

      const closeButton = getCloseButtonPosition(closeButtonPosition, isFirstRouteInStack, isModal);
      const handleClose = getHandleCloseAction(onCloseButtonPressed, navigation, route);

      let headerRight;
      let headerLeft;

      if (closeButton === CloseButtonPosition.Right) {
        headerRight = () => (
          <TouchableOpacity
            accessibilityRole="button"
            accessibilityLabel={loc._.close}
            style={isFormSheet ? [styles.buttonFormSheet, { backgroundColor: theme.colors.lightButton }] : styles.button}
            onPress={handleClose}
            testID="NavigationCloseButton"
          >
            <Image source={theme.closeImage} />
          </TouchableOpacity>
        );
      } else if (closeButton === CloseButtonPosition.Left) {
        headerLeft = () => (
          <TouchableOpacity
            accessibilityRole="button"
            accessibilityLabel={loc._.close}
            style={isFormSheet ? [styles.buttonFormSheet, { backgroundColor: theme.colors.lightButton }] : styles.button}
            onPress={handleClose}
            testID="NavigationCloseButton"
          >
            <Image source={theme.closeImage} />
          </TouchableOpacity>
        );
      }
      const baseHeaderStyle = {
        headerShadowVisible: false,
        headerTitleStyle: {
          fontWeight: '600' as const,
          color: theme.colors.foregroundColor,
        },
        headerTintColor: theme.colors.foregroundColor,
        headerBackButtonDisplayMode: 'minimal',
      };
      const isLeftCloseButtonAndroid = closeButton === CloseButtonPosition.Left && Platform.OS === 'android';

      const leftCloseButtonStyle = isLeftCloseButtonAndroid ? { headerBackImageSource: theme.closeImage } : { headerLeft };

      let options: NativeStackNavigationOptions = {
        ...baseHeaderStyle,
        ...leftCloseButtonStyle,
        headerBackButtonDisplayMode: 'minimal',
        headerRight,
        ...opts,
      };

      if (formatter) {
        options = formatter(options, { theme, navigation, route });
      }

      return options;
    };
};

export default navigationStyle;
export { CloseButtonPosition };


================================================
FILE: ./components/SegmentControl.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo } from 'react';
import { requireNativeComponent, View, StyleSheet, NativeSyntheticEvent } from 'react-native';

interface SegmentedControlProps {
  values: string[];
  selectedIndex: number;
  onChange: (index: number) => void;
}

interface SegmentedControlEvent {
  selectedIndex: number;
}

interface NativeSegmentedControlProps {
  values: string[];
  selectedIndex: number;
  onChangeEvent: (event: NativeSyntheticEvent<SegmentedControlEvent>) => void;
  style?: object;
}

const NativeSegmentedControl = requireNativeComponent<NativeSegmentedControlProps>('CustomSegmentedControl');

const SegmentedControl: React.FC<SegmentedControlProps> = ({ values, selectedIndex, onChange }) => {
  const handleChange = useMemo(
    () => (event: NativeSyntheticEvent<SegmentedControlEvent>) => {
      if (event?.nativeEvent?.selectedIndex !== undefined) {
        onChange(event.nativeEvent.selectedIndex);
      }
    },
    [onChange],
  );

  if (!Array.isArray(values) || values.length === 0) {
    return null;
  }

  return (
    <View style={styles.container}>
      <NativeSegmentedControl values={values} selectedIndex={selectedIndex} style={styles.segmentedControl} onChangeEvent={handleChange} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    marginHorizontal: 18,
    marginBottom: 18,
    minHeight: 40,
  },
  segmentedControl: {
    height: 40,
  },
});

export default SegmentedControl;


================================================
FILE: ./components/SecondButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef } from 'react';
import { StyleSheet, Text, TouchableOpacity, View, ActivityIndicator } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from './themes';

type IconProps = {
  name: string;
  type: string;
  color: string;
};

type SecondButtonProps = {
  backgroundColor?: string;
  disabled?: boolean;
  icon?: IconProps;
  title?: string;
  onPress?: () => void;
  loading?: boolean;
  testID?: string;
};

export const SecondButton = forwardRef<React.ElementRef<typeof TouchableOpacity>, SecondButtonProps>((props, ref) => {
  const { colors } = useTheme();
  let backgroundColor = props.backgroundColor ? props.backgroundColor : colors.buttonGrayBackgroundColor;
  let fontColor = colors.secondButtonTextColor;
  if (props.disabled === true) {
    backgroundColor = colors.buttonDisabledBackgroundColor;
    fontColor = colors.buttonDisabledTextColor;
  }

  const buttonView = props.loading ? (
    <ActivityIndicator size="small" color={colors.buttonTextColor} />
  ) : (
    <View style={styles.view}>
      {props.icon && <Icon name={props.icon.name} type={props.icon.type} color={props.icon.color} />}
      {props.title && <Text style={[styles.text, { color: fontColor }]}>{props.title}</Text>}
    </View>
  );

  return props.onPress ? (
    <TouchableOpacity
      disabled={props.disabled || props.loading}
      accessibilityRole="button"
      testID={props.testID}
      style={[styles.button, { backgroundColor }]}
      {...props}
      ref={ref}
    >
      {buttonView}
    </TouchableOpacity>
  ) : (
    <View style={[styles.button, { backgroundColor }]}>{buttonView}</View>
  );
});

const styles = StyleSheet.create({
  button: {
    minHeight: 45,
    height: 48,
    maxHeight: 48,
    borderRadius: 7,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 16,
    flexGrow: 1,
  },
  content: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginHorizontal: 8,
    fontSize: 16,
    fontWeight: '600',
  },
  view: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
});


================================================
FILE: ./components/WalletButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { ColorValue, DimensionValue, Image, ImageSourcePropType, StyleSheet, Text, Pressable, View } from 'react-native';
import { useLocale } from '@react-navigation/native';

import loc from '../loc';
import { Theme, useTheme } from './themes';

interface ButtonDetails {
  image: ImageSourcePropType;
  title: string;
  explain: string;
  borderColorActive: keyof Theme['colors'];
}

interface WalletButtonProps {
  buttonType: keyof typeof buttonDetails;
  testID?: string;
  onPress: () => void;
  size: {
    width: DimensionValue | undefined;
    height: DimensionValue | undefined;
  };
  active: boolean;
}

const buttonDetails: Record<string, ButtonDetails> = {
  Bitcoin: {
    image: require('../img/addWallet/bitcoin.png'),
    title: loc.wallets.add_bitcoin,
    explain: loc.wallets.add_bitcoin_explain,
    borderColorActive: 'newMalin',
  },
  Vault: {
    image: require('../img/addWallet/vault.png'),
    title: loc.multisig.multisig_vault,
    explain: loc.multisig.multisig_vault_explain,
    borderColorActive: 'foregroundColor',
  },
  Lightning: {
    image: require('../img/addWallet/lightning.png'),
    title: loc.wallets.add_lightning,
    explain: loc.wallets.add_lightning_explain,
    borderColorActive: 'lnborderColor',
  },
  LightningArk: {
    image: require('../img/addWallet/lightning.png'),
    title: loc.wallets.add_lightning,
    explain: loc.wallets.add_lightning_explain + '\nPowered by Arkade',
    borderColorActive: 'lnborderColor',
  },
};

const WalletButton: React.FC<WalletButtonProps> = ({ buttonType, testID, onPress, size, active }) => {
  const details = buttonDetails[buttonType];
  const { colors } = useTheme();
  const { direction } = useLocale();
  const borderColor = active ? colors[details.borderColorActive] : colors.buttonDisabledBackgroundColor;
  const stylesHook = StyleSheet.create({
    buttonContainer: {
      borderColor: borderColor as ColorValue,
      backgroundColor: colors.buttonDisabledBackgroundColor,
      minWidth: size.width,
      minHeight: size.height,
      height: size.height,
    },
    textTitle: {
      color: colors[details.borderColorActive] as ColorValue,
      fontWeight: 'bold',
      fontSize: 18,
      writingDirection: direction,
    },
    textExplain: {
      color: colors.alternativeTextColor,
      fontSize: 13,
      fontWeight: '500',
      writingDirection: direction,
    },
  });

  return (
    <Pressable
      accessibilityRole="button"
      testID={testID}
      onPress={onPress}
      style={({ pressed }) => [pressed && styles.pressed, styles.touchable]}
    >
      <View style={[styles.container, stylesHook.buttonContainer]}>
        <View style={styles.content}>
          <Image style={styles.image} source={details.image} />
          <View style={styles.textContainer}>
            <Text style={stylesHook.textTitle}>{details.title}</Text>
            <Text style={stylesHook.textExplain}>{details.explain}</Text>
          </View>
        </View>
      </View>
    </Pressable>
  );
};

const styles = StyleSheet.create({
  touchable: {
    flex: 1,
    marginBottom: 8,
  },
  container: {
    borderWidth: 1.5,
    borderRadius: 8,
  },
  content: {
    marginHorizontal: 16,
    marginVertical: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  image: {
    width: 34,
    height: 34,
    marginRight: 8,
  },
  textContainer: {
    flex: 1,
  },
  pressed: {
    opacity: 0.6,
  },
});

export default WalletButton;


================================================
FILE: ./components/Context/StorageProvider.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { createContext, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { InteractionManager, LayoutAnimation } from 'react-native';
import { MalinApp as MalinAppClass, LegacyWallet, TCounterpartyMetadata, TTXMetadata, WatchOnlyWallet } from '../../class';
import type { TWallet } from '../../class/wallets/types';
import presentAlert from '../../components/Alert';
import loc, { formatBalanceWithoutSuffix } from '../../loc';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import { startAndDecrypt } from '../../malin_modules/start-and-decrypt';
import { isNotificationsEnabled, majorTomToGroundControl, unsubscribe } from '../../malin_modules/notifications';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { navigationRef } from '../../NavigationService';

const MalinApp = MalinAppClass.getInstance();

// hashmap of timestamps we _started_ refetching some wallet
const _lastTimeTriedToRefetchWallet: { [walletID: string]: number } = {};

interface StorageContextType {
  wallets: TWallet[];
  setWalletsWithNewOrder: (wallets: TWallet[]) => void;
  txMetadata: TTXMetadata;
  counterpartyMetadata: TCounterpartyMetadata;
  saveToDisk: (force?: boolean) => Promise<void>;
  selectedWalletID: () => string | undefined; // Change from string|undefined to a function
  addWallet: (wallet: TWallet) => void;
  deleteWallet: (wallet: TWallet) => void;
  currentSharedCosigner: string;
  setSharedCosigner: (cosigner: string) => void;
  addAndSaveWallet: (wallet: TWallet) => Promise<void>;
  fetchAndSaveWalletTransactions: (walletID: string) => Promise<void>;
  walletsInitialized: boolean;
  setWalletsInitialized: (initialized: boolean) => void;
  refreshAllWalletTransactions: (lastSnappedTo?: number, showUpdateStatusIndicator?: boolean) => Promise<void>;
  resetWallets: () => void;
  walletTransactionUpdateStatus: WalletTransactionsStatus | string;
  setWalletTransactionUpdateStatus: (status: WalletTransactionsStatus | string) => void;
  getTransactions: typeof MalinApp.getTransactions;
  fetchWalletBalances: typeof MalinApp.fetchWalletBalances;
  fetchWalletTransactions: typeof MalinApp.fetchWalletTransactions;
  getBalance: typeof MalinApp.getBalance;
  isStorageEncrypted: typeof MalinApp.storageIsEncrypted;
  startAndDecrypt: typeof startAndDecrypt;
  encryptStorage: typeof MalinApp.encryptStorage;
  sleep: typeof MalinApp.sleep;
  createFakeStorage: typeof MalinApp.createFakeStorage;
  decryptStorage: typeof MalinApp.decryptStorage;
  isPasswordInUse: typeof MalinApp.isPasswordInUse;
  cachedPassword: typeof MalinApp.cachedPassword;
  getItem: typeof MalinApp.getItem;
  setItem: typeof MalinApp.setItem;
  handleWalletDeletion: (walletID: string, forceDelete?: boolean) => Promise<boolean>;
  confirmWalletDeletion: (wallet: any, onConfirmed: () => void) => void;
}

export enum WalletTransactionsStatus {
  NONE = 'NONE',
  ALL = 'ALL',
}

// @ts-ignore default value does not match the type
export const StorageContext = createContext<StorageContextType>(undefined);

export const StorageProvider = ({ children }: { children: React.ReactNode }) => {
  const txMetadata = useRef<TTXMetadata>(MalinApp.tx_metadata);
  const counterpartyMetadata = useRef<TCounterpartyMetadata>(MalinApp.counterparty_metadata || {}); // init

  const [wallets, setWallets] = useState<TWallet[]>([]);
  const [walletTransactionUpdateStatus, setWalletTransactionUpdateStatus] = useState<WalletTransactionsStatus | string>(
    WalletTransactionsStatus.NONE,
  );
  const [walletsInitialized, setWalletsInitialized] = useState<boolean>(false);
  const [currentSharedCosigner, setCurrentSharedCosigner] = useState<string>('');

  const selectedWalletID = useCallback((): string | undefined => {
    if (!navigationRef.current || !navigationRef.current.isReady()) return undefined;

    const screensToCheck = ['LNDCreateInvoice', 'SendDetails', 'WalletTransactions', 'TransactionStatus'];

    const currentRoute = navigationRef.current.getCurrentRoute();
    console.debug('[StorageProvider] Current route:', currentRoute?.name);

    if (currentRoute) {
      if (screensToCheck.includes(currentRoute.name) && currentRoute.params) {
        const params = currentRoute.params as { walletID?: string };
        if (params.walletID) {
          console.debug('[StorageProvider] selectedWalletID from current route:', params.walletID);
          return params.walletID;
        }
      }
    }

    const state = navigationRef.current.getState();

    if (state?.routes) {
      for (const screenName of screensToCheck) {
        const walletID = findWalletIDInNavigationState(state.routes, screenName);
        if (walletID) {
          console.debug('[StorageProvider] selectedWalletID from navigation state:', walletID, 'in screen:', screenName);
          return walletID;
        }
      }

      const drawerRoute = state.routes.find(route => route.name === 'DrawerRoot');
      if (drawerRoute?.state?.routes) {
        const detailViewStack = drawerRoute.state.routes.find(route => route.name === 'DetailViewStackScreensStack');
        if (detailViewStack?.state?.routes) {
          for (const route of detailViewStack.state.routes) {
            if (screensToCheck.includes(route.name) && (route.params as { walletID?: string })?.walletID) {
              console.debug(
                '[StorageProvider] selectedWalletID from drawer navigation:',
                (route.params as { walletID?: string })?.walletID,
              );
              return (route.params as { walletID?: string })?.walletID;
            }
          }
        }
      }
    }

    return undefined;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const findWalletIDInNavigationState = (routes: any[], screenName: string): string | undefined => {
    for (let i = routes.length - 1; i >= 0; i--) {
      const route = routes[i];

      if (route.name === screenName && (route.params as { walletID?: string }).walletID) {
        return (route.params as { walletID?: string }).walletID;
      }

      if (route.state?.routes) {
        const walletID = findWalletIDInNavigationState(route.state.routes, screenName);
        if (walletID) return walletID;
      }

      if (route.params?.screen === screenName && route.params?.params?.walletID) {
        return route.params.params.walletID;
      }

      if (route.name === 'DetailViewStackScreensStack' && route.params?.screen === screenName && route.params?.params?.walletID) {
        return route.params.params.walletID;
      }
    }

    return undefined;
  };

  const saveToDisk = useCallback(
    async (force: boolean = false) => {
      if (!force && MalinApp.getWallets().length === 0) {
        console.debug('Not saving empty wallets array');
        return;
      }
      await InteractionManager.runAfterInteractions(async () => {
        MalinApp.tx_metadata = txMetadata.current;
        MalinApp.counterparty_metadata = counterpartyMetadata.current;
        await MalinApp.saveToDisk();
        const w: TWallet[] = [...MalinApp.getWallets()];
        setWallets(w);
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [txMetadata.current, counterpartyMetadata.current],
  );

  const addWallet = useCallback((wallet: TWallet) => {
    MalinApp.wallets.push(wallet);
    setWallets([...MalinApp.getWallets()]);
  }, []);

  const deleteWallet = useCallback((wallet: TWallet) => {
    MalinApp.deleteWallet(wallet);
    setWallets([...MalinApp.getWallets()]);
  }, []);

  const handleWalletDeletion = useCallback(
    async (walletID: string, forceDelete = false): Promise<boolean> => {
      console.debug(`handleWalletDeletion: invoked for walletID ${walletID}`);
      const wallet = wallets.find(w => w.getID() === walletID);
      if (!wallet) {
        console.warn(`handleWalletDeletion: wallet not found for ${walletID}`);
        return false;
      }

      if (forceDelete) {
        deleteWallet(wallet);
        await saveToDisk(true);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        return true;
      }

      let isNotificationsSettingsEnabled = false;
      try {
        isNotificationsSettingsEnabled = await isNotificationsEnabled();
      } catch (error) {
        console.error(`handleWalletDeletion: error checking notifications for wallet ${walletID}`, error);
        return await new Promise<boolean>(resolve => {
          presentAlert({
            title: loc.errors.error,
            message: loc.wallets.details_delete_wallet_error_message,
            buttons: [
              {
                text: loc.wallets.details_delete_anyway,
                onPress: async () => {
                  const result = await handleWalletDeletion(walletID, true);
                  resolve(result);
                },
                style: 'destructive',
              },
              {
                text: loc.wallets.list_tryagain,
                onPress: async () => {
                  const result = await handleWalletDeletion(walletID);
                  resolve(result);
                },
              },
              {
                text: loc._.cancel,
                onPress: () => resolve(false),
                style: 'cancel',
              },
            ],
            options: { cancelable: false },
          });
        });
      }

      try {
        if (isNotificationsSettingsEnabled) {
          const externalAddresses = wallet.getAllExternalAddresses();
          if (externalAddresses.length > 0) {
            console.debug(`handleWalletDeletion: unsubscribing addresses for wallet ${walletID}`);
            try {
              await unsubscribe(externalAddresses, [], []);
              console.debug(`handleWalletDeletion: unsubscribe succeeded for wallet ${walletID}`);
            } catch (unsubscribeError) {
              console.error(`handleWalletDeletion: unsubscribe failed for wallet ${walletID}`, unsubscribeError);
              presentAlert({
                title: loc.errors.error,
                message: loc.wallets.details_delete_wallet_error_message,
                buttons: [{ text: loc._.ok, onPress: () => {} }],
                options: { cancelable: false },
              });
              return false;
            }
          }
        }
        deleteWallet(wallet);
        console.debug(`handleWalletDeletion: wallet ${walletID} deleted successfully`);
        await saveToDisk(true);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        return true;
      } catch (e: unknown) {
        console.error(`handleWalletDeletion: encountered error for wallet ${walletID}`, e);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        return await new Promise<boolean>(resolve => {
          presentAlert({
            title: loc.errors.error,
            message: loc.wallets.details_delete_wallet_error_message,
            buttons: [
              {
                text: loc.wallets.details_delete_anyway,
                onPress: async () => {
                  const result = await handleWalletDeletion(walletID, true);
                  resolve(result);
                },
                style: 'destructive',
              },
              {
                text: loc.wallets.list_tryagain,
                onPress: async () => {
                  const result = await handleWalletDeletion(walletID);
                  resolve(result);
                },
              },
              {
                text: loc._.cancel,
                onPress: () => resolve(false),
                style: 'cancel',
              },
            ],
            options: { cancelable: false },
          });
        });
      }
    },
    [deleteWallet, saveToDisk, wallets],
  );

  const resetWallets = useCallback(() => {
    setWallets(MalinApp.getWallets());
  }, []);

  const setWalletsWithNewOrder = useCallback(
    (wlts: TWallet[]) => {
      MalinApp.wallets = wlts;
      saveToDisk();
    },
    [saveToDisk],
  );

  // Initialize wallets
  useEffect(() => {
    if (walletsInitialized) {
      txMetadata.current = MalinApp.tx_metadata;
      counterpartyMetadata.current = MalinApp.counterparty_metadata;
      setWallets(MalinApp.getWallets());
    }
  }, [walletsInitialized]);

  // Add a refresh lock to prevent concurrent refreshes
  const refreshingRef = useRef<boolean>(false);

  const refreshAllWalletTransactions = useCallback(
    async (lastSnappedTo?: number, showUpdateStatusIndicator: boolean = true) => {
      if (refreshingRef.current) {
        console.debug('[refreshAllWalletTransactions] Refresh already in progress');
        return;
      }
      console.debug('[refreshAllWalletTransactions] Starting refresh');
      refreshingRef.current = true;

      await new Promise<void>(resolve => InteractionManager.runAfterInteractions(() => resolve()));

      const TIMEOUT_DURATION = 30000;
      let refreshTimeout;
      const timeoutPromise = new Promise<never>(
        (_resolve, reject) =>
          (refreshTimeout = setTimeout(() => {
            console.debug('[refreshAllWalletTransactions] Timeout reached');
            reject(new Error('Timeout reached'));
          }, TIMEOUT_DURATION)),
      );

      try {
        if (showUpdateStatusIndicator) {
          console.debug('[refreshAllWalletTransactions] Setting wallet transaction status to ALL');
          setWalletTransactionUpdateStatus(WalletTransactionsStatus.ALL);
        }
        console.debug('[refreshAllWalletTransactions] Waiting for connectivity...');
        await MalinElectrum.waitTillConnected();
        if (!(await MalinElectrum.ping())) {
          // above `waitTillConnected` is not reliable, as app might have returned from long sleep, so it thinks its
          // connected but actually socket is closed. thus, we ping, and if it fails - we wait again (reconnection code
          // should pick up)
          console.log('[refreshAllWalletTransactions] ping failed, waiting for connection...');
          await MalinElectrum.waitTillConnected();
        }

        console.debug('[refreshAllWalletTransactions] Connected to Electrum');

        // Restore fetch payment codes timing measurement
        if (typeof MalinApp.fetchSenderPaymentCodes === 'function') {
          const codesStart = Date.now();
          console.debug('[refreshAllWalletTransactions] Fetching sender payment codes');
          await MalinApp.fetchSenderPaymentCodes(lastSnappedTo);
          const codesEnd = Date.now();
          console.debug('[refreshAllWalletTransactions] fetch payment codes took', (codesEnd - codesStart) / 1000, 'sec');
        } else {
          console.warn('[refreshAllWalletTransactions] fetchSenderPaymentCodes is not available');
        }

        console.debug('[refreshAllWalletTransactions] Fetching wallet balances and transactions');
        await Promise.race([
          (async () => {
            const balanceStart = Date.now();
            await MalinApp.fetchWalletBalances(lastSnappedTo);
            const balanceEnd = Date.now();
            console.debug('[refreshAllWalletTransactions] fetch balance took', (balanceEnd - balanceStart) / 1000, 'sec');

            const txStart = Date.now();
            await MalinApp.fetchWalletTransactions(lastSnappedTo);
            const txEnd = Date.now();
            console.debug('[refreshAllWalletTransactions] fetch tx took', (txEnd - txStart) / 1000, 'sec');

            clearTimeout(refreshTimeout);

            console.debug('[refreshAllWalletTransactions] Saving data to disk');
            await saveToDisk();
          })(),
          timeoutPromise,
        ]);
        console.debug('[refreshAllWalletTransactions] Refresh completed successfully');
      } catch (error) {
        console.error('[refreshAllWalletTransactions] Error:', error);
      } finally {
        console.debug('[refreshAllWalletTransactions] Resetting wallet transaction status and refresh lock');
        setWalletTransactionUpdateStatus(WalletTransactionsStatus.NONE);
        refreshingRef.current = false;
      }
    },
    [saveToDisk],
  );

  const fetchAndSaveWalletTransactions = useCallback(
    async (walletID: string) => {
      await InteractionManager.runAfterInteractions(async () => {
        const index = wallets.findIndex(wallet => wallet.getID() === walletID);
        let noErr = true;
        try {
          if (Date.now() - (_lastTimeTriedToRefetchWallet[walletID] || 0) < 5000) {
            console.debug('[fetchAndSaveWalletTransactions] Re-fetch wallet happens too fast; NOP');
            return;
          }
          _lastTimeTriedToRefetchWallet[walletID] = Date.now();

          await MalinElectrum.waitTillConnected();
          setWalletTransactionUpdateStatus(walletID);

          const balanceStart = Date.now();
          await MalinApp.fetchWalletBalances(index);
          const balanceEnd = Date.now();
          console.debug('[fetchAndSaveWalletTransactions] fetch balance took', (balanceEnd - balanceStart) / 1000, 'sec');

          const txStart = Date.now();
          await MalinApp.fetchWalletTransactions(index);
          const txEnd = Date.now();
          console.debug('[fetchAndSaveWalletTransactions] fetch tx took', (txEnd - txStart) / 1000, 'sec');
        } catch (err) {
          noErr = false;
          console.error('[fetchAndSaveWalletTransactions] Error:', err);
        } finally {
          setWalletTransactionUpdateStatus(WalletTransactionsStatus.NONE);
        }
        if (noErr) await saveToDisk();
      });
    },
    [saveToDisk, wallets],
  );

  const addAndSaveWallet = useCallback(
    async (w: TWallet) => {
      if (wallets.some(i => i.getID() === w.getID())) {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: 'This wallet has been previously imported.' });
        return;
      }
      const emptyWalletLabel = new LegacyWallet().getLabel();
      if (w.getLabel() === emptyWalletLabel) w.setLabel(loc.wallets.import_imported + ' ' + w.typeReadable);
      w.setUserHasSavedExport(true);
      addWallet(w);
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      await saveToDisk();

      presentAlert({
        hapticFeedback: HapticFeedbackTypes.ImpactHeavy,
        message: w.type === WatchOnlyWallet.type ? loc.wallets.import_success_watchonly : loc.wallets.import_success,
      });

      await w.fetchBalance();
      try {
        await majorTomToGroundControl(w.getAllExternalAddresses(), [], []);
      } catch (error) {
        console.warn('Failed to setup notifications:', error);
        // Consider if user should be notified of notification setup failure
      }
    },
    [wallets, addWallet, saveToDisk],
  );

  function confirmWalletDeletion(wallet: any, onConfirmed: () => void) {
    triggerHapticFeedback(HapticFeedbackTypes.NotificationWarning);
    try {
      const balance = formatBalanceWithoutSuffix(wallet.getBalance(), BitcoinUnit.SATS, true);
      presentAlert({
        title: loc.wallets.details_delete_wallet,
        message: loc.formatString(loc.wallets.details_del_wb_q, { balance }),
        buttons: [
          {
            text: loc.wallets.details_delete,
            onPress: () => {
              triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
              LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
              onConfirmed();
            },
            style: 'destructive',
          },
          {
            text: loc._.cancel,
            onPress: () => {},
            style: 'cancel',
          },
        ],
        options: { cancelable: false },
      });
    } catch (error) {
      // Handle error silently if needed
    }
  }

  const value: StorageContextType = useMemo(
    () => ({
      wallets,
      setWalletsWithNewOrder,
      txMetadata: txMetadata.current,
      counterpartyMetadata: counterpartyMetadata.current,
      saveToDisk,
      getTransactions: MalinApp.getTransactions,
      selectedWalletID,
      addWallet,
      deleteWallet,
      currentSharedCosigner,
      setSharedCosigner: setCurrentSharedCosigner,
      addAndSaveWallet,
      setItem: MalinApp.setItem,
      getItem: MalinApp.getItem,
      fetchWalletBalances: MalinApp.fetchWalletBalances,
      fetchWalletTransactions: MalinApp.fetchWalletTransactions,
      fetchAndSaveWalletTransactions,
      isStorageEncrypted: MalinApp.storageIsEncrypted,
      encryptStorage: MalinApp.encryptStorage,
      startAndDecrypt,
      cachedPassword: MalinApp.cachedPassword,
      getBalance: MalinApp.getBalance,
      walletsInitialized,
      setWalletsInitialized,
      refreshAllWalletTransactions,
      sleep: MalinApp.sleep,
      createFakeStorage: MalinApp.createFakeStorage,
      resetWallets,
      decryptStorage: MalinApp.decryptStorage,
      isPasswordInUse: MalinApp.isPasswordInUse,
      walletTransactionUpdateStatus,
      setWalletTransactionUpdateStatus,
      handleWalletDeletion,
      confirmWalletDeletion,
    }),
    [
      wallets,
      setWalletsWithNewOrder,
      saveToDisk,
      selectedWalletID,
      addWallet,
      deleteWallet,
      currentSharedCosigner,
      addAndSaveWallet,
      fetchAndSaveWalletTransactions,
      walletsInitialized,
      setWalletsInitialized,
      refreshAllWalletTransactions,
      resetWallets,
      walletTransactionUpdateStatus,
      handleWalletDeletion,
    ],
  );

  return <StorageContext.Provider value={value}>{children}</StorageContext.Provider>;
};


================================================
FILE: ./components/Context/SizeClassProvider.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { createContext, ReactNode, useEffect, useMemo, useState } from 'react';
import { Dimensions, Platform, useWindowDimensions } from 'react-native';
import { isDesktop, isTablet } from '../../malin_modules/environment';
import useAppState from '../../hooks/useAppState';

export enum SizeClass {
  Compact,
  Regular,
  Large,
}

interface ISizeClassContext {
  sizeClass: SizeClass;
  horizontalSizeClass: SizeClass;
  verticalSizeClass: SizeClass;
  orientation: 'portrait' | 'landscape';
}

const useSizeClassDetection = () => {
  const dimensions = useWindowDimensions();
  const [horizontalSizeClass, setHorizontalSizeClass] = useState<SizeClass>(SizeClass.Regular);
  const [verticalSizeClass, setVerticalSizeClass] = useState<SizeClass>(SizeClass.Regular);
  const [orientation, setOrientation] = useState<'portrait' | 'landscape'>(dimensions.width < dimensions.height ? 'portrait' : 'landscape');

  const determineSize = () => {
    const { width, height } = Dimensions.get('window');
    const isLandscape = width > height;
    setOrientation(isLandscape ? 'landscape' : 'portrait');

    if (isDesktop) {
      setHorizontalSizeClass(SizeClass.Large);
      setVerticalSizeClass(SizeClass.Large);
      return;
    }

    if (Platform.OS === 'ios' && Platform.isPad) {
      setHorizontalSizeClass(SizeClass.Regular);
      setVerticalSizeClass(SizeClass.Regular);
      return;
    }

    if (isTablet) {
      setHorizontalSizeClass(SizeClass.Regular);
      setVerticalSizeClass(SizeClass.Regular);
      return;
    }

    const aspectRatio = isLandscape ? width / height : height / width;
    const screenArea = width * height;

    if (isLandscape) {
      setHorizontalSizeClass(aspectRatio >= 1.6 || screenArea >= 250000 ? SizeClass.Regular : SizeClass.Compact);
      setVerticalSizeClass(SizeClass.Compact);
    } else {
      setHorizontalSizeClass(SizeClass.Compact);
      setVerticalSizeClass(SizeClass.Regular);
    }
  };

  useEffect(() => {
    const handleDimensionChange = () => {
      determineSize();
    };

    const dimensionSubscription = Dimensions.addEventListener('change', handleDimensionChange);

    determineSize();

    return () => {
      dimensionSubscription.remove();
    };
  }, []);

  const { currentAppState } = useAppState();
  useEffect(() => {
    if (currentAppState === 'active') {
      determineSize();
    }
  }, [currentAppState]);

  const sizeClass = useMemo(() => {
    if (
      (horizontalSizeClass === SizeClass.Large || verticalSizeClass === SizeClass.Large) &&
      horizontalSizeClass !== SizeClass.Compact &&
      verticalSizeClass !== SizeClass.Compact
    ) {
      return SizeClass.Large;
    }

    if (horizontalSizeClass === SizeClass.Compact || verticalSizeClass === SizeClass.Compact) {
      return SizeClass.Compact;
    }

    return SizeClass.Regular;
  }, [horizontalSizeClass, verticalSizeClass]);

  useEffect(() => {
    console.debug(
      `[SizeClass] Size classes updated:`,
      `horizontal=${SizeClass[horizontalSizeClass]}`,
      `vertical=${SizeClass[verticalSizeClass]}`,
      `overall=${SizeClass[sizeClass]}`,
      `orientation=${orientation}`,
    );
  }, [horizontalSizeClass, verticalSizeClass, sizeClass, orientation]);

  return {
    sizeClass,
    horizontalSizeClass,
    verticalSizeClass,
    orientation,
  };
};

type SizeClassProviderProps = {
  children: ReactNode;
};

export const SizeClassContext = createContext<ISizeClassContext>({
  sizeClass: SizeClass.Regular,
  horizontalSizeClass: SizeClass.Regular,
  verticalSizeClass: SizeClass.Regular,
  orientation: 'portrait',
});

export const SizeClassProvider: React.FC<SizeClassProviderProps> = ({ children }) => {
  const { sizeClass, horizontalSizeClass, verticalSizeClass, orientation } = useSizeClassDetection();

  const contextValue = useMemo(
    () => ({
      sizeClass,
      horizontalSizeClass,
      verticalSizeClass,
      orientation,
    }),
    [sizeClass, horizontalSizeClass, verticalSizeClass, orientation],
  );

  return <SizeClassContext.Provider value={contextValue}>{children}</SizeClassContext.Provider>;
};


================================================
FILE: ./components/Context/SettingsProvider.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { createContext, useCallback, useEffect, useMemo, useState } from 'react';
import DefaultPreference from 'react-native-default-preference';
import { isReadClipboardAllowed, setReadClipboardAllowed } from '../../malin_modules/clipboard';
import { getPreferredCurrency, GROUP_IO_MALINWALLET, initCurrencyDaemon, setPreferredCurrency } from '../../malin_modules/currency';
import { clearUseURv1, isURv1Enabled, setUseURv1 } from '../../malin_modules/ur';
import { MalinApp } from '../../class';
import { saveLanguage, STORAGE_KEY } from '../../loc';
import { FiatUnit, TFiatUnit } from '../../models/fiatUnit';
import {
  getEnabled as getIsDeviceQuickActionsEnabled,
  setEnabled as setIsDeviceQuickActionsEnabled,
} from '../../hooks/useDeviceQuickActions';
import { getIsHandOffUseEnabled, setIsHandOffUseEnabled } from '../HandOffComponent';
import { useStorage } from '../../hooks/context/useStorage';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import { TotalWalletsBalanceKey, TotalWalletsBalancePreferredUnit } from '../TotalWalletsBalance';
import { BLOCK_EXPLORERS, getBlockExplorerUrl, saveBlockExplorer, BlockExplorer, normalizeUrl } from '../../models/blockExplorer';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { isBalanceDisplayAllowed, setBalanceDisplayAllowed } from '../../hooks/useWidgetCommunication';
import AsyncStorage from '@react-native-async-storage/async-storage';

const getDoNotTrackStorage = async (): Promise<boolean> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const doNotTrack = await DefaultPreference.get(MalinApp.DO_NOT_TRACK);
    return doNotTrack === '1';
  } catch {
    console.error('Error getting DoNotTrack');
    return false;
  }
};

export const setTotalBalanceViewEnabledStorage = async (value: boolean): Promise<void> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    await DefaultPreference.set(TotalWalletsBalanceKey, value ? 'true' : 'false');
    console.debug('setTotalBalanceViewEnabledStorage value:', value);
  } catch (e) {
    console.error('Error setting TotalBalanceViewEnabled:', e);
  }
};

export const getIsTotalBalanceViewEnabled = async (): Promise<boolean> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const isEnabledValue = (await DefaultPreference.get(TotalWalletsBalanceKey)) ?? 'true';
    console.debug('getIsTotalBalanceViewEnabled', isEnabledValue);
    return isEnabledValue === 'true';
  } catch (e) {
    console.error('Error getting TotalBalanceViewEnabled:', e);
    return true;
  }
};

export const setTotalBalancePreferredUnitStorageFunc = async (unit: BitcoinUnit): Promise<void> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    await DefaultPreference.set(TotalWalletsBalancePreferredUnit, unit);
  } catch (e) {
    console.error('Error setting TotalBalancePreferredUnit:', e);
  }
};

export const getTotalBalancePreferredUnit = async (): Promise<BitcoinUnit> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const unit = (await DefaultPreference.get(TotalWalletsBalancePreferredUnit)) as BitcoinUnit | null;
    return unit ?? BitcoinUnit.BTC;
  } catch (e) {
    console.error('Error getting TotalBalancePreferredUnit:', e);
    return BitcoinUnit.BTC;
  }
};

interface SettingsContextType {
  preferredFiatCurrency: TFiatUnit;
  setPreferredFiatCurrencyStorage: (currency: TFiatUnit) => Promise<void>;
  language: string;
  setLanguageStorage: (language: string) => Promise<void>;
  isHandOffUseEnabled: boolean;
  setIsHandOffUseEnabledAsyncStorage: (value: boolean) => Promise<void>;
  isPrivacyBlurEnabled: boolean;
  setIsPrivacyBlurEnabled: (value: boolean) => void;
  isDoNotTrackEnabled: boolean;
  setDoNotTrackStorage: (value: boolean) => Promise<void>;
  isWidgetBalanceDisplayAllowed: boolean;
  setIsWidgetBalanceDisplayAllowedStorage: (value: boolean) => Promise<void>;
  isLegacyURv1Enabled: boolean;
  setIsLegacyURv1EnabledStorage: (value: boolean) => Promise<void>;
  isClipboardGetContentEnabled: boolean;
  setIsClipboardGetContentEnabledStorage: (value: boolean) => Promise<void>;
  isQuickActionsEnabled: boolean;
  setIsQuickActionsEnabledStorage: (value: boolean) => Promise<void>;
  isTotalBalanceEnabled: boolean;
  setIsTotalBalanceEnabledStorage: (value: boolean) => Promise<void>;
  totalBalancePreferredUnit: BitcoinUnit;
  setTotalBalancePreferredUnitStorage: (unit: BitcoinUnit) => Promise<void>;
  selectedBlockExplorer: BlockExplorer;
  setBlockExplorerStorage: (explorer: BlockExplorer) => Promise<boolean>;
  isElectrumDisabled: boolean;
  setIsElectrumDisabled: (value: boolean) => void;
}

const defaultSettingsContext: SettingsContextType = {
  preferredFiatCurrency: FiatUnit.USD,
  setPreferredFiatCurrencyStorage: async () => {},
  language: 'en',
  setLanguageStorage: async () => {},
  isHandOffUseEnabled: false,
  setIsHandOffUseEnabledAsyncStorage: async () => {},
  isPrivacyBlurEnabled: true,
  setIsPrivacyBlurEnabled: () => {},
  isDoNotTrackEnabled: false,
  setDoNotTrackStorage: async () => {},
  isWidgetBalanceDisplayAllowed: true,
  setIsWidgetBalanceDisplayAllowedStorage: async () => {},
  isLegacyURv1Enabled: false,
  setIsLegacyURv1EnabledStorage: async () => {},
  isClipboardGetContentEnabled: true,
  setIsClipboardGetContentEnabledStorage: async () => {},
  isQuickActionsEnabled: true,
  setIsQuickActionsEnabledStorage: async () => {},
  isTotalBalanceEnabled: true,
  setIsTotalBalanceEnabledStorage: async () => {},
  totalBalancePreferredUnit: BitcoinUnit.BTC,
  setTotalBalancePreferredUnitStorage: async () => {},
  selectedBlockExplorer: BLOCK_EXPLORERS.default,
  setBlockExplorerStorage: async () => false,
  isElectrumDisabled: false,
  setIsElectrumDisabled: () => {},
};

export const SettingsContext = createContext<SettingsContextType>(defaultSettingsContext);

export const SettingsProvider: React.FC<{ children: React.ReactNode }> = React.memo(({ children }: { children: React.ReactNode }) => {
  const [preferredFiatCurrency, setPreferredFiatCurrencyState] = useState<TFiatUnit>(FiatUnit.USD);
  const [language, setLanguage] = useState<string>('en');
  const [isHandOffUseEnabled, setIsHandOffUseEnabledState] = useState<boolean>(false);
  const [isPrivacyBlurEnabled, setIsPrivacyBlurEnabled] = useState<boolean>(true);
  const [isDoNotTrackEnabled, setIsDoNotTrackEnabled] = useState<boolean>(false);
  const [isWidgetBalanceDisplayAllowed, setIsWidgetBalanceDisplayAllowed] = useState<boolean>(true);
  const [isLegacyURv1Enabled, setIsLegacyURv1Enabled] = useState<boolean>(false);
  const [isClipboardGetContentEnabled, setIsClipboardGetContentEnabled] = useState<boolean>(true);
  const [isQuickActionsEnabled, setIsQuickActionsEnabled] = useState<boolean>(true);
  const [isTotalBalanceEnabled, setIsTotalBalanceEnabled] = useState<boolean>(true);
  const [totalBalancePreferredUnit, setTotalBalancePreferredUnit] = useState<BitcoinUnit>(BitcoinUnit.BTC);
  const [selectedBlockExplorer, setSelectedBlockExplorer] = useState<BlockExplorer>(BLOCK_EXPLORERS.default);
  const [isElectrumDisabled, setIsElectrumDisabled] = useState<boolean>(true);

  const { walletsInitialized } = useStorage();

  useEffect(() => {
    const loadSettings = async () => {
      try {
        await DefaultPreference.setName(GROUP_IO_MALINWALLET);
      } catch (e) {
        console.error('Error setting preference name:', e);
      }

      const promises: Promise<void>[] = [
        MalinElectrum.isDisabled().then(disabled => {
          setIsElectrumDisabled(disabled);
        }),
        getIsHandOffUseEnabled().then(handOff => {
          setIsHandOffUseEnabledState(handOff);
        }),
        AsyncStorage.getItem(STORAGE_KEY).then(lang => {
          setLanguage(lang ?? 'en');
        }),
        isBalanceDisplayAllowed().then(balanceDisplayAllowed => {
          setIsWidgetBalanceDisplayAllowed(balanceDisplayAllowed);
        }),
        isURv1Enabled().then(urv1Enabled => {
          setIsLegacyURv1Enabled(urv1Enabled);
        }),
        isReadClipboardAllowed().then(clipboardEnabled => {
          setIsClipboardGetContentEnabled(clipboardEnabled);
        }),
        getIsDeviceQuickActionsEnabled().then(quickActionsEnabled => {
          setIsQuickActionsEnabled(quickActionsEnabled);
        }),
        getDoNotTrackStorage().then(doNotTrack => {
          setIsDoNotTrackEnabled(doNotTrack);
        }),
        getIsTotalBalanceViewEnabled().then(totalBalanceEnabled => {
          setIsTotalBalanceEnabled(totalBalanceEnabled);
        }),
        getTotalBalancePreferredUnit().then(preferredUnit => {
          setTotalBalancePreferredUnit(preferredUnit);
        }),
        getBlockExplorerUrl().then(url => {
          const predefinedExplorer = Object.values(BLOCK_EXPLORERS).find(explorer => normalizeUrl(explorer.url) === normalizeUrl(url));
          setSelectedBlockExplorer(predefinedExplorer ?? ({ key: 'custom', name: 'Custom', url } as BlockExplorer));
        }),
      ];

      const results = await Promise.allSettled(promises);

      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          console.error(`Error loading setting ${index}:`, result.reason);
        }
      });
    };

    loadSettings();
  }, []);

  useEffect(() => {
    initCurrencyDaemon()
      .then(getPreferredCurrency)
      .then(currency => {
        console.debug('SettingsContext currency:', currency);
        setPreferredFiatCurrencyState(currency as TFiatUnit);
      })
      .catch(e => {
        console.error('Error initializing currency daemon or getting preferred currency:', e);
      });
  }, []);

  useEffect(() => {
    if (walletsInitialized) {
      isElectrumDisabled ? MalinElectrum.forceDisconnect() : MalinElectrum.connectMain();
    }
  }, [isElectrumDisabled, walletsInitialized]);

  const setPreferredFiatCurrencyStorage = useCallback(async (currency: TFiatUnit): Promise<void> => {
    try {
      await setPreferredCurrency(currency);
      setPreferredFiatCurrencyState(currency);
    } catch (e) {
      console.error('Error setting preferredFiatCurrency:', e);
    }
  }, []);

  const setLanguageStorage = useCallback(async (newLanguage: string): Promise<void> => {
    try {
      await saveLanguage(newLanguage);
      setLanguage(newLanguage);
    } catch (e) {
      console.error('Error setting language:', e);
    }
  }, []);

  const setDoNotTrackStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      await DefaultPreference.setName(GROUP_IO_MALINWALLET);
      if (value) {
        await DefaultPreference.set(MalinApp.DO_NOT_TRACK, '1');
      } else {
        await DefaultPreference.clear(MalinApp.DO_NOT_TRACK);
      }
      setIsDoNotTrackEnabled(value);
    } catch (e) {
      console.error('Error setting DoNotTrack:', e);
    }
  }, []);

  const setIsHandOffUseEnabledAsyncStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      console.debug('setIsHandOffUseEnabledAsyncStorage', value);
      await setIsHandOffUseEnabled(value);
      setIsHandOffUseEnabledState(value);
    } catch (e) {
      console.error('Error setting isHandOffUseEnabled:', e);
    }
  }, []);

  const setIsWidgetBalanceDisplayAllowedStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      await setBalanceDisplayAllowed(value);
      setIsWidgetBalanceDisplayAllowed(value);
    } catch (e) {
      console.error('Error setting isWidgetBalanceDisplayAllowed:', e);
    }
  }, []);

  const setIsLegacyURv1EnabledStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      if (value) {
        await setUseURv1();
      } else {
        await clearUseURv1();
      }
      setIsLegacyURv1Enabled(value);
    } catch (e) {
      console.error('Error setting isLegacyURv1Enabled:', e);
    }
  }, []);

  const setIsClipboardGetContentEnabledStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      await setReadClipboardAllowed(value);
      setIsClipboardGetContentEnabled(value);
    } catch (e) {
      console.error('Error setting isClipboardGetContentEnabled:', e);
    }
  }, []);

  const setIsQuickActionsEnabledStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      await setIsDeviceQuickActionsEnabled(value);
      setIsQuickActionsEnabled(value);
    } catch (e) {
      console.error('Error setting isQuickActionsEnabled:', e);
    }
  }, []);
  const setIsTotalBalanceEnabledStorage = useCallback(async (value: boolean): Promise<void> => {
    try {
      await setTotalBalanceViewEnabledStorage(value);
      setIsTotalBalanceEnabled(value);
    } catch (e) {
      console.error('Error setting isTotalBalanceEnabled:', e);
    }
  }, []);

  const setTotalBalancePreferredUnitStorage = useCallback(async (unit: BitcoinUnit): Promise<void> => {
    try {
      await setTotalBalancePreferredUnitStorageFunc(unit);
      setTotalBalancePreferredUnit(unit);
    } catch (e) {
      console.error('Error setting totalBalancePreferredUnit:', e);
    }
  }, []);

  const setBlockExplorerStorage = useCallback(async (explorer: BlockExplorer): Promise<boolean> => {
    try {
      const success = await saveBlockExplorer(explorer.url);
      if (success) {
        setSelectedBlockExplorer(explorer);
      }
      return success;
    } catch (e) {
      console.error('Error setting BlockExplorer:', e);
      return false;
    }
  }, []);

  const value = useMemo(
    () => ({
      preferredFiatCurrency,
      setPreferredFiatCurrencyStorage,
      language,
      setLanguageStorage,
      isHandOffUseEnabled,
      setIsHandOffUseEnabledAsyncStorage,
      isPrivacyBlurEnabled,
      setIsPrivacyBlurEnabled,
      isDoNotTrackEnabled,
      setDoNotTrackStorage,
      isWidgetBalanceDisplayAllowed,
      setIsWidgetBalanceDisplayAllowedStorage,
      isLegacyURv1Enabled,
      setIsLegacyURv1EnabledStorage,
      isClipboardGetContentEnabled,
      setIsClipboardGetContentEnabledStorage,
      isQuickActionsEnabled,
      setIsQuickActionsEnabledStorage,
      isTotalBalanceEnabled,
      setIsTotalBalanceEnabledStorage,
      totalBalancePreferredUnit,
      setTotalBalancePreferredUnitStorage,
      selectedBlockExplorer,
      setBlockExplorerStorage,
      isElectrumDisabled,
      setIsElectrumDisabled,
    }),
    [
      preferredFiatCurrency,
      setPreferredFiatCurrencyStorage,
      language,
      setLanguageStorage,
      isHandOffUseEnabled,
      setIsHandOffUseEnabledAsyncStorage,
      isPrivacyBlurEnabled,
      setIsPrivacyBlurEnabled,
      isDoNotTrackEnabled,
      setDoNotTrackStorage,
      isWidgetBalanceDisplayAllowed,
      setIsWidgetBalanceDisplayAllowedStorage,
      isLegacyURv1Enabled,
      setIsLegacyURv1EnabledStorage,
      isClipboardGetContentEnabled,
      setIsClipboardGetContentEnabledStorage,
      isQuickActionsEnabled,
      setIsQuickActionsEnabledStorage,
      isTotalBalanceEnabled,
      setIsTotalBalanceEnabledStorage,
      totalBalancePreferredUnit,
      setTotalBalancePreferredUnitStorage,
      selectedBlockExplorer,
      setBlockExplorerStorage,
      isElectrumDisabled,
    ],
  );

  return <SettingsContext.Provider value={value}>{children}</SettingsContext.Provider>;
});


================================================
FILE: ./components/TransactionPendingIconBig.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from './themes';

export const TransactionPendingIconBig: React.FC = () => {
  const { colors } = useTheme();

  const hookStyles = StyleSheet.create({
    ball: {
      backgroundColor: colors.buttonBackgroundColor,
    },
  });

  return (
    <View>
      <View style={styles.boxIncoming}>
        <View style={[styles.ball, hookStyles.ball]}>
          <Icon name="more-horiz" type="material" size={100} color={colors.foregroundColor} iconStyle={styles.iconStyle} />
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  },
  ball: {
    width: 150,
    height: 150,
    borderRadius: 75,
  },
  iconStyle: {
    left: 0,
    top: 25,
  },
});


================================================
FILE: ./components/TotalWalletsBalance.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo, useCallback } from 'react';
import { TouchableOpacity, Text, StyleSheet, LayoutAnimation, View } from 'react-native';
import { useStorage } from '../hooks/context/useStorage';
import loc, { formatBalanceWithoutSuffix } from '../loc';
import { BitcoinUnit } from '../models/bitcoinUnits';
import ToolTipMenu from './TooltipMenu';
import { CommonToolTipActions } from '../typings/CommonToolTipActions';
import { useSettings } from '../hooks/context/useSettings';
import Clipboard from '@react-native-clipboard/clipboard';
import { useTheme } from './themes';

export const TotalWalletsBalancePreferredUnit = 'TotalWalletsBalancePreferredUnit';
export const TotalWalletsBalanceKey = 'TotalWalletsBalance';

const TotalWalletsBalance: React.FC = React.memo(() => {
  const { wallets } = useStorage();
  const {
    preferredFiatCurrency,
    isTotalBalanceEnabled,
    setIsTotalBalanceEnabledStorage,
    totalBalancePreferredUnit,
    setTotalBalancePreferredUnitStorage,
  } = useSettings();
  const { colors } = useTheme();

  const totalBalanceFormatted = useMemo(() => {
    const totalBalance = wallets.reduce((prev, curr) => {
      return curr.hideBalance ? prev : prev + (curr.getBalance() || 0);
    }, 0);
    return formatBalanceWithoutSuffix(totalBalance, totalBalancePreferredUnit, true);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [wallets, totalBalancePreferredUnit, preferredFiatCurrency]);

  const toolTipActions = useMemo(
    () => [
      {
        id: 'viewInActions',
        text: '',
        displayInline: true,
        subactions: [
          {
            ...CommonToolTipActions.ViewInFiat,
            text: loc.formatString(loc.total_balance_view.display_in_fiat, { currency: preferredFiatCurrency.endPointKey }),
            hidden: totalBalancePreferredUnit === BitcoinUnit.LOCAL_CURRENCY,
          },
          { ...CommonToolTipActions.ViewInSats, hidden: totalBalancePreferredUnit === BitcoinUnit.SATS },
          { ...CommonToolTipActions.ViewInBitcoin, hidden: totalBalancePreferredUnit === BitcoinUnit.BTC },
        ],
      },
      CommonToolTipActions.CopyAmount,
      CommonToolTipActions.Hide,
    ],
    [preferredFiatCurrency, totalBalancePreferredUnit],
  );

  const onPressMenuItem = useCallback(
    async (id: string) => {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      switch (id) {
        case CommonToolTipActions.ViewInFiat.id:
          await setTotalBalancePreferredUnitStorage(BitcoinUnit.LOCAL_CURRENCY);
          break;
        case CommonToolTipActions.ViewInSats.id:
          await setTotalBalancePreferredUnitStorage(BitcoinUnit.SATS);
          break;
        case CommonToolTipActions.ViewInBitcoin.id:
          await setTotalBalancePreferredUnitStorage(BitcoinUnit.BTC);
          break;
        case CommonToolTipActions.Hide.id:
          await setIsTotalBalanceEnabledStorage(false);
          break;
        case CommonToolTipActions.CopyAmount.id:
          Clipboard.setString(totalBalanceFormatted.toString());
          break;
        default:
          break;
      }
    },
    [setIsTotalBalanceEnabledStorage, totalBalanceFormatted, setTotalBalancePreferredUnitStorage],
  );

  const handleBalanceOnPress = useCallback(async () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    const nextUnit =
      totalBalancePreferredUnit === BitcoinUnit.BTC
        ? BitcoinUnit.SATS
        : totalBalancePreferredUnit === BitcoinUnit.SATS
          ? BitcoinUnit.LOCAL_CURRENCY
          : BitcoinUnit.BTC;
    await setTotalBalancePreferredUnitStorage(nextUnit);
  }, [totalBalancePreferredUnit, setTotalBalancePreferredUnitStorage]);

  if (wallets.length <= 1 || !isTotalBalanceEnabled) return null;

  return (
    <ToolTipMenu actions={toolTipActions} onPressMenuItem={onPressMenuItem}>
      <View style={styles.container}>
        <Text style={styles.label}>{loc.wallets.total_balance}</Text>
        <TouchableOpacity onPress={handleBalanceOnPress}>
          <Text style={[styles.balance, { color: colors.foregroundColor }]}>
            {totalBalanceFormatted}{' '}
            {totalBalancePreferredUnit !== BitcoinUnit.LOCAL_CURRENCY && (
              <Text style={[styles.currency, { color: colors.foregroundColor }]}>{totalBalancePreferredUnit}</Text>
            )}
          </Text>
        </TouchableOpacity>
      </View>
    </ToolTipMenu>
  );
});

const styles = StyleSheet.create({
  container: {
    flexDirection: 'column',
    alignItems: 'flex-start',
    padding: 16,
  },
  label: {
    fontSize: 14,
    marginBottom: 4,
    color: '#9BA0A9',
  },
  balance: {
    fontSize: 32,
    fontWeight: 'bold',
  },
  currency: {
    fontSize: 18,
    fontWeight: 'bold',
  },
});

export default TotalWalletsBalance;


================================================
FILE: ./components/SeedWords.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

import { useTheme } from './themes';
import { useLocale } from '@react-navigation/native';

const SeedWords = ({ seed }: { seed: string }) => {
  const words = seed.split(/\s/);
  const { colors } = useTheme();
  const { direction } = useLocale();

  const stylesHook = StyleSheet.create({
    word: {
      backgroundColor: colors.inputBackgroundColor,
    },
    wortText: {
      color: colors.labelText,
    },
    secret: {
      flexDirection: direction === 'rtl' ? 'row-reverse' : 'row',
    },
  });

  return (
    <View style={[styles.secret, stylesHook.secret]}>
      {words.map((secret, index) => {
        const text = `${index + 1}. ${secret}  `;
        return (
          <View style={[styles.word, stylesHook.word]} key={index}>
            <Text style={[styles.wortText, stylesHook.wortText]} textBreakStrategy="simple">
              {text}
            </Text>
          </View>
        );
      })}
      <Text style={styles.hiddenText} testID="Secret">
        {seed}
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  word: {
    marginRight: 8,
    marginBottom: 8,
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 8,
    paddingRight: 8,
    borderRadius: 4,
  },
  wortText: {
    fontWeight: 'bold',
    textAlign: 'left',
    fontSize: 17,
  },
  secret: {
    flexWrap: 'wrap',
    justifyContent: 'center',
  },
  hiddenText: {
    height: 0,
    width: 0,
  },
});

export default SeedWords;


================================================
FILE: ./components/BlurredBalanceView.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Icon } from '@rneui/themed';

export const BlurredBalanceView = () => {
  return (
    <View style={styles.container}>
      <View style={styles.background} />
      <Icon name="eye-slash" type="font-awesome" color="#FFFFFF" />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    borderRadius: 9,
  },
  background: {
    backgroundColor: 'rgba(255, 255, 255, 0.5)',
    height: 30,
    width: 110,
    marginRight: 8,
    borderRadius: 9,
  },
});


================================================
FILE: ./components/TooltipMenu.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useMemo } from 'react';
import { Platform, TouchableOpacity } from 'react-native';
import { MenuView, MenuAction, NativeActionEvent } from '@react-native-menu/menu';
import { ToolTipMenuProps, Action } from './types';
import { useSettings } from '../hooks/context/useSettings';

const ToolTipMenu = (props: ToolTipMenuProps) => {
  const {
    title = '',
    isMenuPrimaryAction = false,
    disabled = false,
    onPress,
    buttonStyle,
    onPressMenuItem,
    children,
    isButton = false,
    ...restProps
  } = props;

  const { language } = useSettings();

  // Map Menu Items for RN Menu (supports subactions and displayInline)
  const mapMenuItemForMenuView = useCallback((action: Action): MenuAction | null => {
    if (!action.id) return null;

    // Check for subactions
    const subactions =
      action.subactions?.map(subaction => {
        const subMenuItem: MenuAction = {
          id: subaction.id.toString(),
          title: subaction.text,
          subtitle: subaction.subtitle,
          image: subaction.icon?.iconValue ? subaction.icon.iconValue : undefined,
          attributes: { disabled: subaction.disabled, destructive: subaction.destructive, hidden: subaction.hidden },
        };
        if ('menuState' in subaction) {
          subMenuItem.state = subaction.menuState ? 'on' : 'off';
        }
        if (subaction.subactions && subaction.subactions.length > 0) {
          const deepSubactions = subaction.subactions.map(deepSub => {
            const deepMenuItem: MenuAction = {
              id: deepSub.id.toString(),
              title: deepSub.text,
              subtitle: deepSub.subtitle,
              image: deepSub.icon?.iconValue ? deepSub.icon.iconValue : undefined,
              attributes: { disabled: deepSub.disabled, destructive: deepSub.destructive, hidden: deepSub.hidden },
            };
            if ('menuState' in deepSub) {
              deepMenuItem.state = deepSub.menuState ? 'on' : 'off';
            }
            return deepMenuItem;
          });
          subMenuItem.subactions = deepSubactions;
        }
        return subMenuItem;
      }) || [];

    const menuItem: MenuAction = {
      id: action.id.toString(),
      title: action.text,
      subtitle: action.subtitle,
      image: action.icon?.iconValue ? action.icon.iconValue : undefined,
      attributes: { disabled: action.disabled, destructive: action.destructive, hidden: action.hidden },
      displayInline: action.displayInline || false,
    };
    if ('menuState' in action) {
      menuItem.state = action.menuState ? 'on' : 'off';
    }
    if (subactions.length > 0) {
      menuItem.subactions = subactions;
    }
    return menuItem;
  }, []);

  const menuViewItemsIOS = useMemo(() => {
    return props.actions
      .map(actionGroup => {
        if (Array.isArray(actionGroup) && actionGroup.length > 0) {
          return {
            id: actionGroup[0].id.toString(),
            title: '',
            subactions: actionGroup
              .filter(action => action.id)
              .map(mapMenuItemForMenuView)
              .filter(item => item !== null) as MenuAction[],
            displayInline: true,
          };
        } else if (!Array.isArray(actionGroup) && actionGroup.id) {
          return mapMenuItemForMenuView(actionGroup);
        }
        return null;
      })
      .filter(item => item !== null) as MenuAction[];
  }, [props.actions, mapMenuItemForMenuView]);

  const menuViewItemsAndroid = useMemo(() => {
    const mergedActions = props.actions.flat().filter(action => action.id);
    return mergedActions.map(mapMenuItemForMenuView).filter(item => item !== null) as MenuAction[];
  }, [props.actions, mapMenuItemForMenuView]);

  const handlePressMenuItemForMenuView = useCallback(
    ({ nativeEvent }: NativeActionEvent) => {
      onPressMenuItem(nativeEvent.event);
    },
    [onPressMenuItem],
  );

  const renderMenuView = () => {
    return (
      <MenuView
        title={title}
        isAnchoredToRight
        onPressAction={handlePressMenuItemForMenuView}
        actions={Platform.OS === 'ios' ? menuViewItemsIOS : menuViewItemsAndroid}
        shouldOpenOnLongPress={!isMenuPrimaryAction}
        // @ts-ignore: Not exposed in types
        accessibilityLabel={props.accessibilityLabel}
        accessibilityHint={props.accessibilityHint}
        accessibilityRole={props.accessibilityRole}
        accessibilityLanguage={language}
      >
        {isMenuPrimaryAction || isButton ? (
          <TouchableOpacity style={buttonStyle} disabled={disabled} onPress={onPress} {...restProps}>
            {children}
          </TouchableOpacity>
        ) : (
          children
        )}
      </MenuView>
    );
  };

  return props.actions.length > 0 ? renderMenuView() : null;
};

export default ToolTipMenu;


================================================
FILE: ./components/TransactionsNavigationHeader.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import Clipboard from '@react-native-clipboard/clipboard';
import { ImageBackground, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import LinearGradient from 'react-native-linear-gradient';
import { LightningArkWallet, LightningCustodianWallet, MultisigHDWallet } from '../class';
import WalletGradient from '../class/wallet-gradient';
import { TWallet } from '../class/wallets/types';
import loc, { formatBalance, formatBalanceWithoutSuffix } from '../loc';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { FiatUnit } from '../models/fiatUnit';
import { BlurredBalanceView } from './BlurredBalanceView';
import { useSettings } from '../hooks/context/useSettings';
import ToolTipMenu from './TooltipMenu';
import useAnimateOnChange from '../hooks/useAnimateOnChange';
import { useLocale } from '@react-navigation/native';

interface TransactionsNavigationHeaderProps {
  wallet: TWallet;
  unit: BitcoinUnit;
  onWalletUnitChange: (unit: BitcoinUnit) => void;
  onManageFundsPressed?: (id?: string) => void;
  onWalletBalanceVisibilityChange?: (isShouldBeVisible: boolean) => void;
}

const TransactionsNavigationHeader: React.FC<TransactionsNavigationHeaderProps> = ({
  wallet,
  onWalletUnitChange,
  onManageFundsPressed,
  onWalletBalanceVisibilityChange,
  unit = BitcoinUnit.BTC,
}) => {
  const { hideBalance } = wallet;
  const [allowOnchainAddress, setAllowOnchainAddress] = useState(false);
  const { preferredFiatCurrency } = useSettings();
  const { direction } = useLocale();

  const verifyIfWalletAllowsOnchainAddress = useCallback(() => {
    if (wallet.type === LightningCustodianWallet.type || wallet.type === LightningArkWallet.type) {
      wallet
        .allowOnchainAddress()
        .then((value: boolean) => setAllowOnchainAddress(value))
        .catch(() => {
          console.error('This LNDhub wallet does not have an onchain address API.');
          setAllowOnchainAddress(false);
        });
    }
  }, [wallet]);

  useEffect(() => {
    verifyIfWalletAllowsOnchainAddress();
  }, [wallet, verifyIfWalletAllowsOnchainAddress]);

  const handleCopyPress = useCallback(() => {
    const value = formatBalance(wallet.getBalance(), unit);
    if (value) {
      Clipboard.setString(value);
    }
  }, [unit, wallet]);

  const handleBalanceVisibility = useCallback(() => {
    onWalletBalanceVisibilityChange?.(!hideBalance);
  }, [onWalletBalanceVisibilityChange, hideBalance]);

  const changeWalletBalanceUnit = () => {
    let newWalletPreferredUnit = wallet.getPreferredBalanceUnit();

    if (newWalletPreferredUnit === BitcoinUnit.BTC) {
      newWalletPreferredUnit = BitcoinUnit.SATS;
    } else if (newWalletPreferredUnit === BitcoinUnit.SATS) {
      newWalletPreferredUnit = BitcoinUnit.LOCAL_CURRENCY;
    } else {
      newWalletPreferredUnit = BitcoinUnit.BTC;
    }

    onWalletUnitChange(newWalletPreferredUnit);
  };

  const handleManageFundsPressed = useCallback(
    (actionKeyID?: string) => {
      if (onManageFundsPressed) {
        onManageFundsPressed(actionKeyID);
      }
    },
    [onManageFundsPressed],
  );

  const onPressMenuItem = useCallback(
    (id: string) => {
      if (id === 'walletBalanceVisibility') {
        handleBalanceVisibility();
      } else if (id === 'copyToClipboard') {
        handleCopyPress();
      }
    },
    [handleBalanceVisibility, handleCopyPress],
  );

  const toolTipActions = useMemo(() => {
    return [
      {
        id: actionKeys.Refill,
        text: loc.lnd.refill,
        icon: actionIcons.Refill,
      },
      {
        id: actionKeys.RefillWithExternalWallet,
        text: loc.lnd.refill_external,
        icon: actionIcons.RefillWithExternalWallet,
      },
    ];
  }, []);

  const currentBalance = wallet ? wallet.getBalance() : 0;
  const formattedBalance = useMemo(() => {
    return unit === BitcoinUnit.LOCAL_CURRENCY
      ? formatBalance(currentBalance, unit, true)
      : formatBalanceWithoutSuffix(currentBalance, unit, true);
  }, [unit, currentBalance]);

  const balance = !wallet.hideBalance && formattedBalance;

  const toolTipWalletBalanceActions = useMemo(() => {
    return hideBalance
      ? [
          {
            id: 'walletBalanceVisibility',
            text: loc.transactions.details_balance_show,
            icon: {
              iconValue: 'eye',
            },
          },
        ]
      : [
          {
            id: 'walletBalanceVisibility',
            text: loc.transactions.details_balance_hide,
            icon: {
              iconValue: 'eye.slash',
            },
          },
          {
            id: 'copyToClipboard',
            text: loc.transactions.details_copy,
            icon: {
              iconValue: 'doc.on.doc',
            },
          },
        ];
  }, [hideBalance]);

  const imageSource = useMemo(() => {
    switch (wallet.type) {
      case LightningCustodianWallet.type:
      case LightningArkWallet.type:
        return direction === 'rtl' ? require('../img/lnd-shape-rtl.png') : require('../img/lnd-shape.png');
      case MultisigHDWallet.type:
        return direction === 'rtl' ? require('../img/vault-shape-rtl.png') : require('../img/vault-shape.png');
      default:
        return direction === 'rtl' ? require('../img/btc-shape-rtl.png') : require('../img/btc-shape.png');
    }
  }, [direction, wallet.type]);

  useAnimateOnChange(balance);
  useAnimateOnChange(hideBalance);
  useAnimateOnChange(unit);
  useAnimateOnChange(wallet.getID?.());

  return (
    <LinearGradient
      colors={WalletGradient.gradientsFor(wallet.type)}
      style={styles.lineaderGradient}
      {...WalletGradient.linearGradientProps(wallet.type)}
    >
      <ImageBackground source={imageSource} style={styles.chainIcon} />

      <Text testID="WalletLabel" numberOfLines={1} style={[styles.walletLabel, { writingDirection: direction }]}>
        {wallet.getLabel()}
      </Text>
      <View style={styles.walletBalanceAndUnitContainer}>
        <ToolTipMenu
          isMenuPrimaryAction
          isButton
          enableAndroidRipple={false}
          buttonStyle={styles.walletBalance}
          onPressMenuItem={onPressMenuItem}
          actions={toolTipWalletBalanceActions}
        >
          <View style={styles.walletBalance}>
            {hideBalance ? (
              <BlurredBalanceView />
            ) : (
              <View>
                <Text
                  key={String(balance)} // force component recreation on balance change. To fix right-to-left languages, like Farsis
                  testID="WalletBalance"
                  numberOfLines={1}
                  minimumFontScale={0.5}
                  adjustsFontSizeToFit
                  style={styles.walletBalanceText}
                >
                  {balance}
                </Text>
              </View>
            )}
          </View>
        </ToolTipMenu>
        <TouchableOpacity style={styles.walletPreferredUnitView} onPress={changeWalletBalanceUnit}>
          <Text style={styles.walletPreferredUnitText}>
            {unit === BitcoinUnit.LOCAL_CURRENCY ? (preferredFiatCurrency?.endPointKey ?? FiatUnit.USD) : unit}
          </Text>
        </TouchableOpacity>
      </View>
      {(wallet.type === LightningCustodianWallet.type || wallet.type === LightningArkWallet.type) && allowOnchainAddress && (
        <ToolTipMenu
          isMenuPrimaryAction
          isButton
          onPressMenuItem={handleManageFundsPressed}
          actions={toolTipActions}
          buttonStyle={styles.manageFundsButton}
        >
          <Text style={styles.manageFundsButtonText}>{loc.lnd.title}</Text>
        </ToolTipMenu>
      )}
      {wallet.type === MultisigHDWallet.type && (
        <TouchableOpacity style={styles.manageFundsButton} accessibilityRole="button" onPress={() => handleManageFundsPressed()}>
          <Text style={styles.manageFundsButtonText}>{loc.multisig.manage_keys}</Text>
        </TouchableOpacity>
      )}
    </LinearGradient>
  );
};

const styles = StyleSheet.create({
  lineaderGradient: {
    padding: 15,
    minHeight: 140,
    justifyContent: 'center',
  },
  chainIcon: {
    width: 99,
    height: 94,
    position: 'absolute',
    bottom: 0,
    right: 0,
  },
  walletLabel: {
    backgroundColor: 'transparent',
    fontSize: 19,
    color: '#fff',
    marginBottom: 10,
  },
  walletBalance: {
    flexShrink: 1,
    marginRight: 6,
  },
  manageFundsButton: {
    marginTop: 14,
    marginBottom: 10,
    backgroundColor: 'rgba(255,255,255,0.2)',
    borderRadius: 9,
    minHeight: 39,
    alignSelf: 'flex-start',
    justifyContent: 'center',
    alignItems: 'center',
  },
  manageFundsButtonText: {
    fontWeight: '500',
    fontSize: 14,
    color: '#FFFFFF',
    padding: 12,
  },
  walletBalanceAndUnitContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingRight: 10, // Ensure there's some padding to the right
  },
  walletBalanceText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 36,
    flexShrink: 1, // Allow the text to shrink if there's not enough space
  },
  walletPreferredUnitView: {
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    borderRadius: 8,
    minHeight: 35,
    minWidth: 65,
  },
  walletPreferredUnitText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export const actionKeys = {
  CopyToClipboard: 'copyToClipboard',
  WalletBalanceVisibility: 'walletBalanceVisibility',
  Refill: 'refill',
  RefillWithExternalWallet: 'refillWithExternalWallet',
};

export const actionIcons = {
  Eye: {
    iconValue: 'eye',
  },
  EyeSlash: {
    iconValue: 'eye.slash',
  },
  Clipboard: {
    iconValue: 'doc.on.doc',
  },
  Refill: {
    iconValue: 'goforward.plus',
  },
  RefillWithExternalWallet: {
    iconValue: 'qrcode',
  },
};

export default TransactionsNavigationHeader;


================================================
FILE: ./components/icons/TransactionExpiredIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ballOutgoingExpired: {
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionExpiredIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesHooks = StyleSheet.create({
    ballOutgoingExpired: {
      backgroundColor: colors.ballOutgoingExpired,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ballOutgoingExpired, stylesHooks.ballOutgoingExpired]}>
        <Icon name="timer" size={16} type="font-awesome-6" color="#9AA0AA" />
      </View>
    </View>
  );
};

export default TransactionExpiredIcon;


================================================
FILE: ./components/icons/SettingsButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useMemo } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';
import { Icon } from '@rneui/themed';
import { useTheme } from '../themes';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import loc from '../../loc';
import ToolTipMenu from '../TooltipMenu';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';

const SettingsButton = () => {
  const { colors } = useTheme();
  const { navigate } = useExtendedNavigation();
  const onPress = () => {
    navigate('Settings');
  };

  const onPressMenuItem = useCallback(
    (menuItem: string) => {
      switch (menuItem) {
        case CommonToolTipActions.ManageWallet.id:
          navigate('ManageWallets');
          break;
        default:
          break;
      }
    },
    [navigate],
  );

  const actions = useMemo(() => [CommonToolTipActions.ManageWallet], []);
  return (
    <ToolTipMenu onPressMenuItem={onPressMenuItem} actions={actions}>
      <TouchableOpacity
        accessibilityRole="button"
        accessibilityLabel={loc.settings.default_title}
        testID="SettingsButton"
        style={[style.buttonStyle, { backgroundColor: colors.lightButton }]}
        onPress={onPress}
      >
        <Icon size={22} name="more-horiz" type="material" color={colors.foregroundColor} />
      </TouchableOpacity>
    </ToolTipMenu>
  );
};

export default SettingsButton;

const style = StyleSheet.create({
  buttonStyle: {
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignContent: 'center',
  },
});


================================================
FILE: ./components/icons/TransactionPendingIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ball: {
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionPendingIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesHook = StyleSheet.create({
    ball: {
      backgroundColor: colors.buttonBackgroundColor,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ball, stylesHook.ball]}>
        <Icon name="more-horiz" type="material" size={16} color={colors.foregroundColor} />
      </View>
    </View>
  );
};

export default TransactionPendingIcon;


================================================
FILE: ./components/icons/TransactionIncomingIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ballIncoming: {
    width: 30,
    height: 30,
    borderRadius: 15,
    transform: [{ rotate: '-45deg' }],
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionIncomingIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesHooks = StyleSheet.create({
    ballIncoming: {
      backgroundColor: colors.ballReceive,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ballIncoming, stylesHooks.ballIncoming]}>
        <Icon name="arrow-down" size={16} type="font-awesome" color={colors.incomingForegroundColor} />
      </View>
    </View>
  );
};

export default TransactionIncomingIcon;


================================================
FILE: ./components/icons/TransactionOnchainIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ballIncoming: {
    width: 30,
    height: 30,
    borderRadius: 15,
    transform: [{ rotate: '-45deg' }],
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionOnchainIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesMalinIconHooks = StyleSheet.create({
    ballIncoming: {
      backgroundColor: colors.ballReceive,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ballIncoming, stylesMalinIconHooks.ballIncoming]}>
        <Icon name="link" size={16} type="font-awesome" color={colors.incomingForegroundColor} />
      </View>
    </View>
  );
};

export default TransactionOnchainIcon;


================================================
FILE: ./components/icons/TransactionOutgoingIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ballOutgoing: {
    width: 30,
    height: 30,
    borderRadius: 15,
    transform: [{ rotate: '225deg' }],
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionOutgoingIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesMalinIconHooks = StyleSheet.create({
    ballOutgoing: {
      backgroundColor: colors.ballOutgoing,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ballOutgoing, stylesMalinIconHooks.ballOutgoing]}>
        <Icon name="arrow-down" size={16} type="font-awesome" color={colors.outgoingForegroundColor} />
      </View>
    </View>
  );
};

export default TransactionOutgoingIcon;


================================================
FILE: ./components/icons/TransactionOffchainIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ballOutgoingWithoutRotate: {
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionOffchainIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesHooks = StyleSheet.create({
    ballOutgoingWithoutRotate: {
      backgroundColor: colors.ballOutgoing,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ballOutgoingWithoutRotate, stylesHooks.ballOutgoingWithoutRotate]}>
        <Icon name="bolt" size={16} type="font-awesome" color={colors.outgoingForegroundColor} />
      </View>
    </View>
  );
};

export default TransactionOffchainIcon;


================================================
FILE: ./components/icons/TransactionOffchainIncomingIcon.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewStyle } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from '../themes';

const styles = StyleSheet.create({
  boxIncoming: {
    position: 'relative',
  } as ViewStyle,
  ballIncomingWithoutRotate: {
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignItems: 'center',
  } as ViewStyle,
});

const TransactionOffchainIncomingIcon: React.FC = () => {
  const { colors } = useTheme();

  const stylesHooks = StyleSheet.create({
    ballIncomingWithoutRotate: {
      backgroundColor: colors.ballReceive,
    },
  });

  return (
    <View style={styles.boxIncoming}>
      <View style={[styles.ballIncomingWithoutRotate, stylesHooks.ballIncomingWithoutRotate]}>
        <Icon name="bolt" size={16} type="font-awesome" color={colors.incomingForegroundColor} />
      </View>
    </View>
  );
};

export default TransactionOffchainIncomingIcon;


================================================
FILE: ./components/HighlightedText.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useMemo, useEffect, useState } from 'react';
import { Text, Animated, StyleSheet, Platform, TextStyle } from 'react-native';
import useBounceAnimation from '../hooks/useBounceAnimation';

interface HighlightedTextProps {
  text: string;
  query: string;
  numberOfLines?: number;
  style?: TextStyle | TextStyle[];
  highlightStyle?: TextStyle;
  bounceAnim?: Animated.Value;
  caseSensitive?: boolean;
  highlightOnlyFirstMatch?: boolean;
}

interface TextPart {
  text: string;
  isMatch: boolean;
}

const HighlightedText: React.FC<HighlightedTextProps> = ({
  text,
  query,
  numberOfLines,
  style,
  highlightStyle,
  bounceAnim: externalBounceAnim,
  caseSensitive = false,
  highlightOnlyFirstMatch = false,
}) => {
  const internalBounceAnim = useBounceAnimation(query);
  const bounceAnim = externalBounceAnim || internalBounceAnim;
  const [queryKey, setQueryKey] = useState<string>('');

  useEffect(() => {
    setQueryKey(query);
  }, [query]);

  const baseTextStyle = useMemo(() => {
    if (!style) return {};

    if (Array.isArray(style)) {
      return style.reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }

    return style;
  }, [style]);

  const highlightedStyle = useMemo(
    () => ({
      ...styles.highlight,
      ...(highlightStyle || {}),
      fontSize: baseTextStyle.fontSize,
      fontFamily: baseTextStyle.fontFamily,
      fontWeight: baseTextStyle.fontWeight || '600',
      lineHeight: baseTextStyle.lineHeight,
      letterSpacing: baseTextStyle.letterSpacing,
      transform: Platform.OS === 'ios' ? [{ scale: bounceAnim }] : undefined,
    }),
    [bounceAnim, highlightStyle, baseTextStyle],
  );

  // Create a style for non-highlighted text parts that ensures it looks the same as original text
  const nonHighlightedStyle = useMemo(
    () => ({
      ...baseTextStyle, // Copy all original text properties
    }),
    [baseTextStyle],
  );

  const renderTextPart = useCallback(
    (part: TextPart, index: number) => {
      if (part.isMatch) {
        return (
          <Animated.View
            key={`highlight-container-${index}-${queryKey}`}
            style={[styles.highlightContainer, { transform: [{ scale: bounceAnim }] }]}
          >
            <Animated.Text key={`highlight-${index}-${queryKey}`} style={highlightedStyle}>
              {part.text}
            </Animated.Text>
          </Animated.View>
        );
      }

      return (
        <Text key={`text-${index}-${queryKey}`} style={nonHighlightedStyle}>
          {part.text}
        </Text>
      );
    },
    [queryKey, highlightedStyle, bounceAnim, nonHighlightedStyle],
  );

  const textParts = useMemo((): TextPart[] => {
    if (!query) {
      return [{ text, isMatch: false }];
    }

    try {
      const searchQueryText = caseSensitive ? query : query.toLowerCase();
      const processedText = caseSensitive ? text : text.toLowerCase();

      if (searchQueryText.trim() === '') {
        return [{ text, isMatch: false }];
      }

      const parts: TextPart[] = [];
      let lastIndex = 0;
      let searchStartIndex = 0;

      while (true) {
        const matchIndex = processedText.indexOf(searchQueryText, searchStartIndex);

        if (matchIndex === -1) {
          break;
        }

        if (matchIndex > lastIndex) {
          parts.push({
            text: text.substring(lastIndex, matchIndex),
            isMatch: false,
          });
        }

        parts.push({
          text: text.substring(matchIndex, matchIndex + searchQueryText.length),
          isMatch: true,
        });

        lastIndex = matchIndex + searchQueryText.length;
        searchStartIndex = lastIndex;

        if (highlightOnlyFirstMatch) {
          break;
        }
      }

      if (lastIndex < text.length) {
        parts.push({
          text: text.substring(lastIndex),
          isMatch: false,
        });
      }

      return parts.length > 0 ? parts : [{ text, isMatch: false }];
    } catch (e) {
      return [{ text, isMatch: false }];
    }
  }, [text, query, caseSensitive, highlightOnlyFirstMatch]);

  if (textParts.length === 1 && !textParts[0].isMatch) {
    return (
      <Text style={[styles.text, style]} numberOfLines={numberOfLines}>
        {text}
      </Text>
    );
  }

  return (
    <Text numberOfLines={numberOfLines} style={[styles.text, style]} key={`highlighted-wrapper-${queryKey}`}>
      {textParts.map(renderTextPart)}
    </Text>
  );
};

const styles = StyleSheet.create({
  text: {
    fontSize: 16,
  },
  highlightContainer: {
    overflow: 'hidden',
    margin: 0,
    padding: 0,
  },
  highlight: {
    fontWeight: '600',
    borderRadius: 4,
    borderWidth: 1,
    paddingHorizontal: 3,
    paddingVertical: 1,
    marginHorizontal: 1,
    overflow: 'hidden',
    textDecorationLine: Platform.OS === 'android' ? 'underline' : 'none',
    backgroundColor: '#FFF5C0',
    color: '#000000',
    borderColor: 'rgba(255, 255, 255, 0.5)',
    shadowColor: '#000000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1,
    elevation: 2,
  },
});

export default HighlightedText;


================================================
FILE: ./components/ArrowPicker.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/* eslint react/prop-types: "off", react-native/no-inline-styles: "off" */
import React, { useState } from 'react';
import { Keyboard, Pressable, StyleSheet, View } from 'react-native';
import { Icon, Text } from '@rneui/themed';

import loc from '../loc';
import { useTheme } from './themes';

interface IHash {
  [key: string]: string;
}

type ArrowPickerProps = {
  onChange: (key: string) => void;
  items: IHash;
  isItemUnknown: boolean;
};

export const ArrowPicker = (props: ArrowPickerProps) => {
  const keys = Object.keys(props.items);
  const [keyIndex, setKeyIndex] = useState(0);

  const { colors } = useTheme();

  const stylesHook = {
    text: {
      color: colors.foregroundColor,
    },
  };
  return (
    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <Pressable
        accessibilityRole="button"
        accessibilityLabel={loc.send.dynamic_prev}
        onPress={() => {
          Keyboard.dismiss();
          let newIndex = keyIndex;
          if (keyIndex <= 0) {
            newIndex = keys.length - 1;
          } else {
            newIndex--;
          }
          setKeyIndex(newIndex);
          props.onChange(keys[newIndex]);
        }}
        style={({ pressed }) => [
          {
            backgroundColor: pressed ? 'rgb(210, 230, 255)' : 'white',
          },
          styles.wrapperCustom,
        ]}
      >
        <Icon size={24} name="chevron-left" type="ionicons" />
      </Pressable>
      <View style={{ width: 200 }}>
        <Text style={[styles.text, stylesHook.text]}>{props.isItemUnknown ? loc.send.fee_custom : keys[keyIndex]}</Text>
      </View>
      <Pressable
        accessibilityRole="button"
        accessibilityLabel={loc.send.dynamic_next}
        onPress={() => {
          Keyboard.dismiss();
          let newIndex = keyIndex;
          if (keyIndex + 1 >= keys.length) {
            newIndex = 0;
          } else {
            newIndex++;
          }
          setKeyIndex(newIndex);
          props.onChange(keys[newIndex]);
        }}
        style={({ pressed }) => [
          {
            backgroundColor: pressed ? 'rgb(210, 230, 255)' : 'white',
          },
          styles.wrapperCustom,
        ]}
      >
        <Icon size={24} name="chevron-right" type="ionicons" />
      </Pressable>
    </View>
  );
};

const styles = StyleSheet.create({
  wrapperCustom: {
    borderRadius: 8,
    padding: 5,
    marginLeft: 20,
    marginRight: 20,
  },
  text: { fontWeight: 'bold', fontSize: 12, textAlign: 'center' },
});


================================================
FILE: ./components/WatchOnlyWarning.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Icon } from '@rneui/themed';
import loc from '../loc';

interface Props {
  handleDismiss: () => void;
}

const WatchOnlyWarning: React.FC<Props> = ({ handleDismiss }) => {
  return (
    <View style={styles.container}>
      <View style={styles.content}>
        <TouchableOpacity style={styles.dismissButton} onPress={handleDismiss}>
          <Icon name="close" color="white" size={20} />
        </TouchableOpacity>
        <Icon name="warning" color="#FFFF" />
        <Text style={styles.title}>{loc.transactions.watchOnlyWarningTitle}</Text>
        <Text style={styles.description}>{loc.transactions.watchOnlyWarningDescription}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#fc990e',
    padding: 16,
    margin: 16,
    borderRadius: 8,
    position: 'relative',
  },
  dismissButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: 'black',
    borderRadius: 15,
    width: 30,
    height: 30,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1,
  },
  content: {
    alignItems: 'center',
  },
  title: {
    color: 'white',
    fontWeight: 'bold',
    marginBottom: 8,
    marginTop: 8,
  },
  description: {
    color: 'white',
    textAlign: 'center',
  },
});

export default WatchOnlyWarning;


================================================
FILE: ./components/types.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { AccessibilityRole, ViewStyle, ColorValue } from 'react-native';

export interface Action {
  id: string | number;
  text: string;
  icon?: {
    iconValue: string;
  };
  menuTitle?: string;
  subtitle?: string;
  menuState?: 'mixed' | boolean | undefined;
  displayInline?: boolean; // Indicates if subactions should be displayed inline or nested (iOS only)
  image?: string;
  imageColor?: ColorValue;
  destructive?: boolean;
  hidden?: boolean;
  disabled?: boolean;
  subactions?: Action[]; // Nested/Inline actions (subactions) within an action
}

export interface ToolTipMenuProps {
  actions: Action[] | Action[][];
  children: React.ReactNode;
  enableAndroidRipple?: boolean;
  dismissMenu?: () => void;
  onPressMenuItem: (id: string) => void;
  title?: string;
  isMenuPrimaryAction?: boolean;
  isButton?: boolean;
  renderPreview?: () => React.ReactNode;
  onPress?: () => void;
  previewValue?: string;
  accessibilityRole?: AccessibilityRole;
  disabled?: boolean;
  testID?: string;
  style?: ViewStyle | ViewStyle[];
  accessibilityLabel?: string;
  accessibilityHint?: string;
  accessibilityState?: object;
  buttonStyle?: ViewStyle | ViewStyle[];
  onMenuWillShow?: () => void;
  onMenuWillHide?: () => void;
}

export enum HandOffActivityType {
  ReceiveOnchain = 'com.malinwallet.app.receiveonchain',
  Xpub = 'com.malinwallet.app.xpub',
  ViewInBlockExplorer = 'com.malinwallet.app.blockexplorer',
}

export interface HandOffComponentProps {
  url?: string;
  title?: string;
  type: HandOffActivityType;
  userInfo?: object;
}


================================================
FILE: ./components/SafeArea.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo } from 'react';
import { StyleSheet, ViewProps, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

import { useTheme } from './themes';

interface SafeAreaProps extends ViewProps {
  floatingButtonHeight?: number;
  orientation?: 'portrait' | 'landscape';
}

const SafeArea = (props: SafeAreaProps) => {
  const { style, floatingButtonHeight, ...otherProps } = props;
  const { colors } = useTheme();
  const insets = useSafeAreaInsets();

  const padding = useMemo(
    () =>
      props.orientation === 'portrait'
        ? {
            paddingTop: insets.top,
            paddingBottom: insets.bottom,
          }
        : {
            paddingTop: insets.top,
            paddingBottom: insets.bottom + (floatingButtonHeight ?? 0),
            paddingLeft: insets.left,
            paddingRight: insets.right,
          },
    [insets, props.orientation, floatingButtonHeight],
  );

  const componentStyle = useMemo(() => {
    return StyleSheet.compose(
      {
        flex: 1,
        backgroundColor: colors.background,
        ...padding,
      },
      style,
    );
  }, [colors.background, padding, style]);

  return <View style={componentStyle} {...otherProps} />;
};

export default SafeArea;


================================================
FILE: ./components/AddWalletButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useMemo } from 'react';
import { StyleSheet, GestureResponderEvent, Pressable } from 'react-native';
import { Icon } from '@rneui/themed';
import { useTheme } from './themes';
import ToolTipMenu from './TooltipMenu';
import { CommonToolTipActions } from '../typings/CommonToolTipActions';
import loc from '../loc';
import { useExtendedNavigation } from '../hooks/useExtendedNavigation';

type AddWalletButtonProps = {
  onPress?: (event: GestureResponderEvent) => void;
};

const styles = StyleSheet.create({
  ball: {
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignContent: 'center',
  },
  pressed: {
    opacity: 0.6,
  },
});

const AddWalletButton: React.FC<AddWalletButtonProps> = ({ onPress }) => {
  const { colors } = useTheme();
  const navigation = useExtendedNavigation();
  const stylesHook = StyleSheet.create({
    ball: {
      backgroundColor: colors.buttonBackgroundColor,
    },
  });

  const onPressMenuItem = useCallback(
    (action: string) => {
      switch (action) {
        case CommonToolTipActions.ImportWallet.id:
          navigation.navigate('AddWalletRoot', { screen: 'ImportWallet' });
          break;
        default:
          break;
      }
    },
    [navigation],
  );

  const actions = useMemo(() => [CommonToolTipActions.ImportWallet], []);

  return (
    <ToolTipMenu accessibilityRole="button" accessibilityLabel={loc.wallets.add_title} onPressMenuItem={onPressMenuItem} actions={actions}>
      <Pressable style={({ pressed }) => [pressed ? styles.pressed : null, styles.ball, stylesHook.ball]} onPress={onPress}>
        <Icon name="add" size={22} type="ionicons" color={colors.foregroundColor} />
      </Pressable>
    </ToolTipMenu>
  );
};

export default AddWalletButton;


================================================
FILE: ./components/InputAccessoryAllFunds.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { InputAccessoryView, Keyboard, Platform, StyleSheet, View } from 'react-native';
import { Text } from '@rneui/themed';
import { MalinButtonLink } from '../MalinComponents';
import loc from '../loc';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { useTheme } from './themes';

interface InputAccessoryAllFundsProps {
  balance: string;
  canUseAll: boolean;
  onUseAllPressed: () => void;
}

const InputAccessoryAllFunds: React.FC<InputAccessoryAllFundsProps> = ({ balance, canUseAll, onUseAllPressed }) => {
  const { colors } = useTheme();

  const stylesHook = StyleSheet.create({
    root: {
      backgroundColor: colors.inputBackgroundColor,
    },
    totalLabel: {
      color: colors.alternativeTextColor,
    },
    totalCanNot: {
      color: colors.alternativeTextColor,
    },
  });

  const inputView = (
    <View style={[styles.root, stylesHook.root]}>
      <View style={styles.left}>
        <Text style={[styles.totalLabel, stylesHook.totalLabel]}>{loc.send.input_total}</Text>
        {canUseAll ? (
          <MalinButtonLink onPress={onUseAllPressed} style={styles.totalCan} title={`${balance} ${BitcoinUnit.BTC}`} />
        ) : (
          <Text style={[styles.totalCanNot, stylesHook.totalCanNot]}>
            {balance} {BitcoinUnit.BTC}
          </Text>
        )}
      </View>
      <View style={styles.right}>
        <MalinButtonLink style={styles.done} title={loc.send.input_done} onPress={Keyboard.dismiss} />
      </View>
    </View>
  );

  if (Platform.OS === 'ios') {
    return <InputAccessoryView nativeID={InputAccessoryAllFundsAccessoryViewID}>{inputView}</InputAccessoryView>;
  }

  // androidPlaceholder View is needed to force shrink screen (KeyboardAvoidingView) where this component is used
  return (
    <>
      <View style={styles.androidPlaceholder} />
      <View style={styles.androidAbsolute}>{inputView}</View>
    </>
  );
};

export const InputAccessoryAllFundsAccessoryViewID = 'useMaxInputAccessoryViewID';

const styles = StyleSheet.create({
  root: {
    flex: 1,
    flexDirection: 'row',
    maxHeight: 44,
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  left: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'flex-start',
  },
  totalLabel: {
    fontSize: 16,
    marginLeft: 8,
    marginRight: 0,
    paddingRight: 0,
    paddingLeft: 0,
    paddingTop: 12,
    paddingBottom: 12,
  },
  totalCan: {
    marginLeft: 8,
    paddingRight: 0,
    paddingLeft: 0,
    paddingTop: 12,
    paddingBottom: 12,
  },
  totalCanNot: {
    fontSize: 16,
    marginLeft: 8,
    marginRight: 0,
    paddingRight: 0,
    paddingLeft: 0,
    paddingTop: 12,
    paddingBottom: 12,
  },
  right: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'flex-end',
  },
  done: {
    paddingRight: 8,
    paddingLeft: 0,
    paddingTop: 12,
    paddingBottom: 12,
  },
  androidPlaceholder: {
    height: 44,
  },
  androidAbsolute: {
    height: 44,
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
  },
});

export default InputAccessoryAllFunds;


================================================
FILE: ./components/AmountInput.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Badge, Icon, Text } from '@rneui/themed';
import BigNumber from 'bignumber.js';
import dayjs from 'dayjs';
import {
  Image,
  LayoutAnimation,
  NativeSyntheticEvent,
  Pressable,
  StyleSheet,
  TextInput,
  TextInputProps,
  TextInputSelectionChangeEventData,
  TouchableOpacity,
  View,
} from 'react-native';

import {
  CurrencyRate,
  fiatToBTC,
  getCurrencySymbol,
  isRateOutdated,
  mostRecentFetchedRate,
  satoshiToBTC,
  updateExchangeRate,
} from '../malin_modules/currency';
import { MalinText } from '../MalinComponents';
import confirm from '../helpers/confirm';
import loc, { formatBalancePlain, formatBalanceWithoutSuffix, removeTrailingZeros } from '../loc';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { useTheme } from './themes';

export const conversionCache: { [key: string]: string } = {};

export const getCachedSatoshis = (amount: string): string | undefined => {
  return conversionCache[amount + BitcoinUnit.LOCAL_CURRENCY];
};

export const setCachedSatoshis = (amount: string, sats: string): void => {
  conversionCache[amount + BitcoinUnit.LOCAL_CURRENCY] = sats;
};

type AmountInputProps = Omit<TextInputProps, 'onChangeText' | 'value'> & {
  /**
   * Whether the input is in a loading state
   */
  isLoading?: boolean;
  /**
   * Whether the input is disabled
   */
  disabled?: boolean;
  /**
   * The current amount value as a string in the current unit denomination
   * e.g. '0.001' or '9.43' or '10000'
   */
  amount?: string;
  /**
   * The current unit of the amount (BTC, SATS, LOCAL_CURRENCY)
   */
  unit: BitcoinUnit;
  /**
   * Callback that returns currently typed amount in current denomination
   * e.g. 0.001 or 10000 or $9.34 (btc, sat, fiat)
   */
  onChangeText: (text: string) => void;
  /**
   * Callback that's fired to notify of currently selected denomination
   * Returns a BitcoinUnit value
   */
  onAmountUnitChange: (unit: BitcoinUnit) => void;
};

export const AmountInput: React.FC<AmountInputProps> = props => {
  const textInputRef = useRef<TextInput>(null);
  const { colors } = useTheme();
  const amount = props.amount || '0'; // internally amount is aways a string with a correct number
  const { onChangeText, unit, onAmountUnitChange, disabled = false, isLoading = false, ...otherProps } = props;
  const [isRateBeingUpdatedLocal, setIsRateBeingUpdatedLocal] = useState(false);
  const [outdatedRefreshRate, setOutdatedRefreshRate] = useState<CurrencyRate | undefined>();

  const maxLength = useMemo(() => {
    switch (unit) {
      case BitcoinUnit.BTC:
        return 11;
      case BitcoinUnit.SATS:
        return 15;
      default:
        return 15;
    }
  }, [unit]);

  const secondaryDisplayCurrency = useMemo(() => {
    if (amount === BitcoinUnit.MAX) {
      return '';
    }
    switch (unit) {
      case BitcoinUnit.BTC: {
        const sat = new BigNumber(amount).multipliedBy(100000000).toNumber();
        return formatBalanceWithoutSuffix(sat, BitcoinUnit.LOCAL_CURRENCY, false);
      }
      case BitcoinUnit.SATS:
        return formatBalanceWithoutSuffix(Number(amount), BitcoinUnit.LOCAL_CURRENCY, false);
      case BitcoinUnit.LOCAL_CURRENCY: {
        let res: string = '';
        if (conversionCache[amount + BitcoinUnit.LOCAL_CURRENCY]) {
          // cache hit! we reuse old value that supposedly doesn't have rounding errors
          const sats = conversionCache[amount + BitcoinUnit.LOCAL_CURRENCY];
          res = satoshiToBTC(Number(sats));
        } else {
          res = fiatToBTC(Number(amount));
        }
        res = removeTrailingZeros(res);
        return `${res} ${loc.units[BitcoinUnit.BTC]}`;
      }
    }
  }, [amount, unit]);

  useEffect(() => {
    (async () => {
      if (await isRateOutdated()) {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        const recent = await mostRecentFetchedRate();
        setOutdatedRefreshRate(recent);
      }
    })();
  }, []);

  const updateRate = useCallback(async () => {
    try {
      await updateExchangeRate();
    } finally {
      setIsRateBeingUpdatedLocal(false);
      if (await isRateOutdated()) {
        const recent = await mostRecentFetchedRate();
        setOutdatedRefreshRate(recent);
      } else {
        setOutdatedRefreshRate(undefined);
      }
    }
  }, []);

  const changeAmountUnit = useCallback(() => {
    let previousUnit = unit;
    let newUnit;
    // cycle through units BTC -> SAT -> LOCAL_CURRENCY -> BTC
    if (previousUnit === BitcoinUnit.BTC) {
      newUnit = BitcoinUnit.SATS;
    } else if (previousUnit === BitcoinUnit.SATS) {
      newUnit = BitcoinUnit.LOCAL_CURRENCY;
    } else if (previousUnit === BitcoinUnit.LOCAL_CURRENCY) {
      newUnit = BitcoinUnit.BTC;
    } else {
      newUnit = BitcoinUnit.BTC;
      previousUnit = BitcoinUnit.SATS;
    }

    /**
     * here we must recalculate old amont value (which was denominated in `previousUnit`) to new denomination `newUnit`
     * and fill this value in input box, so user can switch between, for example, 0.001 BTC <=> 100000 sats
     */
    const log = `${amount}(${previousUnit}) ->`;
    let sats: string = '0';
    switch (previousUnit) {
      case BitcoinUnit.BTC:
        sats = new BigNumber(amount).multipliedBy(100000000).toString();
        break;
      case BitcoinUnit.SATS:
        sats = amount;
        break;
      case BitcoinUnit.LOCAL_CURRENCY:
        sats = new BigNumber(fiatToBTC(+amount)).multipliedBy(100000000).toString();
        break;
    }
    if (previousUnit === BitcoinUnit.LOCAL_CURRENCY && conversionCache[amount + previousUnit]) {
      // cache hit! we reuse old value that supposedly doesnt have rounding errors
      sats = conversionCache[amount + previousUnit];
    }

    const newInputValue = formatBalancePlain(+sats, newUnit, false);
    console.log(`${log} ${sats}(sats) -> ${newInputValue}(${newUnit})`);

    if (newUnit === BitcoinUnit.LOCAL_CURRENCY && previousUnit === BitcoinUnit.SATS) {
      // we cache conversion, so when we will need reverse conversion there wont be a rounding error
      conversionCache[newInputValue + newUnit] = amount;
    }
    onChangeText(newInputValue);
    onAmountUnitChange(newUnit);
  }, [amount, onChangeText, onAmountUnitChange, unit]);

  const handleTextInputOnPress = useCallback(() => {
    textInputRef?.current?.focus();
  }, []);

  const handleChangeText = useCallback(
    (text: string) => {
      text = text.trim();
      if (unit !== BitcoinUnit.LOCAL_CURRENCY) {
        text = text.replace(',', '.');
        const split = text.split('.');
        if (split.length >= 2) {
          text = `${parseInt(split[0], 10)}.${split[1]}`;
        } else {
          text = `${parseInt(split[0], 10)}`;
        }

        text = unit === BitcoinUnit.BTC ? text.replace(/[^0-9.]/g, '') : text.replace(/[^0-9]/g, '');
      } else {
        text = text.replace(/,/gi, '.');
        if (text.split('.').length > 2) {
          // too many dots. stupid code to remove all but first dot:
          let rez = '';
          let first = true;
          for (const part of text.split('.')) {
            rez += part;
            if (first) {
              rez += '.';
              first = false;
            }
          }
          text = rez;
        }
        if (text.startsWith('0') && !(text.includes('.') || text.includes(','))) {
          text = text.replace(/^(0+)/g, '');
        }
        text = text.replace(/[^\d.,-]/g, ''); // remove all but numbers, dots & commas
        text = text.replace(/(\..*)\./g, '$1');
      }
      if (text.startsWith('.')) {
        text = '0.';
      }
      onChangeText(text);
    },
    [onChangeText, unit],
  );

  const resetAmount = useCallback(async () => {
    if (await confirm(loc.send.reset_amount, loc.send.reset_amount_confirm)) {
      onChangeText('0');
    }
  }, [onChangeText]);

  const handleSelectionChange = useCallback(
    (event: NativeSyntheticEvent<TextInputSelectionChangeEventData>) => {
      const { selection } = event.nativeEvent;
      if (selection.start !== selection.end || selection.start !== amount.length) {
        textInputRef.current?.setNativeProps({ selection: { start: amount.length, end: amount.length } });
      }
    },
    [amount],
  );

  const stylesHook = StyleSheet.create({
    center: { padding: amount === BitcoinUnit.MAX ? 0 : 15 },
    localCurrency: { color: disabled ? colors.buttonDisabledTextColor : colors.alternativeTextColor2 },
    input: { color: disabled ? colors.buttonDisabledTextColor : colors.alternativeTextColor2, fontSize: amount.length > 10 ? 20 : 36 },
    cryptoCurrency: { color: disabled ? colors.buttonDisabledTextColor : colors.alternativeTextColor2 },
  });

  return (
    <Pressable accessibilityRole="button" accessibilityLabel={loc._.enter_amount} disabled={disabled} onPress={handleTextInputOnPress}>
      <View style={styles.root}>
        {!disabled && <View style={[styles.center, stylesHook.center]} />}
        <View style={styles.flex}>
          <View style={styles.container}>
            {unit === BitcoinUnit.LOCAL_CURRENCY && amount !== BitcoinUnit.MAX && (
              <Text style={[styles.localCurrency, stylesHook.localCurrency]}>{getCurrencySymbol() + ' '}</Text>
            )}
            {amount !== BitcoinUnit.MAX ? (
              <TextInput
                onSelectionChange={handleSelectionChange}
                testID="BitcoinAmountInput"
                keyboardType="numeric"
                onChangeText={handleChangeText}
                placeholder="0"
                maxLength={maxLength}
                ref={textInputRef}
                editable={!isLoading && !disabled}
                value={amount === BitcoinUnit.MAX ? loc.units.MAX : parseFloat(amount) >= 0 ? String(amount) : undefined}
                placeholderTextColor={disabled ? colors.buttonDisabledTextColor : colors.alternativeTextColor2}
                style={[styles.input, stylesHook.input]}
                {...otherProps}
              />
            ) : (
              <Pressable onPress={resetAmount}>
                <Text style={[styles.input, stylesHook.input]}>{BitcoinUnit.MAX}</Text>
              </Pressable>
            )}
            {unit !== BitcoinUnit.LOCAL_CURRENCY && amount !== BitcoinUnit.MAX && (
              <Text style={[styles.cryptoCurrency, stylesHook.cryptoCurrency]}>{' ' + loc.units[unit]}</Text>
            )}
          </View>
          <View style={styles.secondaryRoot}>
            <Text style={styles.secondaryText} selectable>
              {secondaryDisplayCurrency}
            </Text>
          </View>
        </View>
        {!disabled && amount !== BitcoinUnit.MAX && (
          <TouchableOpacity
            accessibilityRole="button"
            accessibilityLabel={loc._.change_input_currency}
            testID="changeAmountUnitButton"
            style={styles.changeAmountUnit}
            onPress={changeAmountUnit}
          >
            <Image source={require('../img/round-compare-arrows-24-px.png')} />
          </TouchableOpacity>
        )}
      </View>
      {outdatedRefreshRate && (
        <View style={styles.outdatedRateContainer}>
          <Badge status="warning" />
          <View style={styles.spacing8} />
          <MalinText>{loc.formatString(loc.send.outdated_rate, { date: dayjs(outdatedRefreshRate.LastUpdated).format('l LT') })}</MalinText>
          <View style={styles.spacing8} />
          <TouchableOpacity
            accessibilityRole="button"
            accessibilityLabel={loc._.refresh}
            onPress={updateRate}
            disabled={isRateBeingUpdatedLocal}
            style={isRateBeingUpdatedLocal ? styles.disabledButton : styles.enabledButon}
          >
            <Icon name="sync" type="font-awesome-5" size={16} color={colors.buttonAlternativeTextColor} />
          </TouchableOpacity>
        </View>
      )}
    </Pressable>
  );
};

const styles = StyleSheet.create({
  root: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  center: {
    alignSelf: 'center',
  },
  flex: {
    flex: 1,
  },
  spacing8: {
    width: 8,
  },
  disabledButton: {
    opacity: 0.5,
  },
  enabledButon: {
    opacity: 1,
  },
  outdatedRateContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    margin: 16,
  },
  container: {
    flexDirection: 'row',
    alignContent: 'space-between',
    justifyContent: 'center',
    paddingTop: 16,
    paddingBottom: 2,
  },
  localCurrency: {
    fontSize: 18,
    marginHorizontal: 4,
    fontWeight: 'bold',
    alignSelf: 'center',
    justifyContent: 'center',
  },
  input: {
    fontWeight: 'bold',
  },
  cryptoCurrency: {
    fontSize: 15,
    marginHorizontal: 4,
    fontWeight: '600',
    alignSelf: 'center',
    justifyContent: 'center',
  },
  secondaryRoot: {
    alignItems: 'center',
    marginBottom: 22,
  },
  secondaryText: {
    fontSize: 16,
    color: '#9BA0A9',
    fontWeight: '600',
  },
  changeAmountUnit: {
    alignSelf: 'center',
    marginRight: 16,
    paddingLeft: 16,
    paddingVertical: 16,
  },
});


================================================
FILE: ./components/MalinLoading.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { ActivityIndicator, View, ViewProps, ActivityIndicatorProps, StyleSheet } from 'react-native';
import { useTheme } from './themes';

interface MalinLoadingProps extends ViewProps, Pick<ActivityIndicatorProps, 'size' | 'color'> {}

export const MalinLoading: React.FC<MalinLoadingProps> = props => {
  const { color, size, ...otherProps } = props;
  const { colors } = useTheme();

  return (
    <View style={styles.container} {...otherProps}>
      <ActivityIndicator size={size} color={color || colors.buttonTextColor} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center' },
});


================================================
FILE: ./components/MultipleStepsListItem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useRef } from 'react';
import {
  ActivityIndicator,
  findNodeHandle,
  GestureResponderEvent,
  Platform,
  StyleProp,
  StyleSheet,
  Text,
  Pressable,
  View,
  ViewStyle,
} from 'react-native';
import { Icon } from '@rneui/themed';
import ActionSheet from '../screen/ActionSheet';
import { useTheme } from './themes';
import { ActionSheetOptions } from '../screen/ActionSheet.common';

export enum MultipleStepsListItemDashType {
  None = 0,
  Top = 1,
  Bottom = 2,
  TopAndBottom = 3,
}

export enum MultipleStepsListItemButtonType {
  Partial = 0,
  Full = 1,
}

interface MultipleStepsListItemProps {
  circledText?: string;
  checked?: boolean;
  leftText?: string;
  showActivityIndicator?: boolean;
  isActionSheet?: boolean;
  actionSheetOptions?: ActionSheetOptions;
  dashes?: MultipleStepsListItemDashType;
  button?: {
    text?: string;
    onPress?: (e: GestureResponderEvent | number) => void;
    disabled?: boolean;
    buttonType?: MultipleStepsListItemButtonType;
    leftText?: string;
    showActivityIndicator?: boolean;
    testID?: string;
  };
  rightButton?: {
    text?: string;
    onPress?: () => void;
    disabled?: boolean;
    showActivityIndicator?: boolean;
  };
}

const MultipleStepsListItem = (props: MultipleStepsListItemProps) => {
  const { colors } = useTheme();
  const {
    showActivityIndicator = false,
    dashes = MultipleStepsListItemDashType.None,
    circledText = '',
    leftText = '',
    checked = false,
    isActionSheet = false,
    actionSheetOptions = null, // Default to null or appropriate default
  } = props;
  const stylesHook = StyleSheet.create({
    provideKeyButton: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    provideKeyButtonText: {
      color: colors.buttonTextColor,
    },
    vaultKeyCircle: {
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    vaultKeyText: {
      color: colors.alternativeTextColor,
    },
    vaultKeyCircleSuccess: {
      backgroundColor: colors.msSuccessBG,
    },
    rowPartialLeftText: {
      color: colors.alternativeTextColor,
    },
  });
  const selfRef = useRef(null); // Create a ref for the component itself

  const handleOnPressForActionSheet = () => {
    if (isActionSheet && actionSheetOptions) {
      // Clone options to modify them
      let modifiedOptions = { ...actionSheetOptions };

      // Use 'selfRef' if the component uses its own ref, or 'ref' if it's using forwarded ref
      const anchor = findNodeHandle(selfRef.current);

      if (anchor) {
        // Attach the anchor only if it exists
        modifiedOptions = { ...modifiedOptions, anchor };
      }

      ActionSheet.showActionSheetWithOptions(modifiedOptions, buttonIndex => {
        // Call the original onPress function, if provided, and not cancelled
        if (buttonIndex !== -1 && props.button?.onPress) {
          props.button.onPress(buttonIndex);
        }
      });
    }
  };

  const renderDashes = (): StyleProp<ViewStyle> => {
    switch (dashes) {
      case MultipleStepsListItemDashType.TopAndBottom:
        return {
          width: 1,
          borderStyle: 'dashed',
          borderWidth: 0.8,
          borderColor: '#c4c4c4',
          top: 0,
          bottom: 0,
          marginLeft: 20,
          position: 'absolute',
        };
      case MultipleStepsListItemDashType.Bottom:
        return {
          width: 1,
          borderStyle: 'dashed',
          borderWidth: 0.8,
          borderColor: '#c4c4c4',
          top: '50%',
          bottom: 0,
          marginLeft: 20,
          position: 'absolute',
        };
      case MultipleStepsListItemDashType.Top:
        return {
          width: 1,
          borderStyle: 'dashed',
          borderWidth: 0.8,
          borderColor: '#c4c4c4',
          top: 0,
          bottom: '50%',
          marginLeft: 20,
          position: 'absolute',
        };
      default:
        return {};
    }
  };
  const buttonOpacity = { opacity: props.button?.disabled ? 0.5 : 1.0 };
  const rightButtonOpacity = { opacity: props.rightButton?.disabled ? 0.5 : 1.0 };
  const onPress = isActionSheet ? handleOnPressForActionSheet : props.button?.onPress;
  return (
    <View>
      <View style={renderDashes()} />
      <View style={styles.container}>
        <View style={styles.itemKeyUnprovidedWrapper}>
          {checked ? (
            <View style={[styles.vaultKeyCircleSuccess, stylesHook.vaultKeyCircleSuccess]}>
              <Icon size={24} name="check" type="ionicons" color={colors.msSuccessCheck} />
            </View>
          ) : circledText.length > 0 ? (
            <View style={styles.itemKeyUnprovidedWrapper}>
              <View style={[styles.vaultKeyCircle, stylesHook.vaultKeyCircle]}>
                <Text style={[styles.vaultKeyText, stylesHook.vaultKeyText]}>{circledText}</Text>
              </View>
            </View>
          ) : null}
          {!showActivityIndicator && leftText.length > 0 && (
            <View style={styles.vaultKeyTextWrapper}>
              <Text style={[styles.vaultKeyText, stylesHook.vaultKeyText]}>{leftText}</Text>
            </View>
          )}
          {showActivityIndicator && <ActivityIndicator style={styles.activityIndicator} />}
        </View>
        {!showActivityIndicator && props.button && (
          <>
            {props.button.buttonType === undefined ||
              (props.button.buttonType === MultipleStepsListItemButtonType.Full && (
                <Pressable
                  ref={isActionSheet ? selfRef : null}
                  testID={props.button.testID}
                  accessibilityRole="button"
                  disabled={props.button.disabled}
                  android_ripple={{ color: colors.androidRippleColor }}
                  style={({ pressed }) => [
                    Platform.OS === 'ios' && pressed ? styles.pressed : null,
                    styles.provideKeyButton,
                    stylesHook.provideKeyButton,
                    buttonOpacity,
                  ]}
                  onPress={onPress}
                >
                  <Text style={[styles.provideKeyButtonText, stylesHook.provideKeyButtonText]}>{props.button.text}</Text>
                </Pressable>
              ))}
            {props.button.buttonType === MultipleStepsListItemButtonType.Partial && (
              <View style={styles.buttonPartialContainer}>
                <Text numberOfLines={1} style={[styles.rowPartialLeftText, stylesHook.rowPartialLeftText]} lineBreakMode="middle">
                  {props.button.leftText}
                </Text>
                <Pressable
                  testID={props.button.testID}
                  accessibilityRole="button"
                  disabled={props.button.disabled}
                  android_ripple={{ color: colors.androidRippleColor }}
                  style={({ pressed }) => [
                    Platform.OS === 'ios' && pressed ? styles.pressed : null,
                    styles.rowPartialRightButton,
                    stylesHook.provideKeyButton,
                    rightButtonOpacity,
                  ]}
                  onPress={onPress}
                >
                  {props.button.showActivityIndicator ? (
                    <ActivityIndicator />
                  ) : (
                    <Text style={[styles.provideKeyButtonText, stylesHook.provideKeyButtonText, styles.rightButton]}>
                      {props.button.text}
                    </Text>
                  )}
                </Pressable>
              </View>
            )}
          </>
        )}
        {!showActivityIndicator && props.rightButton && checked && (
          <View style={styles.rightButtonContainer}>
            <Pressable
              accessibilityRole="button"
              disabled={props.rightButton.disabled}
              style={({ pressed }) => [pressed && styles.pressed, styles.rightButton]}
              onPress={props.rightButton.onPress}
            >
              {props.rightButton.showActivityIndicator ? (
                <ActivityIndicator />
              ) : (
                <Text style={[styles.provideKeyButtonText, stylesHook.provideKeyButtonText]}>{props.rightButton.text}</Text>
              )}
            </Pressable>
          </View>
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    marginBottom: 16,
    flex: 1,
    justifyContent: 'space-between',
  },
  buttonPartialContainer: {
    borderRadius: 8,
    borderColor: '#EEF0F4',
    borderWidth: 1,
    height: 48,
    flex: 1,
    justifyContent: 'space-between',
    flexDirection: 'row',
    alignItems: 'center',
    paddingLeft: 16,
    paddingRight: 8,
    paddingVertical: 5,
    marginLeft: 40,
  },
  rowPartialRightButton: {
    height: 36,
    borderRadius: 8,
    alignSelf: 'flex-end',
    minWidth: 64,
    justifyContent: 'center',
  },
  itemKeyUnprovidedWrapper: { flexDirection: 'row' },
  vaultKeyCircle: {
    width: 42,
    height: 42,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    alignSelf: 'center',
  },
  vaultKeyText: { fontSize: 18, fontWeight: 'bold' },
  vaultKeyTextWrapper: { justifyContent: 'center', alignContent: 'flex-start', paddingLeft: 16 },
  provideKeyButton: {
    marginLeft: 40,
    height: 48,
    borderRadius: 8,
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 16,
  },
  rightButton: {
    borderRadius: 8,
    textAlign: 'center',
  },
  rightButtonContainer: {
    alignContent: 'center',
    justifyContent: 'center',
  },
  activityIndicator: {
    marginLeft: 40,
  },
  provideKeyButtonText: { fontWeight: '600', fontSize: 15 },
  vaultKeyCircleSuccess: {
    width: 42,
    height: 42,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  rowPartialLeftText: {
    textAlign: 'center',
  },
  pressed: {
    opacity: 0.6,
  },
});

export default MultipleStepsListItem;


================================================
FILE: ./components/CoinsSelected.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { Avatar } from '@rneui/themed';

import loc from '../loc';

const styles = StyleSheet.create({
  root: {
    height: 48,
    borderRadius: 8,
    backgroundColor: '#3477F6',
    flexDirection: 'row',
  },
  labelContainer: {
    flex: 1,
    justifyContent: 'center',
    paddingLeft: 16,
  },
  labelText: {
    color: 'white',
    fontWeight: 'bold',
  },
  buttonContainer: {
    width: 48,
    alignItems: 'center',
    justifyContent: 'center',
  },
  ball: {
    width: 26,
    height: 26,
    borderRadius: 13,
    backgroundColor: 'rgba(255, 255, 255, 0.32)',
  },
});

interface CoinsSelectedProps {
  number: number;
  onContainerPress: () => void;
  onClose: () => void;
}

const CoinsSelected: React.FC<CoinsSelectedProps> = ({ number, onContainerPress, onClose }) => (
  <TouchableOpacity accessibilityRole="button" style={styles.root} onPress={onContainerPress}>
    <View style={styles.labelContainer}>
      <Text style={styles.labelText}>{loc.formatString(loc.cc.coins_selected, { number })}</Text>
    </View>
    <TouchableOpacity accessibilityRole="button" style={styles.buttonContainer} onPress={onClose}>
      <Avatar rounded containerStyle={[styles.ball]} icon={{ name: 'close', size: 22, type: 'ionicons', color: 'white' }} />
    </TouchableOpacity>
  </TouchableOpacity>
);

export default CoinsSelected;


================================================
FILE: ./components/HeaderMenuButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { Pressable, Platform } from 'react-native';
import ToolTipMenu from './TooltipMenu';
import { useTheme } from './themes';
import { Icon } from '@rneui/themed';
import { Action } from './types';

interface HeaderMenuButtonProps {
  onPressMenuItem: (id: string) => void;
  actions?: Action[] | Action[][];
  disabled?: boolean;
  title?: string;
}

const HeaderMenuButton: React.FC<HeaderMenuButtonProps> = ({ onPressMenuItem, actions, disabled, title }) => {
  const { colors } = useTheme();
  const styleProps = Platform.OS === 'android' ? { iconStyle: { transform: [{ rotate: '90deg' }] } } : {};

  if (!actions || actions.length === 0) {
    return (
      <Pressable
        testID="HeaderMenuButton"
        disabled={disabled}
        android_ripple={{ color: colors.lightButton }}
        style={({ pressed }) => [{ opacity: pressed ? 0.5 : 1 }]}
      >
        <Icon size={22} name="more-horiz" type="material" color={colors.foregroundColor} {...styleProps} />
      </Pressable>
    );
  }

  const menuActions = Array.isArray(actions[0]) ? (actions as Action[][]) : (actions as Action[]);

  return (
    <ToolTipMenu
      testID="HeaderMenuButton"
      disabled={disabled}
      isButton
      isMenuPrimaryAction
      onPressMenuItem={onPressMenuItem}
      actions={menuActions}
      title={title}
    >
      <Icon size={22} name="more-horiz" type="material" color={colors.foregroundColor} {...styleProps} />
    </ToolTipMenu>
  );
};

export default HeaderMenuButton;


================================================
FILE: ./components/Header.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { useTheme } from './themes';
import AddWalletButton from './AddWalletButton';

interface HeaderProps {
  leftText: string;
  isDrawerList?: boolean;
  onNewWalletPress?: () => void;
}

export const Header: React.FC<HeaderProps> = ({ leftText, isDrawerList, onNewWalletPress }) => {
  const { colors } = useTheme();
  const styleWithProps = StyleSheet.create({
    root: {
      backgroundColor: isDrawerList ? colors.elevated : colors.background,
      borderTopColor: isDrawerList ? colors.elevated : colors.background,
      borderBottomColor: isDrawerList ? colors.elevated : colors.background,
    },
    text: {
      color: colors.foregroundColor,
    },
  });

  return (
    <View style={[styles.root, styleWithProps.root]}>
      <Text style={[styles.text, styleWithProps.text]}>{leftText}</Text>
      {onNewWalletPress && <AddWalletButton onPress={onNewWalletPress} />}
    </View>
  );
};

const styles = StyleSheet.create({
  root: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    marginBottom: 8,
  },
  text: {
    textAlign: 'left',
    fontWeight: 'bold',
    fontSize: 34,
  },
});


================================================
FILE: ./components/Tabs.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, TouchableOpacity, View } from 'react-native';

import { useTheme } from './themes';

const tabsStyles = StyleSheet.create({
  root: {
    flexDirection: 'row',
    height: 50,
    borderColor: '#e3e3e3',
    borderBottomWidth: 1,
  },
  tabRoot: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    borderColor: 'white',
    borderBottomWidth: 2,
  },
  activeTabRoot: {
    borderColor: 'transparent',
    borderBottomWidth: 2,
  },
  marginBottom: {
    marginBottom: 30,
  },
});

interface TabProps {
  active: boolean;
}

interface TabsProps {
  active: number;
  onSwitch: (index: number) => void;
  tabs: React.ComponentType<TabProps>[];
  isIpad?: boolean;
}

export const Tabs: React.FC<TabsProps> = ({ active, onSwitch, tabs, isIpad = false }) => {
  const { colors } = useTheme();
  return (
    <View style={[tabsStyles.root, isIpad && tabsStyles.marginBottom]}>
      {tabs.map((Tab, i) => (
        <TouchableOpacity
          key={i}
          accessibilityRole="button"
          onPress={() => onSwitch(i)}
          style={[tabsStyles.tabRoot, active === i && { ...tabsStyles.activeTabRoot, borderColor: colors.buttonAlternativeTextColor }]}
        >
          <Tab active={active === i} />
        </TouchableOpacity>
      ))}
    </View>
  );
};


================================================
FILE: ./components/TransactionListItem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useEffect, useMemo, useRef, useState, memo } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Clipboard from '@react-native-clipboard/clipboard';
import { Linking, View, ViewStyle, StyleSheet } from 'react-native';
import Lnurl from '../class/lnurl';
import { EthereumTransaction, LightningTransaction, SolanaTransaction, Transaction } from '../class/wallets/types';
import TransactionExpiredIcon from '../components/icons/TransactionExpiredIcon';
import TransactionIncomingIcon from '../components/icons/TransactionIncomingIcon';
import TransactionOffchainIcon from '../components/icons/TransactionOffchainIcon';
import TransactionOffchainIncomingIcon from '../components/icons/TransactionOffchainIncomingIcon';
import TransactionOnchainIcon from '../components/icons/TransactionOnchainIcon';
import TransactionOutgoingIcon from '../components/icons/TransactionOutgoingIcon';
import TransactionPendingIcon from '../components/icons/TransactionPendingIcon';
import loc, { formatBalanceWithoutSuffix, transactionTimeToReadable } from '../loc';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { useSettings } from '../hooks/context/useSettings';
import ListItem from './ListItem';
import { useTheme } from './themes';
import { Action, ToolTipMenuProps } from './types';
import { useExtendedNavigation } from '../hooks/useExtendedNavigation';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../navigation/DetailViewStackParamList';
import { useStorage } from '../hooks/context/useStorage';
import ToolTipMenu from './TooltipMenu';
import { CommonToolTipActions } from '../typings/CommonToolTipActions';
import { pop } from '../NavigationService';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import HighlightedText from './HighlightedText';
import { EthereumWallet, SolanaWallet } from '../class';

const styles = StyleSheet.create({
  subtitle: {
    color: 'colors.foregroundColor',
    fontSize: 13,
  },
  highlight: {
    backgroundColor: '#FFF5C0',
    color: '#000000',
    fontSize: 13,
    fontWeight: '600',
  },
});

interface TransactionListItemProps {
  itemPriceUnit?: BitcoinUnit;
  walletID: string;
  item: Transaction | LightningTransaction | EthereumTransaction | SolanaTransaction;
  searchQuery?: string;
  style?: ViewStyle;
  renderHighlightedText?: (text: string, query: string) => JSX.Element;
  onPress?: () => void;
}

type NavigationProps = NativeStackNavigationProp<DetailViewStackParamList>;

const isBitcoinTransaction = (tx: any): tx is Transaction => typeof tx.txid === 'string';
const isLightningTransaction = (tx: any): tx is LightningTransaction => tx.type === 'user_invoice' || tx.type === 'payment_request' || tx.type === 'paid_invoice' || tx.type === 'bitcoind_tx';
const isEthereumTransaction = (tx: any): tx is EthereumTransaction => typeof tx.gasPrice === 'number';
const isSolanaTransaction = (tx: any): tx is SolanaTransaction => typeof tx.slot === 'number';

export const TransactionListItem: React.FC<TransactionListItemProps> = memo(
  ({
    item,
    itemPriceUnit = BitcoinUnit.BTC,
    walletID,
    searchQuery,
    style,
    renderHighlightedText,
    onPress: customOnPress,
  }: TransactionListItemProps) => {
    const [subtitleNumberOfLines, setSubtitleNumberOfLines] = useState(1);
    const { colors } = useTheme();
    const { navigate } = useExtendedNavigation<NavigationProps>();
    const menuRef = useRef<ToolTipMenuProps>();
    const { txMetadata, counterpartyMetadata, wallets } = useStorage();
    const { language, selectedBlockExplorer } = useSettings();
    const wallet = wallets.find(w => w.getID() === walletID);
    const insets = useSafeAreaInsets();
    const containerStyle = useMemo(
      () => ({
        backgroundColor: colors.background,
        borderBottomColor: colors.lightBorder,
        paddingLeft: 16,
        paddingRight: 16,
      }),
      [colors.background, colors.lightBorder],
    );

    const combinedStyle = useMemo(() => [containerStyle, style], [containerStyle, style]);

    const normalizedTx = useMemo(() => {
      if (isEthereumTransaction(item) && wallet) {
        const direction = item.from.toLowerCase() === wallet.getAddress().toLowerCase() ? 'sent' : 'received';
        const value = parseFloat(formatBalanceWithoutSuffix(item.value, BitcoinUnit.ETH).toString());
        return {
          hash: item.hash,
          value: direction === 'sent' ? -value : value,
          timestamp: item.timestamp,
          confirmations: item.confirmations,
          direction,
          memo: '',
        };
      } else if (isSolanaTransaction(item) && wallet) {
        const walletAddress = wallet.getAddress();
        const preBalance = item.preBalances[0] ?? 0;
        const postBalance = item.postBalances[0] ?? 0;
        const value = postBalance - preBalance;
        const direction = value > 0 ? 'received' : 'sent';
        return {
          hash: item.signature,
          value: parseFloat(formatBalanceWithoutSuffix(Math.abs(value), BitcoinUnit.SOL).toString()),
          timestamp: item.blockTime,
          confirmations: item.slot ? 1 : 0,
          direction,
          memo: item.memo ?? '',
        };
      } else if (isLightningTransaction(item)) {
         return {
          hash: (item.payment_hash && typeof item.payment_hash === 'string') ? item.payment_hash : '',
          value: item.value ?? 0,
          timestamp: item.timestamp,
          confirmations: 99, // LN txs are instant
          direction: item.value && item.value < 0 ? 'sent' : 'received',
          memo: item.memo ?? '',
        };
      } else if (isBitcoinTransaction(item)) {
        return {
          hash: item.hash,
          value: item.value,
          timestamp: item.timestamp,
          confirmations: item.confirmations,
          direction: item.value && item.value < 0 ? 'sent' : 'received',
          memo: txMetadata[item.hash]?.memo ?? '',
        };
      }
      return null;
    }, [item, wallet, txMetadata]);

    const shortenContactName = (name: string): string => {
      if (name.length < 16) return name;
      return name.substr(0, 7) + '...' + name.substr(name.length - 7, 7);
    };

    const title = useMemo(() => {
      if (normalizedTx && normalizedTx.confirmations === 0) {
        return loc.transactions.pending;
      } else if (normalizedTx) {
        return transactionTimeToReadable(normalizedTx.timestamp);
      }
      return '';
    }, [normalizedTx, language]);

    let counterparty;
    if ('counterparty' in item && item.counterparty) {
      counterparty = counterpartyMetadata?.[item.counterparty]?.label ?? item.counterparty;
    }
    const txMemo = (counterparty ? `[${shortenContactName(counterparty)}] ` : '') + (normalizedTx?.memo ?? '');
    const subtitle = useMemo(() => {
      if (!normalizedTx) return '';
      let sub = Number(normalizedTx.confirmations) < 7 ? loc.formatString(loc.transactions.list_conf, { number: normalizedTx.confirmations }) : '';
      if (sub !== '') sub += ' ';
      sub += txMemo;
      if (isLightningTransaction(item) && item.memo) sub += item.memo;
      return sub || undefined;
    }, [normalizedTx, txMemo, item]);

    const formattedAmount = useMemo(() => {
      if (!normalizedTx) return '';
      return formatBalanceWithoutSuffix(normalizedTx.value, itemPriceUnit, true).toString();
    }, [normalizedTx, itemPriceUnit]);

    const rowTitle = useMemo(() => {
      if (isLightningTransaction(item) && (item.type === 'user_invoice' || item.type === 'payment_request')) {
        const currentDate = new Date();
        const now = Math.floor(currentDate.getTime() / 1000);
        const invoiceExpiration = item.timestamp! + (item.expire_time ?? 0);
        if (invoiceExpiration > now || item.ispaid) {
          return formattedAmount;
        } else {
          return loc.lnd.expired;
        }
      }
      return formattedAmount;
    }, [item, formattedAmount]);

    const rowTitleStyle = useMemo(() => {
      if (!normalizedTx) return {};
      let color = colors.successColor;

      if (isLightningTransaction(item) && (item.type === 'user_invoice' || item.type === 'payment_request')) {
        const currentDate = new Date();
        const now = (currentDate.getTime() / 1000) | 0;
        const invoiceExpiration = item.timestamp! + (item.expire_time ?? 0);

        if (invoiceExpiration > now) {
          color = colors.successColor;
        } else if (invoiceExpiration < now) {
          if (item.ispaid) {
            color = colors.successColor;
          } else {
            color = '#9AA0AA';
          }
        }
      } else if (normalizedTx.direction === 'sent') {
        color = colors.foregroundColor;
      }

      return {
        color,
        fontSize: 14,
        fontWeight: '600',
        textAlign: 'right',
        paddingRight: insets.right,
        paddingLeft: insets.left,
      };
    }, [
      colors.successColor,
      colors.foregroundColor,
      item,
      normalizedTx,
      insets.right,
      insets.left,
    ]);

    const determineTransactionTypeAndAvatar = () => {
      if (!normalizedTx) return { label: '', icon: null };
      if (isLightningTransaction(item)) {
        if (item.category === 'receive' && item.confirmations! < 3) {
            return {
            label: loc.transactions.pending_transaction,
            icon: <TransactionPendingIcon />,
            };
        }

        if (item.type && item.type === 'bitcoind_tx') {
            return {
            label: loc.transactions.onchain,
            icon: <TransactionOnchainIcon />,
            };
        }

        if (item.type === 'paid_invoice') {
            return {
            label: loc.transactions.offchain,
            icon: <TransactionOffchainIcon />,
            };
        }

        if (item.type === 'user_invoice' || item.type === 'payment_request') {
            const currentDate = new Date();
            const now = (currentDate.getTime() / 1000) | 0; // eslint-disable-line no-bitwise
            const invoiceExpiration = item.timestamp! + (item.expire_time ?? 0);
            if (!item.ispaid && invoiceExpiration < now) {
            return {
                label: loc.transactions.expired_transaction,
                icon: <TransactionExpiredIcon />,
            };
            } else if (!item.ispaid) {
            return {
                label: loc.transactions.expired_transaction,
                icon: <TransactionPendingIcon />,
            };
            } else {
            return {
                label: loc.transactions.incoming_transaction,
                icon: <TransactionOffchainIncomingIcon />,
            };
            }
        }
      }

      if (!normalizedTx.confirmations) {
        return {
          label: loc.transactions.pending_transaction,
          icon: <TransactionPendingIcon />,
        };
      } else if (normalizedTx.direction === 'sent') {
        return {
          label: loc.transactions.outgoing_transaction,
          icon: <TransactionOutgoingIcon />,
        };
      } else {
        return {
          label: loc.transactions.incoming_transaction,
          icon: <TransactionIncomingIcon />,
        };
      }
    };

    const { label: transactionTypeLabel, icon: avatar } = determineTransactionTypeAndAvatar();

    const amountWithUnit = useMemo(() => {
      const unitSuffix = itemPriceUnit === BitcoinUnit.BTC || itemPriceUnit === BitcoinUnit.SATS || itemPriceUnit === BitcoinUnit.ETH || itemPriceUnit === BitcoinUnit.SOL ? ` ${itemPriceUnit}` : ' ';
      return `${formattedAmount}${unitSuffix}`;
    }, [formattedAmount, itemPriceUnit]);

    useEffect(() => {
      setSubtitleNumberOfLines(1);
    }, [subtitle]);

    const onPress = useCallback(async () => {
      menuRef?.current?.dismissMenu?.();
      if (customOnPress) {
        customOnPress();
        return;
      }

      if (normalizedTx?.hash) {
        if (renderHighlightedText) {
          pop();
        }
        if (wallet?.type === EthereumWallet.type || wallet?.type === SolanaWallet.type || wallet?.type.startsWith('bitcoin')) {
          navigate('TransactionStatus', { hash: normalizedTx.hash, walletID });
        }
      } else if (isLightningTransaction(item) && (item.type === 'user_invoice' || item.type === 'payment_request' || item.type === 'paid_invoice')) {
        const lightningWallet = wallets.find(w => w.getID() === item.walletID);
        if (lightningWallet) {
          try {
            const LN = new Lnurl(false, AsyncStorage);
            let paymentHash = item.payment_hash!;
            if (typeof paymentHash === 'object') {
              paymentHash = Buffer.from(paymentHash.data).toString('hex');
            }
            const loaded = await LN.loadSuccessfulPayment(paymentHash);
            if (loaded) {
              navigate('ScanLNDInvoiceRoot', {
                screen: 'LnurlPaySuccess',
                params: {
                  paymentHash,
                  justPaid: false,
                  fromWalletID: lightningWallet.getID(),
                },
              });
              return;
            }
          } catch (e) {
            console.debug(e);
          }

          navigate('LNDViewInvoice', {
            invoice: item,
            walletID: lightningWallet.getID(),
          });
        }
      } else {
        console.log('cant handle press');
      }
    }, [normalizedTx, item, renderHighlightedText, navigate, walletID, wallets, customOnPress, wallet]);

    const handleOnExpandNote = useCallback(() => {
      setSubtitleNumberOfLines(0);
    }, []);

    const handleOnDetailsPress = useCallback(() => {
      if (walletID && normalizedTx && normalizedTx.hash) {
        navigate('TransactionDetails', { tx: item, hash: normalizedTx.hash, walletID });
      } else if (isLightningTransaction(item)) {
        const lightningWallet = wallets.find(w => w.getID() === item.walletID);
        if (lightningWallet) {
          navigate('LNDViewInvoice', {
            invoice: item,
            walletID: lightningWallet.getID(),
          });
        }
      }
    }, [item, navigate, walletID, wallets, normalizedTx]);

    const handleOnCopyAmountTap = useCallback(() => Clipboard.setString(rowTitle.replace(/[\s\-]/g, '')), [rowTitle]);
    const handleOnCopyTransactionID = useCallback(() => Clipboard.setString(normalizedTx?.hash ?? ''), [normalizedTx]);
    const handleOnCopyNote = useCallback(() => Clipboard.setString(subtitle ?? ''), [subtitle]);
    
    const handleOnViewOnBlockExplorer = useCallback(() => {
      let url = '';
      if (wallet?.type === EthereumWallet.type) {
        url = `https://etherscan.io/tx/${normalizedTx?.hash}`;
      } else if (wallet?.type === SolanaWallet.type) {
        url = `https://solscan.io/tx/${normalizedTx?.hash}`;
      } else {
        url = `${selectedBlockExplorer.url}/tx/${normalizedTx?.hash}`;
      }

      Linking.canOpenURL(url).then(supported => {
        if (supported) {
          Linking.openURL(url);
        }
      });
    }, [normalizedTx, wallet, selectedBlockExplorer]);
    
    const handleCopyOpenInBlockExplorerPress = useCallback(() => {
      let url = '';
      if (wallet?.type === EthereumWallet.type) {
        url = `https://etherscan.io/tx/${normalizedTx?.hash}`;
      } else if (wallet?.type === SolanaWallet.type) {
        url = `https://solscan.io/tx/${normalizedTx?.hash}`;
      } else {
        url = `${selectedBlockExplorer.url}/tx/${normalizedTx?.hash}`;
      }
      Clipboard.setString(url);
    }, [normalizedTx, wallet, selectedBlockExplorer]);

    const onToolTipPress = useCallback(
      (id: any) => {
        if (id === CommonToolTipActions.CopyAmount.id) {
          handleOnCopyAmountTap();
        } else if (id === CommonToolTipActions.CopyNote.id) {
          handleOnCopyNote();
        } else if (id === CommonToolTipActions.OpenInBlockExplorer.id) {
          handleOnViewOnBlockExplorer();
        } else if (id === CommonToolTipActions.ExpandNote.id) {
          handleOnExpandNote();
        } else if (id === CommonToolTipActions.CopyBlockExplorerLink.id) {
          handleCopyOpenInBlockExplorerPress();
        } else if (id === CommonToolTipActions.CopyTXID.id) {
          handleOnCopyTransactionID();
        } else if (id === CommonToolTipActions.Details.id) {
          handleOnDetailsPress();
        }
      },
      [
        handleCopyOpenInBlockExplorerPress,
        handleOnCopyAmountTap,
        handleOnCopyNote,
        handleOnCopyTransactionID,
        handleOnDetailsPress,
        handleOnExpandNote,
        handleOnViewOnBlockExplorer,
      ],
    );
    const toolTipActions = useMemo((): Action[] => {
      const actions: (Action | Action[])[] = [
        {
          ...CommonToolTipActions.CopyAmount,
          hidden: rowTitle === loc.lnd.expired,
        },
        {
          ...CommonToolTipActions.CopyNote,
          hidden: !subtitle,
        },
        {
          ...CommonToolTipActions.CopyTXID,
          hidden: !normalizedTx?.hash,
        },
        {
          ...CommonToolTipActions.CopyBlockExplorerLink,
          hidden: !normalizedTx?.hash,
        },
        [{ ...CommonToolTipActions.OpenInBlockExplorer, hidden: !normalizedTx?.hash }, CommonToolTipActions.Details],
        [
          {
            ...CommonToolTipActions.ExpandNote,
            hidden: subtitleNumberOfLines !== 1,
          },
        ],
      ];

      return actions as Action[];
    }, [rowTitle, subtitle, normalizedTx, subtitleNumberOfLines]);

    const accessibilityState = useMemo(() => {
      return {
        expanded: subtitleNumberOfLines === 0,
      };
    }, [subtitleNumberOfLines]);

    const subtitleProps = useMemo(() => ({ numberOfLines: subtitleNumberOfLines }), [subtitleNumberOfLines]);

    return (
      <ToolTipMenu
        isButton
        actions={toolTipActions}
        onPressMenuItem={onToolTipPress}
        onPress={onPress}
        accessibilityLabel={`${transactionTypeLabel}, ${amountWithUnit}, ${subtitle ?? title}`}
        accessibilityRole="button"
        accessibilityState={accessibilityState}
      >
        <ListItem
          leftAvatar={avatar}
          title={title}
          subtitleNumberOfLines={subtitleNumberOfLines}
          subtitle={
            subtitle ? (
              renderHighlightedText ? (
                renderHighlightedText(subtitle, searchQuery ?? '')
              ) : (
                <HighlightedText
                  text={subtitle}
                  query={searchQuery ?? ''}
                  caseSensitive={false}
                  highlightOnlyFirstMatch={searchQuery ? searchQuery.length === 1 : false}
                  style={styles.subtitle}
                />
              )
            ) : undefined
          }
          Component={View}
          subtitleProps={subtitleProps}
          chevron={false}
          rightTitle={rowTitle}
          rightTitleStyle={rowTitleStyle}
          containerStyle={combinedStyle}
          testID="TransactionListItem"
        />
      </ToolTipMenu>
    );
  },
  (prevProps, nextProps) => {
    return (
      prevProps.item.hash === nextProps.item.hash &&
      prevProps.item.timestamp === nextProps.item.timestamp &&
      prevProps.itemPriceUnit === nextProps.itemPriceUnit &&
      prevProps.walletID === nextProps.walletID &&
      prevProps.searchQuery === nextProps.searchQuery
    );
  },
);

================================================
FILE: ./components/ListItem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo } from 'react';
import { ActivityIndicator, Pressable, PressableProps, StyleSheet, Switch, TouchableOpacity, View } from 'react-native';
import { Avatar, ListItem as RNElementsListItem, Button } from '@rneui/themed'; // Replace with actual import paths
import { useLocale } from '@react-navigation/native';

import { useTheme } from './themes';

// Update the type for the props
interface ListItemProps {
  swipeable?: boolean;
  rightIcon?: any;
  leftAvatar?: React.JSX.Element;
  containerStyle?: object;
  Component?: typeof React.Component | typeof PressableWrapper;
  bottomDivider?: boolean;
  topDivider?: boolean;
  testID?: string;
  onPress?: () => void;
  onLongPress?: () => void;
  onDeletePressed?: () => void;
  disabled?: boolean;
  switch?: object; // Define more specific type if needed
  leftIcon?: any; // Define more specific type if needed
  title: string;
  subtitle?: string | React.ReactNode;
  subtitleNumberOfLines?: number;
  rightTitle?: string;
  rightTitleStyle?: object;
  isLoading?: boolean;
  chevron?: boolean;
  checkmark?: boolean;
  subtitleProps?: object;
  swipeableLeftContent?: React.ReactNode;
  swipeableRightContent?: React.ReactNode;
}

export class PressableWrapper extends React.Component<PressableProps> {
  render() {
    return <Pressable {...this.props} />;
  }
}

export class TouchableOpacityWrapper extends React.Component {
  render() {
    return <TouchableOpacity {...this.props} />;
  }
}

// Define Swipeable Button Components
const DefaultRightContent: React.FC<{ reset: () => void; onDeletePressed?: () => void }> = ({ reset, onDeletePressed }) => (
  <Button
    title="Delete"
    onPress={() => {
      reset();
      onDeletePressed?.();
    }}
    icon={{ name: 'delete', color: 'white' }}
    buttonStyle={styles.rightButton}
  />
);

const ListItem: React.FC<ListItemProps> = React.memo(
  ({
    swipeable = false,
    Component = TouchableOpacityWrapper,
    rightIcon,
    leftAvatar,
    containerStyle,
    bottomDivider = true,
    topDivider = false,
    testID,
    onPress,
    onLongPress,
    onDeletePressed,
    disabled,
    switch: switchProps,
    leftIcon,
    title,
    subtitle,
    subtitleNumberOfLines,
    rightTitle,
    rightTitleStyle,
    isLoading,
    chevron,
    checkmark,
    swipeableLeftContent,
    swipeableRightContent,
  }: ListItemProps) => {
    const { colors } = useTheme();
    const { direction } = useLocale();
    const stylesHook = StyleSheet.create({
      title: {
        color: disabled ? colors.buttonDisabledTextColor : colors.foregroundColor,
        fontSize: 16,
        fontWeight: '500',
        writingDirection: direction,
      },
      subtitle: {
        flexWrap: 'wrap',
        writingDirection: direction,
        color: colors.alternativeTextColor,
        fontWeight: '400',
        paddingVertical: switchProps ? 8 : 0,
        lineHeight: 20,
        fontSize: 14,
      },

      containerStyle: {
        backgroundColor: colors.background,
      },
    });

    const memoizedSwitchProps = useMemo(() => {
      return switchProps ? { ...switchProps } : undefined;
    }, [switchProps]);

    const renderContent = () => (
      <>
        {leftIcon && (
          <>
            <View style={styles.width16} />
            <Avatar icon={leftIcon} />
          </>
        )}
        {leftAvatar && (
          <>
            {leftAvatar}
            <View style={styles.width16} />
          </>
        )}
        <RNElementsListItem.Content>
          <RNElementsListItem.Title style={stylesHook.title} numberOfLines={0} accessible={switchProps === undefined}>
            {title}
          </RNElementsListItem.Title>
          {subtitle && (
            <RNElementsListItem.Subtitle
              numberOfLines={switchProps ? 0 : (subtitleNumberOfLines ?? 1)}
              accessible={switchProps === undefined}
              style={stylesHook.subtitle}
            >
              {subtitle}
            </RNElementsListItem.Subtitle>
          )}
        </RNElementsListItem.Content>

        {rightTitle && (
          <View style={styles.margin8}>
            <RNElementsListItem.Title style={rightTitleStyle} numberOfLines={0}>
              {rightTitle}
            </RNElementsListItem.Title>
          </View>
        )}
        {isLoading ? (
          <ActivityIndicator />
        ) : (
          <>
            {chevron && <RNElementsListItem.Chevron iconStyle={{ transform: [{ scaleX: direction === 'rtl' ? -1 : 1 }] }} />}
            {rightIcon && <Avatar icon={rightIcon} />}
            {switchProps && (
              <Switch {...memoizedSwitchProps} accessibilityLabel={title} style={styles.margin16} accessible accessibilityRole="switch" />
            )}
            {checkmark && (
              <RNElementsListItem.CheckBox
                iconRight
                containerStyle={stylesHook.containerStyle}
                iconType="octaicon"
                checkedIcon="check"
                checked
              />
            )}
          </>
        )}
      </>
    );

    if (swipeable && !Component) {
      console.warn('Component prop is required when swipeable is true.');
      return null;
    }

    return swipeable ? (
      <RNElementsListItem.Swipeable
        containerStyle={containerStyle ?? stylesHook.containerStyle}
        Component={Component}
        bottomDivider={bottomDivider}
        topDivider={topDivider}
        testID={testID}
        onPress={onPress}
        onLongPress={onLongPress}
        disabled={disabled}
        leftContent={swipeableLeftContent}
        rightContent={swipeableRightContent ?? <DefaultRightContent reset={() => {}} onDeletePressed={onDeletePressed} />}
        accessible={switchProps === undefined}
      >
        {renderContent()}
      </RNElementsListItem.Swipeable>
    ) : (
      <RNElementsListItem
        containerStyle={containerStyle ?? stylesHook.containerStyle}
        Component={Component}
        bottomDivider={bottomDivider}
        topDivider={topDivider}
        testID={testID}
        onPress={onPress}
        onLongPress={onLongPress}
        disabled={disabled}
        accessible={switchProps === undefined}
      >
        {renderContent()}
      </RNElementsListItem>
    );
  },
);

export default ListItem;

const styles = StyleSheet.create({
  rightButton: {
    minHeight: '100%',
    backgroundColor: 'red',
  },
  margin8: {
    margin: 8,
  },
  margin16: {
    marginLeft: 16,
  },
  width16: { width: 16 },
});


================================================
FILE: ./components/CameraScreen.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState, useRef } from 'react';
import { Animated, Platform, StyleSheet, TouchableOpacity, View } from 'react-native';
// @ts-ignore: no declaration file yet
import { Camera, CameraApi, CameraType, Orientation } from 'react-native-camera-kit';
import loc from '../loc';
import { Icon } from '@rneui/base';
import { triggerSelectionHapticFeedback } from '../malin_modules/hapticFeedback';
import { isDesktop } from '../malin_modules/environment';
// @ts-ignore: no declaration file yet
import { OnOrientationChangeData, OnReadCodeData } from 'react-native-camera-kit/dist/CameraProps';

interface CameraScreenProps {
  onCancelButtonPress: () => void;
  showImagePickerButton?: boolean;
  showFilePickerButton?: boolean;
  onImagePickerButtonPress?: () => void;
  onFilePickerButtonPress?: () => void;
  onReadCode?: (event: OnReadCodeData) => void;
}

const CameraScreen: React.FC<CameraScreenProps> = ({
  onCancelButtonPress,
  showImagePickerButton,
  showFilePickerButton,
  onImagePickerButtonPress,
  onFilePickerButtonPress,
  onReadCode,
}) => {
  const cameraRef = useRef<CameraApi>(null);
  const [torchMode, setTorchMode] = useState(false);
  const [cameraType, setCameraType] = useState(CameraType.Back);
  const [zoom, setZoom] = useState<number | undefined>();
  const [orientationAnim] = useState(new Animated.Value(3));

  const onSwitchCameraPressed = () => {
    const direction = cameraType === CameraType.Back ? CameraType.Front : CameraType.Back;
    setCameraType(direction);
    setZoom(1); // When changing camera type, reset to default zoom for that camera
    triggerSelectionHapticFeedback();
  };

  const onSetTorch = () => {
    setTorchMode(!torchMode);
    triggerSelectionHapticFeedback();
  };

  // Counter-rotate the icons to indicate the actual orientation of the captured photo.
  // For this example, it'll behave incorrectly since UI orientation is allowed (and already-counter rotates the entire screen)
  // For real phone apps, lock your UI orientation using a library like 'react-native-orientation-locker'
  const rotateUi = true;
  const uiRotation = orientationAnim.interpolate({
    inputRange: [1, 2, 3, 4],
    outputRange: ['180deg', '90deg', '0deg', '-90deg'],
  });
  const uiRotationStyle = rotateUi ? { transform: [{ rotate: uiRotation }] } : {};

  function rotateUiTo(rotationValue: number) {
    Animated.timing(orientationAnim, {
      toValue: rotationValue,
      useNativeDriver: true,
      duration: 200,
      isInteraction: false,
    }).start();
  }

  const handleZoom = (e: { nativeEvent: { zoom: number } }) => {
    console.debug('zoom', e.nativeEvent.zoom);
    setZoom(e.nativeEvent.zoom);
  };

  const handleOrientationChange = (e: OnOrientationChangeData) => {
    switch (e.nativeEvent.orientation) {
      case Orientation.PORTRAIT_UPSIDE_DOWN:
        console.debug('orientationChange', 'PORTRAIT_UPSIDE_DOWN');
        rotateUiTo(1);
        break;
      case Orientation.LANDSCAPE_LEFT:
        console.debug('orientationChange', 'LANDSCAPE_LEFT');
        rotateUiTo(2);
        break;
      case Orientation.PORTRAIT:
        console.debug('orientationChange', 'PORTRAIT');
        rotateUiTo(3);
        break;
      case Orientation.LANDSCAPE_RIGHT:
        console.debug('orientationChange', 'LANDSCAPE_RIGHT');
        rotateUiTo(4);
        break;
      default:
        console.debug('orientationChange', e.nativeEvent);
        break;
    }
  };

  const handleReadCode = (event: OnReadCodeData) => {
    onReadCode?.(event);
  };

  return (
    <View style={styles.screen}>
      {/* Render top buttons only if not desktop as they would not be relevant */}
      {!isDesktop && (
        <View style={styles.topButtons}>
          <TouchableOpacity style={[styles.topButton, uiRotationStyle, torchMode ? styles.activeTorch : {}]} onPress={onSetTorch}>
            <Animated.View style={styles.topButtonImg}>
              {Platform.OS === 'ios' ? (
                <Icon name={torchMode ? 'flashlight-on' : 'flashlight-off'} type="font-awesome-6" color={torchMode ? '#000' : '#fff'} />
              ) : (
                <Icon name={torchMode ? 'flash-on' : 'flash-off'} type="ionicons" color={torchMode ? '#000' : '#fff'} />
              )}
            </Animated.View>
          </TouchableOpacity>
          <View style={styles.rightButtonsContainer}>
            {showImagePickerButton && (
              <TouchableOpacity
                accessibilityRole="button"
                accessibilityLabel={loc._.pick_image}
                style={[styles.topButton, styles.spacing, uiRotationStyle]}
                onPress={onImagePickerButtonPress}
              >
                <Animated.View style={styles.topButtonImg}>
                  <Icon name="image" type="font-awesome" color="#ffffff" />
                </Animated.View>
              </TouchableOpacity>
            )}
            {showFilePickerButton && (
              <TouchableOpacity
                accessibilityRole="button"
                accessibilityLabel={loc._.pick_file}
                style={[styles.topButton, styles.spacing, uiRotationStyle]}
                onPress={onFilePickerButtonPress}
              >
                <Animated.View style={styles.topButtonImg}>
                  <Icon name="file-import" type="font-awesome-5" color="#ffffff" />
                </Animated.View>
              </TouchableOpacity>
            )}
          </View>
        </View>
      )}
      <View style={styles.cameraContainer}>
        <Camera
          ref={cameraRef}
          style={styles.cameraPreview}
          cameraType={cameraType}
          scanBarcode
          resizeMode="cover"
          onReadCode={handleReadCode}
          torchMode={torchMode ? 'on' : 'off'}
          resetFocusWhenMotionDetected
          zoom={zoom}
          onZoom={handleZoom}
          maxZoom={10}
          onOrientationChange={handleOrientationChange}
        />
      </View>
      <View style={styles.bottomButtons}>
        <TouchableOpacity onPress={onCancelButtonPress}>
          <Animated.Text style={[styles.backTextStyle, uiRotationStyle]}>{loc._.cancel}</Animated.Text>
        </TouchableOpacity>
        {isDesktop ? (
          <View style={styles.rightButtonsContainer}>
            {showImagePickerButton && (
              <TouchableOpacity
                accessibilityRole="button"
                accessibilityLabel={loc._.pick_image}
                style={[styles.bottomButton, styles.spacing, uiRotationStyle]}
                onPress={onImagePickerButtonPress}
              >
                <Animated.View style={styles.topButtonImg}>
                  <Icon name="image" type="font-awesome" color="#ffffff" />
                </Animated.View>
              </TouchableOpacity>
            )}
            {showFilePickerButton && (
              <TouchableOpacity
                accessibilityRole="button"
                accessibilityLabel={loc._.pick_file}
                style={[styles.bottomButton, styles.spacing, uiRotationStyle]}
                onPress={onFilePickerButtonPress}
              >
                <Animated.View style={styles.topButtonImg}>
                  <Icon name="file-import" type="font-awesome-5" color="#ffffff" />
                </Animated.View>
              </TouchableOpacity>
            )}
          </View>
        ) : (
          <TouchableOpacity style={[styles.bottomButton, uiRotationStyle]} onPress={onSwitchCameraPressed}>
            <Animated.View style={[styles.topButtonImg, uiRotationStyle]}>
              {Platform.OS === 'ios' ? (
                <Icon name="cameraswitch" type="font-awesome-6" color="#ffffff" />
              ) : (
                <Icon name={cameraType === CameraType.Back ? 'camera-rear' : 'camera-front'} type="ionicons" color="#ffffff" />
              )}
            </Animated.View>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
};

export default CameraScreen;

const styles = StyleSheet.create({
  activeTorch: {
    backgroundColor: '#fff',
  },
  screen: {
    height: '100%',
    backgroundColor: '#000000',
  },
  topButtons: {
    padding: 10,
    zIndex: 10,
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  topButton: {
    backgroundColor: '#222',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
  },
  topButtonImg: {
    margin: 10,
    width: 24,
    height: 24,
  },
  cameraContainer: {
    justifyContent: 'center',
    flex: 1,
  },
  cameraPreview: {
    width: '100%',
    height: '100%',
  },
  bottomButtons: {
    padding: 10,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  backTextStyle: {
    padding: 10,
    color: 'white',
    fontSize: 20,
  },
  rightButtonsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  bottomButton: {
    backgroundColor: '#222',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
  },
  spacing: {
    marginLeft: 20,
  },
});


================================================
FILE: ./components/AddressInputScanButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useMemo } from 'react';
import { Image, Keyboard, Platform, StyleSheet, Text } from 'react-native';
import Clipboard from '@react-native-clipboard/clipboard';
import ToolTipMenu from './TooltipMenu';
import loc from '../loc';
import { showFilePickerAndReadFile, showImagePickerAndReadImage } from '../malin_modules/fs';
import presentAlert from './Alert';
import { useTheme } from './themes';
import RNQRGenerator from 'rn-qr-generator';
import { CommonToolTipActions } from '../typings/CommonToolTipActions';
import { useSettings } from '../hooks/context/useSettings';
import { scanQrHelper } from '../helpers/scan-qr.ts';

interface AddressInputScanButtonProps {
  isLoading?: boolean;
  onChangeText: (text: string) => void;
  type?: 'default' | 'link';
  testID?: string;
  beforePress?: () => Promise<void> | void;
}

export const AddressInputScanButton = ({
  isLoading,
  onChangeText,
  type = 'default',
  testID = 'MalinAddressInputScanQrButton',
  beforePress,
}: AddressInputScanButtonProps) => {
  const { colors } = useTheme();
  const { isClipboardGetContentEnabled } = useSettings();

  const stylesHook = StyleSheet.create({
    scan: {
      backgroundColor: colors.scanLabel,
    },
    scanText: {
      color: colors.inverseForegroundColor,
    },
  });

  const toolTipOnPress = useCallback(async () => {
    if (beforePress) {
      await beforePress();
    }
    Keyboard.dismiss();
    scanQrHelper().then(onChangeText);
  }, [beforePress, onChangeText]);

  const actions = useMemo(() => {
    const availableActions = [
      CommonToolTipActions.ChoosePhoto,
      CommonToolTipActions.ImportFile,
      {
        ...CommonToolTipActions.PasteFromClipboard,
        hidden: !isClipboardGetContentEnabled,
      },
    ];

    return availableActions;
  }, [isClipboardGetContentEnabled]);

  const onMenuItemPressed = useCallback(
    async (action: string) => {
      switch (action) {
        case CommonToolTipActions.PasteFromClipboard.id:
          try {
            let getImage: string | null = null;
            let hasImage = false;
            if (Platform.OS === 'android') {
              hasImage = true;
            } else {
              hasImage = await Clipboard.hasImage();
            }

            if (hasImage) {
              getImage = await Clipboard.getImage();
            }

            if (getImage) {
              try {
                const base64Data = getImage.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
                const values = await RNQRGenerator.detect({
                  base64: base64Data,
                });

                if (values && values.values.length > 0) {
                  onChangeText(values.values[0]);
                } else {
                  presentAlert({ message: loc.send.qr_error_no_qrcode });
                }
              } catch (error) {
                presentAlert({ message: (error as Error).message });
              }
            } else {
              const clipboardText = await Clipboard.getString();
              onChangeText(clipboardText);
            }
          } catch (error) {
            presentAlert({ message: (error as Error).message });
          }
          break;
        case CommonToolTipActions.ChoosePhoto.id:
          showImagePickerAndReadImage()
            .then(value => {
              if (value) {
                onChangeText(value);
              }
            })
            .catch(error => {
              presentAlert({ message: error.message });
            });
          break;
        case CommonToolTipActions.ImportFile.id:
          showFilePickerAndReadFile()
            .then(value => {
              if (value.data) {
                onChangeText(value.data);
              }
            })
            .catch(error => {
              presentAlert({ message: error.message });
            });
          break;
      }
      Keyboard.dismiss();
    },
    [onChangeText],
  );

  const buttonStyle = useMemo(() => [styles.scan, stylesHook.scan], [stylesHook.scan]);

  return (
    <ToolTipMenu
      actions={actions}
      isButton
      onPressMenuItem={onMenuItemPressed}
      testID={testID}
      disabled={isLoading}
      onPress={toolTipOnPress}
      buttonStyle={type === 'default' ? buttonStyle : undefined}
      accessibilityLabel={loc.send.details_scan}
      accessibilityHint={loc.send.details_scan_hint}
    >
      {type === 'default' ? (
        <>
          <Image source={require('../img/scan-white.png')} accessible={false} />
          <Text style={[styles.scanText, stylesHook.scanText]} accessible={false}>
            {loc.send.details_scan}
          </Text>
        </>
      ) : (
        <Text style={[styles.linkText, { color: colors.foregroundColor }]}>{loc.wallets.import_scan_qr}</Text>
      )}
    </ToolTipMenu>
  );
};

AddressInputScanButton.displayName = 'AddressInputScanButton';

const styles = StyleSheet.create({
  scan: {
    height: 36,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderRadius: 4,
    paddingVertical: 4,
    paddingHorizontal: 8,
    marginHorizontal: 4,
  },
  scanText: {
    marginLeft: 4,
  },
  linkText: {
    textAlign: 'center',
    fontSize: 16,
  },
});


================================================
FILE: ./components/AddressInput.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleProp, StyleSheet, TextInput, View, ViewStyle } from 'react-native';
import loc from '../loc';
import { AddressInputScanButton } from './AddressInputScanButton';
import { useTheme } from './themes';

interface AddressInputProps {
  isLoading?: boolean;
  address?: string;
  placeholder?: string;
  onChangeText: (text: string) => void;
  editable?: boolean;
  inputAccessoryViewID?: string;
  onFocus?: () => void;
  onBlur?: () => void;
  testID?: string;
  style?: StyleProp<ViewStyle>;
  keyboardType?:
    | 'default'
    | 'numeric'
    | 'email-address'
    | 'ascii-capable'
    | 'numbers-and-punctuation'
    | 'url'
    | 'number-pad'
    | 'phone-pad'
    | 'name-phone-pad'
    | 'decimal-pad'
    | 'twitter'
    | 'web-search'
    | 'visible-password';
}

const AddressInput = ({
  isLoading = false,
  address = '',
  testID = 'AddressInput',
  placeholder = loc.send.details_address,
  onChangeText,
  editable = true,
  inputAccessoryViewID,
  onFocus = () => {},
  onBlur = () => {},
  keyboardType = 'default',
  style,
}: AddressInputProps) => {
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    root: {
      borderColor: colors.formBorder,
      borderBottomColor: colors.formBorder,
      backgroundColor: colors.inputBackgroundColor,
    },
    input: {
      color: colors.foregroundColor,
    },
  });

  return (
    <View style={[styles.root, stylesHook.root, style]}>
      <TextInput
        testID={testID}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#81868e"
        value={address}
        style={[styles.input, stylesHook.input]}
        editable={!isLoading && editable}
        multiline={!editable}
        inputAccessoryViewID={inputAccessoryViewID}
        clearButtonMode="while-editing"
        onFocus={onFocus}
        autoCapitalize="none"
        autoCorrect={false}
        keyboardType={keyboardType}
        onBlur={onBlur}
      />
      {editable ? <AddressInputScanButton isLoading={isLoading} onChangeText={onChangeText} /> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  root: {
    flexDirection: 'row',
    borderWidth: 1.0,
    borderBottomWidth: 0.5,
    minHeight: 44,
    height: 44,
    alignItems: 'center',
    borderRadius: 4,
  },
  input: {
    flex: 1,
    paddingHorizontal: 8,
    minHeight: 33,
  },
});

export default AddressInput;


================================================
FILE: ./components/ReplaceFeeSuggestions.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { View, Text, TextInput, TouchableOpacity, Keyboard, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { MalinText } from '../MalinComponents';
import loc, { formatStringAddTwoWhiteSpaces } from '../loc';
import NetworkTransactionFees, { NetworkTransactionFee, NetworkTransactionFeeType } from '../models/networkTransactionFees';
import { useTheme } from './themes';
import { DismissKeyboardInputAccessory, DismissKeyboardInputAccessoryViewID } from './DismissKeyboardInputAccessory';

interface ReplaceFeeSuggestionsProps {
  onFeeSelected: (fee: number) => void;
  transactionMinimum?: number;
}

const ReplaceFeeSuggestions: React.FC<ReplaceFeeSuggestionsProps> = ({ onFeeSelected, transactionMinimum = 1 }) => {
  const [networkFees, setNetworkFees] = useState<NetworkTransactionFee | null>(null);
  const [selectedFeeType, setSelectedFeeType] = useState<NetworkTransactionFeeType>(NetworkTransactionFeeType.FAST);
  const [customFeeValue, setCustomFeeValue] = useState<string>('1');
  const customTextInput = useRef<TextInput>(null);
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    activeButton: {
      backgroundColor: colors.incomingBackgroundColor,
    },
    buttonText: {
      color: colors.successColor,
    },
    timeContainer: {
      backgroundColor: colors.successColor,
    },
    timeText: {
      color: colors.background,
    },
    rateText: {
      color: colors.successColor,
    },
    customFeeInput: {
      backgroundColor: colors.inputBackgroundColor,
      borderBottomColor: colors.formBorder,
      borderColor: colors.formBorder,
    },
    alternativeText: {
      color: colors.alternativeTextColor,
    },
  });

  const fetchNetworkFees = useCallback(async () => {
    try {
      const cachedNetworkTransactionFees = JSON.parse((await AsyncStorage.getItem(NetworkTransactionFee.StorageKey)) || '{}');

      if (cachedNetworkTransactionFees && 'fastestFee' in cachedNetworkTransactionFees) {
        setNetworkFees(cachedNetworkTransactionFees);
        onFeeSelected(cachedNetworkTransactionFees.fastestFee);
        setSelectedFeeType(NetworkTransactionFeeType.FAST);
      }
    } catch (_) {}
    const fees = await NetworkTransactionFees.recommendedFees();
    setNetworkFees(fees);
    onFeeSelected(fees.fastestFee);
    setSelectedFeeType(NetworkTransactionFeeType.FAST);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    fetchNetworkFees();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleFeeSelection = (feeType: NetworkTransactionFeeType) => {
    if (feeType !== NetworkTransactionFeeType.CUSTOM) {
      Keyboard.dismiss();
    }
    if (networkFees) {
      let selectedFee: number;
      switch (feeType) {
        case NetworkTransactionFeeType.FAST:
          selectedFee = networkFees.fastestFee;
          break;
        case NetworkTransactionFeeType.MEDIUM:
          selectedFee = networkFees.mediumFee;
          break;
        case NetworkTransactionFeeType.SLOW:
          selectedFee = networkFees.slowFee;
          break;
        case NetworkTransactionFeeType.CUSTOM:
          selectedFee = Number(customFeeValue);
          break;
      }
      onFeeSelected(selectedFee);
      setSelectedFeeType(feeType);
    }
  };

  const handleCustomFeeChange = (customFee: string) => {
    const sanitizedFee = customFee.replace(/[^0-9]/g, '');
    setCustomFeeValue(sanitizedFee);
    handleFeeSelection(NetworkTransactionFeeType.CUSTOM);
  };

  return (
    <View>
      {networkFees &&
        [
          {
            label: loc.send.fee_fast,
            time: loc.send.fee_10m,
            type: NetworkTransactionFeeType.FAST,
            rate: networkFees.fastestFee,
            active: selectedFeeType === NetworkTransactionFeeType.FAST,
          },
          {
            label: formatStringAddTwoWhiteSpaces(loc.send.fee_medium),
            time: loc.send.fee_3h,
            type: NetworkTransactionFeeType.MEDIUM,
            rate: networkFees.mediumFee,
            active: selectedFeeType === NetworkTransactionFeeType.MEDIUM,
          },
          {
            label: loc.send.fee_slow,
            time: loc.send.fee_1d,
            type: NetworkTransactionFeeType.SLOW,
            rate: networkFees.slowFee,
            active: selectedFeeType === NetworkTransactionFeeType.SLOW,
          },
        ].map(({ label, type, time, rate, active }) => (
          <TouchableOpacity
            accessibilityRole="button"
            key={label}
            onPress={() => handleFeeSelection(type)}
            style={[styles.button, active && stylesHook.activeButton]}
          >
            <View style={styles.buttonContent}>
              <Text style={[styles.buttonText, stylesHook.buttonText]}>{label}</Text>
              <View style={[styles.timeContainer, stylesHook.timeContainer]}>
                <Text style={stylesHook.timeText}>~{time}</Text>
              </View>
            </View>
            <View style={styles.rateContainer}>
              <Text style={stylesHook.rateText}>{rate} sat/byte</Text>
            </View>
          </TouchableOpacity>
        ))}
      <TouchableOpacity
        accessibilityRole="button"
        onPress={() => customTextInput.current?.focus()}
        style={[styles.button, selectedFeeType === NetworkTransactionFeeType.CUSTOM && stylesHook.activeButton]}
      >
        <View style={styles.buttonContent}>
          <Text style={[styles.buttonText, stylesHook.buttonText]}>{formatStringAddTwoWhiteSpaces(loc.send.fee_custom)}</Text>
        </View>
        <View style={[styles.buttonContent, styles.customFeeInputContainer]}>
          <TextInput
            onChangeText={handleCustomFeeChange}
            keyboardType="numeric"
            value={customFeeValue}
            ref={customTextInput}
            maxLength={9}
            style={[styles.customFeeInput, stylesHook.customFeeInput]}
            onFocus={() => handleCustomFeeChange(customFeeValue)}
            placeholder={loc.send.fee_satvbyte}
            placeholderTextColor="#81868e"
            inputAccessoryViewID={DismissKeyboardInputAccessoryViewID}
          />
          <DismissKeyboardInputAccessory />
          <Text style={stylesHook.rateText}>sat/byte</Text>
        </View>
      </TouchableOpacity>
      <MalinText style={stylesHook.alternativeText}>{loc.formatString(loc.send.fee_replace_minvb, { min: transactionMinimum })}</MalinText>
    </View>
  );
};

const styles = StyleSheet.create({
  button: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginBottom: 10,
    borderRadius: 8,
  },
  buttonContent: {
    justifyContent: 'space-between',
    flexDirection: 'row',
    alignItems: 'center',
  },
  buttonText: {
    fontSize: 22,
    fontWeight: '600',
  },
  timeContainer: {
    borderRadius: 5,
    paddingHorizontal: 6,
    paddingVertical: 3,
  },
  rateContainer: {
    justifyContent: 'flex-end',
    flexDirection: 'row',
    alignItems: 'center',
  },
  customFeeInputContainer: {
    marginTop: 5,
  },
  customFeeInput: {
    borderBottomWidth: 0.5,
    borderRadius: 4,
    borderWidth: 1.0,
    color: '#81868e',
    flex: 1,
    marginRight: 10,
    minHeight: 33,
    paddingRight: 5,
    paddingLeft: 5,
  },
});

export default ReplaceFeeSuggestions;


================================================
FILE: ./components/MalinBigCheckmark.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, View, ViewProps } from 'react-native';
import { Icon } from '@rneui/themed';
import { useTheme } from './themes';

interface MalinBigCheckmarkProps extends ViewProps {}

export function MalinBigCheckmark(props: MalinBigCheckmarkProps) {
  const { colors } = useTheme();
  return (
    <View style={[styles.container, props.style]}>
      <Icon name="check" size={50} type="font-awesome" color={colors.successCheck} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#ccddf9',
    width: 120,
    height: 120,
    borderRadius: 60,
    alignSelf: 'center',
    justifyContent: 'center',
    marginTop: 0,
    marginBottom: 0,
  },
});


================================================
FILE: ./components/HandOffComponent.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { HandOffComponentProps } from './types';

const HandOffComponent: React.FC<HandOffComponentProps> = props => {
  console.debug('HandOffComponent render.');
  return null;
};

export const setIsHandOffUseEnabled = async (value: boolean) => {};

export const getIsHandOffUseEnabled = async (): Promise<boolean> => {
  return false;
};

export default HandOffComponent;


================================================
FILE: ./components/FloatButtons.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef, ReactNode, useEffect, useRef, useState, useCallback, useMemo } from 'react';
import {
  Animated,
  LayoutAnimation,
  Platform,
  PixelRatio,
  StyleSheet,
  Text,
  TouchableOpacity,
  UIManager,
  useWindowDimensions,
  View,
  StyleProp,
  TextStyle,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useTheme } from './themes';
import { useSizeClass, SizeClass } from '../malin_modules/sizeClass';
import { isDesktop } from '../malin_modules/environment';
import debounce from '../malin_modules/debounce';

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const scheduleInNextFrame = (callback: () => void): number => {
  return requestAnimationFrame(() => {
    // Use a second requestAnimationFrame to ensure we're not in the same frame
    requestAnimationFrame(callback);
  });
};

const LAYOUT = {
  PADDINGS: 30,
  ICON_MARGIN: 7,
  BUTTON_MARGIN: 10,
  MIN_BUTTON_WIDTH: 100,
  MIN_BUTTON_WIDTH_LARGE: 130,
  DRAWER_WIDTH: 320,
  BUTTON_HEIGHT: 52,
  SINGLE_BUTTON_HEIGHT: 58,
  CONTAINER_SIDE_MARGIN: 20,
  DEFAULT_BORDER_RADIUS: 8,
  SINGLE_BUTTON_RADIUS: 29,
  SINGLE_BUTTON_WIDTH_FACTOR: 0.625,
  MAX_BUTTON_FONT_SIZE: 24,
  SAFETY_MARGIN: 20,
  ANIMATION_DURATION: 300,
  SPRING_CONFIG: {
    speed: 12,
    bounciness: 4,
    useNativeDriver: true,
  },
  TIMING_CONFIG: {
    duration: 300,
    useNativeDriver: true,
  },
};

const useFloatButtonAnimation = (height: number) => {
  const slideAnimation = useRef(new Animated.Value(height)).current;
  const animatedButtonRadius = useRef(new Animated.Value(LAYOUT.DEFAULT_BORDER_RADIUS)).current;
  const animatedSingleButtonRadius = useRef(new Animated.Value(LAYOUT.SINGLE_BUTTON_RADIUS)).current;
  const [isAnimating, setIsAnimating] = useState(false);
  const animationInterrupted = useRef(false);

  useEffect(() => {
    slideAnimation.setValue(height);

    if (isDesktop) {
      slideAnimation.setValue(0);
      return;
    }

    Animated.spring(slideAnimation, {
      toValue: 0,
      friction: 7,
      tension: 40,
      useNativeDriver: true,
    }).start();
  }, [height, slideAnimation]);

  const configureLayoutAnimation = useCallback(() => {
    if (isDesktop) return;

    LayoutAnimation.configureNext({
      duration: 250,
      create: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
      },
      update: {
        type: LayoutAnimation.Types.spring,
        springDamping: 0.85,
      },
      delete: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
      },
    });
  }, []);

  const animateBorderRadius = useCallback(
    (buttonRadius: number, singleRadius: number, onComplete?: () => void) => {
      if (isDesktop) {
        animatedButtonRadius.setValue(buttonRadius);
        animatedSingleButtonRadius.setValue(singleRadius);
        if (onComplete) onComplete();
        return;
      }

      if (isAnimating) {
        animationInterrupted.current = true;
        return;
      }

      setIsAnimating(true);
      animationInterrupted.current = false;

      Animated.parallel([
        Animated.timing(animatedButtonRadius, {
          toValue: buttonRadius,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(animatedSingleButtonRadius, {
          toValue: singleRadius,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start(({ finished }) => {
        setIsAnimating(false);
        if (finished && !animationInterrupted.current && onComplete) {
          onComplete();
        }
      });
    },
    [animatedButtonRadius, animatedSingleButtonRadius, isAnimating],
  );

  return {
    slideAnimation,
    animatedButtonRadius,
    animatedSingleButtonRadius,
    isAnimating: isDesktop ? false : isAnimating,
    setIsAnimating,
    configureLayoutAnimation,
    animateBorderRadius,
  };
};

const useFloatButtonLayout = (width: number, sizeClass: SizeClass) => {
  const lastVerticalDecision = useRef(false);

  const shouldUseVerticalLayout = useCallback(
    (totalWidthNeeded: number, availableWidth: number, totalChildren: number) => {
      if (sizeClass !== SizeClass.Large || totalChildren <= 1) return false;

      const minWidthPerButton = 130;
      const totalButtonsWidth = minWidthPerButton * totalChildren;
      const totalSpacing = LAYOUT.BUTTON_MARGIN * (totalChildren - 1);
      const minRequiredWidth = totalButtonsWidth + totalSpacing;

      const wouldBeTooNarrow = availableWidth < minRequiredWidth;

      if (!lastVerticalDecision.current && wouldBeTooNarrow) {
        const shouldSwitch = availableWidth < minRequiredWidth * 0.9;
        lastVerticalDecision.current = shouldSwitch;
        return shouldSwitch;
      }

      if (lastVerticalDecision.current && !wouldBeTooNarrow) {
        const shouldSwitchBack = availableWidth > minRequiredWidth * 1.2;
        lastVerticalDecision.current = !shouldSwitchBack;
        return !shouldSwitchBack;
      }

      return lastVerticalDecision.current;
    },
    [sizeClass],
  );

  const calculateButtonWidth = useCallback(
    (containerWidth: number, totalChildren: number): number => {
      if (containerWidth <= 0) return 0;

      const drawerOffset = sizeClass === SizeClass.Large ? LAYOUT.DRAWER_WIDTH : 0;
      const availableWidth = width - drawerOffset - LAYOUT.CONTAINER_SIDE_MARGIN * 2;

      const contentWidth = Math.ceil(containerWidth);
      const buttonWidth = contentWidth + LAYOUT.PADDINGS * 2;
      const totalButtonWidth = buttonWidth * totalChildren;
      const totalSpacersWidth = (totalChildren - 1) * LAYOUT.BUTTON_MARGIN;
      const totalWidthNeeded = totalButtonWidth + totalSpacersWidth + LAYOUT.SAFETY_MARGIN;

      const effectiveMinButtonWidth =
        sizeClass === SizeClass.Large
          ? LAYOUT.MIN_BUTTON_WIDTH_LARGE
          : sizeClass === SizeClass.Regular
            ? LAYOUT.MIN_BUTTON_WIDTH
            : LAYOUT.MIN_BUTTON_WIDTH * 0.85;

      const shouldBeVertical = shouldUseVerticalLayout(totalWidthNeeded, availableWidth, totalChildren);

      let calculatedWidth;

      if (shouldBeVertical) {
        calculatedWidth = sizeClass === SizeClass.Large ? availableWidth - LAYOUT.CONTAINER_SIDE_MARGIN * 2 : availableWidth;
      } else {
        if (totalWidthNeeded > availableWidth) {
          const availableWidthPerButton = (availableWidth - totalSpacersWidth) / totalChildren;
          calculatedWidth = Math.floor(availableWidthPerButton) - LAYOUT.PADDINGS * 2;
        } else {
          calculatedWidth = Math.max(contentWidth, effectiveMinButtonWidth);
        }
      }

      if (totalChildren === 1 && !shouldBeVertical) {
        const singleButtonMaxWidth = availableWidth * (sizeClass === SizeClass.Compact ? 0.7 : LAYOUT.SINGLE_BUTTON_WIDTH_FACTOR);
        const effectiveSingleMinWidth = sizeClass === SizeClass.Large ? LAYOUT.MIN_BUTTON_WIDTH * 1.2 : LAYOUT.MIN_BUTTON_WIDTH;

        calculatedWidth = Math.max(
          effectiveSingleMinWidth - LAYOUT.PADDINGS * 2,
          Math.min(calculatedWidth, singleButtonMaxWidth - LAYOUT.PADDINGS * 2),
        );
      }

      return Math.floor(calculatedWidth);
    },
    [width, sizeClass, shouldUseVerticalLayout],
  );

  const calculateVisualParameters = useCallback(
    (calculatedWidth: number, totalChildren: number) => {
      const drawerOffset = sizeClass === SizeClass.Large ? LAYOUT.DRAWER_WIDTH : 0;
      const availableWidth = width - drawerOffset - LAYOUT.CONTAINER_SIDE_MARGIN * 2;

      const buttonWidth = Math.max(calculatedWidth, LAYOUT.MIN_BUTTON_WIDTH_LARGE) + LAYOUT.PADDINGS * 2;
      const totalButtonWidth = buttonWidth * totalChildren;
      const totalSpacersWidth = (totalChildren - 1) * LAYOUT.BUTTON_MARGIN;
      const totalWidthNeeded = totalButtonWidth + totalSpacersWidth;

      const shouldBeVertical = shouldUseVerticalLayout(totalWidthNeeded, availableWidth, totalChildren);

      let buttonRadius;
      if (totalChildren === 1) {
        buttonRadius = LAYOUT.SINGLE_BUTTON_RADIUS;
      } else {
        buttonRadius = Math.min(LAYOUT.DEFAULT_BORDER_RADIUS * 1.5, calculatedWidth / 12);
      }

      const multiButtonRadius = Math.max(LAYOUT.DEFAULT_BORDER_RADIUS, Math.floor(buttonRadius));
      const singleButtonRadius = LAYOUT.SINGLE_BUTTON_RADIUS;

      return { buttonRadius: multiButtonRadius, singleButtonRadius, shouldBeVertical };
    },
    [width, sizeClass, shouldUseVerticalLayout],
  );

  const calculateContainerHeight = useCallback((childrenCount: number, isVerticalLayout: boolean) => {
    if (!isVerticalLayout) return { height: '8%', minHeight: LAYOUT.BUTTON_HEIGHT };

    const totalButtonsHeight = childrenCount * LAYOUT.BUTTON_HEIGHT;
    const totalMarginsHeight = (childrenCount - 1) * LAYOUT.BUTTON_MARGIN;
    const calculatedHeight = totalButtonsHeight + totalMarginsHeight;

    return { height: calculatedHeight };
  }, []);

  const calculateButtonFontSize = useMemo(() => {
    const divisor = sizeClass === SizeClass.Large ? 22 : sizeClass === SizeClass.Regular ? 24 : 28;
    const baseSize = PixelRatio.roundToNearestPixel(width / divisor);
    return Math.min(LAYOUT.MAX_BUTTON_FONT_SIZE, baseSize);
  }, [width, sizeClass]);

  return {
    calculateButtonWidth,
    calculateVisualParameters,
    calculateContainerHeight,
    buttonFontSize: calculateButtonFontSize,
  };
};

const containerStyles = StyleSheet.create({
  root: {
    alignSelf: 'center',
    height: '8%',
    minHeight: LAYOUT.BUTTON_HEIGHT,
    marginHorizontal: LAYOUT.CONTAINER_SIDE_MARGIN,
  },
  rootAbsolute: {
    position: 'absolute',
  },
  rootInline: {},
  rootPre: {
    position: 'absolute',
    bottom: -1000,
  },
  rootPost: {
    flexDirection: 'row',
    overflow: 'hidden',
  },
  rootPostVertical: {
    flexDirection: 'column',
    overflow: 'hidden',
  },
  childWrapper: {
    width: '100%',
  },
});

const buttonStyles = StyleSheet.create({
  root: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    overflow: 'hidden',
  },
  icon: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: 24,
    minHeight: 24,
    overflow: 'visible',
    alignSelf: 'center',
  },
  touchContainer: {
    width: '100%',
    height: '100%',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  centeredText: {
    textAlign: 'center',
    textAlignVertical: 'center',
  },
});

const buttonContentStaticStyles = StyleSheet.create({
  root: {
    height: LAYOUT.BUTTON_HEIGHT,
    overflow: 'hidden',
    justifyContent: 'center',
  },
  rootSingle: {
    height: LAYOUT.SINGLE_BUTTON_HEIGHT,
    overflow: 'hidden',
    justifyContent: 'center',
  },
  marginRight: {
    marginRight: LAYOUT.BUTTON_MARGIN,
  },
  marginBottom: {
    marginBottom: LAYOUT.BUTTON_MARGIN,
  },
  textBase: {
    fontWeight: '600',
    marginLeft: LAYOUT.ICON_MARGIN,
    backgroundColor: 'transparent',
    textAlign: 'center',
    textAlignVertical: 'center',
  },
  contentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
    height: '100%',
  },
});

interface FContainerProps {
  children: ReactNode | ReactNode[];
  inline?: boolean;
}

interface FButtonProps {
  text: string;
  icon: ReactNode;
  width?: number;
  first?: boolean;
  last?: boolean;
  singleChild?: boolean;
  isVertical?: boolean;
  borderRadius?: number | Animated.Value;
  fontSize?: number;
  isAnimating?: boolean;
  disabled?: boolean;
  testID?: string;
  onPress: () => void;
  onLongPress?: () => void;
}

interface ButtonContentProps {
  icon: ReactNode;
  text: string;
  textStyle: StyleProp<TextStyle>;
  iconStyle: StyleProp<any>;
}

const getScaledIconSize = (fontSize: number): number => {
  return Math.max(Math.round(fontSize * 1.2), 16);
};

const ButtonContent = ({ icon, text, textStyle, iconStyle }: ButtonContentProps) => {
  const computedStyle = StyleSheet.flatten(textStyle);
  const fontSize = computedStyle.fontSize || LAYOUT.MAX_BUTTON_FONT_SIZE;
  const iconSize = getScaledIconSize(Number(fontSize));

  let scaledIcon;

  if (React.isValidElement(icon)) {
    const iconElement = icon as React.ReactElement;

    scaledIcon = React.cloneElement(iconElement, {
      ...iconElement.props,
      size: iconSize,
      width: iconSize,
      height: iconSize,
    });
  } else {
    scaledIcon = icon;
  }

  return (
    <View style={buttonContentStaticStyles.contentContainer}>
      <View style={buttonStyles.iconContainer}>{scaledIcon}</View>
      <Text numberOfLines={1} adjustsFontSizeToFit style={[textStyle, buttonStyles.centeredText, { lineHeight: fontSize * 1.2 }]}>
        {text}
      </Text>
    </View>
  );
};

export const FButton = ({
  text,
  icon,
  width,
  first,
  last,
  singleChild,
  isVertical,
  borderRadius = LAYOUT.DEFAULT_BORDER_RADIUS,
  fontSize = LAYOUT.MAX_BUTTON_FONT_SIZE,
  isAnimating = false,
  testID,
  ...props
}: FButtonProps) => {
  const { colors } = useTheme();

  const customButtonStyles = useMemo(() => {
    const baseStyles = singleChild ? { ...buttonContentStaticStyles.rootSingle } : { ...buttonContentStaticStyles.root };
    return {
      root: {
        ...baseStyles,
        backgroundColor: colors.buttonBackgroundColor,
      },
      text: {
        color: colors.buttonAlternativeTextColor,
        fontSize,
      },
      textDisabled: {
        color: colors.formBorder,
      },
      marginRight: buttonContentStaticStyles.marginRight,
      marginBottom: buttonContentStaticStyles.marginBottom,
      textBase: buttonContentStaticStyles.textBase,
    };
  }, [colors, fontSize, singleChild]);

  const style: Record<string, any> = {};
  const additionalStyles = !last ? (isVertical ? customButtonStyles.marginBottom : customButtonStyles.marginRight) : {};

  if (width) {
    style.paddingHorizontal = LAYOUT.PADDINGS;
    if (singleChild && !isVertical) {
      style.width = width * LAYOUT.SINGLE_BUTTON_WIDTH_FACTOR + LAYOUT.PADDINGS * 2;
    } else {
      style.width = isVertical ? '100%' : width + LAYOUT.PADDINGS * 2;
    }
  }

  const textStyle = [customButtonStyles.textBase, props.disabled ? customButtonStyles.textDisabled : customButtonStyles.text];

  if (isAnimating && borderRadius instanceof Animated.Value) {
    return (
      <Animated.View style={[buttonStyles.root, customButtonStyles.root, style, additionalStyles, { borderRadius }]}>
        <TouchableOpacity
          accessibilityLabel={text}
          accessibilityRole="button"
          testID={testID}
          style={[buttonStyles.root, buttonStyles.touchContainer]}
          {...props}
        >
          <ButtonContent icon={icon} text={text} textStyle={textStyle} iconStyle={buttonStyles.icon} />
        </TouchableOpacity>
      </Animated.View>
    );
  }

  return (
    <TouchableOpacity
      accessibilityLabel={text}
      accessibilityRole="button"
      testID={testID}
      style={[
        buttonStyles.root,
        customButtonStyles.root,
        style,
        additionalStyles,
        { borderRadius: typeof borderRadius === 'number' ? borderRadius : LAYOUT.DEFAULT_BORDER_RADIUS },
      ]}
      {...props}
    >
      <ButtonContent icon={icon} text={text} textStyle={textStyle} iconStyle={buttonStyles.icon} />
    </TouchableOpacity>
  );
};

export const FContainer = forwardRef<View, FContainerProps>((props, ref) => {
  const insets = useSafeAreaInsets();
  const { height, width } = useWindowDimensions();
  const { sizeClass } = useSizeClass();

  const [newWidth, setNewWidth] = useState<number | undefined>(undefined);
  const [isVertical, setIsVertical] = useState(false);
  const [layoutReady, setLayoutReady] = useState(false);
  const [buttonBorderRadius, setButtonBorderRadius] = useState<number>(LAYOUT.DEFAULT_BORDER_RADIUS);
  const [singleButtonBorderRadius, setSingleButtonBorderRadius] = useState<number>(LAYOUT.SINGLE_BUTTON_RADIUS);

  const layoutWidth = useRef<number>(0);
  const layoutCalculated = useRef(false);
  const orientationChangeTimestamp = useRef<number>(0);
  const animationInProgress = useRef(false);
  const pendingAnimationParams = useRef<any>(null);

  const bottomInsets = useMemo(
    () => ({
      bottom: insets.bottom ? insets.bottom + 10 : 30,
    }),
    [insets.bottom],
  );

  const { slideAnimation, animatedButtonRadius, animatedSingleButtonRadius, isAnimating, configureLayoutAnimation, animateBorderRadius } =
    useFloatButtonAnimation(height);

  const { calculateButtonWidth, calculateVisualParameters, calculateContainerHeight, buttonFontSize } = useFloatButtonLayout(
    width,
    sizeClass,
  );

  const handleBorderRadiusAnimation = useCallback(
    (buttonRadius: number, singleRadius: number, shouldBeVertical: boolean, calculatedWidth: number) => {
      const now = Date.now();
      const isOrientationChange = Math.abs(width / height - height / width) > 0.8;

      if (isOrientationChange) {
        orientationChangeTimestamp.current = now;
        setNewWidth(calculatedWidth);
        setIsVertical(shouldBeVertical);
        setButtonBorderRadius(buttonRadius);
        setSingleButtonBorderRadius(singleRadius);
        return;
      }

      if (animationInProgress.current) {
        pendingAnimationParams.current = { buttonRadius, singleRadius, shouldBeVertical, calculatedWidth };
        return;
      }

      if (isDesktop || now - orientationChangeTimestamp.current < 1000) {
        setNewWidth(calculatedWidth);
        setIsVertical(shouldBeVertical);
        setButtonBorderRadius(buttonRadius);
        setSingleButtonBorderRadius(singleRadius);
        return;
      }

      animationInProgress.current = true;

      if (shouldBeVertical !== isVertical) {
        configureLayoutAnimation();
      }

      setNewWidth(calculatedWidth);
      setIsVertical(shouldBeVertical);

      animateBorderRadius(buttonRadius, singleRadius, () => {
        setButtonBorderRadius(buttonRadius);
        setSingleButtonBorderRadius(singleRadius);
        animationInProgress.current = false;

        if (pendingAnimationParams.current) {
          const {
            buttonRadius: nextRadius,
            singleRadius: nextSingle,
            shouldBeVertical: nextVertical,
            calculatedWidth: nextWidth,
          } = pendingAnimationParams.current;
          pendingAnimationParams.current = null;

          setTimeout(() => {
            handleBorderRadiusAnimation(nextRadius, nextSingle, nextVertical, nextWidth);
          }, 50);
        }
      });
    },
    [animateBorderRadius, configureLayoutAnimation, height, width, isVertical],
  );

  const calculateLayout = useCallback(() => {
    if (!layoutReady || layoutWidth.current <= 0) return;

    scheduleInNextFrame(() => {
      const totalChildren = React.Children.toArray(props.children).filter(Boolean).length;
      const calculatedWidth = calculateButtonWidth(layoutWidth.current, totalChildren);
      const { buttonRadius, singleButtonRadius, shouldBeVertical } = calculateVisualParameters(calculatedWidth, totalChildren);

      if (shouldBeVertical !== isVertical || newWidth !== calculatedWidth) {
        handleBorderRadiusAnimation(buttonRadius, singleButtonRadius, shouldBeVertical, calculatedWidth);
      } else {
        setNewWidth(calculatedWidth);
        setIsVertical(shouldBeVertical);
        setButtonBorderRadius(buttonRadius);
        setSingleButtonBorderRadius(singleButtonRadius);
      }

      layoutCalculated.current = true;
    });
  }, [
    layoutReady,
    calculateButtonWidth,
    calculateVisualParameters,
    handleBorderRadiusAnimation,
    isVertical,
    newWidth,
    props.children,
    setNewWidth,
    setIsVertical,
    setButtonBorderRadius,
    setSingleButtonBorderRadius,
  ]);

  const debouncedCalculateLayout = useMemo(() => debounce(calculateLayout, 16), [calculateLayout]);

  useEffect(() => {
    debouncedCalculateLayout();
  }, [debouncedCalculateLayout, width, height, props.children, sizeClass]);

  const onLayout = (event: { nativeEvent: { layout: { width: number } } }) => {
    const { width: currentLayoutWidth } = event.nativeEvent.layout;

    if (currentLayoutWidth > 0) {
      if (Math.abs(layoutWidth.current - currentLayoutWidth) > 2) {
        layoutWidth.current = currentLayoutWidth;
        layoutCalculated.current = false;
      }

      if (!layoutReady) {
        setLayoutReady(true);
      }
    }
  };

  const renderChild = (child: ReactNode, index: number, array: ReactNode[]): ReactNode => {
    if (typeof child === 'string') {
      return (
        <View key={index} style={[containerStyles.childWrapper, { width: newWidth }]}>
          <Text adjustsFontSizeToFit numberOfLines={1}>
            {child}
          </Text>
        </View>
      );
    }

    const isSingleChild = array.length === 1;
    const borderRadiusToUse = isSingleChild
      ? isAnimating
        ? animatedSingleButtonRadius
        : singleButtonBorderRadius
      : isAnimating
        ? animatedButtonRadius
        : buttonBorderRadius;

    return React.cloneElement(child as React.ReactElement<any>, {
      width: newWidth,
      key: index,
      first: index === 0,
      last: index === array.length - 1,
      singleChild: isSingleChild,
      isVertical,
      borderRadius: borderRadiusToUse,
      fontSize: buttonFontSize,
      isAnimating,
    });
  };

  const totalChildren = React.Children.toArray(props.children).filter(Boolean).length;
  const containerHeight = useMemo(
    () => calculateContainerHeight(totalChildren, isVertical),
    [calculateContainerHeight, totalChildren, isVertical],
  );

  const dynamicRoundStyle = useMemo(() => {
    if (totalChildren === 1) {
      return {
        borderRadius: isAnimating ? animatedSingleButtonRadius : singleButtonBorderRadius,
        overflow: 'hidden',
      };
    }
    return null;
  }, [totalChildren, singleButtonBorderRadius, isAnimating, animatedSingleButtonRadius]);

  const combinedStyles = useMemo(
    () => [
      containerStyles.root,
      props.inline ? containerStyles.rootInline : containerStyles.rootAbsolute,
      bottomInsets,
      newWidth ? (isVertical ? containerStyles.rootPostVertical : containerStyles.rootPost) : containerStyles.rootPre,
      dynamicRoundStyle,
      isVertical ? containerHeight : null,
      { transform: [{ translateY: slideAnimation }] },
    ],
    [props.inline, bottomInsets, newWidth, isVertical, dynamicRoundStyle, containerHeight, slideAnimation],
  );

  return (
    <Animated.View ref={ref} onLayout={onLayout} style={combinedStyles}>
      {newWidth && layoutReady ? React.Children.toArray(props.children).filter(Boolean).map(renderChild) : props.children}
    </Animated.View>
  );
});


================================================
FILE: ./components/SquareButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef } from 'react';
import { StyleProp, StyleSheet, Text, TouchableOpacity, View, ViewStyle } from 'react-native';

import { useTheme } from './themes';

interface SquareButtonProps {
  title: string;
  onPress?: () => void;
  style?: StyleProp<ViewStyle>;
  testID?: string;
}

export const SquareButton = forwardRef<React.ElementRef<typeof TouchableOpacity>, SquareButtonProps>((props, ref) => {
  const { title, onPress, style, testID } = props;
  const { colors } = useTheme();

  const hookStyles = StyleSheet.create({
    text: {
      color: colors.buttonTextColor,
    },
  });

  const buttonView = (
    <View style={styles.contentContainer}>
      <Text style={[styles.text, hookStyles.text]}>{title}</Text>
    </View>
  );

  return onPress ? (
    <TouchableOpacity ref={ref} style={style} onPress={onPress} testID={testID} accessibilityRole="button">
      {buttonView}
    </TouchableOpacity>
  ) : (
    <View style={style}>{buttonView}</View>
  );
});

const styles = StyleSheet.create({
  contentContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginHorizontal: 8,
    fontSize: 16,
  },
});


================================================
FILE: ./components/PasswordInput.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef, useImperativeHandle, useRef, useState } from 'react';
import { Animated, Easing, StyleSheet, TextInput, View } from 'react-native';
import { useTheme } from './themes';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import loc from '../loc';

export interface PasswordInputHandle {
  focus: () => void;
  blur: () => void;
  clear: () => void;
  showError: () => void;
  showSuccess: () => void;
  reset: () => void;
  getValue: () => string;
}

interface PasswordInputProps {
  onSubmit: (password: string) => void;
  placeholder?: string;
  disabled?: boolean;
  onChangeText?: (text: string) => void;
}

export const PasswordInput = forwardRef<PasswordInputHandle, PasswordInputProps>(
  ({ onSubmit, placeholder = loc._.enter_password, disabled = false, onChangeText }, ref) => {
    const [password, setPassword] = useState('');
    const [isSuccess, setIsSuccess] = useState(false);
    const inputRef = useRef<TextInput>(null);
    const shakeAnimation = useRef(new Animated.Value(0)).current;
    const checkmarkScale = useRef(new Animated.Value(0)).current;
    const checkmarkOpacity = useRef(new Animated.Value(0)).current;
    const { colors } = useTheme();

    useImperativeHandle(ref, () => ({
      focus: () => {
        inputRef.current?.focus();
      },
      blur: () => inputRef.current?.blur(),
      clear: () => setPassword(''),
      getValue: () => password,
      showError: () => {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        setIsSuccess(false);

        // macOS-style shake animation - quick and snappy
        Animated.sequence([
          Animated.timing(shakeAnimation, {
            toValue: 20,
            duration: 80,
            easing: Easing.linear,
            useNativeDriver: true,
          }),
          Animated.timing(shakeAnimation, {
            toValue: -20,
            duration: 80,
            easing: Easing.linear,
            useNativeDriver: true,
          }),
          Animated.timing(shakeAnimation, {
            toValue: 20,
            duration: 80,
            easing: Easing.linear,
            useNativeDriver: true,
          }),
          Animated.timing(shakeAnimation, {
            toValue: 0,
            duration: 80,
            easing: Easing.linear,
            useNativeDriver: true,
          }),
        ]).start(() => {
          // Clear password after shake
          setPassword('');
        });
      },
      showSuccess: () => {
        triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
        setIsSuccess(true);

        // Dismiss keyboard on success
        inputRef.current?.blur();

        // Quick pop-in animation for checkmark
        checkmarkScale.setValue(0);
        checkmarkOpacity.setValue(0);

        Animated.parallel([
          Animated.spring(checkmarkScale, {
            toValue: 1,
            tension: 100,
            friction: 5,
            useNativeDriver: true,
          }),
          Animated.timing(checkmarkOpacity, {
            toValue: 1,
            duration: 200,
            useNativeDriver: true,
          }),
        ]).start();
      },
      reset: () => {
        setPassword('');
        setIsSuccess(false);
        shakeAnimation.setValue(0);
        checkmarkScale.setValue(0);
        checkmarkOpacity.setValue(0);
      },
    }));

    const handleSubmit = () => {
      if (password.trim() && !isSuccess) {
        onSubmit(password);
      }
    };

    const stylesHook = StyleSheet.create({
      container: {
        borderColor: isSuccess ? colors.successColor : colors.formBorder,
        backgroundColor: colors.inputBackgroundColor,
      },
      input: {
        color: colors.foregroundColor,
      },
      checkmark: {
        color: colors.successColor,
      },
    });

    return (
      <Animated.View
        style={[
          styles.container,
          stylesHook.container,
          {
            transform: [{ translateX: shakeAnimation }],
          },
        ]}
      >
        <TextInput
          ref={inputRef}
          testID="PasswordInput"
          style={[styles.input, stylesHook.input]}
          value={password}
          onChangeText={text => {
            setPassword(text);
            onChangeText?.(text);
          }}
          clearButtonMode={isSuccess ? 'never' : 'while-editing'}
          placeholder={placeholder}
          placeholderTextColor={colors.alternativeTextColor}
          secureTextEntry
          autoCapitalize="none"
          autoCorrect={false}
          editable={!isSuccess}
          onSubmitEditing={handleSubmit}
          returnKeyType="done"
          enablesReturnKeyAutomatically={true}
        />

        {isSuccess && (
          <Animated.View
            style={[
              styles.checkmarkContainer,
              {
                opacity: checkmarkOpacity,
                transform: [{ scale: checkmarkScale }],
              },
            ]}
            pointerEvents="none"
          >
            <View style={styles.checkmarkCircle}>
              <View style={[styles.checkmark, { borderColor: colors.successColor }]} />
            </View>
          </Animated.View>
        )}
      </Animated.View>
    );
  },
);

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    borderRadius: 8,
    borderWidth: 2,
    paddingHorizontal: 16,
    minHeight: 54,
    width: '100%',
  },
  input: {
    flex: 1,
    fontSize: 16,
    paddingVertical: 12,
  },
  checkmarkContainer: {
    marginLeft: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkmarkCircle: {
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkmark: {
    width: 8,
    height: 14,
    borderBottomWidth: 3,
    borderRightWidth: 3,
    transform: [{ rotate: '45deg' }, { translateY: -2 }],
  },
});

PasswordInput.displayName = 'PasswordInput';


================================================
FILE: ./components/SafeAreaSectionList.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo } from 'react';
import { StyleSheet, SectionList, SectionListProps } from 'react-native';

import { useTheme } from './themes';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

interface SafeAreaSectionListProps<ItemT, SectionT> extends SectionListProps<ItemT, SectionT> {
  floatingButtonHeight?: number;
  ignoreTopInset?: boolean;
}

const SafeAreaSectionList = <ItemT, SectionT>(props: SafeAreaSectionListProps<ItemT, SectionT>) => {
  const { style, contentContainerStyle, floatingButtonHeight = 0, ignoreTopInset = false, ...otherProps } = props;
  const { colors } = useTheme();
  const insets = useSafeAreaInsets();

  const componentStyle = useMemo(() => {
    return StyleSheet.compose({ flex: 1, backgroundColor: colors.background }, style);
  }, [colors.background, style]);

  const contentStyle = useMemo(() => {
    return StyleSheet.compose(
      {
        paddingBottom: insets.bottom + floatingButtonHeight, // Add extra padding for the floating button
        paddingRight: insets.right,
        paddingLeft: insets.left,
        paddingTop: ignoreTopInset ? 0 : insets.top,
      },
      contentContainerStyle,
    );
  }, [insets, contentContainerStyle, floatingButtonHeight, ignoreTopInset]);

  return (
    <SectionList
      style={componentStyle}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustKeyboardInsets
      automaticallyAdjustContentInsets
      automaticallyAdjustsScrollIndicatorInsets
      contentContainerStyle={contentStyle}
      {...otherProps}
    />
  );
};

export default SafeAreaSectionList;


================================================
FILE: ./components/CopyTextToClipboard.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import Clipboard from '@react-native-clipboard/clipboard';
import React, { forwardRef, useEffect, useState } from 'react';
import { Animated, StyleSheet, TouchableOpacity, View } from 'react-native';

import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import loc from '../loc';

type CopyTextToClipboardProps = {
  text: string;
  truncated?: boolean;
};

const styleCopyTextToClipboard = StyleSheet.create({
  address: {
    marginVertical: 32,
    fontSize: 15,
    color: '#9aa0aa',
    textAlign: 'center',
  },
});

const CopyTextToClipboard = forwardRef<React.ElementRef<typeof TouchableOpacity>, CopyTextToClipboardProps>(({ text, truncated }, ref) => {
  const [hasTappedText, setHasTappedText] = useState(false);
  const [address, setAddress] = useState(text);

  useEffect(() => {
    if (!hasTappedText) {
      setAddress(text);
    }
  }, [text, hasTappedText]);

  const copyToClipboard = () => {
    setHasTappedText(true);
    Clipboard.setString(text);
    triggerHapticFeedback(HapticFeedbackTypes.Selection);
    setAddress(loc.wallets.xpub_copiedToClipboard); // Adjust according to your localization logic
    setTimeout(() => {
      setHasTappedText(false);
      setAddress(text);
    }, 1000);
  };

  return (
    <View style={styles.container}>
      <TouchableOpacity
        ref={ref}
        accessibilityRole="button"
        onPress={copyToClipboard}
        disabled={hasTappedText}
        testID="CopyTextToClipboard"
      >
        <Animated.Text
          style={styleCopyTextToClipboard.address}
          {...(truncated ? { numberOfLines: 1, ellipsizeMode: 'middle' } : { numberOfLines: 0 })}
          testID="AddressValue"
        >
          {address}
        </Animated.Text>
      </TouchableOpacity>
    </View>
  );
});

export default CopyTextToClipboard;

const styles = StyleSheet.create({
  container: { justifyContent: 'center', alignItems: 'center', paddingHorizontal: 16 },
});


================================================
FILE: ./components/Alert.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Alert as RNAlert, Platform, ToastAndroid, AlertButton, AlertOptions } from 'react-native';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import loc from '../loc';
import { navigationRef } from '../NavigationService';

export enum AlertType {
  Alert,
  Toast,
}

const presentAlert = (() => {
  let lastAlertParams: {
    title?: string;
    message: string;
    type?: AlertType;
    hapticFeedback?: HapticFeedbackTypes;
    buttons?: AlertButton[];
    options?: AlertOptions;
  } | null = null;

  const clearCache = () => {
    lastAlertParams = null;
  };

  const showAlert = (title: string | undefined, message: string, buttons: AlertButton[], options: AlertOptions) => {
    if (Platform.OS === 'ios' && navigationRef.isReady()) {
      RNAlert.alert(title ?? message, title && message ? message : undefined, buttons, options);
    } else {
      RNAlert.alert(title ?? '', message, buttons, options);
    }
  };

  return ({
    title,
    message,
    type = AlertType.Alert,
    hapticFeedback,
    buttons = [],
    options = { cancelable: false },
    allowRepeat = true,
  }: {
    title?: string;
    message: string;
    type?: AlertType;
    hapticFeedback?: HapticFeedbackTypes;
    buttons?: AlertButton[];
    options?: AlertOptions;
    allowRepeat?: boolean;
  }) => {
    const currentAlertParams = { title, message, type, hapticFeedback, buttons, options };

    if (!allowRepeat && lastAlertParams && JSON.stringify(lastAlertParams) === JSON.stringify(currentAlertParams)) {
      return;
    }

    if (JSON.stringify(lastAlertParams) !== JSON.stringify(currentAlertParams)) {
      clearCache();
    }

    lastAlertParams = currentAlertParams;

    if (hapticFeedback) {
      triggerHapticFeedback(hapticFeedback);
    }

    const wrappedButtons: AlertButton[] = buttons.length > 0 ? buttons : [{ text: loc._.ok, onPress: () => {}, style: 'default' }];

    switch (type) {
      case AlertType.Toast:
        if (Platform.OS === 'android') {
          ToastAndroid.show(message, ToastAndroid.LONG);
          clearCache();
        } else {
          // For iOS, treat Toast as a normal alert
          showAlert(title, message, wrappedButtons, options);
        }
        break;
      default:
        showAlert(title, message, wrappedButtons, options);
        break;
    }
  };
})();

export default presentAlert;


================================================
FILE: ./components/DevMenu.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useEffect } from 'react';
import { DevSettings, Alert, Platform, AlertButton } from 'react-native';
import { useStorage } from '../hooks/context/useStorage';
import { HDSegwitBech32Wallet, WatchOnlyWallet } from '../class';
import Clipboard from '@react-native-clipboard/clipboard';
import { TWallet } from '../class/wallets/types';

const getRandomLabelFromSecret = (secret: string): string => {
  const words = secret.split(' ');
  const firstWord = words[0];
  const lastWord = words[words.length - 1];
  return `[Developer] ${firstWord} ${lastWord}`;
};

const showAlertWithWalletOptions = (
  wallets: TWallet[],
  title: string,
  message: string,
  onWalletSelected: (wallet: TWallet) => void,
  filterFn?: (wallet: TWallet) => boolean,
) => {
  const filteredWallets = filterFn ? wallets.filter(filterFn) : wallets;

  const showWallet = (index: number) => {
    if (index >= filteredWallets.length) return;
    const wallet = filteredWallets[index];

    if (Platform.OS === 'android') {
      // Android: Use a limited number of buttons since the alert dialog has a limit
      Alert.alert(
        `${title}: ${wallet.getLabel()}`,
        `${message}\n\nSelected Wallet: ${wallet.getLabel()}\n\nWould you like to select this wallet or see the next one?`,
        [
          {
            text: 'Select This Wallet',
            onPress: () => onWalletSelected(wallet),
          },
          {
            text: 'Show Next Wallet',
            onPress: () => showWallet(index + 1),
          },
          {
            text: 'Cancel',
            style: 'cancel',
          },
        ],
        { cancelable: true },
      );
    } else {
      const options: AlertButton[] = filteredWallets.map(w => ({
        text: w.getLabel(),
        onPress: () => onWalletSelected(w),
      }));

      options.push({
        text: 'Cancel',
        style: 'cancel',
      });

      Alert.alert(title, message, options, { cancelable: true });
    }
  };

  if (filteredWallets.length > 0) {
    showWallet(0);
  } else {
    Alert.alert('No wallets available');
  }
};

const DevMenu: React.FC = () => {
  const { wallets, addWallet } = useStorage();

  useEffect(() => {
    if (__DEV__) {
      // Clear existing Dev Menu items to prevent duplication
      DevSettings.addMenuItem('Reset Dev Menu', () => {
        DevSettings.reload();
      });

      DevSettings.addMenuItem('Add New Wallet', async () => {
        const wallet = new HDSegwitBech32Wallet();
        await wallet.generate();
        const label = getRandomLabelFromSecret(wallet.getSecret());
        wallet.setLabel(label);
        addWallet(wallet);

        Clipboard.setString(wallet.getSecret());
        Alert.alert('New Wallet created!', `Wallet secret copied to clipboard.\nLabel: ${label}`);
      });

      DevSettings.addMenuItem('Copy Wallet Secret', () => {
        if (wallets.length === 0) {
          Alert.alert('No wallets available');
          return;
        }

        showAlertWithWalletOptions(wallets, 'Copy Wallet Secret', 'Select the wallet to copy the secret', wallet => {
          Clipboard.setString(wallet.getSecret());
          Alert.alert('Wallet Secret copied to clipboard!');
        });
      });

      DevSettings.addMenuItem('Copy Wallet ID', () => {
        if (wallets.length === 0) {
          Alert.alert('No wallets available');
          return;
        }

        showAlertWithWalletOptions(wallets, 'Copy Wallet ID', 'Select the wallet to copy the ID', wallet => {
          Clipboard.setString(wallet.getID());
          Alert.alert('Wallet ID copied to clipboard!');
        });
      });

      DevSettings.addMenuItem('Copy Wallet Xpub', () => {
        if (wallets.length === 0) {
          Alert.alert('No wallets available');
          return;
        }

        showAlertWithWalletOptions(
          wallets,
          'Copy Wallet Xpub',
          'Select the wallet to copy the Xpub',
          wallet => {
            const xpub = wallet.getXpub();
            if (xpub) {
              Clipboard.setString(xpub);
              Alert.alert('Wallet Xpub copied to clipboard!');
            } else {
              Alert.alert('This wallet does not have an Xpub.');
            }
          },
          wallet => typeof wallet.getXpub === 'function',
        );
      });

      DevSettings.addMenuItem('Purge Wallet Transactions', () => {
        if (wallets.length === 0) {
          Alert.alert('No wallets available');
          return;
        }

        showAlertWithWalletOptions(wallets, 'Purge Wallet Transactions', 'Select the wallet to purge transactions', wallet => {
          const msg = 'Transactions purged successfully!';

          if (wallet.type === HDSegwitBech32Wallet.type) {
            wallet._txs_by_external_index = {};
            wallet._txs_by_internal_index = {};
          }

          if (wallet.type === WatchOnlyWallet.type && wallet._hdWalletInstance) {
            wallet._hdWalletInstance._txs_by_external_index = {};
            wallet._hdWalletInstance._txs_by_internal_index = {};
          }

          Alert.alert(msg);
        });
      });
    }
  }, [wallets, addWallet]);

  return null;
};

export default DevMenu;


================================================
FILE: ./components/StyledButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { FC } from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

import { useTheme } from './themes';

export const StyledButtonType: Record<string, string> = { default: 'default', destroy: 'destroy', grey: 'grey' };

interface StyledButtonProps {
  onPress: () => void;
  text: string;
  disabled?: boolean;
  buttonStyle?: keyof typeof StyledButtonType;
}

const StyledButton: FC<StyledButtonProps> = ({ onPress, text, disabled = false, buttonStyle = StyledButtonType.default }) => {
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    buttonGrey: {
      backgroundColor: colors.lightButton,
    },
    textGray: {
      color: colors.buttonTextColor,
    },
    container: {
      opacity: disabled ? 0.5 : 1.0,
    },
  });
  const textStyles = () => {
    if (buttonStyle === StyledButtonType.grey) {
      return stylesHook.textGray;
    } else if (buttonStyle === StyledButtonType.destroy) {
      return styles.textDestroy;
    } else {
      return styles.textDefault;
    }
  };

  const buttonStyles = () => {
    if (buttonStyle === StyledButtonType.grey) {
      return stylesHook.buttonGrey;
    } else if (buttonStyle === StyledButtonType.destroy) {
      return styles.buttonDestroy;
    } else {
      return styles.buttonDefault;
    }
  };

  return (
    <TouchableOpacity accessibilityRole="button" onPress={onPress} disabled={disabled} style={stylesHook.container}>
      <View style={[styles.buttonContainer, buttonStyles()]}>
        <Text style={[styles.text, textStyles()]}>{text}</Text>
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  buttonContainer: {
    borderRadius: 9,
    minHeight: 49,
    paddingHorizontal: 8,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
    alignSelf: 'auto',
    flexGrow: 1,
    marginHorizontal: 4,
  },
  buttonDefault: {
    backgroundColor: '#EBF2FB',
  },
  buttonDestroy: {
    backgroundColor: '#FFF5F5',
  },
  text: {
    fontWeight: '600',
    fontSize: 15,
  },
  textDefault: {
    color: '#1961B9',
  },
  textDestroy: {
    color: '#D0021B',
  },
});

export default StyledButton;


================================================
FILE: ./components/CopyToClipboardButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import Clipboard from '@react-native-clipboard/clipboard';
import React from 'react';
import { StyleSheet, Text, TouchableOpacity } from 'react-native';

import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import loc from '../loc';

type CopyToClipboardButtonProps = {
  stringToCopy: string;
  displayText?: string;
};

export const CopyToClipboardButton: React.FC<CopyToClipboardButtonProps> = ({ stringToCopy, displayText }) => {
  const onPress = () => {
    Clipboard.setString(stringToCopy);
    triggerHapticFeedback(HapticFeedbackTypes.Selection);
  };

  return (
    <TouchableOpacity accessibilityRole="button" onPress={onPress}>
      <Text style={styles.text}>{displayText && displayText.length > 0 ? displayText : loc.transactions.details_copy}</Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  text: { fontSize: 16, fontWeight: '400', color: '#68bbe1' },
});

export default CopyToClipboardButton;


================================================
FILE: ./components/MalinSpacing.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { View, ViewProps, StyleSheet } from 'react-native';

interface MalinSpacingProps extends ViewProps {
  horizontal?: boolean; // Optional prop to determine if spacing is horizontal
}

export const MalinSpacing10: React.FC<MalinSpacingProps> = props => {
  const { style, ...otherProps } = props;
  return <View {...otherProps} style={[styles.spacing10, style]} />;
};

export const MalinSpacing20: React.FC<MalinSpacingProps> = props => {
  const { horizontal = false, style, ...otherProps } = props;
  return <View {...otherProps} style={[horizontal ? styles.spacing20Horizontal : styles.spacing20Vertical, style]} />;
};

export const MalinSpacing40: React.FC<MalinSpacingProps> = props => {
  const { style, ...otherProps } = props;
  return <View {...otherProps} style={[styles.spacing40, style]} />;
};

export const MalinSpacing: React.FC<MalinSpacingProps> = props => {
  const { style, ...otherProps } = props;
  return <View {...otherProps} style={[styles.spacing60, style]} />;
};

const styles = StyleSheet.create({
  spacing10: {
    height: 10,
  },
  spacing20Vertical: {
    height: 20,
    width: 0,
    opacity: 0,
  },
  spacing20Horizontal: {
    height: 0,
    width: 20,
    opacity: 0,
  },
  spacing40: {
    height: 40,
  },
  spacing60: {
    height: 60,
  },
});


================================================
FILE: ./components/BottomModal.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef, useImperativeHandle, useRef, ReactElement, ComponentType } from 'react';
import { SheetSize, SizeChangeEvent, TrueSheet, TrueSheetProps } from '@lodev09/react-native-true-sheet';
import { Keyboard, Image, StyleSheet, View, Pressable, Platform, GestureResponderEvent, Text } from 'react-native';
import SaveFileButton from './SaveFileButton';
import { useTheme } from './themes';
import { Icon } from '@rneui/base';

interface BottomModalProps extends TrueSheetProps {
  children?: React.ReactNode;
  onClose?: () => void;
  onCloseModalPressed?: () => Promise<void>;
  isGrabberVisible?: boolean;
  sizes?: SheetSize[] | undefined;
  footer?: ReactElement | ComponentType<any> | null;
  footerDefaultMargins?: boolean | number;
  onPresent?: () => void;
  onSizeChange?: (event: SizeChangeEvent) => void;
  showCloseButton?: boolean;
  shareContent?: BottomModalShareContent;
  shareButtonOnPress?: (event: GestureResponderEvent) => void;
  header?: ReactElement | ComponentType<any> | null;
  headerTitle?: string;
  headerSubtitle?: string;
}

type BottomModalShareContent = {
  fileName: string;
  fileContent: string;
};

export interface BottomModalHandle {
  present: () => Promise<void>;
  dismiss: () => Promise<void>;
}

const BottomModal = forwardRef<BottomModalHandle, BottomModalProps>(
  (
    {
      onClose,
      onCloseModalPressed,
      onPresent,
      onSizeChange,
      showCloseButton = true,
      isGrabberVisible = true,
      shareContent,
      shareButtonOnPress,
      sizes = ['auto'],
      footer,
      footerDefaultMargins,
      header,
      headerTitle,
      headerSubtitle,
      children,
      ...props
    },
    ref,
  ) => {
    const trueSheetRef = useRef<TrueSheet>(null);
    const { colors, closeImage } = useTheme();
    const stylesHook = StyleSheet.create({
      barButton: {
        backgroundColor: colors.lightButton,
      },
      headerTitle: {
        color: colors.foregroundColor,
      },
    });

    useImperativeHandle(ref, () => ({
      present: async () => {
        Keyboard.dismiss();
        if (trueSheetRef.current?.present) {
          await trueSheetRef.current.present();
        } else {
          return Promise.resolve();
        }
      },
      dismiss: async () => {
        Keyboard.dismiss();
        if (trueSheetRef.current?.dismiss) {
          await trueSheetRef.current.dismiss();
        } else {
          return Promise.resolve();
        }
      },
    }));

    const dismiss = async () => {
      try {
        await onCloseModalPressed?.();
        await trueSheetRef.current?.dismiss();
      } catch (error) {
        console.error('Error during dismiss:', error);
      }
    };

    const renderTopRightButton = () => {
      const buttons = [];
      if (shareContent || shareButtonOnPress) {
        if (shareContent) {
          buttons.push(
            <SaveFileButton
              style={[styles.topRightButton, stylesHook.barButton]}
              fileContent={shareContent.fileContent}
              fileName={shareContent.fileName}
              testID="ModalShareButton"
              key="ModalShareButton"
            >
              <Icon
                name={Platform.OS === 'android' ? 'share' : 'file-upload'}
                type="font-awesome6"
                size={20}
                color={colors.buttonTextColor}
              />
            </SaveFileButton>,
          );
        } else if (shareButtonOnPress) {
          buttons.push(
            <Pressable
              testID="ModalShareButton"
              key="ModalShareButton"
              style={({ pressed }) => [pressed && styles.pressed, styles.topRightButton, stylesHook.barButton]}
              onPress={shareButtonOnPress}
            >
              <Icon
                name={Platform.OS === 'android' ? 'share' : 'file-upload'}
                type="font-awesome6"
                size={20}
                color={colors.buttonTextColor}
              />
            </Pressable>,
          );
        }
      }
      if (showCloseButton) {
        buttons.push(
          <Pressable
            style={({ pressed }) => [pressed && styles.pressed, styles.topRightButton, stylesHook.barButton]}
            onPress={dismiss}
            key="ModalDoneButton"
            testID="ModalDoneButton"
          >
            <Image source={closeImage} />
          </Pressable>,
        );
      }
      return <View style={styles.topRightButtonContainer}>{buttons}</View>;
    };

    const renderHeader = () => {
      if (headerTitle || headerSubtitle) {
        return (
          <View style={styles.headerContainer}>
            <View style={styles.headerContent}>
              {headerTitle && <Text style={[styles.headerTitle, stylesHook.headerTitle]}>{headerTitle}</Text>}
              {headerSubtitle && <Text style={[styles.headerSubtitle, stylesHook.headerTitle]}>{headerSubtitle}</Text>}
            </View>
            {renderTopRightButton()}
          </View>
        );
      }

      if (showCloseButton || shareContent)
        return (
          <View style={styles.headerContainer}>
            <View style={styles.headerContent}>{typeof header === 'function' ? <header /> : header}</View>
            {renderTopRightButton()}
          </View>
        );

      if (React.isValidElement(header)) {
        return (
          <View style={styles.headerContainerWithCloseButton}>
            {header}
            {renderTopRightButton()}
          </View>
        );
      }
      return null;
    };

    const renderFooter = (): ReactElement | undefined => {
      if (React.isValidElement(footer)) {
        return footerDefaultMargins ? <View style={styles.footerContainer}>{footer}</View> : footer;
      } else if (typeof footer === 'function') {
        const ModalFooterComponent = footer as ComponentType<any>;
        return <ModalFooterComponent />;
      }

      return undefined;
    };

    const FooterComponent = renderFooter();

    return (
      <TrueSheet
        ref={trueSheetRef}
        sizes={sizes}
        onDismiss={onClose}
        onPresent={onPresent}
        onSizeChange={onSizeChange}
        grabber={isGrabberVisible}
        FooterComponent={FooterComponent as ReactElement}
        {...props}
      >
        <View style={styles.childrenContainer}>{children}</View>
        {renderHeader()}
      </TrueSheet>
    );
  },
);

export default BottomModal;

const styles = StyleSheet.create({
  footerContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  headerContainer: {
    position: 'absolute',
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    minHeight: 22,
    right: 16,
    top: 16,
  },
  headerContainerWithCloseButton: {
    position: 'absolute',
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    minHeight: 22,
    width: '100%',
    top: 16,
    left: 0,
    justifyContent: 'space-between',
  },
  headerContent: {
    flex: 1,
    justifyContent: 'center',
    minHeight: 22,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  headerSubtitle: {
    fontSize: 14,
  },
  topRightButton: {
    justifyContent: 'center',
    alignItems: 'center',
    width: 30,
    height: 30,
    borderRadius: 15,
    marginLeft: 22,
  },
  topRightButtonContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  childrenContainer: {
    paddingTop: 66,
    paddingHorizontal: 16,
    width: '100%',
  },
  pressed: {
    opacity: 0.6,
  },
});


================================================
FILE: ./components/SettingsBlockExplorerCustomUrlListItem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, TextInput, View, Switch } from 'react-native';
import { ListItem } from '@rneui/themed';
import { useTheme } from './themes';
import loc from '../loc';

interface SettingsBlockExplorerCustomUrlItemProps {
  isCustomEnabled: boolean;
  onSwitchToggle: (value: boolean) => void;
  customUrl: string;
  onCustomUrlChange: (url: string) => void;
  onSubmitCustomUrl: () => void;
  inputRef?: React.RefObject<TextInput>;
}

const SettingsBlockExplorerCustomUrlItem: React.FC<SettingsBlockExplorerCustomUrlItemProps> = ({
  isCustomEnabled,
  onSwitchToggle,
  customUrl,
  onCustomUrlChange,
  onSubmitCustomUrl,
  inputRef,
}) => {
  const { colors } = useTheme();

  return (
    <>
      <ListItem containerStyle={[styles.container, { backgroundColor: colors.background }]} bottomDivider>
        <ListItem.Content>
          <ListItem.Title style={[styles.title, { color: colors.text }]}>{loc.settings.block_explorer_preferred}</ListItem.Title>
        </ListItem.Content>
        <Switch
          accessible
          accessibilityRole="switch"
          accessibilityState={{ checked: isCustomEnabled }}
          onValueChange={onSwitchToggle}
          value={isCustomEnabled}
        />
      </ListItem>

      {isCustomEnabled && (
        <View style={[styles.uriContainer, { borderColor: colors.formBorder, backgroundColor: colors.inputBackgroundColor }]}>
          <TextInput
            ref={inputRef}
            value={customUrl}
            placeholder={loc._.enter_url}
            onChangeText={onCustomUrlChange}
            numberOfLines={1}
            style={[styles.uriText, { color: colors.text }]}
            placeholderTextColor={colors.placeholderTextColor}
            textContentType="URL"
            clearButtonMode="while-editing"
            autoCapitalize="none"
            autoCorrect={false}
            underlineColorAndroid="transparent"
            onSubmitEditing={onSubmitCustomUrl}
            editable={isCustomEnabled}
          />
        </View>
      )}
    </>
  );
};

export default SettingsBlockExplorerCustomUrlItem;

const styles = StyleSheet.create({
  container: {
    minHeight: 60,
    paddingVertical: 10,
  },
  title: {
    fontSize: 16,
    fontWeight: '500',
  },
  uriContainer: {
    flexDirection: 'row',
    borderWidth: 1,
    borderRadius: 4,
    marginHorizontal: 15,
    marginVertical: 10,
    paddingHorizontal: 10,
    alignItems: 'center',
  },
  uriText: {
    flex: 1,
    minHeight: 36,
  },
});


================================================
FILE: ./components/QRCodeComponent.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import Clipboard from '@react-native-clipboard/clipboard';
import React, { useCallback, useRef } from 'react';
import { Platform, StyleSheet, View } from 'react-native';
import QRCode from 'react-native-qrcode-svg';
import Share from 'react-native-share';

import loc from '../loc';
import { ActionIcons } from '../typings/ActionIcons';
import { useTheme } from './themes';
import ToolTipMenu from './TooltipMenu';
import { Action } from './types';

interface QRCodeComponentProps {
  value: string;
  isLogoRendered?: boolean;
  isMenuAvailable?: boolean;
  logoSize?: number;
  size?: number;
  ecl?: 'H' | 'Q' | 'M' | 'L';
  onError?: () => void;
}

const BORDER_WIDTH = 6;

const actionIcons: { [key: string]: ActionIcons } = {
  Share: {
    iconValue: 'square.and.arrow.up',
  },
  Copy: {
    iconValue: 'doc.on.doc',
  },
};

const actionKeys = {
  Share: 'share',
  Copy: 'copy',
};

const menuActions: Action[] =
  Platform.OS === 'ios' || Platform.OS === 'macos'
    ? [
        {
          id: actionKeys.Copy,
          text: loc.transactions.details_copy,
          icon: actionIcons.Copy,
        },
        { id: actionKeys.Share, text: loc.receive.details_share, icon: actionIcons.Share },
      ]
    : [
        {
          id: actionKeys.Copy,
          text: loc.transactions.details_copy,
          icon: actionIcons.Copy,
        },
      ];

const QRCodeComponent: React.FC<QRCodeComponentProps> = ({
  value = '',
  isLogoRendered = true,
  isMenuAvailable = true,
  logoSize = 90,
  size = 300,
  ecl = 'H',
  onError = () => {},
}) => {
  const qrCode = useRef<any>();
  const { colors, dark } = useTheme();

  const handleShareQRCode = () => {
    qrCode.current.toDataURL((data: string) => {
      data = data.replace(/(\r\n|\n|\r)/gm, '');
      const shareImageBase64 = {
        url: `data:image/png;base64,${data}`,
      };
      Share.open(shareImageBase64).catch((error: Error) => console.log(error));
    });
  };

  const onPressMenuItem = useCallback((id: string) => {
    if (id === actionKeys.Share) {
      handleShareQRCode();
    } else if (id === actionKeys.Copy) {
      qrCode.current.toDataURL(Clipboard.setImage);
    }
  }, []);

  // Adjust the size of the QR code to account for the border width
  const newSize = dark ? size - BORDER_WIDTH * 2 : size;
  const stylesHook = StyleSheet.create({
    container: { borderWidth: dark ? BORDER_WIDTH : 0 },
  });

  const renderQRCode = (
    <QRCode
      value={value}
      {...(isLogoRendered ? { logo: require('../img/qr-code.png') } : {})}
      size={newSize}
      logoSize={logoSize}
      color="#000000"
      logoBackgroundColor={colors.brandingColor}
      backgroundColor="#FFFFFF"
      ecl={ecl}
      getRef={(c: any) => (qrCode.current = c)}
      onError={onError}
    />
  );

  return (
    <View
      style={[styles.container, stylesHook.container]}
      testID="BitcoinAddressQRCodeContainer"
      accessibilityIgnoresInvertColors
      importantForAccessibility="no-hide-descendants"
      accessibilityRole="image"
      accessibilityLabel={loc.receive.qrcode_for_the_address}
    >
      {isMenuAvailable ? (
        <ToolTipMenu actions={menuActions} onPressMenuItem={onPressMenuItem}>
          {renderQRCode}
        </ToolTipMenu>
      ) : (
        renderQRCode
      )}
    </View>
  );
};

export default QRCodeComponent;

const styles = StyleSheet.create({
  container: { borderColor: '#FFFFFF' },
});


================================================
FILE: ./components/DoneAndDismissKeyboardInputAccessory.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { InputAccessoryView, Keyboard, Platform, StyleSheet, View } from 'react-native';
import { MalinButtonLink } from '../MalinComponents';
import loc from '../loc';
import { useTheme } from './themes';
import Clipboard from '@react-native-clipboard/clipboard';

interface DoneAndDismissKeyboardInputAccessoryProps {
  onPasteTapped: (clipboard: string) => void;
  onClearTapped: () => void;
}
export const DoneAndDismissKeyboardInputAccessoryViewID = 'DoneAndDismissKeyboardInputAccessory';
export const DoneAndDismissKeyboardInputAccessory: React.FC<DoneAndDismissKeyboardInputAccessoryProps> = props => {
  const { colors } = useTheme();

  const styleHooks = StyleSheet.create({
    container: {
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  const onPasteTapped = async () => {
    const clipboard = await Clipboard.getString();
    props.onPasteTapped(clipboard);
  };

  const inputView = (
    <View style={[styles.container, styleHooks.container]}>
      <MalinButtonLink title={loc.send.input_clear} onPress={props.onClearTapped} />
      <MalinButtonLink title={loc.send.input_paste} onPress={onPasteTapped} />
      <MalinButtonLink title={loc.send.input_done} onPress={Keyboard.dismiss} />
    </View>
  );

  if (Platform.OS === 'ios') {
    return <InputAccessoryView nativeID={DoneAndDismissKeyboardInputAccessoryViewID}>{inputView}</InputAccessoryView>;
  } else {
    return inputView;
  }
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    maxHeight: 44,
  },
});


================================================
FILE: ./components/SafeAreaScrollView.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo, forwardRef } from 'react';
import { StyleSheet, ScrollView, ScrollViewProps } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

import { useTheme } from './themes';

interface SafeAreaScrollViewProps extends ScrollViewProps {
  floatingButtonHeight?: number;
}

const SafeAreaScrollView = forwardRef<ScrollView, SafeAreaScrollViewProps>((props, ref) => {
  const { style, contentContainerStyle, floatingButtonHeight = 0, ...otherProps } = props;
  const { colors } = useTheme();
  const insets = useSafeAreaInsets();

  const componentStyle = useMemo(() => {
    return StyleSheet.compose({ flex: 1, backgroundColor: colors.background }, style);
  }, [colors.background, style]);

  const contentStyle = useMemo(() => {
    // Calculate base inset paddings with proper typing
    const basePadding: {
      paddingBottom: number;
      paddingTop: number;
      paddingLeft?: number;
      paddingRight?: number;
    } = {
      paddingBottom: insets.bottom + floatingButtonHeight, // Add extra padding for the floating button
      paddingTop: insets.top > 0 ? 5 : 0, // Small padding if we have a safe area at top
    };

    // Only add horizontal paddings if they aren't explicitly defined in contentContainerStyle
    if (!StyleSheet.flatten(contentContainerStyle)?.paddingHorizontal && !StyleSheet.flatten(contentContainerStyle)?.paddingLeft) {
      basePadding.paddingLeft = insets.left;
    }

    if (!StyleSheet.flatten(contentContainerStyle)?.paddingHorizontal && !StyleSheet.flatten(contentContainerStyle)?.paddingRight) {
      basePadding.paddingRight = insets.right;
    }

    // Now compose with contentContainerStyle to ensure passed styles override defaults
    return StyleSheet.compose(basePadding, contentContainerStyle);
  }, [insets, contentContainerStyle, floatingButtonHeight]);

  return (
    <ScrollView
      ref={ref}
      style={componentStyle}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustKeyboardInsets
      automaticallyAdjustsScrollIndicatorInsets
      contentContainerStyle={contentStyle}
      {...otherProps}
    />
  );
});

export default SafeAreaScrollView;


================================================
FILE: ./components/DynamicQRCode.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { Component } from 'react';
import {
  Dimensions,
  LayoutAnimation,
  StyleSheet,
  TouchableOpacity,
  View
} from 'react-native';
import { Text } from '@rneui/themed';

import { encodeUR } from '../malin_modules/ur';
import { MalinCurrentTheme } from '../components/themes';
import loc from '../loc';
import QRCodeComponent from './QRCodeComponent';
import { MalinSpacing20 } from './MalinSpacing';

const { height, width } = Dimensions.get('window');

interface DynamicQRCodeProps {
  value: string;
  capacity?: number;
  hideControls?: boolean;
}

interface DynamicQRCodeState {
  index: number;
  total: number;
  qrCodeHeight: number;
  intervalHandler: ReturnType<typeof setInterval> | number | null;
  displayQRCode: boolean;
  hideControls?: boolean;
}

export class DynamicQRCode extends Component<
  DynamicQRCodeProps,
  DynamicQRCodeState
> {
  constructor(props: DynamicQRCodeProps) {
    super(props);
    const qrCodeHeight = height > width ? width - 40 : width / 3;
    const qrCodeMaxHeight = 370;
    this.state = {
      index: 0,
      total: 0,
      qrCodeHeight: Math.min(qrCodeHeight, qrCodeMaxHeight),
      intervalHandler: null,
      displayQRCode: true,
    }
  }

  fragments: string[] = [];

  componentDidMount () {
    const { value, capacity = 175, hideControls = true } = this.props;
    try {
      this.fragments = encodeUR(value, capacity);
      this.setState(
        {
          total: this.fragments.length,
          hideControls,
          displayQRCode: true,
        },
        () => {
          this.startAutoMove();
        }
      )
    } catch (e) {
      console.log(e);
      this.setState({ displayQRCode: false, hideControls });
    }
  }

  moveToNextFragment = () => {
    const { index, total } = this.state;
    if (index === total - 1) {
      this.setState({
        index: 0,
      })
    } else {
      this.setState((state) => ({
        index: state.index + 1,
      }));
    }
  };

  startAutoMove = () => {
    if (!this.state.intervalHandler) {
      this.setState(() => ({
        intervalHandler: setInterval(this.moveToNextFragment, 500)
      }))
    }
  };

  stopAutoMove = () => {
    clearInterval(this.state.intervalHandler as number);
    this.setState(() => ({
      intervalHandler: null,
    }));
  }

  moveToPreviousFragment = () => {
    const { index, total } = this.state;
    if (index > 0) {
      this.setState((state) => ({
        index: state.index - 1,
      }));
    } else {
      this.setState((state) => ({
        index: total - 1,
      }));
    }
  };

  onError = () => {
    console.log('Data is too large for QR Code.');
    this.setState({ displayQRCode: false });
  }

  render () {
    const currentFragment = this.fragments[this.state.index];

    if (!currentFragment && this.state.displayQRCode) {
      return (
        <View>
          <Text>{loc.send.dynamic_init}</Text>
        </View>
      );
    }

    return (
      <View style={animatedQRCodeStyle.container}>
        <TouchableOpacity
          accessibilityRole="button"
          testID="DynamicCode"
          onPress={() => {
            LayoutAnimation.configureNext(
              LayoutAnimation.Presets.easeInEaseOut
            );
            this.setState((prevState) => ({
              hideControls: !prevState.hideControls
            }));
          }}
        >
          {this.state.displayQRCode && (
            <View style={animatedQRCodeStyle.qrcodeContainer}>
              <QRCodeComponent
                isLogoRendered={false}
                value={currentFragment.toUpperCase()}
                size={this.state.qrCodeHeight}
                isMenuAvailable={false}
                ecl="L"
                onError={this.onError}
              />
            </View>
          )}
        </TouchableOpacity>

        {!this.state.hideControls && (
          <View style={animatedQRCodeStyle.container}>
            <MalinSpacing20 />
            <View>
              <Text style={animatedQRCodeStyle.text}>
                {loc.formatString(loc._.of, {
                  number: this.state.index + 1,
                  total: this.state.total
                })}
              </Text>
            </View>
            <MalinSpacing20 />
            <View style={animatedQRCodeStyle.controller}>
              <TouchableOpacity
                accessibilityRole="button"
                style={[
                  animatedQRCodeStyle.button,
                  animatedQRCodeStyle.buttonPrev
                ]}
                onPress={this.moveToPreviousFragment}
              >
                <Text style={animatedQRCodeStyle.text}>
                  {loc.send.dynamic_prev}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                accessibilityRole="button"
                style={[
                  animatedQRCodeStyle.button,
                  animatedQRCodeStyle.buttonStopStart
                ]}
                onPress={
                  this.state.intervalHandler
                    ? this.stopAutoMove
                    : this.startAutoMove
                }
              >
                <Text style={animatedQRCodeStyle.text}>
                  {this.state.intervalHandler
                    ? loc.send.dynamic_stop
                    : loc.send.dynamic_start}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                accessibilityRole="button"
                style={[
                  animatedQRCodeStyle.button,
                  animatedQRCodeStyle.buttonNext
                ]}
                onPress={this.moveToNextFragment}
              >
                <Text style={animatedQRCodeStyle.text}>
                  {loc.send.dynamic_next}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        )}
      </View>
    );
  }
}

const animatedQRCodeStyle = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'column',
    alignItems: 'center',
  },
  qrcodeContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  controller: {
    width: '90%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderRadius: 25,
    height: 45,
    paddingHorizontal: 18,
  },
  button: {
    alignItems: 'center',
    height: 45,
    justifyContent: 'center',
  },
  buttonPrev: {
    width: '25%',
    alignItems: 'flex-start',
  },
  buttonStopStart: {
    width: '50%',
  },
  buttonNext: {
    width: '25%',
    alignItems: 'flex-end',
  },
  text: {
    fontSize: 14,
    color: MalinCurrentTheme.colors.foregroundColor,
    fontWeight: 'bold',
  },
})
export default DynamicQRCode;


================================================
FILE: ./components/HeaderRightButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, Text, TouchableOpacity } from 'react-native';

import { useTheme } from './themes';

interface HeaderRightButtonProps {
  disabled?: boolean;
  onPress?: () => void;
  title: string;
  testID?: string;
}

const HeaderRightButton: React.FC<HeaderRightButtonProps> = ({ disabled = true, onPress, title, testID }) => {
  const { colors } = useTheme();
  const opacity = disabled ? 0.5 : 1;
  return (
    <TouchableOpacity
      accessibilityRole="button"
      disabled={disabled}
      style={[styles.save, { backgroundColor: colors.lightButton }, { opacity }]}
      onPress={onPress}
      testID={testID}
    >
      <Text style={[styles.saveText, { color: colors.buttonTextColor }]}>{title}</Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  save: {
    alignItems: 'center',
    justifyContent: 'center',
    width: 80,
    borderRadius: 8,
    height: 34,
  },
  saveText: {
    fontSize: 15,
    fontWeight: '600',
  },
});

export default HeaderRightButton;


================================================
FILE: ./components/WalletsCarousel.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef, useCallback, useImperativeHandle, useMemo, useRef, useEffect, createRef } from 'react';
import {
  Animated,
  FlatList,
  ImageBackground,
  Platform,
  Pressable,
  StyleSheet,
  Text,
  useWindowDimensions,
  View,
  FlatListProps,
  ListRenderItemInfo,
  ViewStyle,
  LayoutAnimation,
  UIManager,
} from 'react-native';
import LinearGradient from 'react-native-linear-gradient';
import { LightningArkWallet, LightningCustodianWallet, MultisigHDWallet } from '../class';
import WalletGradient from '../class/wallet-gradient';
import { useSizeClass, SizeClass } from '../malin_modules/sizeClass';
import loc, { formatBalance, transactionTimeToReadable } from '../loc';
import { BlurredBalanceView } from './BlurredBalanceView';
import { useTheme } from './themes';
import { useStorage } from '../hooks/context/useStorage';
import { WalletTransactionsStatus } from './Context/StorageProvider';
import { Transaction, TWallet } from '../class/wallets/types';
import HighlightedText from './HighlightedText';
import { MalinSpacing10 } from './MalinSpacing';
import { useLocale } from '@react-navigation/native';

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

interface NewWalletPanelProps {
  onPress: () => void;
}

const nStyles = StyleSheet.create({
  container: {
    borderRadius: 10,
    minHeight: Platform.OS === 'ios' ? 164 : 181,
    justifyContent: 'center',
    alignItems: 'flex-start',
  },
  addAWAllet: {
    fontWeight: '600',
    fontSize: 24,
    marginBottom: 4,
  },
  addLine: {
    fontSize: 13,
  },
  button: {
    marginTop: 12,
    backgroundColor: '#007AFF',
    paddingHorizontal: 32,
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonText: {
    fontWeight: '500',
  },
});

const NewWalletPanel: React.FC<NewWalletPanelProps> = ({ onPress }) => {
  const { colors } = useTheme();
  const { width } = useWindowDimensions();
  const itemWidth = width * 0.82 > 375 ? 375 : width * 0.82;
  const { isLarge } = useSizeClass();
  const nStylesHooks = StyleSheet.create({
    container: isLarge
      ? {
          paddingHorizontal: 24,
          marginVertical: 16,
        }
      : { paddingVertical: 16, paddingHorizontal: 24 },
  });

  const scale = useRef(new Animated.Value(1)).current;

  const handlePressIn = useCallback(() => {
    Animated.spring(scale, {
      toValue: 0.97,
      useNativeDriver: true,
      friction: 4,
    }).start();
  }, [scale]);

  const handlePressOut = useCallback(() => {
    Animated.spring(scale, {
      toValue: 1,
      useNativeDriver: true,
      friction: 4,
    }).start();
  }, [scale]);

  return (
    <Pressable
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      onPress={onPress}
      testID="CreateAWallet"
      style={({ pressed }) => [
        isLarge ? {} : { width: itemWidth * 1.2 },
        {
          opacity: pressed ? 0.9 : 1.0,
        },
      ]}
      accessibilityRole="button"
      accessibilityLabel={loc.wallets.list_create_a_wallet}
    >
      <Animated.View
        style={[
          nStyles.container,
          nStylesHooks.container,
          { backgroundColor: WalletGradient.createWallet() },
          isLarge ? {} : { width: itemWidth },
          { transform: [{ scale }] },
        ]}
      >
        <Text style={[nStyles.addAWAllet, { color: colors.foregroundColor }]}>{loc.wallets.list_create_a_wallet}</Text>
        <Text style={[nStyles.addLine, { color: colors.alternativeTextColor }]}>{loc.wallets.list_create_a_wallet_text}</Text>
        <View style={nStyles.button}>
          <Text style={[nStyles.buttonText, { color: colors.brandingColor }]}>{loc.wallets.list_create_a_button}</Text>
        </View>
      </Animated.View>
    </Pressable>
  );
};

interface WalletCarouselItemProps {
  item: TWallet;
  onPress: (item: TWallet) => void;
  handleLongPress?: () => void;
  isSelectedWallet?: boolean;
  customStyle?: ViewStyle;
  horizontal?: boolean;
  isPlaceHolder?: boolean;
  searchQuery?: string;
  renderHighlightedText?: (text: string, query: string) => JSX.Element;
  animationsEnabled?: boolean;
  onPressIn?: () => void;
  onPressOut?: () => void;
  isNewWallet?: boolean;
  isExiting?: boolean;
}

const iStyles = StyleSheet.create({
  root: { paddingRight: 20 },
  rootLargeDevice: { marginVertical: 20 },
  grad: {
    padding: 15,
    borderRadius: 12,
    minHeight: 164,
  },
  balanceContainer: {
    height: 40,
  },
  image: {
    width: 99,
    height: 94,
    position: 'absolute',
    bottom: 0,
    right: 0,
  },
  br: {
    backgroundColor: 'transparent',
  },
  label: {
    backgroundColor: 'transparent',
    fontSize: 19,
  },
  balance: {
    backgroundColor: 'transparent',
    fontWeight: 'bold',
    fontSize: 36,
  },
  latestTx: {
    backgroundColor: 'transparent',
    fontSize: 13,
  },
  latestTxTime: {
    backgroundColor: 'transparent',
    fontWeight: 'bold',
    fontSize: 16,
  },
  shadowContainer: {
    ...Platform.select({
      ios: {
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 25 / 100,
        shadowRadius: 8,
        borderRadius: 12,
      },
      android: {
        elevation: 8,
        borderRadius: 12,
      },
    }),
  },
});

export const WalletCarouselItem: React.FC<WalletCarouselItemProps> = React.memo(
  ({
    item,
    onPress,
    handleLongPress,
    isSelectedWallet,
    customStyle,
    horizontal,
    searchQuery,
    renderHighlightedText,
    animationsEnabled = true,
    isPlaceHolder = false,
    onPressIn,
    onPressOut,
    isNewWallet = false,
    isExiting = false,
  }: WalletCarouselItemProps) => {
    const scaleValue = useRef(new Animated.Value(1.0)).current;
    const opacityValue = useRef(new Animated.Value(isSelectedWallet === false ? 0.5 : 1.0)).current;
    const translateYValue = useRef(new Animated.Value(isNewWallet ? 20 : 0)).current;
    const { colors } = useTheme();
    const { walletTransactionUpdateStatus } = useStorage();
    const { width } = useWindowDimensions();
    const itemWidth = width * 0.82 > 375 ? 375 : width * 0.82;
    const { sizeClass } = useSizeClass();
    const { direction } = useLocale();

    const springConfig = useMemo(() => ({ useNativeDriver: true, tension: 100 }), []);
    const animateScale = useCallback(
      (toValue: number, callback?: () => void) => {
        Animated.spring(scaleValue, { toValue, ...springConfig }).start(callback);
      },
      [scaleValue, springConfig],
    );

    useEffect(() => {
      if (!animationsEnabled) return;

      const targetOpacity = isSelectedWallet === false ? 0.5 : 1.0;
      Animated.spring(opacityValue, {
        toValue: targetOpacity,
        useNativeDriver: true,
        tension: 30,
        friction: 7,
        velocity: 0.1,
      }).start();
    }, [isSelectedWallet, opacityValue, animationsEnabled]);

    const onPressedIn = useCallback(() => {
      if (animationsEnabled) {
        animateScale(0.95);
      }
      if (onPressIn) onPressIn();
    }, [animateScale, animationsEnabled, onPressIn]);

    const onPressedOut = useCallback(() => {
      if (animationsEnabled) {
        animateScale(1.0);
      }
      if (onPressOut) onPressOut();
    }, [animateScale, animationsEnabled, onPressOut]);

    const handlePress = useCallback(() => {
      onPress(item);
    }, [item, onPress]);

    useEffect(() => {
      if (isNewWallet && animationsEnabled) {
        Animated.parallel([
          Animated.timing(translateYValue, {
            toValue: 0,
            duration: 300,
            useNativeDriver: true,
          }),
          Animated.spring(opacityValue, {
            toValue: isSelectedWallet === false ? 0.5 : 1.0,
            useNativeDriver: true,
            friction: 7,
          }),
        ]).start();
      }
    }, [isNewWallet, animationsEnabled, translateYValue, opacityValue, isSelectedWallet]);

    useEffect(() => {
      if (isExiting && animationsEnabled) {
        Animated.parallel([
          Animated.timing(translateYValue, {
            toValue: -20,
            duration: 200,
            useNativeDriver: true,
          }),
          Animated.timing(opacityValue, {
            toValue: 0,
            duration: 200,
            useNativeDriver: true,
          }),
        ]).start();
      }
    }, [isExiting, animationsEnabled, translateYValue, opacityValue]);

    let image;
    switch (item.type) {
      case LightningCustodianWallet.type:
      case LightningArkWallet.type:
        image = direction === 'rtl' ? require('../img/lnd-shape-rtl.png') : require('../img/lnd-shape.png');
        break;
      case MultisigHDWallet.type:
        image = direction === 'rtl' ? require('../img/vault-shape-rtl.png') : require('../img/vault-shape.png');
        break;
      default:
        image = direction === 'rtl' ? require('../img/btc-shape-rtl.png') : require('../img/btc-shape.png');
    }

    let latestTransactionText;

    if (walletTransactionUpdateStatus === WalletTransactionsStatus.ALL || walletTransactionUpdateStatus === item.getID()) {
      latestTransactionText = loc.transactions.updating;
    } else if (item.getBalance() !== 0 && item.getLatestTransactionTime() === 0) {
      latestTransactionText = loc.wallets.pull_to_refresh;
    } else if (item.getTransactions().find((tx: Transaction) => tx.confirmations === 0)) {
      latestTransactionText = loc.transactions.pending;
    } else {
      latestTransactionText = transactionTimeToReadable(item.getLatestTransactionTime());
    }

    const balance = !item.hideBalance && formatBalance(Number(item.getBalance()), item.getPreferredBalanceUnit(), true);

    return (
      <Animated.View
        style={[
          sizeClass === SizeClass.Large || !horizontal
            ? [iStyles.rootLargeDevice, customStyle]
            : (customStyle ?? { ...iStyles.root, width: itemWidth }),
          {
            opacity: opacityValue,
            transform: [{ scale: scaleValue }, { translateY: translateYValue }],
          },
        ]}
      >
        <Pressable
          accessibilityRole="button"
          testID={item.getLabel()}
          onPressIn={onPressedIn}
          onPressOut={onPressedOut}
          onLongPress={() => {
            if (handleLongPress) handleLongPress();
          }}
          onPress={handlePress}
          delayHoverIn={0}
          delayHoverOut={0}
        >
          <View style={[iStyles.shadowContainer, { backgroundColor: colors.background, shadowColor: colors.shadowColor }]}>
            <LinearGradient colors={WalletGradient.gradientsFor(item.type)} style={iStyles.grad}>
              <ImageBackground source={image} style={iStyles.image} />
              <Text style={iStyles.br} />
              {!isPlaceHolder && (
                <>
                  <Text numberOfLines={1} style={[iStyles.label, { color: colors.inverseForegroundColor, writingDirection: direction }]}>
                    {renderHighlightedText && searchQuery ? (
                      <HighlightedText
                        text={item.getLabel()}
                        query={searchQuery}
                        style={[iStyles.label, { color: colors.inverseForegroundColor, writingDirection: direction }]}
                      />
                    ) : (
                      item.getLabel()
                    )}
                  </Text>
                  <View style={iStyles.balanceContainer}>
                    {item.hideBalance ? (
                      <>
                        <MalinSpacing10 />
                        <BlurredBalanceView />
                      </>
                    ) : (
                      <Text
                        numberOfLines={1}
                        adjustsFontSizeToFit
                        key={`${balance}`} // force component recreation on balance change. To fix right-to-left languages, like Farsi
                        style={[iStyles.balance, { color: colors.inverseForegroundColor, writingDirection: direction }]}
                      >
                        {`${balance} `}
                      </Text>
                    )}
                  </View>
                  <Text style={iStyles.br} />
                  <Text numberOfLines={1} style={[iStyles.latestTx, { color: colors.inverseForegroundColor, writingDirection: direction }]}>
                    {loc.wallets.list_latest_transaction}
                  </Text>
                  <Text
                    numberOfLines={1}
                    style={[iStyles.latestTxTime, { color: colors.inverseForegroundColor, writingDirection: direction }]}
                  >
                    {latestTransactionText}
                  </Text>
                </>
              )}
            </LinearGradient>
          </View>
        </Pressable>
      </Animated.View>
    );
  },
);

interface WalletsCarouselProps extends Partial<FlatListProps<any>> {
  horizontal?: boolean;
  isFlatList?: boolean;
  selectedWallet?: string;
  onPress: (item: TWallet) => void;
  onNewWalletPress?: () => void;
  handleLongPress?: () => void;
  data: TWallet[];
  scrollEnabled?: boolean;
  searchQuery?: string;
  renderHighlightedText?: (text: string, query: string) => JSX.Element;
  animateChanges?: boolean;
}

type FlatListRefType = FlatList<any> & {
  scrollToEnd(params?: { animated?: boolean | null }): void;
  scrollToIndex(params: { animated?: boolean | null; index: number; viewOffset?: number; viewPosition?: number }): void;
  scrollToItem(params: { animated?: boolean | null; item: TWallet; viewPosition?: number }): void;
  scrollToOffset(params: { animated?: boolean | null; offset: number }): void;
  recordInteraction(): void;
  flashScrollIndicators(): void;
  getNativeScrollRef(): View;
};

const styles = StyleSheet.create({
  listHeaderSeparator: {
    width: 16,
    height: 20,
  },
});

const ListHeaderSeparator = () => <View style={styles.listHeaderSeparator} />;

const WalletsCarousel = forwardRef<FlatListRefType, WalletsCarouselProps>((props, ref) => {
  const {
    horizontal = true,
    data,
    handleLongPress,
    onPress,
    selectedWallet,
    scrollEnabled = true,
    onNewWalletPress,
    searchQuery,
    renderHighlightedText,
    isFlatList = true,
    animateChanges = false,
  } = props;

  const { width } = useWindowDimensions();
  const itemWidth = React.useMemo(() => (width * 0.82 > 375 ? 375 : width * 0.82), [width]);

  const prevDataLength = useRef(data.length);
  const prevWalletIds = useRef<string[]>([]);
  const newWalletsMap = useRef<Record<string, boolean>>({});
  const lastAddedWalletId = useRef<string | null>(null);
  const hasFocusedRef = useRef(false);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isInitialMount = useRef(true);

  const flatListRef = useRef<FlatList<any>>(null);
  const walletRefs = useRef<Record<string, React.RefObject<View>>>({});

  const { sizeClass } = useSizeClass();

  useImperativeHandle(ref, (): any => {
    if (isFlatList) {
      return {
        scrollToEnd: (params: { animated?: boolean | null | undefined } | undefined) => flatListRef.current?.scrollToEnd(params),
        scrollToIndex: (params: {
          animated?: boolean | null | undefined;
          index: number;
          viewOffset?: number | undefined;
          viewPosition?: number | undefined;
        }) => flatListRef.current?.scrollToIndex(params),
        scrollToItem: (params: {
          animated?: boolean | null | undefined;
          item: any;
          viewOffset?: number | undefined;
          viewPosition?: number | undefined;
        }) => flatListRef.current?.scrollToItem(params),
        scrollToOffset: (params: { animated?: boolean | null | undefined; offset: number }) => flatListRef.current?.scrollToOffset(params),
        recordInteraction: () => flatListRef.current?.recordInteraction(),
        flashScrollIndicators: () => flatListRef.current?.flashScrollIndicators(),
        getNativeScrollRef: () => flatListRef.current?.getNativeScrollRef(),
      };
    } else {
      // For non-FlatList mode, we'll return simpler methods to get/set information
      // but not actually handle scrolling (leaving that to the parent drawer)
      return {
        scrollToEnd: () => console.debug('[WalletsCarousel] scrollToEnd not implemented for non-FlatList'),
        scrollToIndex: () => console.debug('[WalletsCarousel] scrollToIndex not implemented for non-FlatList'),
        scrollToItem: () => console.debug('[WalletsCarousel] scrollToItem not implemented for non-FlatList'),
        scrollToOffset: () => console.debug('[WalletsCarousel] scrollToOffset not implemented for non-FlatList'),
        recordInteraction: () => {},
        flashScrollIndicators: () => {},
        getNativeScrollRef: () => null,
        // Add a method to get position information about a wallet
        getWalletPosition: (walletId: string) => {
          const walletRef = walletRefs.current[walletId];
          if (walletRef?.current) {
            return new Promise<{ x: number; y: number; width: number; height: number }>(resolve => {
              walletRef.current?.measure((x, y, widthVal, heightVal, pageX, pageY) => {
                resolve({ x: pageX, y: pageY, width: widthVal, height: heightVal });
              });
            });
          }
          return Promise.resolve(null);
        },
      };
    }
  }, [isFlatList]);

  useEffect(() => {
    return () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
    };
  }, []);

  useEffect(() => {
    data.forEach(wallet => {
      if (!walletRefs.current[wallet.getID()]) {
        walletRefs.current[wallet.getID()] = createRef<View>();
      }
    });
  }, [data]);

  const scrollToWalletById = useCallback(
    (walletId: string, animated = true) => {
      if (!walletId) return;

      console.debug('[WalletsCarousel] Attempting to scroll to wallet:', walletId);

      if (isFlatList && flatListRef.current) {
        const walletIndex = data.findIndex(wallet => wallet.getID() === walletId);
        if (walletIndex !== -1) {
          try {
            console.debug('[WalletsCarousel] Found wallet at index:', walletIndex, 'horizontal:', horizontal);
            flatListRef.current.scrollToIndex({
              index: walletIndex,
              animated,
              viewPosition: 0.5, // Center the wallet in the view
            });
          } catch (error) {
            console.warn('[WalletsCarousel] Error scrolling to wallet:', error);
            // Fallback: try scrolling to offset
            // Use different measurement based on orientation
            const itemSize = horizontal ? itemWidth : 195; // 195 is the approximate height of wallet card
            flatListRef.current.scrollToOffset({
              offset: itemSize * walletIndex,
              animated,
            });
          }
        }
      } else if (!isFlatList) {
        // For non-FlatList, just log the attempt
        // The parent DrawerContentScrollView should handle this
        const walletIndex = data.findIndex(wallet => wallet.getID() === walletId);
        console.debug(
          '[WalletsCarousel] Would scroll to wallet index:',
          walletIndex,
          'but leaving scrolling to parent DrawerContentScrollView',
        );
      }
    },
    [data, isFlatList, itemWidth, horizontal],
  );

  useEffect(() => {
    if (animateChanges) {
      const currentWalletIds = data.map(wallet => wallet.getID());

      // Skip auto-scrolling on initial mount
      if (isInitialMount.current) {
        isInitialMount.current = false;
        prevWalletIds.current = currentWalletIds;
        prevDataLength.current = data.length;
        return;
      }

      // Handle wallet additions
      const addedWallets = currentWalletIds.filter(id => !prevWalletIds.current.includes(id));
      if (addedWallets.length > 0) {
        // Track last added wallet for animations and scrolling
        lastAddedWalletId.current = addedWallets[addedWallets.length - 1];

        addedWallets.forEach(id => {
          newWalletsMap.current[id] = true;
        });

        // Always animate layout changes
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

        // Auto-scroll to new wallet after mount (no condition, always scroll)
        if (scrollTimeoutRef.current) {
          clearTimeout(scrollTimeoutRef.current);
        }

        scrollTimeoutRef.current = setTimeout(() => {
          // Add null check before calling scrollToWalletById
          if (lastAddedWalletId.current !== null) {
            scrollToWalletById(lastAddedWalletId.current, true);
          }
        }, 300);
      }

      // Handle wallet removals
      if (prevDataLength.current > data.length) {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      }

      // Update refs for next comparison
      prevWalletIds.current = currentWalletIds;
      prevDataLength.current = data.length;

      // Clear animation states
      if (addedWallets.length > 0) {
        setTimeout(() => {
          addedWallets.forEach(id => {
            delete newWalletsMap.current[id];
          });
          lastAddedWalletId.current = null;
        }, 2000);
      }
    }
  }, [data, animateChanges, scrollToWalletById]);

  const onScrollToIndexFailed = (error: { averageItemLength: number; index: number }): void => {
    console.debug('onScrollToIndexFailed', error);
    flatListRef.current?.scrollToOffset({ offset: error.averageItemLength * error.index, animated: true });
    setTimeout(() => {
      if (data.length !== 0 && flatListRef.current !== null) {
        flatListRef.current.scrollToIndex({ index: error.index, animated: true });
      }
    }, 100);
  };

  const renderItem = useCallback(
    ({ item, index }: ListRenderItemInfo<TWallet>) =>
      item ? (
        <WalletCarouselItem
          isSelectedWallet={!horizontal && selectedWallet ? selectedWallet === item.getID() : undefined}
          item={item}
          handleLongPress={handleLongPress}
          onPress={onPress}
          horizontal={horizontal}
          searchQuery={searchQuery}
          renderHighlightedText={renderHighlightedText}
          isNewWallet={animateChanges && newWalletsMap.current[item.getID()]}
          animationsEnabled={animateChanges}
        />
      ) : null,
    [horizontal, selectedWallet, handleLongPress, onPress, searchQuery, renderHighlightedText, animateChanges],
  );

  const keyExtractor = useCallback((item: TWallet, index: number) => (item?.getID ? item.getID() : index.toString()), []);

  const sliderHeight = 195;

  useEffect(() => {
    return () => {
      hasFocusedRef.current = false;
    };
  }, []);

  const renderNonFlatListWallets = useCallback(() => {
    return data.map((item, index) =>
      item ? (
        <View
          key={item.getID()}
          ref={walletRefs.current[item.getID()]}
          onLayout={() => {
            if (walletRefs.current[item.getID()]?.current && newWalletsMap.current[item.getID()]) {
              walletRefs.current[item.getID()].current?.measure((x, y, widthVal, heightVal, pageX, pageY) => {
                console.debug(`[WalletsCarousel] New wallet ${item.getID()} positioned at y=${y}, pageY=${pageY}`);
              });
            }
          }}
        >
          <WalletCarouselItem
            isSelectedWallet={!horizontal && selectedWallet ? selectedWallet === item.getID() : undefined}
            item={item}
            handleLongPress={handleLongPress}
            onPress={onPress}
            searchQuery={props.searchQuery}
            renderHighlightedText={props.renderHighlightedText}
            isNewWallet={animateChanges && newWalletsMap.current[item.getID()]}
            animationsEnabled={animateChanges}
          />
        </View>
      ) : null,
    );
  }, [data, horizontal, selectedWallet, handleLongPress, onPress, props.searchQuery, props.renderHighlightedText, animateChanges]);

  useEffect(() => {
    // We check the current values inside the effect, but don't include them as dependencies
    if (!isFlatList && lastAddedWalletId.current !== null && !isInitialMount.current) {
      // Use a slightly longer delay to ensure the ScrollView has fully rendered
      const scrollDelay = setTimeout(() => {
        console.debug('[WalletsCarousel] Attempting delayed scroll to:', lastAddedWalletId.current);
        if (lastAddedWalletId.current !== null) {
          scrollToWalletById(lastAddedWalletId.current, true);
        }
      }, 500);

      return () => clearTimeout(scrollDelay);
    }
  }, [isFlatList, scrollToWalletById]); // Remove ref.current values from dependency array

  const cStyles = StyleSheet.create({
    content: {
      paddingTop: 16,
    },
    contentLargeScreen: {
      paddingHorizontal: sizeClass === SizeClass.Large ? 16 : 12,
    },
  });

  return isFlatList ? (
    <FlatList
      ref={flatListRef}
      renderItem={renderItem}
      extraData={[data, animateChanges, newWalletsMap.current, selectedWallet, lastAddedWalletId.current]}
      keyExtractor={keyExtractor}
      showsVerticalScrollIndicator={false}
      pagingEnabled={horizontal}
      disableIntervalMomentum={horizontal}
      snapToInterval={itemWidth}
      decelerationRate="fast"
      contentContainerStyle={cStyles.content}
      directionalLockEnabled
      showsHorizontalScrollIndicator={false}
      initialNumToRender={10}
      scrollEnabled={scrollEnabled}
      keyboardShouldPersistTaps="handled"
      ListHeaderComponent={ListHeaderSeparator}
      contentInsetAdjustmentBehavior="automatic"
      automaticallyAdjustContentInsets
      automaticallyAdjustKeyboardInsets
      automaticallyAdjustsScrollIndicatorInsets
      style={{ minHeight: sliderHeight + 12 }}
      onScrollToIndexFailed={onScrollToIndexFailed}
      ListFooterComponent={onNewWalletPress ? <NewWalletPanel onPress={onNewWalletPress} /> : null}
      {...props}
    />
  ) : (
    <View style={cStyles.contentLargeScreen}>
      {renderNonFlatListWallets()}
      {onNewWalletPress && <NewWalletPanel onPress={onNewWalletPress} />}
    </View>
  );
});

export default WalletsCarousel;


================================================
FILE: ./components/PromptPasswordConfirmationModal.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useState, useRef, forwardRef, useImperativeHandle, useEffect } from 'react';
import { View, Text, TextInput, StyleSheet, Animated, Easing, ViewStyle, Keyboard, Platform, UIManager } from 'react-native';
import BottomModal, { BottomModalHandle } from './BottomModal';
import { useTheme } from '../components/themes';
import loc from '../loc';
import { SecondButton } from './SecondButton';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import { useKeyboard } from '../hooks/useKeyboard';

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

export const MODAL_TYPES = {
  ENTER_PASSWORD: 'ENTER_PASSWORD',
  CREATE_PASSWORD: 'CREATE_PASSWORD',
  CREATE_FAKE_STORAGE: 'CREATE_FAKE_STORAGE',
  SUCCESS: 'SUCCESS',
} as const;

export type ModalType = (typeof MODAL_TYPES)[keyof typeof MODAL_TYPES];

interface PromptPasswordConfirmationModalProps {
  modalType: ModalType;
  onConfirmationSuccess: (password: string) => Promise<boolean>;
  onConfirmationFailure: () => void;
}

export interface PromptPasswordConfirmationModalHandle {
  present: () => Promise<void>;
  dismiss: () => Promise<void>;
}

const PromptPasswordConfirmationModal = forwardRef<PromptPasswordConfirmationModalHandle, PromptPasswordConfirmationModalProps>(
  ({ modalType, onConfirmationSuccess, onConfirmationFailure }, ref) => {
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [isSuccess, setIsSuccess] = useState(false);
    const [showExplanation, setShowExplanation] = useState(false); // State to toggle between explanation and password input for CREATE_PASSWORD and CREATE_FAKE_STORAGE
    const modalRef = useRef<BottomModalHandle>(null);
    const fadeOutAnimation = useRef(new Animated.Value(1)).current;
    const fadeInAnimation = useRef(new Animated.Value(0)).current;
    const scaleAnimation = useRef(new Animated.Value(1)).current;
    const shakeAnimation = useRef(new Animated.Value(0)).current;
    const explanationOpacity = useRef(new Animated.Value(1)).current;
    const { colors } = useTheme();
    const passwordInputRef = useRef<TextInput>(null);
    const confirmPasswordInputRef = useRef<TextInput>(null);
    const { isVisible } = useKeyboard();

    const stylesHook = StyleSheet.create({
      modalContent: {
        backgroundColor: colors.elevated,
        width: '100%',
      },
      input: {
        backgroundColor: colors.inputBackgroundColor,
        borderColor: colors.formBorder,
        color: colors.foregroundColor,
        width: '100%',
      },
      feeModalCustomText: {
        color: colors.buttonAlternativeTextColor,
      },
      feeModalLabel: {
        color: colors.successColor,
      },
    });

    useImperativeHandle(ref, () => ({
      present: async () => {
        resetState();
        modalRef.current?.present();
        if (modalType === MODAL_TYPES.CREATE_PASSWORD || (modalType === MODAL_TYPES.CREATE_FAKE_STORAGE && !showExplanation)) {
          passwordInputRef.current?.focus();
        } else if (modalType === MODAL_TYPES.ENTER_PASSWORD) {
          passwordInputRef.current?.focus();
        }
      },
      dismiss: async () => {
        await modalRef.current?.dismiss();
        resetState();
      },
    }));

    const resetState = () => {
      setPassword('');
      setConfirmPassword('');
      setIsSuccess(false);
      setIsLoading(false);
      fadeOutAnimation.setValue(1);
      fadeInAnimation.setValue(0);
      scaleAnimation.setValue(1);
      shakeAnimation.setValue(0);
      explanationOpacity.setValue(1);
      setShowExplanation(modalType === MODAL_TYPES.CREATE_PASSWORD);
    };

    useEffect(() => {
      resetState();
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [modalType]);

    const performShake = (shakeAnimRef: Animated.Value) => {
      Animated.sequence([
        Animated.timing(shakeAnimRef, {
          toValue: 10,
          duration: 100,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(shakeAnimRef, {
          toValue: -10,
          duration: 100,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(shakeAnimRef, {
          toValue: 5,
          duration: 100,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(shakeAnimRef, {
          toValue: -5,
          duration: 100,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(shakeAnimRef, {
          toValue: 0,
          duration: 100,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ]).start();
    };

    const handleShakeAnimation = () => {
      performShake(shakeAnimation);
    };

    const handleSuccessAnimation = () => {
      // Step 1: Cross-fade current content out and success content in
      Animated.timing(fadeOutAnimation, {
        toValue: 0, // Fade out current content
        duration: 300,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      }).start(() => {
        setIsSuccess(true);

        Animated.timing(fadeInAnimation, {
          toValue: 1, // Fade in success content
          duration: 300,
          easing: Easing.out(Easing.ease),
          useNativeDriver: true,
        }).start(() => {
          // Step 2: Perform any additional animations like scaling if necessary
          Animated.timing(scaleAnimation, {
            toValue: 1.1,
            duration: 300,
            easing: Easing.out(Easing.ease),
            useNativeDriver: true,
          }).start(() => {
            Animated.timing(scaleAnimation, {
              toValue: 1, // Return scale to normal size
              duration: 300,
              easing: Easing.out(Easing.ease),
              useNativeDriver: true,
            }).start(() => {
              // Optional delay before dismissing the modal
              setTimeout(async () => {
                await modalRef.current?.dismiss();
              }, 1000);
            });
          });
        });
      });
    };

    const handleConfirmationFailure = () => {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
      if (!isSuccess) handleShakeAnimation();
      onConfirmationFailure();
    };

    const handleConfirmSuccess = () => {
      triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
      handleSuccessAnimation();
    };

    const handleSubmit = async () => {
      Keyboard.dismiss();
      setIsLoading(true);
      let success = false;

      try {
        if (modalType === MODAL_TYPES.CREATE_PASSWORD || modalType === MODAL_TYPES.CREATE_FAKE_STORAGE) {
          if (password === confirmPassword && password) {
            success = await onConfirmationSuccess(password);
            success ? handleConfirmSuccess() : handleConfirmationFailure();
          } else {
            handleConfirmationFailure();
          }
        } else if (modalType === MODAL_TYPES.ENTER_PASSWORD) {
          success = await onConfirmationSuccess(password);
          success ? handleConfirmSuccess() : handleConfirmationFailure();
        }
      } finally {
        setIsLoading(false); // Ensure loading state is reset
        if (success) {
          // Ensure shake animation is reset before starting the success animation
          shakeAnimation.setValue(0);
        }
      }
    };

    const handleTransitionToCreatePassword = () => {
      Animated.timing(explanationOpacity, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start(() => {
        setShowExplanation(false);
        explanationOpacity.setValue(1); // Reset opacity for when transitioning back
        passwordInputRef.current?.focus();
      });
    };

    const handleCancel = async () => {
      onConfirmationFailure();
      await modalRef.current?.dismiss();
    };

    const animatedViewStyle: Animated.WithAnimatedObject<ViewStyle> = {
      opacity: fadeOutAnimation,
      transform: [{ scale: scaleAnimation }],
      width: '100%',
    };

    const onModalDismiss = () => {
      resetState();
      onConfirmationFailure();
    };

    const opacity = isVisible ? 0 : 1;
    return (
      <BottomModal
        ref={modalRef}
        onClose={onModalDismiss}
        grabber={false}
        showCloseButton={!isSuccess}
        onCloseModalPressed={handleCancel}
        backgroundColor={colors.modal}
        isGrabberVisible={!isSuccess}
        dismissible={false}
        sizes={Platform.OS === 'ios' ? ['auto'] : [460, '90%']}
        footer={
          !isSuccess ? (
            showExplanation && modalType === MODAL_TYPES.CREATE_PASSWORD ? (
              <Animated.View style={[{ opacity: explanationOpacity }, styles.feeModalFooterSpacing]}>
                <SecondButton
                  title={loc.settings.i_understand}
                  onPress={handleTransitionToCreatePassword}
                  disabled={isLoading}
                  testID="IUnderstandButton"
                />
              </Animated.View>
            ) : (
              <Animated.View
                style={[
                  { opacity: isVisible ? opacity : fadeOutAnimation, transform: [{ scale: scaleAnimation }] },
                  styles.feeModalFooterSpacing,
                ]}
              >
                <SecondButton
                  title={isLoading ? '' : loc._.ok}
                  onPress={handleSubmit}
                  testID="OKButton"
                  loading={isLoading}
                  disabled={isLoading || !password || (modalType === MODAL_TYPES.CREATE_PASSWORD && !confirmPassword)}
                />
              </Animated.View>
            )
          ) : null
        }
      >
        {!isSuccess && (
          <Animated.View style={[animatedViewStyle, styles.minHeight]}>
            {modalType === MODAL_TYPES.CREATE_PASSWORD && showExplanation && (
              <Animated.View style={{ opacity: explanationOpacity }}>
                <Text style={[styles.textLabel, stylesHook.feeModalLabel]}>{loc.settings.encrypt_storage_explanation_headline}</Text>
                <Animated.View>
                  <Text style={[styles.description, stylesHook.feeModalCustomText]} maxFontSizeMultiplier={1.2}>
                    {loc.settings.encrypt_storage_explanation_description_line1}
                  </Text>
                  <Text style={[styles.description, stylesHook.feeModalCustomText]} maxFontSizeMultiplier={1.2}>
                    {loc.settings.encrypt_storage_explanation_description_line2}
                  </Text>
                </Animated.View>
                <View style={styles.feeModalFooter} />
              </Animated.View>
            )}
            {(modalType === MODAL_TYPES.ENTER_PASSWORD ||
              ((modalType === MODAL_TYPES.CREATE_PASSWORD || modalType === MODAL_TYPES.CREATE_FAKE_STORAGE) && !showExplanation)) && (
              <>
                <Text adjustsFontSizeToFit style={[styles.textLabel, stylesHook.feeModalLabel]}>
                  {modalType === MODAL_TYPES.CREATE_PASSWORD
                    ? loc.settings.password_explain
                    : modalType === MODAL_TYPES.CREATE_FAKE_STORAGE
                      ? `${loc.settings.password_explain} ${loc.plausibledeniability.create_password_explanation}`
                      : loc._.enter_password}
                </Text>
                <View style={styles.inputContainer}>
                  <Animated.View style={{ transform: [{ translateX: shakeAnimation }] }}>
                    <TextInput
                      testID="PasswordInput"
                      ref={passwordInputRef}
                      secureTextEntry
                      placeholder="Password"
                      value={password}
                      autoCapitalize="none"
                      autoComplete="off"
                      autoCorrect={false}
                      onChangeText={setPassword}
                      style={[styles.input, stylesHook.input]}
                      clearTextOnFocus
                      clearButtonMode="while-editing"
                      autoFocus
                    />
                  </Animated.View>
                  {(modalType === MODAL_TYPES.CREATE_PASSWORD || modalType === MODAL_TYPES.CREATE_FAKE_STORAGE) && (
                    <Animated.View style={{ transform: [{ translateX: shakeAnimation }] }}>
                      <TextInput
                        testID="ConfirmPasswordInput"
                        ref={confirmPasswordInputRef}
                        secureTextEntry
                        placeholder="Confirm Password"
                        value={confirmPassword}
                        clearTextOnFocus
                        autoCorrect={false}
                        autoComplete="off"
                        autoCapitalize="none"
                        clearButtonMode="while-editing"
                        onChangeText={setConfirmPassword}
                        style={[styles.input, stylesHook.input]}
                      />
                    </Animated.View>
                  )}
                </View>
              </>
            )}
          </Animated.View>
        )}
        {isSuccess && (
          <Animated.View
            style={{
              opacity: fadeInAnimation,
              transform: [{ scale: scaleAnimation }],
            }}
          >
            <View style={styles.successContainer}>
              <View style={styles.circle}>
                <Animated.Text
                  style={[
                    styles.checkmark,
                    {
                      transform: [
                        {
                          scale: scaleAnimation.interpolate({
                            inputRange: [0.8, 1],
                            outputRange: [0.8, 1],
                          }),
                        },
                      ],
                    },
                  ]}
                >
                  
                </Animated.Text>
              </View>
            </View>
          </Animated.View>
        )}
      </BottomModal>
    );
  },
);

export default PromptPasswordConfirmationModal;

const styles = StyleSheet.create({
  modalContent: {
    padding: 22,
    width: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  minHeight: {
    minHeight: 420,
  },
  feeModalFooter: {
    padding: 16,
  },
  feeModalFooterSpacing: {
    padding: 16,
    marginVertical: 24,
  },
  inputContainer: {
    marginBottom: 10,
    width: '100%',
  },
  input: {
    borderRadius: 4,
    padding: 8,
    marginVertical: 8,
    fontSize: 16,
    width: '100%',
  },
  textLabel: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 16,
    textAlign: 'center',
  },
  description: {
    fontSize: 16,
    marginBottom: 12,
    textAlign: 'center',
  },
  successContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    margin: 24,
    marginBottom: 48,
  },
  circle: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: 'green',
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkmark: {
    color: 'white',
    fontSize: 30,
  },
});


================================================
FILE: ./components/themes.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import {
  DarkTheme,
  DefaultTheme,
  useTheme as useThemeBase
} from '@react-navigation/native';
import { Appearance } from 'react-native';

export const MalinDefaultTheme = {
  ...DefaultTheme,
  closeImage: require('../img/close.png'),
  barStyle: 'dark-content',
  scanImage: require('../img/scan.png'),
  colors: {
    ...DefaultTheme.colors,
    borderWidth: 0.5,
    brandingColor: '#D4AF37',
    customHeader: '#ffffff',
    foregroundColor: '#0c2550',
    borderTopColor: 'rgba(0, 0, 0, 0.1)',
    buttonBackgroundColor: '#F5E6A3',
    buttonTextColor: '#0c2550',
    secondButtonTextColor: '#50555C',
    buttonAlternativeTextColor: '#AA8C2C',
    buttonDisabledBackgroundColor: '#eef0f4',
    buttonDisabledTextColor: '#9aa0aa',
    inputBorderColor: '#d2d2d2',
    inputBackgroundColor: '#f5f5f5',
    alternativeTextColor: '#9aa0aa',
    alternativeTextColor2: '#D4AF37',
    buttonMalinBackgroundColor: '#F5E6A3',
    buttonGrayBackgroundColor: '#EEEEEE',
    incomingBackgroundColor: '#d2f8d6',
    incomingForegroundColor: '#37c0a1',
    outgoingBackgroundColor: '#f8d2d2',
    outgoingForegroundColor: '#d0021b',
    successColor: '#37c0a1',
    failedColor: '#ff0000',
    placeholderTextColor: '#81868e',
    shadowColor: '#000000',
    inverseForegroundColor: '#ffffff',
    hdborderColor: '#D4AF37',
    hdbackgroundColor: '#FFFAEF',
    lnborderColor: '#FFB600',
    lnbackgroundColor: '#FFFAEF',
    background: '#FFFFFF',
    lightButton: '#FDF2DA',
    ballReceive: '#d2f8d6',
    ballOutgoing: '#f8d2d2',
    lightBorder: '#ededed',
    ballOutgoingExpired: '#EEF0F4',
    modal: '#ffffff',
    formBorder: '#d2d2d2',
    modalButton: '#F5E6A3',
    darkGray: '#9AA0AA',
    scanLabel: '#9AA0AA',
    feeText: '#81868e',
    feeLabel: '#d2f8d6',
    feeValue: '#37c0a1',
    feeActive: '#d2f8d6',
    labelText: '#81868e',
    cta2: '#062453',
    outputValue: '#13244D',
    elevated: '#ffffff',
    mainColor: '#D4AF37',
    success: '#F5E6A3',
    successCheck: '#AA8C2C',
    msSuccessBG: '#37c0a1',
    msSuccessCheck: '#ffffff',
    newMalin: '#D4AF37',
    redBG: '#F8D2D2',
    redText: '#D0021B',
    changeBackground: '#FDF2DA',
    changeText: '#F38C47',
    receiveBackground: '#D1F9D6',
    receiveText: '#37C0A1',
    navigationBarColor: '#FFFFFF',
    androidRippleColor: '#CCCCCC',
  },
}

export type Theme = typeof MalinDefaultTheme;

export const MalinDarkTheme: Theme = {
  ...DarkTheme,
  closeImage: require('../img/close-white.png'),
  scanImage: require('../img/scan-white.png'),
  barStyle: 'light-content',
  colors: {
    ...MalinDefaultTheme.colors,
    ...DarkTheme.colors,
    customHeader: '#000000',
    brandingColor: '#000000',
    borderTopColor: '#9aa0aa',
    background: '#000000',
    foregroundColor: '#ffffff',
    buttonDisabledBackgroundColor: '#3A3A3C',
    buttonBackgroundColor: '#3A3A3C',
    buttonTextColor: '#ffffff',
    lightButton: 'rgba(255,255,255,.1)',
    buttonAlternativeTextColor: '#ffffff',
    alternativeTextColor: '#9aa0aa',
    alternativeTextColor2: '#0A84FF',
    ballReceive: '#202020',
    ballOutgoing: '#202020',
    lightBorder: '#313030',
    ballOutgoingExpired: '#202020',
    modal: '#202020',
    formBorder: '#202020',
    inputBackgroundColor: '#262626',
    modalButton: '#000000',
    darkGray: '#3A3A3C',
    feeText: '#81868e',
    feeLabel: '#8EFFE5',
    feeValue: '#000000',
    feeActive: 'rgba(210,248,214,.2)',
    cta2: '#ffffff',
    outputValue: '#ffffff',
    elevated: '#121212',
    mainColor: '#0A84FF',
    success: '#202020',
    successCheck: '#0A84FF',
    buttonMalinBackgroundColor: '#202020',
    scanLabel: 'rgba(255,255,255,.2)',
    labelText: '#ffffff',
    msSuccessBG: '#8EFFE5',
    msSuccessCheck: '#000000',
    newMalin: '#007AFF',
    redBG: '#5A4E4E',
    redText: '#FC6D6D',
    changeBackground: '#5A4E4E',
    changeText: '#F38C47',
    receiveBackground: 'rgba(210,248,214,.2)',
    receiveText: '#37C0A1',
    navigationBarColor: '#3A3A3C',
    androidRippleColor: '#444444',
  },
}

// Casting theme value to get autocompletion
export const useTheme = (): Theme => useThemeBase() as Theme;

export class MalinCurrentTheme {
  static colors: Theme['colors'];
  static closeImage: Theme['closeImage'];
  static scanImage: Theme['scanImage'];

  static updateColorScheme(): void {
    const isColorSchemeDark = Appearance.getColorScheme() === 'dark';
    MalinCurrentTheme.colors = isColorSchemeDark
      ? MalinDarkTheme.colors
      : MalinDefaultTheme.colors;
    MalinCurrentTheme.closeImage = isColorSchemeDark
      ? MalinDarkTheme.closeImage
      : MalinDefaultTheme.closeImage;
    MalinCurrentTheme.scanImage = isColorSchemeDark
      ? MalinDarkTheme.scanImage
      : MalinDefaultTheme.scanImage;
  }
}

MalinCurrentTheme.updateColorScheme();


================================================
FILE: ./components/addresses/AddressItem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo, useCallback } from 'react';
import Clipboard from '@react-native-clipboard/clipboard';
import { StyleSheet, Text, View } from 'react-native';
import { ListItem } from '@rneui/themed';
import Share from 'react-native-share';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../../malin_modules/hapticFeedback';
import confirm from '../../helpers/confirm';
import { unlockWithBiometrics, useBiometrics } from '../../hooks/useBiometrics';
import loc, { formatBalance } from '../../loc';
import { BitcoinUnit } from '../../models/bitcoinUnits';
import presentAlert from '../Alert';
import QRCodeComponent from '../QRCodeComponent';
import { useTheme } from '../themes';
import { AddressTypeBadge } from './AddressTypeBadge';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../../navigation/DetailViewStackParamList';
import { useStorage } from '../../hooks/context/useStorage';
import ToolTipMenu from '../TooltipMenu';
import { CommonToolTipActions } from '../../typings/CommonToolTipActions';
import { useExtendedNavigation } from '../../hooks/useExtendedNavigation';
import HighlightedText from '../HighlightedText';

interface AddressItemProps {
  item: any;
  balanceUnit: BitcoinUnit;
  walletID: string;
  allowSignVerifyMessage: boolean;
  onPress?: () => void; // example: ManageWallets uses this
  searchQuery?: string;
  renderHighlightedText?: (text: string, query: string) => JSX.Element;
}

type NavigationProps = NativeStackNavigationProp<DetailViewStackParamList>;

const AddressItem = ({
  item,
  balanceUnit,
  walletID,
  allowSignVerifyMessage,
  onPress,
  searchQuery = '',
  renderHighlightedText,
}: AddressItemProps) => {
  const { wallets } = useStorage();
  const { colors } = useTheme();
  const { isBiometricUseCapableAndEnabled } = useBiometrics();

  const hasTransactions = item.transactions > 0;

  const stylesHook = StyleSheet.create({
    container: {
      borderBottomColor: colors.lightBorder,
      backgroundColor: colors.elevated,
    },

    index: {
      color: colors.alternativeTextColor,
    },
    balance: {
      color: colors.alternativeTextColor,
    },
    address: {
      color: hasTransactions ? colors.darkGray : colors.buttonTextColor,
    },
  });

  const { navigate } = useExtendedNavigation<NavigationProps>();

  const navigateToReceive = useCallback(() => {
    if (onPress) {
      onPress();
    } else {
      navigate('ReceiveDetails', {
        walletID,
        address: item.address,
      });
    }
  }, [navigate, walletID, item.address, onPress]);

  const navigateToSignVerify = useCallback(() => {
    navigate('SignVerifyRoot', {
      screen: 'SignVerify',
      params: {
        walletID,
        address: item.address,
      },
    });
  }, [navigate, walletID, item.address]);

  const menuActions = useMemo(
    () => [
      CommonToolTipActions.CopyTXID,
      CommonToolTipActions.Share,
      {
        ...CommonToolTipActions.SignVerify,
        hidden: !allowSignVerifyMessage,
      },
      {
        ...CommonToolTipActions.ExportPrivateKey,
        hidden: !allowSignVerifyMessage,
      },
    ],
    [allowSignVerifyMessage],
  );

  const balance = formatBalance(item.balance, balanceUnit, true);

  const handleCopyPress = useCallback(() => {
    Clipboard.setString(item.address);
  }, [item.address]);

  const handleSharePress = useCallback(() => {
    Share.open({ message: item.address }).catch(error => console.log(error));
  }, [item.address]);

  const handleCopyPrivkeyPress = useCallback(() => {
    const wallet = wallets.find(w => w.getID() === walletID);
    if (!wallet) {
      presentAlert({ message: 'Internal error: cant find wallet' });
      return;
    }

    try {
      const wif = wallet._getWIFbyAddress(item.address);
      if (!wif) {
        presentAlert({ message: 'Internal error: cant get WIF from the wallet' });
        return;
      }
      triggerHapticFeedback(HapticFeedbackTypes.Selection);
      Clipboard.setString(wif);
    } catch (error: any) {
      presentAlert({ message: error.message });
    }
  }, [wallets, walletID, item.address]);

  const onToolTipPress = useCallback(
    async (id: string) => {
      if (id === CommonToolTipActions.CopyTXID.id) {
        handleCopyPress();
      } else if (id === CommonToolTipActions.Share.id) {
        handleSharePress();
      } else if (id === CommonToolTipActions.SignVerify.id) {
        navigateToSignVerify();
      } else if (id === CommonToolTipActions.ExportPrivateKey.id) {
        if (await confirm(loc.addresses.sensitive_private_key)) {
          if (await isBiometricUseCapableAndEnabled()) {
            if (!(await unlockWithBiometrics())) {
              return;
            }
          }
          handleCopyPrivkeyPress();
        }
      }
    },
    [handleCopyPress, handleSharePress, navigateToSignVerify, handleCopyPrivkeyPress, isBiometricUseCapableAndEnabled],
  );

  const renderPreview = useCallback(() => <QRCodeComponent value={item.address} isMenuAvailable={false} />, [item.address]);

  // Render address with highlighting if a search query is provided
  const renderAddressContent = () => {
    if (searchQuery && searchQuery.length > 0) {
      if (renderHighlightedText) {
        return renderHighlightedText(item.address, searchQuery);
      }
      return (
        <HighlightedText
          text={item.address}
          query={searchQuery}
          caseSensitive={false}
          highlightOnlyFirstMatch={searchQuery.length === 1}
          style={[stylesHook.address, styles.address]}
        />
      );
    }

    return (
      <Text style={[stylesHook.address, styles.address]} numberOfLines={1} ellipsizeMode="middle">
        {item.address}
      </Text>
    );
  };

  return (
    <ToolTipMenu
      title={item.address}
      actions={menuActions}
      onPressMenuItem={onToolTipPress}
      // Revisit once RNMenu has renderPreview prop
      renderPreview={renderPreview}
      onPress={navigateToReceive}
      isButton
    >
      <ListItem key={item.key} containerStyle={stylesHook.container}>
        <ListItem.Content>
          <View style={styles.row}>
            <View style={styles.leftSection}>
              <Text style={[styles.index, stylesHook.index]}>{item.index}</Text>
            </View>
            <View style={styles.middleSection}>
              {renderAddressContent()}
              <Text style={[stylesHook.balance, styles.balance]}>{balance}</Text>
            </View>
          </View>
        </ListItem.Content>
        <View style={styles.rightContainer}>
          <AddressTypeBadge isInternal={item.isInternal} hasTransactions={hasTransactions} />
          <Text style={[stylesHook.balance, styles.balance]}>
            {loc.addresses.transactions}: {item.transactions ?? 0}
          </Text>
        </View>
      </ListItem>
    </ToolTipMenu>
  );
};

const styles = StyleSheet.create({
  address: {
    fontWeight: 'bold',
    marginHorizontal: 4,
  },
  index: {
    fontSize: 15,
  },
  balance: {
    marginTop: 4,
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  leftSection: {
    marginRight: 8,
  },
  middleSection: {
    flex: 1,
  },
  rightContainer: {
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
});

export { AddressItem };


================================================
FILE: ./components/addresses/AddressTypeBadge.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

import loc, { formatStringAddTwoWhiteSpaces } from '../../loc';
import { useTheme } from '../themes';

type Props = { isInternal: boolean; hasTransactions: boolean };

export const AddressTypeBadge: React.FC<Props> = ({ isInternal, hasTransactions }) => {
  const { colors } = useTheme();

  const stylesHook = StyleSheet.create({
    changeBadge: { backgroundColor: colors.changeBackground },
    receiveBadge: { backgroundColor: colors.receiveBackground },
    usedBadge: { backgroundColor: colors.buttonDisabledBackgroundColor },
    changeText: { color: colors.changeText },
    receiveText: { color: colors.receiveText },
    usedText: { color: colors.alternativeTextColor },
  });

  const badgeLabel = hasTransactions
    ? loc.addresses.type_used
    : isInternal
      ? formatStringAddTwoWhiteSpaces(loc.addresses.type_change)
      : formatStringAddTwoWhiteSpaces(loc.addresses.type_receive);

  // eslint-disable-next-line prettier/prettier
  const badgeStyle = hasTransactions
   ? stylesHook.usedBadge
   : isInternal
    ? stylesHook.changeBadge
    : stylesHook.receiveBadge;

  // eslint-disable-next-line prettier/prettier
  const textStyle = hasTransactions
    ? stylesHook.usedText
    : isInternal
      ? stylesHook.changeText
      : stylesHook.receiveText;

  return (
    <View style={[styles.container, badgeStyle]}>
      <Text style={[styles.badgeText, textStyle]}>{badgeLabel}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingVertical: 4,
    paddingHorizontal: 10,
    borderRadius: 20,
    alignSelf: 'flex-end',
  },
  badgeText: {
    fontSize: 12,
    textAlign: 'center',
  },
});


================================================
FILE: ./components/ManageWalletsListItem.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useState, useEffect, useRef } from 'react';
import { StyleSheet, ViewStyle, TouchableOpacity, ActivityIndicator, Platform, Animated, View, Text, TextStyle } from 'react-native';
import { Icon, ListItem } from '@rneui/base';
import { ExtendedTransaction, LightningTransaction, Transaction, TWallet } from '../class/wallets/types';
import { WalletCarouselItem } from './WalletsCarousel';
import { TransactionListItem } from './TransactionListItem';
import { useTheme } from './themes';
import { BitcoinUnit } from '../models/bitcoinUnits';
import loc from '../loc';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import { AddressItem } from './addresses/AddressItem';
import { ItemType, AddressItemData } from '../models/itemTypes';
import WalletGradient from '../class/wallet-gradient';

interface WalletItem {
  type: ItemType.WalletSection;
  data: TWallet;
}

interface TransactionItem {
  type: ItemType.TransactionSection;
  data: ExtendedTransaction & LightningTransaction;
}

interface AddressItem {
  type: ItemType.AddressSection;
  data: AddressItemData;
}

type Item = WalletItem | TransactionItem | AddressItem;

interface ManageWalletsListItemProps {
  item: Item;
  isDraggingDisabled: boolean;
  drag?: () => void;
  isPlaceHolder?: boolean;
  onPressIn?: () => void;
  onPressOut?: () => void;
  state: { wallets: TWallet[]; searchQuery: string; isSearchFocused?: boolean };
  navigateToWallet: (wallet: TWallet) => void;
  navigateToAddress?: (address: string, walletID: string) => void;
  renderHighlightedText: (text: string, query: string) => JSX.Element;
  handleDeleteWallet: (wallet: TWallet) => void;
  handleToggleHideBalance: (wallet: TWallet) => void;
  isActive?: boolean;
  style?: ViewStyle;
  globalDragActive?: boolean;
}

interface SwipeContentProps {
  onPress: () => void;
  hideBalance?: boolean;
  colors: any;
}

const LeftSwipeContent: React.FC<SwipeContentProps> = ({ onPress, hideBalance, colors }) => (
  <TouchableOpacity
    onPress={onPress}
    style={[styles.leftButtonContainer, { backgroundColor: colors.buttonAlternativeTextColor } as ViewStyle]}
    accessibilityRole="button"
    accessibilityLabel={hideBalance ? loc.transactions.details_balance_show : loc.transactions.details_balance_hide}
  >
    <Icon name={hideBalance ? 'eye' : 'eye-slash'} color={colors.brandingColor} type="font-awesome-5" />
  </TouchableOpacity>
);

const RightSwipeContent: React.FC<Partial<SwipeContentProps>> = ({ onPress }) => (
  <TouchableOpacity
    onPress={onPress}
    style={styles.rightButtonContainer as ViewStyle}
    accessibilityRole="button"
    accessibilityLabel="Delete Wallet"
  >
    <Icon name={Platform.OS === 'android' ? 'delete' : 'delete-outline'} color="#FFFFFF" />
  </TouchableOpacity>
);

const ManageWalletsListItem: React.FC<ManageWalletsListItemProps> = ({
  item,
  isDraggingDisabled,
  drag,
  state,
  isPlaceHolder = false,
  navigateToWallet,
  navigateToAddress,
  renderHighlightedText,
  handleDeleteWallet,
  handleToggleHideBalance,
  onPressIn,
  onPressOut,
  isActive,
  globalDragActive,
  style,
}) => {
  const { colors } = useTheme();
  const [isLoading, setIsLoading] = useState(false);
  const [isSwipeActive, setIsSwipeActive] = useState(false);
  const resetFunctionRef = useRef<(() => void) | null>(null);

  const CARD_SORT_ACTIVE = 1.06;
  const INACTIVE_SCALE_WHEN_ACTIVE = 0.9;
  const SCALE_DURATION = 200;
  const scaleValue = useRef(new Animated.Value(1)).current;
  const prevIsActive = useRef(isActive);

  const DEFAULT_VERTICAL_MARGIN = -10;
  const REDUCED_VERTICAL_MARGIN = -50;

  const animateItemIn = useCallback(() => {
    if (Platform.OS === 'ios') {
      Animated.spring(scaleValue, {
        toValue: isActive ? CARD_SORT_ACTIVE : globalDragActive ? INACTIVE_SCALE_WHEN_ACTIVE : 1,
        friction: 8,
        tension: 40,
        useNativeDriver: true,
      }).start();
    } else {
      Animated.timing(scaleValue, {
        toValue: isActive ? CARD_SORT_ACTIVE : globalDragActive ? INACTIVE_SCALE_WHEN_ACTIVE : 1,
        duration: SCALE_DURATION,
        useNativeDriver: true,
      }).start();
    }
  }, [isActive, globalDragActive, scaleValue, CARD_SORT_ACTIVE, INACTIVE_SCALE_WHEN_ACTIVE, SCALE_DURATION]);

  useEffect(() => {
    if (isActive !== prevIsActive.current) {
      triggerHapticFeedback(HapticFeedbackTypes.ImpactMedium);
    }
    prevIsActive.current = isActive;

    animateItemIn();
  }, [isActive, globalDragActive, animateItemIn]);

  const onPress = useCallback(() => {
    if (item.type === ItemType.WalletSection) {
      setIsLoading(true);
      navigateToWallet(item.data);
      setIsLoading(false);
    } else if (item.type === ItemType.AddressSection && navigateToAddress) {
      navigateToAddress(item.data.address, item.data.walletID);
    }
  }, [item, navigateToWallet, navigateToAddress]);

  const handleLeftPress = (reset: () => void) => {
    handleToggleHideBalance(item.data as TWallet);
    reset();
  };

  const leftContent = (reset: () => void) => {
    resetFunctionRef.current = reset;
    return <LeftSwipeContent onPress={() => handleLeftPress(reset)} hideBalance={(item.data as TWallet).hideBalance} colors={colors} />;
  };

  const handleRightPress = (reset: () => void) => {
    reset();

    setTimeout(() => {
      handleDeleteWallet(item.data as TWallet);
    }, 100); // short delay to allow swipe reset animation to complete
  };

  const rightContent = (reset: () => void) => {
    resetFunctionRef.current = reset;
    return <RightSwipeContent onPress={() => handleRightPress(reset)} />;
  };

  const startDrag = useCallback(() => {
    if (isSwipeActive) {
      return;
    }

    if (resetFunctionRef.current) {
      resetFunctionRef.current();
    }

    scaleValue.setValue(CARD_SORT_ACTIVE);
    triggerHapticFeedback(HapticFeedbackTypes.ImpactMedium);
    if (drag) {
      drag();
    }
  }, [CARD_SORT_ACTIVE, drag, scaleValue, isSwipeActive]);

  if (isLoading) {
    return <ActivityIndicator size="large" color={colors.brandingColor} />;
  }

  if (item.type === ItemType.WalletSection) {
    const animatedStyle = {
      transform: [{ scale: scaleValue }],
      marginVertical: globalDragActive && !isActive ? REDUCED_VERTICAL_MARGIN : DEFAULT_VERTICAL_MARGIN,
    };

    const backgroundColor = isActive || globalDragActive ? colors.brandingColor : colors.background;

    // Disable swiping only when search bar is focused or during active dragging
    const swipeDisabled = isActive || globalDragActive || state.isSearchFocused === true;

    return (
      <Animated.View style={animatedStyle}>
        <ListItem.Swipeable
          leftWidth={swipeDisabled ? 0 : 80}
          rightWidth={swipeDisabled ? 0 : 90}
          containerStyle={[style, { backgroundColor }, swipeDisabled ? styles.transparentBackground : {}]}
          leftContent={swipeDisabled ? null : leftContent}
          rightContent={swipeDisabled ? null : rightContent}
          onPressOut={onPressOut}
          minSlideWidth={swipeDisabled ? 0 : 80}
          onPressIn={onPressIn}
          style={swipeDisabled ? styles.transparentBackground : {}}
          onSwipeBegin={direction => {
            if (!swipeDisabled) {
              console.debug(`Swipe began: ${direction}`);
              setIsSwipeActive(true);
            }
          }}
          onSwipeEnd={() => {
            if (!swipeDisabled) {
              console.debug('Swipe ended');
              setIsSwipeActive(false);
            }
          }}
        >
          <ListItem.Content>
            <WalletCarouselItem
              item={item.data}
              handleLongPress={isDraggingDisabled || isSwipeActive ? undefined : startDrag}
              onPress={onPress}
              onPressIn={onPressIn}
              onPressOut={onPressOut}
              animationsEnabled={false}
              searchQuery={state.searchQuery}
              isPlaceHolder={isPlaceHolder}
              renderHighlightedText={renderHighlightedText}
              customStyle={styles.carouselItem}
            />
          </ListItem.Content>
        </ListItem.Swipeable>
      </Animated.View>
    );
  } else if (item.type === ItemType.TransactionSection && item.data) {
    try {
      const w = state.wallets.find(wallet => wallet.getTransactions()?.some((tx: Transaction) => tx.hash === item.data.hash));

      const walletID = w ? w.getID() : '';

      const transactionStyle = {
        borderLeftWidth: 2,
        borderLeftColor: colors.brandingColor,
        backgroundColor: colors.background,
        background: colors.background,
      };

      return (
        <Animated.View
          style={{
            transform: [{ scale: scaleValue }],
            opacity: scaleValue.interpolate({
              inputRange: [0.9, 1],
              outputRange: [0.7, 1],
            }),
          }}
        >
          <TransactionListItem
            item={item.data}
            itemPriceUnit={w?.getPreferredBalanceUnit() || BitcoinUnit.BTC}
            walletID={walletID}
            searchQuery={state.searchQuery}
            renderHighlightedText={renderHighlightedText}
            style={transactionStyle}
          />
        </Animated.View>
      );
    } catch (e) {
      console.warn('Error rendering transaction item:', e);
      return null;
    }
  } else if (item.type === ItemType.AddressSection) {
    const wallet = state.wallets.find(w => w.getID() === item.data.walletID);
    if (!wallet) return null;

    const addressItemProps = {
      item: {
        key: item.data.address,
        index: item.data.index,
        address: item.data.address,
        isInternal: item.data.isInternal,
        balance: 0,
        transactions: 0,
      },
      balanceUnit: wallet.getPreferredBalanceUnit() || BitcoinUnit.BTC,
      walletID: item.data.walletID,
      allowSignVerifyMessage: wallet.allowSignVerifyMessage ? wallet.allowSignVerifyMessage() : false,
      onPress: navigateToAddress ? () => navigateToAddress(item.data.address, item.data.walletID) : undefined,
      searchQuery: state.searchQuery,
      renderHighlightedText,
    };

    return (
      <Animated.View
        style={{
          transform: [{ scale: scaleValue }],
          opacity: scaleValue.interpolate({
            inputRange: [0.9, 1],
            outputRange: [0.7, 1],
          }),
        }}
      >
        <AddressItem {...addressItemProps} />
      </Animated.View>
    );
  }

  return null;
};

// WalletGroupItem component to handle displaying wallet and related search results
interface WalletGroupProps {
  wallet: TWallet;
  transactions: TransactionItem[];
  addresses: AddressItem[];
  state: { wallets: TWallet[]; searchQuery: string };
  navigateToWallet: (wallet: TWallet) => void;
  navigateToAddress?: (address: string, walletID: string) => void;
  renderHighlightedText: (text: string, query: string) => JSX.Element;
  isSearching: boolean;
}

const WalletGroupComponent: React.FC<WalletGroupProps> = ({
  wallet,
  transactions,
  addresses,
  state,
  navigateToWallet,
  navigateToAddress,
  renderHighlightedText,
  isSearching,
}) => {
  const { colors } = useTheme();
  const [expanded] = useState(true); // Always show child items when searching
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, [fadeAnim]);

  const walletGradientColors = WalletGradient.gradientsFor(wallet.type);
  const primaryColor = walletGradientColors[0];

  const containerStyle: ViewStyle = {
    marginHorizontal: 10,
    marginVertical: 16,
    borderRadius: 10,
    overflow: 'hidden' as const,
    backgroundColor: colors.elevated,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: 1,
    borderColor: primaryColor + '30',
  };

  const headerStyle: ViewStyle = {
    padding: 12,
    backgroundColor: primaryColor + '15', // Using translucent primary color as background
    borderTopLeftRadius: 10,
    borderTopRightRadius: 10,
    borderTopWidth: Platform.OS === 'ios' ? 4 : 2,
    borderTopColor: primaryColor,
    paddingVertical: 12,
  };

  const childItemsContainerStyle = {
    borderBottomLeftRadius: 10,
    borderBottomRightRadius: 10,
    backgroundColor: colors.elevated,
    borderLeftWidth: 1,
    borderRightWidth: 1,
    borderBottomWidth: 1,
    borderColor: primaryColor + '20',
  };

  const childItemStyle = (): ViewStyle => ({
    borderLeftWidth: 3,
    borderLeftColor: primaryColor,
    backgroundColor: colors.inputBackgroundColor,
  });

  const sectionHeaderStyle: ViewStyle = {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: primaryColor + '10',
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: primaryColor + '30',
  };

  const sectionHeaderTextStyle: TextStyle = {
    color: colors.foregroundColor,
    fontWeight: '600' as const,
    fontSize: 14,
  };

  const dividerStyle = [styles.itemDivider, { backgroundColor: primaryColor + '20' }];

  const onWalletPress = useCallback(() => {
    navigateToWallet(wallet);
  }, [navigateToWallet, wallet]);

  return (
    <Animated.View style={{ opacity: fadeAnim }}>
      <View style={containerStyle}>
        {/* Wallet Header */}
        <View style={headerStyle}>
          <WalletCarouselItem
            item={wallet}
            handleLongPress={undefined}
            onPress={onWalletPress}
            animationsEnabled={false}
            searchQuery={state.searchQuery}
            isPlaceHolder={false}
            renderHighlightedText={renderHighlightedText}
            customStyle={styles.carouselItem}
          />
        </View>

        {/* Search results container */}
        {expanded && (
          <View style={childItemsContainerStyle}>
            {/* Transactions section */}
            {transactions.length > 0 && (
              <>
                <View style={sectionHeaderStyle}>
                  <Text style={sectionHeaderTextStyle}>
                    {loc.addresses.transactions} ({transactions.length})
                  </Text>
                </View>
                {transactions.map((transaction, index) => (
                  <View key={`tx-${index}`}>
                    <View style={childItemStyle()}>
                      <TransactionListItem
                        item={transaction.data}
                        itemPriceUnit={wallet.getPreferredBalanceUnit() || BitcoinUnit.BTC}
                        walletID={wallet.getID()}
                        searchQuery={state.searchQuery}
                        renderHighlightedText={renderHighlightedText}
                      />
                    </View>
                    {index < transactions.length - 1 && <View style={dividerStyle} />}
                  </View>
                ))}
              </>
            )}

            {/* Addresses section */}
            {addresses.length > 0 && (
              <>
                <View style={sectionHeaderStyle}>
                  <Text style={sectionHeaderTextStyle}>
                    {loc.addresses.addresses_title} ({addresses.length})
                  </Text>
                </View>
                {addresses.map((address, index) => {
                  const addressItemProps = {
                    item: {
                      key: address.data.address,
                      index: address.data.index,
                      address: address.data.address,
                      isInternal: address.data.isInternal,
                      balance: 0,
                      transactions: 0,
                    },
                    balanceUnit: wallet.getPreferredBalanceUnit() || BitcoinUnit.BTC,
                    walletID: address.data.walletID,
                    allowSignVerifyMessage: wallet.allowSignVerifyMessage ? wallet.allowSignVerifyMessage() : false,
                    // Use the onPress function returned by navigateToAddress instead of calling it directly
                    onPress: navigateToAddress ? () => navigateToAddress(address.data.address, address.data.walletID) : undefined,
                    searchQuery: state.searchQuery,
                    renderHighlightedText,
                  };

                  return (
                    <View key={`addr-${index}`}>
                      <View style={childItemStyle()}>
                        <AddressItem {...addressItemProps} />
                      </View>
                      {index < addresses.length - 1 && <View style={dividerStyle} />}
                    </View>
                  );
                })}
              </>
            )}
          </View>
        )}
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  leftButtonContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  carouselItem: {
    width: '100%',
  },
  rightButtonContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'red',
  },
  transparentBackground: {
    backgroundColor: 'transparent',
  },
  itemDivider: {
    height: 1,
    width: '100%',
  },
});

export { LeftSwipeContent, RightSwipeContent, WalletGroupComponent };
export default ManageWalletsListItem;


================================================
FILE: ./components/Button.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { forwardRef } from 'react';
import { ActivityIndicator, StyleProp, StyleSheet, Text, Pressable, PressableProps, View, ViewStyle, Platform } from 'react-native';
import { Icon } from '@rneui/themed';

import { useTheme } from './themes';

interface ButtonProps extends PressableProps {
  backgroundColor?: string;
  buttonTextColor?: string;
  disabled?: boolean;
  testID?: string;
  icon?: {
    name: string;
    type: string;
    color: string;
  };
  title?: string;
  style?: StyleProp<ViewStyle>;
  onPress?: () => void;
  showActivityIndicator?: boolean;
}

export const Button = forwardRef<React.ElementRef<typeof Pressable>, ButtonProps>((props, ref) => {
  const { colors } = useTheme();

  let backgroundColor = props.backgroundColor ?? colors.mainColor;
  let fontColor = props.buttonTextColor ?? colors.buttonTextColor;
  if (props.disabled) {
    backgroundColor = colors.buttonDisabledBackgroundColor;
    fontColor = colors.buttonDisabledTextColor;
  }

  const buttonStyle = {
    ...styles.button,
    backgroundColor,
    borderColor: props.disabled ? colors.buttonDisabledBackgroundColor : 'transparent',
  };

  const textStyle = {
    ...styles.text,
    color: fontColor,
  };

  const buttonView = props.showActivityIndicator ? (
    <ActivityIndicator size="small" color={textStyle.color} />
  ) : (
    <>
      {props.icon && <Icon name={props.icon.name} type={props.icon.type} color={props.icon.color} />}
      {props.title && <Text style={textStyle}>{props.title}</Text>}
    </>
  );

  return props.onPress ? (
    <View style={styles.pressableWrapper}>
      <Pressable
        ref={ref}
        testID={props.testID}
        android_ripple={{ color: colors.androidRippleColor }}
        style={({ pressed }) => [Platform.OS === 'ios' && pressed ? styles.pressed : null, buttonStyle, props.style, styles.content]}
        accessibilityRole="button"
        onPress={props.onPress}
        disabled={props.disabled}
        {...props}
      >
        {buttonView}
      </Pressable>
    </View>
  ) : (
    <View style={[buttonStyle, props.style, styles.content]}>{buttonView}</View>
  );
});

const styles = StyleSheet.create({
  button: {
    borderWidth: 0.7,
    minHeight: 45,
    height: 48,
    maxHeight: 48,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 16,
    flexGrow: 1,
  },
  content: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginHorizontal: 8,
    fontSize: 16,
    fontWeight: '600',
  },
  pressableWrapper: {
    overflow: 'hidden',
    borderRadius: 25,
  },
  pressed: {
    opacity: 0.6,
  },
});

export default Button;


================================================
FILE: ./components/HandOffComponent.ios.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import DefaultPreference from 'react-native-default-preference';
// @ts-ignore: Handoff is not typed
import Handoff from 'react-native-handoff';
import { useSettings } from '../hooks/context/useSettings';
import { GROUP_IO_MALINWALLET } from '../malin_modules/currency';
import { MalinApp } from '../class';
import { HandOffComponentProps } from './types';

const HandOffComponent: React.FC<HandOffComponentProps> = props => {
  const { isHandOffUseEnabled } = useSettings();
  if (!props || !props.type || !props.userInfo || Object.keys(props.userInfo).length === 0) {
    console.debug('HandOffComponent: Missing required type or userInfo data');
    return null;
  }
  const userInfo = JSON.stringify(props.userInfo);
  console.debug(`HandOffComponent is rendering. Type: ${props.type}, UserInfo: ${userInfo}...`);
  return isHandOffUseEnabled ? <Handoff {...props} /> : null;
};

const MemoizedHandOffComponent = React.memo(HandOffComponent);

export const setIsHandOffUseEnabled = async (value: boolean) => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    await DefaultPreference.set(MalinApp.HANDOFF_STORAGE_KEY, value.toString());
    console.debug('setIsHandOffUseEnabled', value);
  } catch (error) {
    console.error('Error setting handoff enabled status:', error);
    throw error; // Propagate error to caller
  }
};

export const getIsHandOffUseEnabled = async (): Promise<boolean> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const isEnabledValue = await DefaultPreference.get(MalinApp.HANDOFF_STORAGE_KEY);
    const result = isEnabledValue === 'true';
    console.debug('getIsHandOffUseEnabled', result);
    return result;
  } catch (error) {
    console.error('Error getting handoff enabled status:', error);
    return false;
  }
};

export default MemoizedHandOffComponent;


================================================
FILE: ./components/DismissKeyboardInputAccessory.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { InputAccessoryView, Keyboard, Platform, StyleSheet, View } from 'react-native';
import { useTheme } from './themes';
import { MalinButtonLink } from '../MalinComponents';
import loc from '../loc';

export const DismissKeyboardInputAccessoryViewID = 'DismissKeyboardInputAccessory';
export const DismissKeyboardInputAccessory: React.FC = () => {
  const { colors } = useTheme();
  const styleHooks = StyleSheet.create({
    container: {
      backgroundColor: colors.inputBackgroundColor,
    },
  });

  if (Platform.OS !== 'ios') {
    return null;
  }

  return (
    <InputAccessoryView nativeID={DismissKeyboardInputAccessoryViewID}>
      <View style={[styles.container, styleHooks.container]}>
        <MalinButtonLink title={loc.send.input_done} onPress={Keyboard.dismiss} />
      </View>
    </InputAccessoryView>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    maxHeight: 44,
  },
});


================================================
FILE: ./components/WalletToImport.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { StyleSheet, TouchableOpacity, View } from 'react-native';
import { Text } from '@rneui/themed';
import { useLocale } from '@react-navigation/native';

import { useTheme } from './themes';

interface WalletToImportProp {
  title: string;
  subtitle: string;
  active: boolean;
  onPress: () => void;
}

const WalletToImport: React.FC<WalletToImportProp> = ({ title, subtitle, active, onPress }) => {
  const { colors } = useTheme();
  const { direction } = useLocale();

  const stylesHooks = StyleSheet.create({
    root: {
      borderColor: active ? colors.newMalin : colors.buttonDisabledBackgroundColor,
      backgroundColor: colors.buttonDisabledBackgroundColor,
    },
    title: {
      color: colors.newMalin,
      writingDirection: direction,
    },
    subtitle: {
      color: colors.alternativeTextColor,
      writingDirection: direction,
    },
  });

  return (
    <TouchableOpacity accessibilityRole="button" onPress={onPress}>
      <View style={[styles.root, stylesHooks.root]}>
        <Text style={[styles.title, stylesHooks.title]}>{title}</Text>
        <Text style={[styles.subtitle, stylesHooks.subtitle]}>{subtitle}</Text>
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  root: {
    alignItems: 'stretch',
    borderRadius: 8,
    borderWidth: 1.5,
    flexDirection: 'column',
    justifyContent: 'center',
    marginBottom: 8,
    minWidth: '100%',
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  title: {
    fontWeight: 'bold',
    fontSize: 15,
    paddingBottom: 3,
  },
  subtitle: {
    fontSize: 13,
    fontWeight: '500',
  },
});

export default WalletToImport;


================================================
FILE: ./components/SafeAreaFlatList.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo } from 'react';
import { StyleSheet, FlatList, FlatListProps } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

import { useTheme } from './themes';

const SafeAreaFlatList = <ItemT,>(props: FlatListProps<ItemT>) => {
  const { style, contentContainerStyle, ...otherProps } = props;
  const { colors } = useTheme();
  const insets = useSafeAreaInsets();

  const componentStyle = useMemo(() => {
    return StyleSheet.compose({ flex: 1, backgroundColor: colors.background }, style);
  }, [colors.background, style]);

  const contentStyle = useMemo(() => {
    return StyleSheet.compose(
      {
        paddingBottom: insets.bottom,
        paddingLeft: insets.left,
        paddingRight: insets.right,
      },
      contentContainerStyle,
    );
  }, [insets, contentContainerStyle]);

  return <FlatList style={componentStyle} contentContainerStyle={contentStyle} {...otherProps} />;
};

export default SafeAreaFlatList;


================================================
FILE: ./components/SaveFileButton.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { ReactNode, useCallback } from 'react';
import { StyleProp, TouchableOpacityProps, ViewStyle } from 'react-native';

import * as fs from '../malin_modules/fs';
import loc from '../loc';
import { ActionIcons } from '../typings/ActionIcons';
import ToolTipMenu from './TooltipMenu';
import { Action } from './types';

interface SaveFileButtonProps extends TouchableOpacityProps {
  fileName: string;
  fileContent: string;
  children?: ReactNode;
  style?: StyleProp<ViewStyle>;
  afterOnPress?: () => void;
  beforeOnPress?: (() => Promise<void>) | (() => void);
  onMenuWillHide?: () => void;
  onMenuWillShow?: () => void;
}

const SaveFileButton: React.FC<SaveFileButtonProps> = ({
  fileName,
  fileContent,
  children,
  style,
  beforeOnPress,
  afterOnPress,
  onMenuWillHide,
  onMenuWillShow,
}) => {
  const handlePressMenuItem = useCallback(
    async (actionId: string) => {
      if (beforeOnPress) {
        await beforeOnPress();
      }
      const action = actions.find(a => a.id === actionId);

      if (action?.id === 'save') {
        await fs.writeFileAndExport(fileName, fileContent, false).finally(() => {
          afterOnPress?.();
        });
      } else if (action?.id === 'share') {
        await fs.writeFileAndExport(fileName, fileContent, true).finally(() => {
          afterOnPress?.();
        });
      }
    },
    [afterOnPress, beforeOnPress, fileContent, fileName],
  );

  return (
    <ToolTipMenu
      onMenuWillHide={onMenuWillHide}
      onMenuWillShow={onMenuWillShow}
      isButton
      isMenuPrimaryAction
      actions={actions}
      onPressMenuItem={handlePressMenuItem}
      buttonStyle={style as ViewStyle} // Type assertion to match ViewStyle
      {...{ children }}
    >
      {children}
    </ToolTipMenu>
  );
};

export default SaveFileButton;

const actionIcons: { [key: string]: ActionIcons } = {
  Share: {
    iconValue: 'square.and.arrow.up',
  },
  Save: {
    iconValue: 'square.and.arrow.down',
  },
};
const actions: Action[] = [
  { id: 'save', text: loc._.save, icon: actionIcons.Save },
  { id: 'share', text: loc.receive.details_share, icon: actionIcons.Share },
];


================================================
FILE: ./components/TipBox.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';
import { useTheme } from './themes';
import { MalinText } from '../MalinComponents';

interface TipBoxProps {
  number?: string;
  title?: string;
  description?: string;
  additionalDescription?: string;
  containerStyle?: ViewStyle;
}

const TipBox: React.FC<TipBoxProps> = ({ number, title, description, additionalDescription, containerStyle }) => {
  const { colors } = useTheme();
  const stylesHook = StyleSheet.create({
    tipBox: {
      backgroundColor: colors.ballOutgoingExpired,
      borderRadius: 12,
      padding: 16,
      marginBottom: 24,
      ...containerStyle,
    },
    tipHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: number || title ? 16 : 0,
    },
    tipHeaderText: {
      marginLeft: 4,
      flex: 1,
    },
    description: {
      marginBottom: additionalDescription ? 16 : 0,
    },
  });

  return (
    <View style={stylesHook.tipBox}>
      {(number || title) && (
        <View style={stylesHook.tipHeader}>
          {number && (
            <View style={styles.vaultKeyCircle}>
              <MalinText style={styles.vaultKeyText}>{number}</MalinText>
            </View>
          )}
          {title && (
            <MalinText bold style={stylesHook.tipHeaderText}>
              {title}
            </MalinText>
          )}
        </View>
      )}
      {description && <MalinText style={stylesHook.description}>{description}</MalinText>}
      {additionalDescription && <MalinText>{additionalDescription}</MalinText>}
    </View>
  );
};

const styles = StyleSheet.create({
  vaultKeyCircle: {
    width: 32,
    height: 32,
    justifyContent: 'center',
    alignItems: 'center',
  },
  vaultKeyText: {
    fontSize: 18,
    fontWeight: 'bold',
  },
});

export default TipBox;


================================================
FILE: ./App.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { NavigationContainer } from '@react-navigation/native';
import React from 'react';
import { useColorScheme } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { SizeClassProvider } from './components/Context/SizeClassProvider';
import { SettingsProvider } from './components/Context/SettingsProvider';
import MasterView from './navigation/MasterView';
import { navigationRef } from './NavigationService';
import { useDevTools } from '@react-navigation/devtools';
import { StorageProvider } from './components/Context/StorageProvider';

const App = () => {
  const colorScheme = useColorScheme();

  // Intgration de Dark Gold Theme
  const theme = {
    dark: true,
    colors: {
      background: '#212121',  // Noir mat
      text: '#FCD600',        // Or fonc
      primary: '#FCD600',    // Or
      card: '#333333',       // Gris trs fonc
      border: '#757575',     // Gris moyen
      notification: '#FCD600',
    }
  };

  useDevTools(navigationRef);

  return (
    <SizeClassProvider>
      <NavigationContainer ref={navigationRef} theme={theme}>
        <SafeAreaProvider style={{ backgroundColor: theme.colors.background }}>
          <StorageProvider>
            <SettingsProvider>
              <MasterView />
            </SettingsProvider>
          </StorageProvider>
        </SafeAreaProvider>
      </NavigationContainer>
    </SizeClassProvider>
  );
};

export default App;

================================================
FILE: ./metro.config.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');
const path = require('path');

const config = {
  resolver: {
    extraNodeModules: {
      stream: require.resolve('stream-browserify'),
      crypto: require.resolve('crypto-browserify'),
      net: require.resolve('react-native-tcp-socket'),
      tls: require.resolve('react-native-tcp-socket'),
      buffer: require.resolve('buffer'),
      events: require.resolve('events'),
      url: require.resolve('url'),
    },
    sourceExts: ['ts', 'tsx', 'js', 'jsx', 'json'],
    assetExts: ['png', 'gif', 'jpg', 'jpeg', 'bmp', 'psd', 'svg', 'webp', 'm4v', 'mov', 'mp4', 'mpeg', 'mpg', 'webm', 'aac', 'aiff', 'caf', 'm4a', 'mp3', 'wav', 'html', 'pdf', 'bin', 'txt'],
  },
  transformer: {
    getTransformOptions: async () => ({
      transform: {
        experimentalImportSupport: false,
        inlineRequires: false,
      },
    }),
  },
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);


================================================
FILE: ./gesture-handler.native.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// Only import react-native-gesture-handler on native platforms
import 'react-native-gesture-handler';


================================================
FILE: ./NavigationService.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createNavigationContainerRef, NavigationAction, ParamListBase, StackActions } from '@react-navigation/native';

export const navigationRef = createNavigationContainerRef<ParamListBase>();

export function navigate(name: string, params?: ParamListBase, options?: { merge: boolean }) {
  if (navigationRef.isReady()) {
    navigationRef.current?.navigate({ name, params, merge: options?.merge });
  }
}

export function dispatch(action: NavigationAction) {
  if (navigationRef.isReady()) {
    navigationRef.current?.dispatch(action);
  }
}

export function reset() {
  if (navigationRef.isReady()) {
    navigationRef.current?.reset({
      index: 0,
      routes: [{ name: 'UnlockWithScreen' }],
    });
  }
}

export function popToTop() {
  if (navigationRef.isReady()) {
    navigationRef.current?.dispatch(StackActions.popToTop());
  }
}

export function pop() {
  if (navigationRef.isReady()) {
    navigationRef.current?.dispatch(StackActions.pop());
  }
}


================================================
FILE: ./vite.config.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  root: 'miniapp',
  build: {
    outDir: '../dist_miniapp'
  }
})


================================================
FILE: ./class/measure.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * Simple helper to measure execution time of a code block
 */
export class Measure {
  private _label: string;
  private _start: number;

  constructor(label: string) {
    this._label = label;
    this._start = Date.now();
  }

  public end() {
    const end = Date.now();
    const duration = Number(((end - this._start) / 1000).toFixed(3));
    console.log(`${this._label} took ${duration}s`);
  }
}


================================================
FILE: ./class/wallets/hd-legacy-breadwallet-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory, { BIP32Interface } from 'bip32';
import * as bitcoinjs from 'bitcoinjs-lib';
import { Psbt } from 'bitcoinjs-lib';
import { CoinSelectReturnInput } from 'coinselect';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { ElectrumHistory } from '../../malin_modules/MalinElectrum';
import ecc from '../../malin_modules/noble_ecc';
import { AbstractHDElectrumWallet } from './abstract-hd-electrum-wallet';
import { HDLegacyP2PKHWallet } from './hd-legacy-p2pkh-wallet';

const bip32 = BIP32Factory(ecc);

/**
 * HD Wallet (BIP39).
 * In particular, Breadwallet-compatible (Legacy addresses)
 */
export class HDLegacyBreadwalletWallet extends HDLegacyP2PKHWallet {
  static readonly type = 'HDLegacyBreadwallet';
  static readonly typeReadable = 'HD Legacy Breadwallet (P2PKH)';
  // @ts-ignore: override
  public readonly type = HDLegacyBreadwalletWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDLegacyBreadwalletWallet.typeReadable;
  static readonly derivationPath = "m/0'";

  // track address index at which wallet switched to segwit
  _external_segwit_index: number | null = null;
  _internal_segwit_index: number | null = null;

  // we need a separate function without external_addresses_cache to use in binarySearch
  _calcNodeAddressByIndex(node: number, index: number, p2wpkh: boolean = false) {
    let _node: BIP32Interface | undefined;
    if (node === 0) {
      _node = this._node0 || (this._node0 = bip32.fromBase58(this.getXpub()).derive(node));
    }
    if (node === 1) {
      _node = this._node1 || (this._node1 = bip32.fromBase58(this.getXpub()).derive(node));
    }

    if (!_node) {
      throw new Error('Internal error: this._node0 or this._node1 is undefined');
    }

    const pubkey = _node.derive(index).publicKey;
    const address = p2wpkh ? bitcoinjs.payments.p2wpkh({ pubkey }).address : bitcoinjs.payments.p2pkh({ pubkey }).address;

    if (!address) {
      throw new Error('Internal error: no address in _calcNodeAddressByIndex');
    }

    return address;
  }

  // this function is different from HDLegacyP2PKHWallet._getNodeAddressByIndex.
  // It takes _external_segwit_index _internal_segwit_index for account
  // and starts to generate segwit addresses if index more than them
  _getNodeAddressByIndex(node: number, index: number): string {
    index = index * 1; // cast to int
    if (node === 0) {
      if (this.external_addresses_cache[index]) return this.external_addresses_cache[index]; // cache hit
    }

    if (node === 1) {
      if (this.internal_addresses_cache[index]) return this.internal_addresses_cache[index]; // cache hit
    }

    let p2wpkh = false;
    if (
      (node === 0 && this._external_segwit_index !== null && index >= this._external_segwit_index) ||
      (node === 1 && this._internal_segwit_index !== null && index >= this._internal_segwit_index)
    ) {
      p2wpkh = true;
    }

    const address = this._calcNodeAddressByIndex(node, index, p2wpkh);

    if (node === 0) {
      return (this.external_addresses_cache[index] = address);
    }

    if (node === 1) {
      return (this.internal_addresses_cache[index] = address);
    }

    throw new Error('Internal error: unknown node');
  }

  async fetchBalance() {
    try {
      if (this.next_free_change_address_index === 0 && this.next_free_address_index === 0) {
        // doing binary search for last used addresses external/internal and legacy/bech32:
        const [nextFreeExternalLegacy, nextFreeInternalLegacy] = await Promise.all([
          this._binarySearchIteration(0, 1000, 0, false),
          this._binarySearchIteration(0, 1000, 1, false),
        ]);
        const [nextFreeExternalBech32, nextFreeInternalBech32] = await Promise.all([
          this._binarySearchIteration(nextFreeExternalLegacy, nextFreeExternalLegacy + 1000, 0, true),
          this._binarySearchIteration(nextFreeInternalLegacy, nextFreeInternalLegacy + 1000, 1, true),
        ]);

        // trying to detect if segwit activated. This condition can be deleted when BRD will enable segwit by default
        if (nextFreeExternalLegacy < nextFreeExternalBech32) {
          this._external_segwit_index = nextFreeExternalLegacy;
        }
        this.next_free_address_index = nextFreeExternalBech32;

        this._internal_segwit_index = nextFreeInternalLegacy; // force segwit for change
        this.next_free_change_address_index = nextFreeInternalBech32;
      } // end rescanning fresh wallet

      // finally fetching balance
      await this._fetchBalance();
    } catch (err) {
      console.warn(err);
    }
  }

  async _binarySearchIteration(startIndex: number, endIndex: number, node: number = 0, p2wpkh: boolean = false) {
    const gerenateChunkAddresses = (chunkNum: number) => {
      const ret = [];
      for (let c = this.gap_limit * chunkNum; c < this.gap_limit * (chunkNum + 1); c++) {
        ret.push(this._calcNodeAddressByIndex(node, c, p2wpkh));
      }
      return ret;
    };

    let lastChunkWithUsedAddressesNum: number;
    let lastHistoriesWithUsedAddresses: Record<string, ElectrumHistory[]>;
    for (let c = 0; c < Math.round(endIndex / this.gap_limit); c++) {
      const histories = await MalinElectrum.multiGetHistoryByAddress(gerenateChunkAddresses(c));
      if (AbstractHDElectrumWallet._getTransactionsFromHistories(histories).length > 0) {
        // in this particular chunk we have used addresses
        lastChunkWithUsedAddressesNum = c;
        lastHistoriesWithUsedAddresses = histories;
      } else {
        // empty chunk. no sense searching more chunks
        break;
      }
    }

    let lastUsedIndex = startIndex;

    if (lastHistoriesWithUsedAddresses!) {
      // now searching for last used address in batch lastChunkWithUsedAddressesNum
      for (
        let c = lastChunkWithUsedAddressesNum! * this.gap_limit;
        c < lastChunkWithUsedAddressesNum! * this.gap_limit + this.gap_limit;
        c++
      ) {
        const address = this._calcNodeAddressByIndex(node, c, p2wpkh);
        if (lastHistoriesWithUsedAddresses[address] && lastHistoriesWithUsedAddresses[address].length > 0) {
          lastUsedIndex = Math.max(c, lastUsedIndex) + 1; // point to next, which is supposed to be unsued
        }
      }
    }

    return lastUsedIndex;
  }

  _addPsbtInput(psbt: Psbt, input: CoinSelectReturnInput, sequence: number, masterFingerprintBuffer: Uint8Array) {
    // hack to use
    // AbstractHDElectrumWallet._addPsbtInput for bech32 address
    // HDLegacyP2PKHWallet._addPsbtInput for legacy address
    const ProxyClass = input?.address?.startsWith('bc1') ? AbstractHDElectrumWallet : HDLegacyP2PKHWallet;
    const proxy = new ProxyClass();
    return proxy._addPsbtInput.apply(this, [psbt, input, sequence, masterFingerprintBuffer]);
  }
}


================================================
FILE: ./class/wallets/hd-legacy-p2pkh-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory, { BIP32Interface } from 'bip32';
import { Psbt } from 'bitcoinjs-lib';
import { CoinSelectReturnInput } from 'coinselect';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import ecc from '../../malin_modules/noble_ecc';
import { AbstractHDElectrumWallet } from './abstract-hd-electrum-wallet';
import { hexToUint8Array } from '../../malin_modules/uint8array-extras';

const bip32 = BIP32Factory(ecc);

/**
 * HD Wallet (BIP39).
 * In particular, BIP44 (P2PKH legacy addressess)
 * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
 */
export class HDLegacyP2PKHWallet extends AbstractHDElectrumWallet {
  static readonly type = 'HDlegacyP2PKH';
  static readonly typeReadable = 'HD Legacy (BIP44 P2PKH)';
  // @ts-ignore: override
  public readonly type = HDLegacyP2PKHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDLegacyP2PKHWallet.typeReadable;
  static readonly derivationPath = "m/44'/0'/0'";

  allowSend() {
    return true;
  }

  allowCosignPsbt() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }

  allowMasterFingerprint() {
    return true;
  }

  allowXpub() {
    return true;
  }

  allowBIP47() {
    return true;
  }

  getXpub() {
    if (this._xpub) {
      return this._xpub; // cache hit
    }
    const seed = this._getSeed();
    const root = bip32.fromSeed(seed);

    const path = this.getDerivationPath();
    if (!path) {
      throw new Error('Internal error: no path');
    }
    const child = root.derivePath(path).neutered();
    this._xpub = child.toBase58();

    return this._xpub;
  }

  _hdNodeToAddress(hdNode: BIP32Interface): string {
    return this._nodeToLegacyAddress(hdNode);
  }

  async fetchUtxo(): Promise<void> {
    await super.fetchUtxo();
    // now we need to fetch txhash for each input as required by PSBT
    const txhexes = await MalinElectrum.multiGetTransactionByTxid(
      this.getUtxo().map(x => x.txid),
      false,
    );

    for (const u of this.getUtxo()) {
      if (txhexes[u.txid]) u.txhex = txhexes[u.txid];
    }
  }

  _addPsbtInput(psbt: Psbt, input: CoinSelectReturnInput, sequence: number, masterFingerprintBuffer: Uint8Array) {
    if (!input.address) {
      throw new Error('Internal error: no address on Utxo during _addPsbtInput()');
    }
    const pubkey = this._getPubkeyByAddress(input.address);
    const path = this._getDerivationPathByAddress(input.address);
    if (!pubkey || !path) {
      throw new Error('Internal error: pubkey or path are invalid');
    }

    if (!input.txhex) throw new Error('UTXO is missing txhex of the input, which is required by PSBT for non-segwit input');

    psbt.addInput({
      hash: input.txid,
      index: input.vout,
      sequence,
      bip32Derivation: [
        {
          masterFingerprint: masterFingerprintBuffer,
          path,
          pubkey,
        },
      ],
      // non-segwit inputs now require passing the whole previous tx as Buffer
      nonWitnessUtxo: hexToUint8Array(input.txhex),
    });

    return psbt;
  }

  allowSilentPaymentSend(): boolean {
    return true;
  }
}


================================================
FILE: ./class/wallets/hd-segwit-electrum-seed-p2wpkh-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
import b58 from 'bs58check';
import * as mn from 'electrum-mnemonic';

import ecc from '../../malin_modules/noble_ecc';
import { concatUint8Arrays, hexToUint8Array } from '../../malin_modules/uint8array-extras';
import { HDSegwitBech32Wallet } from './hd-segwit-bech32-wallet';

const bip32 = BIP32Factory(ecc);
const PREFIX = mn.PREFIXES.segwit;

type SeedOpts = {
  prefix?: string;
  passphrase?: string;
};

/**
 * ElectrumSeed means that instead of BIP39 seed format it works with the format invented by Electrum wallet. Otherwise
 * its a regular HD wallet that has all the properties of parent class.
 *
 * @see https://electrum.readthedocs.io/en/latest/seedphrase.html
 */
export class HDSegwitElectrumSeedP2WPKHWallet extends HDSegwitBech32Wallet {
  static readonly type = 'HDSegwitElectrumSeedP2WPKHWallet';
  static readonly typeReadable = 'HD Electrum (BIP32 P2WPKH)';
  // @ts-ignore: override
  public readonly type = HDSegwitElectrumSeedP2WPKHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDSegwitElectrumSeedP2WPKHWallet.typeReadable;
  static readonly derivationPath = "m/0'";

  validateMnemonic() {
    return mn.validateMnemonic(this.secret, PREFIX);
  }

  allowBIP47() {
    return false;
  }

  async generate() {
    throw new Error('Not implemented');
  }

  getXpub() {
    if (this._xpub) {
      return this._xpub; // cache hit
    }
    const args: SeedOpts = { prefix: PREFIX };
    if (this.passphrase) args.passphrase = this.passphrase;
    const root = bip32.fromSeed(mn.mnemonicToSeedSync(this.secret, args));
    const xpub = root.derivePath("m/0'").neutered().toBase58();

    // bitcoinjs does not support zpub yet, so we just convert it from xpub
    let data = b58.decode(xpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('04b24746'), data]);
    this._xpub = b58.encode(concatenated);

    return this._xpub;
  }

  _getInternalAddressByIndex(index: number) {
    index = index * 1; // cast to int
    if (this.internal_addresses_cache[index]) return this.internal_addresses_cache[index]; // cache hit

    const xpub = this._zpubToXpub(this.getXpub());
    const node = bip32.fromBase58(xpub);
    const address = bitcoin.payments.p2wpkh({
      pubkey: node.derive(1).derive(index).publicKey,
    }).address;
    if (!address) {
      throw new Error('Internal error: no address in _getInternalAddressByIndex');
    }

    return (this.internal_addresses_cache[index] = address);
  }

  _getExternalAddressByIndex(index: number) {
    index = index * 1; // cast to int
    if (this.external_addresses_cache[index]) return this.external_addresses_cache[index]; // cache hit

    const xpub = this._zpubToXpub(this.getXpub());
    const node = bip32.fromBase58(xpub);
    const address = bitcoin.payments.p2wpkh({
      pubkey: node.derive(0).derive(index).publicKey,
    }).address;
    if (!address) {
      throw new Error('Internal error: no address in _getExternalAddressByIndex');
    }

    return (this.external_addresses_cache[index] = address);
  }

  _getWIFByIndex(internal: boolean, index: number): string | false {
    if (!this.secret) return false;
    const args: SeedOpts = { prefix: PREFIX };
    if (this.passphrase) args.passphrase = this.passphrase;
    const root = bip32.fromSeed(mn.mnemonicToSeedSync(this.secret, args));
    const path = `m/0'/${internal ? 1 : 0}/${index}`;
    const child = root.derivePath(path);

    return child.toWIF();
  }

  _getNodePubkeyByIndex(node: number, index: number) {
    index = index * 1; // cast to int

    if (node === 0 && !this._node0) {
      const xpub = this._zpubToXpub(this.getXpub());
      const hdNode = bip32.fromBase58(xpub);
      this._node0 = hdNode.derive(node);
    }

    if (node === 1 && !this._node1) {
      const xpub = this._zpubToXpub(this.getXpub());
      const hdNode = bip32.fromBase58(xpub);
      this._node1 = hdNode.derive(node);
    }

    if (node === 0 && this._node0) {
      return this._node0.derive(index).publicKey;
    }

    if (node === 1 && this._node1) {
      return this._node1.derive(index).publicKey;
    }

    throw new Error('Internal error: this._node0 or this._node1 is undefined');
  }

  isSegwit() {
    return true;
  }
}


================================================
FILE: ./class/wallets/types.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';
import { CoinSelectOutput, CoinSelectReturnInput, CoinSelectUtxo } from 'coinselect';

import { BitcoinUnit } from '../../models/bitcoinUnits';
import { HDAezeedWallet } from './hd-aezeed-wallet';
import { HDLegacyBreadwalletWallet } from './hd-legacy-breadwallet-wallet';
import { HDLegacyElectrumSeedP2PKHWallet } from './hd-legacy-electrum-seed-p2pkh-wallet';
import { HDLegacyP2PKHWallet } from './hd-legacy-p2pkh-wallet';
import { HDSegwitBech32Wallet } from './hd-segwit-bech32-wallet';
import { HDSegwitElectrumSeedP2WPKHWallet } from './hd-segwit-electrum-seed-p2wpkh-wallet';
import { HDSegwitP2SHWallet } from './hd-segwit-p2sh-wallet';
import { LegacyWallet } from './legacy-wallet';
import { LightningCustodianWallet } from './lightning-custodian-wallet';
import { MultisigHDWallet } from './multisig-hd-wallet';
import { SegwitBech32Wallet } from './segwit-bech32-wallet';
import { SegwitP2SHWallet } from './segwit-p2sh-wallet';
import { SLIP39LegacyP2PKHWallet, SLIP39SegwitBech32Wallet, SLIP39SegwitP2SHWallet } from './slip39-wallets';
import { WatchOnlyWallet } from './watch-only-wallet';
import { TaprootWallet } from './taproot-wallet.ts';
import { HDTaprootWallet } from './hd-taproot-wallet.ts';
import { LightningArkWallet } from './lightning-ark-wallet.ts';
import { EthereumWallet } from './ethereum-wallet.ts';
import { SolanaWallet } from './solana-wallet.ts';

export type Utxo = {
  // Returned by MalinElectrum
  height: number;
  address: string;
  txid: string;
  vout: number;
  value: number;

  // Others
  txhex?: string;
  confirmations?: number;
  wif?: string | false;
};

/**
 * same as coinselect.d.ts/CoinSelectUtxo
 */
export interface CreateTransactionUtxo extends CoinSelectUtxo {}

/**
 * if address is missing and `script.hex` is set - this is a custom script (like OP_RETURN)
 */
export type CreateTransactionTarget = {
  address?: string;
  value?: number;
  script?: {
    length?: number; // either length or hex should be present
    hex?: string;
  };
};

export type CreateTransactionResult = {
  tx?: bitcoin.Transaction;
  inputs: CoinSelectReturnInput[];
  outputs: CoinSelectOutput[];
  fee: number;
  psbt: bitcoin.Psbt;
};

type TransactionInput = {
  txid: string;
  vout: number;
  scriptSig: { asm: string; hex: string };
  txinwitness: string[];
  sequence: number;
  addresses?: string[];
  address?: string;
  value?: number;
};

export type TransactionOutput = {
  value: number;
  n: number;
  scriptPubKey: {
    asm: string;
    hex: string;
    reqSigs: number;
    type: string;
    addresses: string[];
  };
};

export interface DecodedInvoice {
  destination: string;
  payment_hash: string;
  num_satoshis: number;
  timestamp: number;
  expiry: number;
  description: string;
  description_hash: string;
  fallback_addr: string;
  cltv_expiry: string;
  route_hints: any[];
  [key: string]: any;
}

export type LightningTransaction = {
  memo?: string;
  type?: 'user_invoice' | 'payment_request' | 'bitcoind_tx' | 'paid_invoice';
  payment_hash?: string | { data: string };
  category?: 'receive';
  timestamp: number; // seconds, not milliseconds
  expire_time?: number;
  ispaid?: boolean;
  walletID?: string;
  value?: number;
  amt?: number;
  fee?: number;
  payment_preimage?: string;
  payment_request?: string;
  description?: string;
};

export type EthereumTransaction = {
  hash: string;
  from: string;
  to: string;
  value: number; // in wei
  gasPrice?: number; // in wei
  gasUsed?: number;
  gas: number;
  nonce: number;
  input: string;
  blockHash: string;
  blockNumber: number;
  confirmations: number;
  timestamp: number; // in seconds
  fee?: number; // in wei
};

export type SolanaTransaction = {
  signature: string;
  slot: number;
  blockTime: number; // in seconds
  memo?: string;
  fee: number; // in lamports
  preBalances: number[];
  postBalances: number[];
};

export type Transaction = {
  txid: string;
  hash: string;
  version: number;
  size: number;
  vsize: number;
  weight: number;
  locktime: number;
  inputs: TransactionInput[];
  outputs: TransactionOutput[];
  blockhash: string;
  confirmations: number;
  time: number;
  blocktime: number;
  timestamp: number; // seconds, not milliseconds
  value?: number;

  /**
   * if known, who is on the other end of the transaction (BIP47 payment code)
   */
  counterparty?: string;
};

/**
 * in some cases we add additional data to each tx object so the code that works with that transaction can find the
 * wallet that owns it etc
 */
export type ExtendedTransaction = Transaction & {
  walletID: string;
  walletPreferredBalanceUnit: BitcoinUnit;
};

export type TWallet =
  | HDAezeedWallet
  | HDLegacyBreadwalletWallet
  | HDLegacyElectrumSeedP2PKHWallet
  | HDLegacyP2PKHWallet
  | HDSegwitBech32Wallet
  | HDSegwitElectrumSeedP2WPKHWallet
  | HDSegwitP2SHWallet
  | HDTaprootWallet
  | LegacyWallet
  | LightningArkWallet
  | LightningCustodianWallet
  | MultisigHDWallet
  | SLIP39LegacyP2PKHWallet
  | SLIP39SegwitBech32Wallet
  | SLIP39SegwitP2SHWallet
  | SegwitBech32Wallet
  | SegwitP2SHWallet
  | TaprootWallet
  | WatchOnlyWallet
  | EthereumWallet
  | SolanaWallet;

export type THDWalletForWatchOnly = HDSegwitBech32Wallet | HDSegwitP2SHWallet | HDLegacyP2PKHWallet | HDTaprootWallet;


================================================
FILE: ./class/wallets/abstract-hd-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { BIP32Interface } from 'bip32';
import * as bip39 from 'bip39';

import * as bip39custom from '../../malin_modules/bip39';
import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { LegacyWallet } from './legacy-wallet';
import { Transaction } from './types';

type AbstractHDWalletStatics = {
  derivationPath?: string;
};

/**
 * @deprecated
 */
export class AbstractHDWallet extends LegacyWallet {
  static readonly type = 'abstract';
  static readonly typeReadable = 'abstract';
  // @ts-ignore: override
  public readonly type = AbstractHDWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = AbstractHDWallet.typeReadable;

  next_free_address_index: number;
  next_free_change_address_index: number;
  internal_addresses_cache: Record<number, string>;
  external_addresses_cache: Record<number, string>;
  _xpub: string;
  usedAddresses: string[];
  _address_to_wif_cache: Record<string, string>;
  gap_limit: number;
  passphrase?: string;
  _node0?: BIP32Interface;
  _node1?: BIP32Interface;

  constructor() {
    super();
    const Constructor = this.constructor as unknown as AbstractHDWalletStatics;
    this.next_free_address_index = 0;
    this.next_free_change_address_index = 0;
    this.internal_addresses_cache = {}; // index => address
    this.external_addresses_cache = {}; // index => address
    this._xpub = ''; // cache
    this.usedAddresses = [];
    this._address_to_wif_cache = {};
    this.gap_limit = 20;
    this._derivationPath = Constructor.derivationPath;
  }

  getNextFreeAddressIndex(): number {
    return this.next_free_address_index;
  }

  getNextFreeChangeAddressIndex(): number {
    return this.next_free_change_address_index;
  }

  prepareForSerialization(): void {
    // deleting structures that cant be serialized
    delete this._node0;
    delete this._node1;
  }

  generate(): Promise<void> {
    throw new Error('Not implemented');
  }

  allowSend(): boolean {
    return false;
  }

  getTransactions(): Transaction[] {
    throw new Error('Not implemented');
  }

  /**
   * @return {Buffer} wallet seed
   */
  _getSeed(): Buffer {
    const mnemonic = this.secret;
    const passphrase = this.passphrase;
    return bip39.mnemonicToSeedSync(mnemonic, passphrase);
  }

  setSecret(newSecret: string): this {
    // first, checking if it's a SeedQR:
    try {
      // compact seedQR should be between 32 - 64 chars long in hex format
      if (newSecret.length === 64 || newSecret.length === 32) {
        // not supported as mobile scanners dont recognize such QRs at all.
        // nop
      } else if (newSecret.length === 96 || newSecret.length === 48) {
        // standard seedQR
        const wordlist = bip39.wordlists[bip39.getDefaultWordlist()];
        const words = newSecret.match(/[\d]{4}/g);

        if (words) {
          newSecret = words.map(num => wordlist[parseInt(num, 10)]).join(' ');
        }
      }
    } catch (e) {}
    // end SeedQR

    this.secret = newSecret.trim().toLowerCase();
    this.secret = this.secret.replace(/[^a-zA-Z0-9]/g, ' ').replace(/\s+/g, ' ');

    // Try to match words to the default bip39 wordlist and complete partial words
    const wordlist = bip39.wordlists[bip39.getDefaultWordlist()];
    const lookupMap = wordlist.reduce((map, word) => {
      const prefix3 = word.substr(0, 3);
      const prefix4 = word.substr(0, 4);

      map.set(prefix3, !map.has(prefix3) ? word : false);
      map.set(prefix4, !map.has(prefix4) ? word : false);

      return map;
    }, new Map<string, string | false>());

    this.secret = this.secret
      .split(' ')
      .map(word => lookupMap.get(word) || word)
      .join(' ');

    return this;
  }

  setPassphrase(passphrase: string): void {
    this.passphrase = passphrase;
  }

  getPassphrase(): string | undefined {
    return this.passphrase;
  }

  /**
   * @return {Boolean} is mnemonic in `this.secret` valid
   */
  validateMnemonic(): boolean {
    return bip39custom.validateMnemonic(this.secret);
  }

  /**
   * Derives from hierarchy, returns next free address
   * (the one that has no transactions). Looks for several,
   * gives up if none found, and returns the used one
   *
   * @return {Promise.<string>}
   */
  async getAddressAsync(): Promise<string> {
    // looking for free external address
    let freeAddress = '';
    let c;
    for (c = 0; c < this.gap_limit + 1; c++) {
      if (this.next_free_address_index + c < 0) continue;
      const address = this._getExternalAddressByIndex(this.next_free_address_index + c);
      this.external_addresses_cache[this.next_free_address_index + c] = address; // updating cache just for any case
      let txs = [];
      try {
        txs = await MalinElectrum.getTransactionsByAddress(address);
      } catch (Err: any) {
        console.warn('MalinElectrum.getTransactionsByAddress()', Err.message);
      }
      if (txs.length === 0) {
        // found free address
        freeAddress = address;
        this.next_free_address_index += c; // now points to _this one_
        break;
      }
    }

    if (!freeAddress) {
      // could not find in cycle above, give up
      freeAddress = this._getExternalAddressByIndex(this.next_free_address_index + c); // we didnt check this one, maybe its free
      this.next_free_address_index += c; // now points to this one
    }
    this._address = freeAddress;
    return freeAddress;
  }

  /**
   * Derives from hierarchy, returns next free CHANGE address
   * (the one that has no transactions). Looks for several,
   * gives up if none found, and returns the used one
   *
   * @return {Promise.<string>}
   */
  async getChangeAddressAsync(): Promise<string> {
    // looking for free internal address
    let freeAddress = '';
    let c;
    for (c = 0; c < this.gap_limit + 1; c++) {
      if (this.next_free_change_address_index + c < 0) continue;
      const address = this._getInternalAddressByIndex(this.next_free_change_address_index + c);
      this.internal_addresses_cache[this.next_free_change_address_index + c] = address; // updating cache just for any case
      let txs = [];
      try {
        txs = await MalinElectrum.getTransactionsByAddress(address);
      } catch (Err: any) {
        console.warn('MalinElectrum.getTransactionsByAddress()', Err.message);
      }
      if (txs.length === 0) {
        // found free address
        freeAddress = address;
        this.next_free_change_address_index += c; // now points to _this one_
        break;
      }
    }

    if (!freeAddress) {
      // could not find in cycle above, give up
      freeAddress = this._getInternalAddressByIndex(this.next_free_change_address_index + c); // we didnt check this one, maybe its free
      this.next_free_change_address_index += c; // now points to this one
    }
    this._address = freeAddress;
    return freeAddress;
  }

  /**
   * Should not be used in HD wallets
   *
   * @deprecated
   * @return {string}
   */
  getAddress(): string | false {
    return this._address;
  }

  _getExternalWIFByIndex(index: number): string | false {
    throw new Error('Not implemented');
  }

  _getInternalWIFByIndex(index: number): string | false {
    throw new Error('Not implemented');
  }

  _getExternalAddressByIndex(index: number): string {
    throw new Error('Not implemented');
  }

  _getInternalAddressByIndex(index: number): string {
    throw new Error('Not implemented');
  }

  getXpub(): string {
    throw new Error('Not implemented');
  }

  /**
   * Async function to fetch all transactions. Use getter to get actual txs.
   * Also, sets internals:
   *  `this.internal_addresses_cache`
   *  `this.external_addresses_cache`
   *
   * @returns {Promise<void>}
   */
  async fetchTransactions(): Promise<void> {
    throw new Error('not implemented');
  }

  /**
   * Given that `address` is in our HD hierarchy, try to find
   * corresponding WIF
   *
   * @param address {String} In our HD hierarchy
   * @return {String} WIF if found
   */
  _getWifForAddress(address: string): string {
    if (this._address_to_wif_cache[address]) return this._address_to_wif_cache[address]; // cache hit

    // fast approach, first lets iterate over all addressess we have in cache
    for (const indexStr of Object.keys(this.internal_addresses_cache)) {
      const index = parseInt(indexStr, 10);
      if (this._getInternalAddressByIndex(index) === address) {
        return (this._address_to_wif_cache[address] = <string>this._getInternalWIFByIndex(index));
      }
    }

    for (const indexStr of Object.keys(this.external_addresses_cache)) {
      const index = parseInt(indexStr, 10);
      if (this._getExternalAddressByIndex(index) === address) {
        return (this._address_to_wif_cache[address] = <string>this._getExternalWIFByIndex(index));
      }
    }

    // no luck - lets iterate over all addresses we have up to first unused address index
    for (let c = 0; c <= this.next_free_change_address_index + this.gap_limit; c++) {
      const possibleAddress = this._getInternalAddressByIndex(c);
      if (possibleAddress === address) {
        return (this._address_to_wif_cache[address] = <string>this._getInternalWIFByIndex(c));
      }
    }

    for (let c = 0; c <= this.next_free_address_index + this.gap_limit; c++) {
      const possibleAddress = this._getExternalAddressByIndex(c);
      if (possibleAddress === address) {
        return (this._address_to_wif_cache[address] = <string>this._getExternalWIFByIndex(c));
      }
    }

    throw new Error('Could not find WIF for ' + address);
  }

  async fetchBalance(): Promise<void> {
    throw new Error('Not implemented');
  }

  /**
   * @inheritDoc
   */
  async fetchUtxo(): Promise<void> {
    throw new Error('Not implemented');
  }

  _getDerivationPathByAddress(address: string): string | false {
    throw new Error('Not implemented');
  }

  _getNodePubkeyByIndex(node: number, index: number): Uint8Array | undefined {
    throw new Error('Not implemented');
  }

  /**
   * @returns {string} Root derivation path for wallet if any
   */
  getDerivationPath() {
    return this._derivationPath;
  }

  /*
   * Set derivation path for the wallet
   *
   * @param {String} path - path
   */
  setDerivationPath(path: string) {
    this._derivationPath = path;
  }
}


================================================
FILE: ./class/wallets/abstract-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import b58 from 'bs58check';
import { sha256 } from '@noble/hashes/sha256';
import wif from 'wif';

import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { CreateTransactionResult, CreateTransactionUtxo, Transaction, Utxo } from './types';
import { hexToUint8Array, concatUint8Arrays, uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

type WalletWithPassphrase = AbstractWallet & { getPassphrase: () => string };
type UtxoMetadata = {
  frozen?: boolean;
  memo?: string;
};

export class AbstractWallet {
  static readonly type = 'abstract';
  static readonly typeReadable = 'abstract';
  // @ts-ignore: override
  public readonly type = AbstractWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = AbstractWallet.typeReadable;

  static fromJson(obj: string): AbstractWallet {
    const obj2 = JSON.parse(obj);
    const temp = new this();
    for (const key2 of Object.keys(obj2)) {
      // @ts-ignore This kind of magic is not allowed in typescript, we should try and be more specific
      temp[key2] = obj2[key2];
    }

    return temp;
  }

  segwitType?: 'p2wpkh' | 'p2sh(p2wpkh)' | 'p2tr';
  _derivationPath?: string;
  label: string;
  secret: string;
  balance: number;
  unconfirmed_balance: number;
  _address: string | false;
  _utxo: Utxo[];
  _lastTxFetch: number;
  _lastBalanceFetch: number;
  preferredBalanceUnit: BitcoinUnit;
  chain: Chain;
  hideBalance: boolean;
  userHasSavedExport: boolean;
  _hideTransactionsInWalletsList: boolean;
  _utxoMetadata: Record<string, UtxoMetadata>;
  use_with_hardware_wallet: boolean;
  masterFingerprint: number;

  constructor() {
    this.label = '';
    this.secret = ''; // private key or recovery phrase
    this.balance = 0;
    this.unconfirmed_balance = 0;
    this._address = false; // cache
    this._utxo = [];
    this._lastTxFetch = 0;
    this._lastBalanceFetch = 0;
    this.preferredBalanceUnit = BitcoinUnit.BTC;
    this.chain = Chain.ONCHAIN;
    this.hideBalance = false;
    this.userHasSavedExport = false;
    this._hideTransactionsInWalletsList = false;
    this._utxoMetadata = {};
    this.use_with_hardware_wallet = false;
    this.masterFingerprint = 0;
  }

  /**
   * @returns {number} Timestamp (millisecsec) of when last transactions were fetched from the network
   */
  getLastTxFetch(): number {
    return this._lastTxFetch;
  }

  getID(): string {
    const thisWithPassphrase = this as unknown as WalletWithPassphrase;
    const passphrase = thisWithPassphrase.getPassphrase ? thisWithPassphrase.getPassphrase() : '';
    const path = this._derivationPath ?? '';
    const string2hash = this.type + this.getSecret() + passphrase + path;
    return uint8ArrayToHex(sha256(string2hash));
  }

  getTransactions(): Transaction[] {
    throw new Error('not implemented');
  }

  getUserHasSavedExport(): boolean {
    return this.userHasSavedExport;
  }

  setUserHasSavedExport(value: boolean): void {
    this.userHasSavedExport = value;
  }

  getHideTransactionsInWalletsList(): boolean {
    return this._hideTransactionsInWalletsList;
  }

  setHideTransactionsInWalletsList(value: boolean): void {
    this._hideTransactionsInWalletsList = value;
  }

  /**
   *
   * @returns {string}
   */
  getLabel(): string {
    if (this.label.trim().length === 0) {
      return 'Wallet';
    }
    return this.label;
  }

  getXpub(): string | false {
    return this._address;
  }

  /**
   *
   * @returns {number} Available to spend amount, int, in sats
   */
  getBalance(): number {
    return this.balance + (this.getUnconfirmedBalance() < 0 ? this.getUnconfirmedBalance() : 0);
  }

  getPreferredBalanceUnit(): BitcoinUnit {
    for (const value of Object.values(BitcoinUnit)) {
      if (value === this.preferredBalanceUnit) {
        return this.preferredBalanceUnit;
      }
    }
    return BitcoinUnit.BTC;
  }

  async allowOnchainAddress(): Promise<boolean> {
    throw new Error('allowOnchainAddress: Not implemented');
  }

  allowBIP47(): boolean {
    return false;
  }

  switchBIP47(value: boolean): void {
    throw new Error('switchBIP47: not implemented');
  }

  allowReceive(): boolean {
    return true;
  }

  allowSend(): boolean {
    return true;
  }

  allowSilentPaymentSend(): boolean {
    return false;
  }

  allowRBF(): boolean {
    return false;
  }

  allowPayJoin(): boolean {
    return false;
  }

  allowCosignPsbt(): boolean {
    return false;
  }

  allowSignVerifyMessage(): boolean {
    return false;
  }

  allowMasterFingerprint(): boolean {
    return false;
  }

  allowXpub(): boolean {
    return false;
  }

  weOwnAddress(address: string): boolean {
    throw Error('not implemented');
  }

  weOwnTransaction(txid: string): boolean {
    throw Error('not implemented');
  }

  /**
   * Returns delta of unconfirmed balance. For example, if theres no
   * unconfirmed balance its 0
   *
   * @return {number} Satoshis
   */
  getUnconfirmedBalance(): number {
    return this.unconfirmed_balance;
  }

  setLabel(newLabel: string): this {
    this.label = newLabel;
    return this;
  }

  getSecret(): string {
    return this.secret;
  }

  setSecret(newSecret: string): this {
    const origSecret = newSecret;

    // is it minikey https://en.bitcoin.it/wiki/Mini_private_key_format
    // Starts with S, is 22 length or larger, is base58
    if (newSecret.startsWith('S') && newSecret.length >= 22 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(newSecret)) {
      // minikey + ? hashed with SHA256 starts with 0x00 byte
      if (uint8ArrayToHex(sha256(`${newSecret}?`)).startsWith('00')) {
        // it is a valid minikey
        newSecret = wif.encode(0x80, Buffer.from(sha256(newSecret)), false);
      }
    }

    this.secret = newSecret.trim().replace('bitcoin:', '').replace('BITCOIN:', '');

    if (this.secret.startsWith('BC1')) this.secret = this.secret.toLowerCase();

    // is it output descriptor?
    if (
      this.secret.startsWith('wpkh(') ||
      this.secret.startsWith('pkh(') ||
      this.secret.startsWith('sh(') ||
      this.secret.startsWith('tr(')
    ) {
      const xpubIndex = Math.max(this.secret.indexOf('xpub'), this.secret.indexOf('ypub'), this.secret.indexOf('zpub'));
      let fpAndPath;
      if (this.secret.includes('[')) {
        fpAndPath = this.secret.substring(this.secret.indexOf('['), xpubIndex).replace(/[[\]]/g, '');
      } else {
        // old (or broken) format..? no square brackets, only "()"
        fpAndPath = this.secret.substring(this.secret.indexOf('('), xpubIndex).replace(/[()]/g, '');
      }
      const xpub = this.secret.substring(xpubIndex).replace(/\(|\)/, '').split('/')[0];

      const pathIndex = fpAndPath.indexOf('/');
      const path = 'm' + fpAndPath.substring(pathIndex).replace(/h/g, "'");
      const fp = fpAndPath.substring(0, pathIndex);

      this._derivationPath = path;
      const mfp = uint8ArrayToHex(hexToUint8Array(fp).reverse());
      this.masterFingerprint = parseInt(mfp, 16);

      if (this.secret.startsWith('wpkh(')) {
        this.secret = this._xpubToZpub(xpub);
      } else {
        // nop
        this.secret = xpub;
      }

      return this;
    }

    // [fingerprint/derivation]zpub
    const re = /\[([^\]]+)\](.*)/;
    const m = this.secret.match(re);
    if (m && m.length === 3) {
      let [hexFingerprint, ...derivationPathArray] = m[1].split('/');
      const derivationPath = `m/${derivationPathArray.join('/').replace(/h/g, "'")}`;
      if (hexFingerprint.length === 8) {
        hexFingerprint = uint8ArrayToHex(hexToUint8Array(hexFingerprint).reverse());
        this.masterFingerprint = parseInt(hexFingerprint, 16);
        this._derivationPath = derivationPath;
      }
      this.secret = m[2];

      if (derivationPath.startsWith("m/84'/0'/") && this.secret.toLowerCase().startsWith('xpub')) {
        // need to convert xpub to zpub
        this.secret = this._xpubToZpub(this.secret.split('/')[0]);
      }

      if (derivationPath.startsWith("m/49'/0'/") && this.secret.toLowerCase().startsWith('xpub')) {
        // need to convert xpub to ypub
        this.secret = this._xpubToYpub(this.secret);
      }
    }

    try {
      let parsedSecret;
      // regex might've matched invalid data. if so, parse newSecret.
      if (this.secret.trim().length > 0) {
        try {
          parsedSecret = JSON.parse(this.secret);
        } catch (e) {
          parsedSecret = JSON.parse(newSecret);
        }
      } else {
        parsedSecret = JSON.parse(newSecret);
      }
      if (parsedSecret && parsedSecret.keystore && parsedSecret.keystore.xpub) {
        let masterFingerprint: number = 0;
        if (parsedSecret.keystore.ckcc_xfp) {
          // It is a ColdCard Hardware Wallet
          masterFingerprint = Number(parsedSecret.keystore.ckcc_xfp);
        } else if (parsedSecret.keystore.root_fingerprint) {
          masterFingerprint = Number(parsedSecret.keystore.root_fingerprint);
          if (!masterFingerprint) masterFingerprint = this.getMasterFingerprintFromHex(parsedSecret.keystore.root_fingerprint);
        }
        if (parsedSecret.keystore.label) {
          this.setLabel(parsedSecret.keystore.label);
        }
        if (parsedSecret.keystore.derivation) {
          this._derivationPath = parsedSecret.keystore.derivation;
          this._derivationPath = this._derivationPath?.replace(/h/g, "'");
        }
        this.secret = parsedSecret.keystore.xpub;
        this.masterFingerprint = masterFingerprint;

        if (parsedSecret.keystore.type === 'hardware') this.use_with_hardware_wallet = true;
      }
      // It is a Cobo Vault Hardware Wallet
      if (parsedSecret && parsedSecret.ExtPubKey && parsedSecret.MasterFingerprint && parsedSecret.AccountKeyPath) {
        this.secret = parsedSecret.ExtPubKey;
        const mfp = uint8ArrayToHex(hexToUint8Array(parsedSecret.MasterFingerprint).reverse());
        this.masterFingerprint = parseInt(mfp, 16);
        this._derivationPath = parsedSecret.AccountKeyPath.startsWith('m/')
          ? parsedSecret.AccountKeyPath
          : `m/${parsedSecret.AccountKeyPath}`;
        if (parsedSecret.CoboVaultFirmwareVersion) this.use_with_hardware_wallet = true;
        return this;
      }
    } catch (_) {}

    if (!this._derivationPath) {
      if (this.secret.startsWith('xpub')) {
        this._derivationPath = "m/44'/0'/0'"; // Assume default BIP44 path for legacy wallets
      } else if (this.secret.startsWith('ypub')) {
        this._derivationPath = "m/49'/0'/0'"; // Assume default BIP49 path for segwit wrapped wallets
      } else if (this.secret.startsWith('zpub')) {
        this._derivationPath = "m/84'/0'/0'"; // Assume default BIP84 for native segwit wallets
      }
    }

    // is it new-wasabi.json exported from coldcard?
    try {
      const json = JSON.parse(origSecret);
      if (json.MasterFingerprint && json.ExtPubKey) {
        // technically we should allow choosing which format user wants, BIP44 / BIP49 / BIP84, but meh...
        this.secret = this._xpubToZpub(json.ExtPubKey);
        const mfp = uint8ArrayToHex(hexToUint8Array(json.MasterFingerprint).reverse());
        this.masterFingerprint = parseInt(mfp, 16);
        return this;
      }
    } catch (_) {}

    // is it sparrow-export ?
    try {
      const json = JSON.parse(origSecret);
      if (json.chain && json.chain === 'BTC' && json.xfp && json.bip84) {
        // technically we should allow choosing which format user wants, BIP44 / BIP49 / BIP84, but meh...
        this.secret = json.bip84._pub;
        const mfp = uint8ArrayToHex(hexToUint8Array(json.xfp).reverse());
        this.masterFingerprint = parseInt(mfp, 16);
        this._derivationPath = json.bip84.deriv;
        return this;
      }
    } catch (_) {}

    return this;
  }

  getLatestTransactionTime(): string | 0 {
    return 0;
  }

  /**
   * @deprecated
   * TODO: be more precise on the type
   */

  createTx(): any {
    throw Error('not implemented');
  }

  /**
   *
   * @param utxos {Array.<{vout: Number, value: Number, txid: String, address: String}>} List of spendable utxos
   * @param targets {Array.<{value: Number, address: String}>} Where coins are going. If theres only 1 target and that target has no value - this will send MAX to that address (respecting fee rate)
   * @param feeRate {Number} satoshi per byte
   * @param changeAddress {String} Excessive coins will go back to that address
   * @param sequence {Number} Used in RBF
   * @param skipSigning {boolean} Whether we should skip signing, use returned `psbt` in that case
   * @param masterFingerprint {number} Decimal number of wallet's master fingerprint
   * @returns {{outputs: Array, tx: Transaction, inputs: Array, fee: Number, psbt: Psbt}}
   */
  createTransaction(
    utxos: CreateTransactionUtxo[],
    targets: {
      address: string;
      value?: number;
    }[],
    feeRate: number,
    changeAddress: string,
    sequence: number,
    skipSigning = false,
    masterFingerprint: number,
  ): CreateTransactionResult {
    throw Error('not implemented');
  }

  getAddress(): string | false | undefined {
    throw Error('not implemented');
  }

  getAddressAsync(): Promise<string | false | undefined> {
    return new Promise(resolve => resolve(this.getAddress()));
  }

  async getChangeAddressAsync(): Promise<string | false | undefined> {
    return new Promise(resolve => resolve(this.getAddress()));
  }

  useWithHardwareWalletEnabled(): boolean {
    return false;
  }

  isBIP47Enabled(): boolean {
    return false;
  }

  async wasEverUsed(): Promise<boolean> {
    throw new Error('Not implemented');
  }

  /**
   * Returns _all_ external addresses in hierarchy (for HD wallets) or just address for single-address wallets
   * _Not_ internal ones, as this method is supposed to be used for subscription of external notifications.
   *
   * @returns string[] Addresses
   */
  getAllExternalAddresses(): string[] {
    return [];
  }

  /*
   * Converts zpub to xpub
   *
   * @param {String} zpub
   * @returns {String} xpub
   */
  _zpubToXpub(zpub: string): string {
    let data = b58.decode(zpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('0488b21e'), data]);

    return b58.encode(concatenated);
  }

  /**
   * Converts ypub to xpub
   * @param {String} ypub - wallet ypub
   * @returns {*}
   */
  static _ypubToXpub(ypub: string): string {
    let data = b58.decode(ypub);
    if (data.readUInt32BE() !== 0x049d7cb2) throw new Error('Not a valid ypub extended key!');
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('0488b21e'), data]);

    return b58.encode(concatenated);
  }

  _xpubToZpub(xpub: string): string {
    let data = b58.decode(xpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('04b24746'), data]);

    return b58.encode(concatenated);
  }

  _xpubToYpub(xpub: string): string {
    let data = b58.decode(xpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('049d7cb2'), data]);

    return b58.encode(concatenated);
  }

  prepareForSerialization(): void {}

  /*
   * Get metadata (frozen, memo) for a specific UTXO
   *
   * @param {String} txid - transaction id
   * @param {number} vout - an index number of the output in transaction
   */
  getUTXOMetadata(txid: string, vout: number): UtxoMetadata {
    return this._utxoMetadata[`${txid}:${vout}`] || {};
  }

  /*
   * Set metadata (frozen, memo) for a specific UTXO
   *
   * @param {String} txid - transaction id
   * @param {number} vout - an index number of the output in transaction
   * @param {{memo: String, frozen: Boolean}} opts - options to attach to UTXO
   */
  setUTXOMetadata(txid: string, vout: number, opts: UtxoMetadata): void {
    const meta = this._utxoMetadata[`${txid}:${vout}`] || {};
    if ('memo' in opts) meta.memo = opts.memo;
    if ('frozen' in opts) meta.frozen = opts.frozen;
    this._utxoMetadata[`${txid}:${vout}`] = meta;
  }

  isSegwit() {
    return false;
  }

  getMasterFingerprintFromHex(hexValue: string): number {
    if (hexValue.length < 8) hexValue = '0' + hexValue;
    const b = hexToUint8Array(hexValue);
    if (b.length !== 4) throw new Error('invalid fingerprint hex');

    hexValue = hexValue[6] + hexValue[7] + hexValue[4] + hexValue[5] + hexValue[2] + hexValue[3] + hexValue[0] + hexValue[1];

    return parseInt(hexValue, 16);
  }
}


================================================
FILE: ./class/wallets/legacy-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BigNumber from 'bignumber.js';
import * as bitcoin from 'bitcoinjs-lib';
import bitcoinMessage from 'bitcoinjs-message';
import coinSelect, {
  CoinSelectOutput,
  CoinSelectReturnInput,
  CoinSelectTarget
} from 'coinselect';
import coinSelectSplit from 'coinselect/split';
import { ECPairAPI, ECPairFactory, Signer } from 'ecpair';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import ecc from '../../malin_modules/noble_ecc';
import {
  hexToUint8Array,
  concatUint8Arrays
} from '../../malin_modules/uint8array-extras';
import { HDSegwitBech32Wallet } from '..';
import { randomBytes } from '../rng';
import { AbstractWallet } from './abstract-wallet';
import {
  CreateTransactionResult,
  CreateTransactionTarget,
  CreateTransactionUtxo,
  Transaction,
  Utxo
} from './types';
const ECPair: ECPairAPI = ECPairFactory(ecc);
bitcoin.initEccLib(ecc);

/**
 *  Has private key and single address like "1ABCD....."
 *  (legacy P2PKH compressed)
 */
export class LegacyWallet extends AbstractWallet {
  static readonly type = 'legacy';
  static readonly typeReadable = 'Legacy (P2PKH)';
  // @ts-ignore: override
  public readonly type = LegacyWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = LegacyWallet.typeReadable;

  _txs_by_external_index: Transaction[] = [];
  _txs_by_internal_index: Transaction[] = [];

  /**
   * Simple function which says that we havent tried to fetch balance
   * for a long time
   *
   * @return {boolean}
   */
  timeToRefreshBalance (): boolean {
    if (+new Date() - this._lastBalanceFetch >= 5 * 60 * 1000) {
      return true;
    }
    return false;
  }

  /**
   * Simple function which says if we hve some low-confirmed transactions
   * and we better fetch them
   *
   * @return {boolean}
   */
  timeToRefreshTransaction(): boolean {
    for (const tx of this.getTransactions()) {
      if (
        (tx.confirmations ?? 0) < 7 &&
        this._lastTxFetch < +new Date() - 5 * 60 * 1000
      ) {
        return true;
      }
    }
    return false;
  }

  async generate(): Promise<void> {
    const buf = await randomBytes(32);
    this.secret = ECPair.makeRandom({ rng: () => buf }).toWIF();
  }

  async generateFromEntropy(user: Uint8Array): Promise<void> {
    if (user.length !== 32) {
      throw new Error('Entropy should be 32 bytes');
    }
    this.secret = ECPair.fromPrivateKey(user).toWIF();
  }

  getAddress(): string | false {
    if (this._address) return this._address;
    let address;
    try {
      const keyPair = ECPair.fromWIF(this.secret);
      address = bitcoin.payments.p2pkh({
        pubkey: keyPair.publicKey,
      }).address;
    } catch (err) {
      return false;
    }
    this._address = address ?? false;

    return this._address;
  }

  /**
   * @inheritDoc
   */
  getAllExternalAddresses(): string[] {
    const address = this.getAddress();

    return address ? [address] : [];
  }

  /**
   * Fetches balance of the Wallet via API.
   * Returns VOID. Get the actual balance via getter.
   *
   * @returns {Promise.<void>}
   */
  async fetchBalance(): Promise<void> {
    try {
      const address = this.getAddress();
      if (!address) throw new Error('LegacyWallet: Invalid address');
      const balance = await MalinElectrum.getBalanceByAddress(address);
      this.balance = Number(balance.confirmed);
      this.unconfirmed_balance = Number(balance.unconfirmed);
      this._lastBalanceFetch = +new Date();
    } catch (error) {
      console.warn(error);
    }
  }

  /**
   * Fetches UTXO from API. Returns VOID.
   *
   * @return {Promise.<void>}
   */
  async fetchUtxo(): Promise<void> {
    try {
      const address = this.getAddress();
      if (!address) throw new Error('LegacyWallet: Invalid address');
      const utxos = await MalinElectrum.multiGetUtxoByAddress([address]);
      this._utxo = [];
      for (const arr of Object.values(utxos)) {
        this._utxo = this._utxo.concat(arr);
      }

      // now we need to fetch txhash for each input as required by PSBT
      if (LegacyWallet.type !== this.type) return; // but only for LEGACY single-address wallets
      const txhexes = await MalinElectrum.multiGetTransactionByTxid(
        this._utxo.map((u) => u.txid),
        false,
      )

      const newUtxos = [];
      for (const u of this._utxo) {
        if (txhexes[u.txid]) u.txhex = txhexes[u.txid];
        newUtxos.push(u);
      }

      this._utxo = newUtxos;
    } catch (error) {
      console.warn(error);
    }
  }

  /**
   * Getter for previously fetched UTXO. For example:
   *     [ { height: 0,
   *    value: 666,
   *    address: 'string',
   *    vout: 1,
   *    txid: 'string',
   *    wif: 'string',
   *    confirmations: 0 } ]
   *
   * @param respectFrozen {boolean} Add Frozen outputs
   * @returns {[]}
   */
  getUtxo(respectFrozen = false): Utxo[] {
    let ret: Utxo[] = [];
    for (const u of this._utxo) {
      if (!u.confirmations && u.height)
        {u.confirmations = MalinElectrum.estimateCurrentBlockheight() - u.height}
      ret.push(u);
    }

    if (ret.length === 0) {
      ret = this.getDerivedUtxoFromOurTransaction(); // oy vey, no stored utxo. lets attempt to derive it from stored transactions
    }

    if (!respectFrozen) {
      ret = ret.filter(
        ({ txid, vout }) => !txid || !this.getUTXOMetadata(txid, vout).frozen
      );
    }
    return ret;
  }

  getDerivedUtxoFromOurTransaction(returnSpentUtxoAsWell = false): Utxo[] {
    const utxos: Utxo[] = [];

    const ownedAddressesHashmap: Record<string, boolean> = {};
    const addrs = this.getAddress();
    if (addrs) ownedAddressesHashmap[addrs] = true;

    /**
     * below copypasted from
     * @see AbstractHDElectrumWallet.getDerivedUtxoFromOurTransaction
     */

    for (const tx of this.getTransactions()) {
      for (const output of tx.outputs) {
        let address: string | false = false;
        if (
          output.scriptPubKey &&
          output.scriptPubKey.addresses &&
          output.scriptPubKey.addresses[0]
        ) {
          address = output.scriptPubKey.addresses[0];
        }
        if (address && ownedAddressesHashmap[address]) {
          const value = new BigNumber(output.value)
            .multipliedBy(100000000)
            .toNumber();
          utxos.push({
            txid: tx.txid,
            vout: output.n,
            address,
            value,
            confirmations: tx.confirmations,
            wif: false,
            height:
              MalinElectrum.estimateCurrentBlockheight() -
              (tx.confirmations ?? 0),
          })
        }
      }
    }

    if (returnSpentUtxoAsWell) return utxos;

    // got all utxos we ever had. lets filter out the ones that are spent:
    const ret = [];
    const txs = this.getTransactions();
    for (const utxo of utxos) {
      let spent = false;
      for (const tx of txs) {
        for (const input of tx.inputs) {
          if (input.txid === utxo.txid && input.vout === utxo.vout)
            {spent = true}
          // utxo we got previously was actually spent right here ^^
        }
      }

      if (!spent) {
        ret.push(utxo);
      }
    }

    return ret;
  }

  /**
   * Fetches transactions via Electrum. Returns VOID.
   * Use getter to get the actual list.   *
   * @see AbstractHDElectrumWallet.fetchTransactions()
   *
   * @return {Promise.<void>}
   */
  async fetchTransactions(): Promise<void> {
    // Below is a simplified copypaste from HD electrum wallet
    const _txsByExternalIndex: Transaction[] = [];
    const address = this.getAddress();
    const addresses2fetch = address ? [address] : [];

    // first: batch fetch for all addresses histories
    const histories =
      await MalinElectrum.multiGetHistoryByAddress(addresses2fetch);
    const txs: Record<
      string,
      {
        tx_hash: string;
        height: number;
        address: string;
      }
    > = {};
    for (const history of Object.values(histories)) {
      for (const tx of history) {
        txs[tx.tx_hash] = tx;
      }
    }

    if (
      this.getTransactions().length === 0 &&
      Object.values(txs).length > 1000
    ) {
      throw new Error('Addresses with history of > 1000 transactions are not supported')
    }
    // we check existing transactions, so if there are any then user is just using his wallet and gradually reaching the theshold, which
    // is safe because in that case our cache is filled

    // next, batch fetching each txid we got
    const txdatas = await MalinElectrum.multiGetTransactionByTxid(
      Object.keys(txs),
      true
    );
    const transactions = Object.values(txdatas);

    // now, tricky part. we collect all transactions from inputs (vin), and batch fetch them too.
    // then we combine all this data (we need inputs to see source addresses and amounts)
    const vinTxids = [];
    for (const txdata of transactions) {
      for (const vin of txdata.vin) {
        vin.txid && vinTxids.push(vin.txid);
        // ^^^^ not all inputs have txid, some of them are Coinbase (newly-created coins)
      }
    }
    const vintxdatas = await MalinElectrum.multiGetTransactionByTxid(
      vinTxids,
      true
    );

    // fetched all transactions from our inputs. now we need to combine it.
    // iterating all _our_ transactions:
    const transactionsWithInputValue = transactions.map((tx) => {
      return {
        ...tx,
        vin: tx.vin.map((vin) => {
          const inpTxid = vin.txid;
          const inpVout = vin.vout;
          // got txid and output number of _previous_ transaction we shoud look into

          if (vintxdatas[inpTxid] && vintxdatas[inpTxid].vout[inpVout]) {
            return {
              ...vin,
              addresses:
                vintxdatas[inpTxid].vout[inpVout].scriptPubKey.addresses,
              value: vintxdatas[inpTxid].vout[inpVout].value,
            }
          } else {
            return vin;
          }
        }),
      }
    });

    // now, we need to put transactions in all relevant `cells` of internal hashmaps: this.transactions_by_internal_index && this.transactions_by_external_index

    for (const tx of transactionsWithInputValue) {
      for (const vin of tx.vin) {
        if (
          'addresses' in vin &&
          vin.addresses &&
          vin.addresses.indexOf(address || '') !== -1
        ) {
          // this TX is related to our address
          const { vin: vin2, vout, ...txRest } = tx;
          const clonedTx: Transaction = {
            ...txRest,
            inputs: [...vin2],
            outputs: [...vout],
            timestamp:
              tx.blocktime ||
              tx.time ||
              Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
          }

          _txsByExternalIndex.push(clonedTx);
        }
      }
      for (const vout of tx.vout) {
        if (
          vout.scriptPubKey.addresses &&
          vout.scriptPubKey.addresses.indexOf(address || '') !== -1
        ) {
          // this TX is related to our address
          const { vin, vout: vout2, ...txRest } = tx;
          const clonedTx: Transaction = {
            ...txRest,
            inputs: [...vin],
            outputs: [...vout2],
            timestamp:
              tx.blocktime ||
              tx.time ||
              Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
          }

          _txsByExternalIndex.push(clonedTx);
        }
      }
    }

    this._txs_by_external_index = _txsByExternalIndex;
    this._lastTxFetch = +new Date();
  }

  getTransactions(): Transaction[] {
    // a hacky code reuse from electrum HD wallet:
    this._txs_by_external_index = this._txs_by_external_index || [];
    this._txs_by_internal_index = [];

    const hd = new HDSegwitBech32Wallet();
    return hd.getTransactions.apply(this);
  }

  /**
   * Broadcast txhex. Can throw an exception if failed
   *
   * @param {String} txhex
   * @returns {Promise<boolean>}
   */
  async broadcastTx(txhex: string): Promise<boolean> {
    const broadcast = await MalinElectrum.broadcastV2(txhex);
    console.log({ broadcast });
    if (broadcast.indexOf('successfully') !== -1) return true;
    return broadcast.length === 64; // this means return string is txid (precise length), so it was broadcasted ok
  }

  coinselect(
    utxos: CreateTransactionUtxo[],
    targets: CreateTransactionTarget[],
    feeRate: number,
  ): {
    inputs: CoinSelectReturnInput[];
    outputs: CoinSelectOutput[];
    fee: number;
  } {
    let algo = coinSelect;
    // if targets has output without a value, we want send MAX to it
    if (targets.some((i) => !('value' in i))) {
      algo = coinSelectSplit;
    }

    const _utxos = JSON.parse(JSON.stringify(utxos)) as CreateTransactionUtxo[];
    const _targets = JSON.parse(
      JSON.stringify(targets)
    ) as CreateTransactionTarget[];

    // compensating for coinselect inability to deal with segwit inputs, and overriding script length for proper vbytes calculation
    for (const u of _utxos) {
      if (u.script?.length) {
        continue;
      }

      // counting the number of vbytes for each script type:
      if (this.segwitType === 'p2wpkh') {
        // 72 (high R low S signature) + 1 + 33 (comp pubkey) + 1 = 107 / 4 = 26.75 rounded up.
        u.script = { length: 27 };
      } else if (this.segwitType === 'p2sh(p2wpkh)') {
        // ((72 (high R low S signature) + 1 + 33 (comp pubkey) + 1) / 4) + 22 (P2WPKH output on scriptSig stack) + 1 = 49.75 rounded up
        u.script = { length: 50 };
      } else if (this.segwitType === 'p2tr') {
        // taproot key path spend is just a 64 or 65 byte signature on the witness stack.
        // So it would be 65 bytes (assuming max size) + the pushbyte for 65 bytes on the stack, which makes 66.
        // 66 / 4 = 16.5 round up to 17
        u.script = { length: 17 };
      }
    }

    for (const t of _targets) {
      if (t.address?.startsWith('bc1')) {
        // in case address is non-typical and takes more bytes than coinselect library anticipates by default
        t.script = {
          length: bitcoin.address.toOutputScript(t.address).length + 3
        }
      }

      if (t.script?.hex) {
        // setting length for coinselect lib manually as it is not aware of our field `hex`
        t.script.length = t.script.hex.length / 2 - 4;
      }
    }

    const { inputs, outputs, fee } = algo(
      _utxos,
      _targets as CoinSelectTarget[],
      feeRate
    );

    // .inputs and .outputs will be undefined if no solution was found
    if (!inputs || !outputs) {
      throw new Error(
        'Not enough balance. Try sending smaller amount or decrease the fee.',
      )
    }

    return { inputs, outputs, fee };
  }

  /**
   *
   * @param utxos {Array.<{vout: Number, value: Number, txid: String, address: String, txhex: String, }>} List of spendable utxos
   * @param targets {Array.<{value: Number, address: String}>} Where coins are going. If theres only 1 target and that target has no value - this will send MAX to that address (respecting fee rate)
   * @param feeRate {Number} satoshi per byte
   * @param changeAddress {String} Excessive coins will go back to that address
   * @param sequence {Number} Used in RBF
   * @param skipSigning {boolean} Whether we should skip signing, use returned `psbt` in that case
   * @param masterFingerprint {number} Decimal number of wallet's master fingerprint
   * @returns {{outputs: Array, tx: Transaction, inputs: Array, fee: Number, psbt: Psbt}}
   */
  createTransaction(
    utxos: CreateTransactionUtxo[],
    targets: CoinSelectTarget[],
    feeRate: number,
    changeAddress: string,
    sequence: number,
    skipSigning = false,
    masterFingerprint: number,
  ): CreateTransactionResult {
    if (targets.length === 0) throw new Error('No destination provided');
    const { inputs, outputs, fee } = this.coinselect(utxos, targets, feeRate);
    sequence = sequence || 0xffffffff; // disable RBF by default
    const psbt = new bitcoin.Psbt();
    let c = 0;
    const values: Record<number, number> = {};
    let keyPair: Signer | null = null;

    if (!skipSigning) {
      // skiping signing related stuff
      keyPair = ECPair.fromWIF(this.secret); // secret is WIF
    }

    inputs.forEach((input) => {
      values[c] = input.value;
      c++

      if (!input.txhex) {
        throw new Error(
          "UTXO is missing txhex of the input, which is required by PSBT for non-segwit input"
        );
      }

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        // non-segwit inputs now require passing the whole previous tx as Buffer
        nonWitnessUtxo: hexToUint8Array(input.txhex),
      })
    });

    const sanitizedOutputs = outputs.map((output) => ({
      ...output,
      // if output has no address - this is change output
      address: output.address ?? changeAddress,
    }));

    sanitizedOutputs.forEach((output) => {
      const outputData = {
        address: output.address,
        value: BigInt(output.value),
      }

      psbt.addOutput(outputData);
    })

    if (!skipSigning && keyPair) {
      // skiping signing related stuff
      for (let cc = 0; cc < c; cc++) {
        psbt.signInput(cc, keyPair);
      }
    }

    let tx;
    if (!skipSigning) {
      tx = psbt.finalizeAllInputs().extractTransaction();
    }
    return { tx, inputs, outputs: sanitizedOutputs, fee, psbt };
  }

  getLatestTransactionTime(): string | 0 {
    if (this.getTransactions().length === 0) {
      return 0;
    }
    let max = 0;
    for (const tx of this.getTransactions()) {
      max = Math.max(tx.timestamp ? tx.timestamp * 1000 : 0, max);
    }
    return new Date(max).toString();
  }

  /**
   * Validates any address, including legacy, p2sh and bech32
   *
   * p2tr addresses have extra logic, rejecting all versions >1
   * @see https://github.com/MalinWallet/MalinWallet-wallet/issues/3394
   * @see https://github.com/bitcoinjs/bitcoinjs-lib/issues/1750
   * @see https://github.com/bitcoin/bips/blob/edffe529056f6dfd33d8f716fb871467c3c09263/bip-0350.mediawiki#Addresses_for_segregated_witness_outputs
   *
   * @param address
   * @returns {boolean}
   */
  isAddressValid(address: string): boolean {
    try {
      bitcoin.address.toOutputScript(address); // throws, no?

      if (!address.toLowerCase().startsWith('bc1')) return true;
      const decoded = bitcoin.address.fromBech32(address);
      if (decoded.version === 0) return true;
      if (decoded.version === 1 && decoded.data.length !== 32) return false;
      if (
        decoded.version === 1 &&
        !ecc.isPoint(concatUint8Arrays([new Uint8Array([2]), decoded.data]))
      )
        return false;
      if (decoded.version > 1) return false;
      // ^^^ some day, when versions above 1 will be actually utilized, we would need to unhardcode this
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * Converts script pub key to legacy address if it can. Returns FALSE if it cant.
   *
   * @param scriptPubKey
   * @returns {boolean|string} Either p2pkh address or false
   */
  static scriptPubKeyToAddress(scriptPubKey: string): string | false {
    try {
      const scriptPubKey2 = hexToUint8Array(scriptPubKey);
      return (
        bitcoin.payments.p2pkh({
          output: scriptPubKey2,
          network: bitcoin.networks.bitcoin,
        }).address ?? false
      );
    } catch (_) {
      return false;
    }
  }

  weOwnAddress(address: string): boolean {
    if (!address) return false;
    let cleanAddress = address;

    if (this.segwitType === 'p2wpkh') {
      cleanAddress = address.toLowerCase();
    }

    return this.getAddress() === cleanAddress || this._address === cleanAddress;
  }

  weOwnTransaction(txid: string): boolean {
    for (const tx of this.getTransactions()) {
      if (tx && tx.txid && tx.txid === txid) return true;
    }

    return false;
  }

  allowSignVerifyMessage(): boolean {
    return true;
  }

  /**
   * Check if address is a Change address. Needed for Coin control.
   * Useless for Legacy wallets, so it is always false
   *
   * @param address
   * @returns {Boolean} Either address is a change or not
   */
  addressIsChange(address: string): boolean {
    return false;
  }

  /**
   * Finds WIF corresponding to address and returns it
   *
   * @param address {string} Address that belongs to this wallet
   * @returns {string|false} WIF or false
   */
  _getWIFbyAddress(address: string): string | false {
    return this.getAddress() === address ? this.secret : false;
  }

  /**
   * Signes text message using address private key and returs signature
   *
   * @param message {string}
   * @param address {string}
   * @returns {string} base64 encoded signature
   */
  signMessage(message: string, address: string, useSegwit = true): string {
    const wif = this._getWIFbyAddress(address);
    if (!wif) throw new Error('Invalid address');
    const keyPair = ECPair.fromWIF(wif);
    const privateKey = keyPair.privateKey;
    if (!privateKey) throw new Error('Invalid private key');
    let segwitType: 'p2wpkh' | 'p2sh(p2wpkh)';
    switch (this.segwitType) {
      case 'p2sh(p2wpkh)':
        segwitType = 'p2sh(p2wpkh)';
        break;
      default:
        segwitType = 'p2wpkh';
        break;
    }
    const options = this.segwitType && useSegwit ? { segwitType } : undefined;
    const signature = bitcoinMessage.sign(
      message,
      Buffer.from(privateKey),
      keyPair.compressed,
      options
    );
    return signature.toString('base64');
  }

  /**
   * Verifies text message signature by address
   *
   * @param message {string}
   * @param address {string}
   * @param signature {string}
   * @returns {boolean} base64 encoded signature
   */
  verifyMessage(message: string, address: string, signature: string): boolean {
    // undefined, true so it can verify Electrum signatures without errors
    try {
      return bitcoinMessage.verify(
        message,
        address,
        signature,
        undefined,
        true
      );
    } catch (e: any) {
      if (
        e.message ===
        'checkSegwitAlways can only be used with a compressed pubkey signature flagbyte'
      ) {
        // If message created with uncompressed private key, it will throw this error
        // in this case we should re-try with checkSegwitAlways flag off
        // node_modules/bitcoinjs-message/index.js:187
        return bitcoinMessage.verify(message, address, signature);
      }
      throw e;
    }
  }

  /**
   * Probes address for transactions, if there are any returns TRUE
   *
   * @returns {Promise<boolean>}
   */
  async wasEverUsed(): Promise<boolean> {
    const address = this.getAddress();
    if (!address) return Promise.resolve(false);
    const txs = await MalinElectrum.getTransactionsByAddress(address);
    return txs.length > 0;
  }
}


================================================
FILE: ./class/wallets/lightning-custodian-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import bolt11 from "bolt11";
import { BitcoinUnit, Chain } from "../../models/bitcoinUnits";
import { fetch } from "../../util/fetch";
import { LegacyWallet } from "./legacy-wallet";
import { DecodedInvoice, LightningTransaction, Transaction } from "./types";

const _staticDecodedInvoiceCache: Record<string, DecodedInvoice> = {}

export class LightningCustodianWallet extends LegacyWallet {
  static readonly type = "lightningCustodianWallet";
  static readonly typeReadable = "Lightning";
  static readonly subtitleReadable = "LNDhub";
  // @ts-ignore: override
  public readonly type = LightningCustodianWallet.type
  // @ts-ignore: override
  public readonly typeReadable = LightningCustodianWallet.typeReadable

  baseURI?: string
  refresh_token: string = "";
  access_token: string = "";
  _refresh_token_created_ts: number = 0
  _access_token_created_ts: number = 0
  refill_addressess: string[] = []
  pending_transactions_raw: any[] = []
  transactions_raw: any[] = []
  user_invoices_raw: any[] = []
  preferredBalanceUnit = BitcoinUnit.SATS
  chain = Chain.OFFCHAIN
  last_paid_invoice_result?: any

  /**
   * requires calling init() after setting
   *
   * @param URI
   */
  setBaseURI (URI: string | undefined) {
    this.baseURI = URI?.endsWith("/") ? URI.slice(0, -1) : URI
  }

  getBaseURI () {
    return this.baseURI
  }

  allowSend () {
    return true
  }

  getAddress (): string | false {
    if (this.refill_addressess.length > 0) {
      return this.refill_addressess[0]
    } else {
      return false
    }
  }

  getSecret () {
    return this.secret + "@" + this.baseURI
  }

  timeToRefreshBalance () {
    return (+new Date() - this._lastBalanceFetch) / 1000 > 300 // 5 min
  }

  timeToRefreshTransaction () {
    return (+new Date() - this._lastTxFetch) / 1000 > 300 // 5 min
  }

  async init () {
    // un-cache refill onchain addresses on cold start. should help for cases when certain lndhub
    // is turned off permanently, so users cant pull refill address from cache and send money to a black hole
    this.refill_addressess = []
  }

  accessTokenExpired () {
    return (+new Date() - this._access_token_created_ts) / 1000 >= 3600 * 2 // 2h
  }

  refreshTokenExpired () {
    return (
      (+new Date() - this._refresh_token_created_ts) / 1000 >= 3600 * 24 * 7
    ); // 7d
  }

  generate (): Promise<void> {
    // nop
    return Promise.resolve()
  }

  async createAccount (isTest: boolean = false) {
    const response = await fetch(this.baseURI + "/create", {
      method: "POST",
      body: JSON.stringify({
        partnerid: "malinwallet",
        accounttype: (isTest && "test") || "common",
      }),
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
      }
    });
    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " +
          (json.message ? json.message : json.error) +
          " (code " +
          json.code +
          ")",
      );
    }

    if (!json.login || !json.password) {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    this.secret = "lndhub://" + json.login + ":" + json.password
  }

  async payInvoice (invoice: string, freeAmount: number = 0) {
    const response = await fetch(this.baseURI + "/payinvoice", {
      method: "POST",
      body: JSON.stringify({ invoice, amount: freeAmount }),
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
        Authorization: "Bearer" + " " + this.access_token
      }
    })

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    this.last_paid_invoice_result = json
  }

  /**
   * Returns list of LND invoices created by user
   *
   * @return {Promise.<Array>}
   */
  async getUserInvoices (limit: number | false = false) {
    let limitString = "";
    if (limit) {
      limitString = '?limit=' + parseInt(limit as unknown as string, 10)
    }
    const response = await fetch(
      this.baseURI + "/getuserinvoices" + limitString,
      {
        method: "GET",
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json",
          Authorization: "Bearer" + " " + this.access_token
        },
      },
    )
    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (limit) {
      // need to merge existing invoices with the ones that arrived
      // but the ones received later should overwrite older ones

      for (const oldInvoice of this.user_invoices_raw) {
        // iterate all OLD invoices
        let found = false
        for (const newInvoice of json) {
          // iterate all NEW invoices
          if (newInvoice.payment_request === oldInvoice.payment_request) {
            found = true
          }
        }

        if (!found) {
          // if old invoice is not found in NEW array, we simply add it:
          json.push(oldInvoice)
        }
      }
    }

    this.user_invoices_raw = json.sort(function (
      a: { timestamp: number },
      b: { timestamp: number },
    ) {
      return a.timestamp - b.timestamp
    });

    return this.user_invoices_raw
  }

  /**
   * Basically the same as this.getUserInvoices() but saves invoices list
   * to internal variable
   *
   * @returns {Promise<void>}
   */
  async fetchUserInvoices () {
    await this.getUserInvoices()
  }

  isInvoiceGeneratedByWallet (paymentRequest: string) {
    return this.user_invoices_raw.some(
      (invoice) => invoice.payment_request === paymentRequest,
    )
  }

  weOwnAddress (address: string) {
    return this.refill_addressess.some(
      (refillAddress) => address === refillAddress,
    )
  }

  async addInvoice (amt: number, memo: string) {
    const response = await fetch(this.baseURI + "/addinvoice", {
      method: "POST",
      body: JSON.stringify({ amt: amt + "", memo }),
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
        Authorization: "Bearer" + " " + this.access_token
      }
    })
    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (!json.r_hash || !json.pay_req) {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    return json.pay_req
  }

  /**
   * Uses login & pass stored in `this.secret` to authorize
   * and set internal `access_token` & `refresh_token`
   *
   * @return {Promise.<void>}
   */
  async authorize () {
    let login, password
    if (this.secret.indexOf("blitzhub://") !== -1) {
      login = this.secret.replace("blitzhub://", "").split(":")[0]
      password = this.secret.replace("blitzhub://", "").split(":")[1]
    } else {
      login = this.secret.replace("lndhub://", "").split(":")[0]
      password = this.secret.replace("lndhub://", "").split(":")[1]
    }
    const response = await fetch(this.baseURI + "/auth?type=auth", {
      method: "POST",
      body: JSON.stringify({ login, password }),
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
      }
    });

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (!json.access_token || !json.refresh_token) {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    this.refresh_token = json.refresh_token
    this.access_token = json.access_token
    this._refresh_token_created_ts = +new Date()
    this._access_token_created_ts = +new Date()
  }

  async checkLogin () {
    if (this.accessTokenExpired() && this.refreshTokenExpired()) {
      // all tokens expired, only option is to login with login and password
      return this.authorize()
    }

    if (this.accessTokenExpired()) {
      // only access token expired, so only refreshing it
      let refreshedOk = true
      try {
        await this.refreshAcessToken()
      } catch (Err) {
        refreshedOk = false
      }

      if (!refreshedOk) {
        // something went wrong, lets try to login regularly
        return this.authorize()
      }
    }
  }

  async refreshAcessToken () {
    const response = await fetch(this.baseURI + "/auth?type=refresh_token", {
      method: "POST",
      body: JSON.stringify({ refresh_token: this.refresh_token }),
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
      }
    });

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (!json.access_token || !json.refresh_token) {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    this.refresh_token = json.refresh_token
    this.access_token = json.access_token
    this._refresh_token_created_ts = +new Date()
    this._access_token_created_ts = +new Date()
  }

  async fetchBtcAddress () {
    const response = await fetch(this.baseURI + "/getbtc", {
      method: "GET",
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
        Authorization: "Bearer" + " " + this.access_token
      }
    })

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    this.refill_addressess = []

    for (const arr of json) {
      this.refill_addressess.push(arr.address)
    }
  }

  async getAddressAsync () {
    await this.fetchBtcAddress()
    return this.getAddress()
  }

  async allowOnchainAddress () {
    if (this.getAddress() !== undefined && this.getAddress() !== null) {
      return true
    } else {
      await this.fetchBtcAddress()
      return this.getAddress() !== undefined && this.getAddress() !== null
    }
  }

  getTransactions (): (Transaction & LightningTransaction)[] {
    let txs: any = []
    txs = txs.concat(
      this.pending_transactions_raw.slice(),
      this.transactions_raw.slice().reverse(),
      this.user_invoices_raw.slice(),
    ) // slice so array is cloned

    for (const tx of txs) {
      tx.walletID = this.getID()
      if (tx.amount) {
        // pending tx
        tx.amt = tx.amount * -100000000
        tx.fee = 0
        tx.memo = "On-chain transaction";
      }

      if (typeof tx.amt !== "undefined" && typeof tx.fee !== "undefined") {
        // lnd tx outgoing
        tx.value = (tx.amt * 1 + tx.fee * 1) * -1
      }

      if (tx.type === "paid_invoice") {
        tx.memo = tx.memo || "Lightning payment";
        if (tx.value > 0) tx.value = tx.value * -1 // value already includes fee in it (see lndhub)
        // outer code expects spending transactions to of negative value
      }

      if (tx.type === "bitcoind_tx") {
        tx.memo = "On-chain transaction";
      }

      if (tx.type === "user_invoice") {
        // incoming ln tx
        tx.value = parseInt(tx.amt, 10)
        tx.fee = 0
        tx.memo = tx.description || "Lightning invoice";
      }

      tx.timestamp = tx.timestamp || tx.time
    }
    return txs.sort(function (
      a: { timestamp: number },
      b: { timestamp: number },
    ) {
      return b.timestamp - a.timestamp
    });
  }

  async fetchPendingTransactions () {
    const response = await fetch(this.baseURI + "/getpending", {
      method: "GET",
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
        Authorization: "Bearer" + " " + this.access_token
      }
    })

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    this.pending_transactions_raw = json
  }

  async fetchTransactions () {
    // TODO: iterate over all available pages
    const limit = 10
    let queryRes = "";
    const offset = 0
    queryRes += "?limit=" + limit
    queryRes += "&offset=" + offset

    const response = await fetch(this.baseURI + "/gettxs" + queryRes, {
      method: "GET",
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
        Authorization: "Bearer" + " " + this.access_token
      }
    })

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (!Array.isArray(json)) {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    this._lastTxFetch = +new Date()
    this.transactions_raw = json
  }

  getBalance () {
    return this.balance
  }

  async fetchBalance (noRetry?: boolean): Promise<void> {
    await this.checkLogin()

    const response = await fetch(this.baseURI + "/balance", {
      method: "GET",
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
        Authorization: "Bearer" + " " + this.access_token
      }
    })

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      if (json.code * 1 === 1 && !noRetry) {
        await this.authorize()
        return this.fetchBalance(true)
      }
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (!json.BTC || typeof json.BTC.AvailableBalance === "undefined") {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    this.balance = json.BTC.AvailableBalance
    this._lastBalanceFetch = +new Date()
  }

  /**
   * Example return:
   * { destination: '03864ef025fde8fb587d989186ce6a4a186895ee44a926bfc370e2c366597a3f8f',
   *   payment_hash: 'faf996300a468b668c58ca0702a12096475a0dd2c3dde8e812f954463966bcf4',
   *   num_satoshis: '100',
   *   timestamp: '1535116657',
   *   expiry: '3600',
   *   description: 'hundredSatoshis blitzhub',
   *   description_hash: '',
   *   fallback_addr: '',
   *   cltv_expiry: '10',
   *   route_hints: [] }
   *
   * @param invoice BOLT invoice string
   * @return {DecodedInvoice}
   */
  decodeInvoice (invoice: string): DecodedInvoice {
    if (_staticDecodedInvoiceCache[invoice]) {
      return _staticDecodedInvoiceCache[invoice]
    } // cache hit

    const { payeeNodeKey, tags, satoshis, millisatoshis, timestamp } =
      bolt11.decode(invoice)

    const decoded: DecodedInvoice = {
      destination: payeeNodeKey ?? "",
      num_satoshis: satoshis ? +satoshis : 0,
      num_millisatoshis: millisatoshis ? +millisatoshis : 0,
      timestamp: timestamp ?? 0,
      fallback_addr: "",
      route_hints: [],
      payment_hash: "",
      expiry: 3600, // default
      description: "",
      description_hash: "",
      cltv_expiry: "",
    }

    for (let i = 0; i < tags.length; i++) {
      const { tagName, data } = tags[i]
      switch (tagName) {
        case "payment_hash":
          decoded.payment_hash = String(data)
          break
        case "purpose_commit_hash":
          decoded.description_hash = String(data)
          break
        case "min_final_cltv_expiry":
          decoded.cltv_expiry = data.toString()
          break
        case "expire_time":
          decoded.expiry = +data
          break
        case "description":
          decoded.description = String(data)
          break
      }
    }

    if (!decoded.expiry) decoded.expiry = 3600 // default

    if (decoded.num_satoshis === 0 && decoded.num_millisatoshis > 0) {
      decoded.num_satoshis = Math.floor(decoded.num_millisatoshis / 1000)
    }

    _staticDecodedInvoiceCache[invoice] = decoded

    return decoded
  }

  static async isValidNodeAddress (address: string): Promise<boolean> {
    const normalizedAddress = new URL(
      "/getinfo",
      address.replace(/([^:]\/)\/+/g, "$1"),
    );

    const response = await fetch(normalizedAddress.toString(), {
      method: "GET",
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
      }
    });

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.code && json.code !== 1) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    return true
  }

  allowReceive () {
    return true
  }

  allowSignVerifyMessage () {
    return false
  }

  /**
   * Example return:
   * { destination: '03864ef025fde8fb587d989186ce6a4a186895ee44a926bfc370e2c366597a3f8f',
   *   payment_hash: 'faf996300a468b668c58ca0702a12096475a0dd2c3dde8e812f954463966bcf4',
   *   num_satoshis: '100',
   *   timestamp: '1535116657',
   *   expiry: '3600',
   *   description: 'hundredSatoshis blitzhub',
   *   description_hash: '',
   *   fallback_addr: '',
   *   cltv_expiry: '10',
   *   route_hints: [] }
   *
   * @param invoice BOLT invoice string
   * @return {Promise.<Object>}
   */
  async decodeInvoiceRemote (invoice: string) {
    await this.checkLogin()

    const response = await fetch(
      this.baseURI + "/decodeinvoice?invoice=" + invoice,
      {
        method: "GET",
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json",
          Authorization: "Bearer" + " " + this.access_token
        },
      },
    )

    const json = await response.json()
    if (!json) {
      throw new Error("API failure: " + response.statusText)
    }

    if (json.error) {
      throw new Error(
        "API error: " + json.message + " (code " + json.code + ")",
      );
    }

    if (!json.payment_hash) {
      throw new Error("API unexpected response: " + JSON.stringify(json))
    }

    return json
  }

  weOwnTransaction (txid: string) {
    for (const tx of this.getTransactions()) {
      if (tx && tx.payment_hash && tx.payment_hash === txid) return true
    }

    return false
  }

  authenticate (lnurl: any) {
    return lnurl.authenticate(this.secret)
  }

  getLatestTransactionTime (): string | 0 {
    const transactions = this.getTransactions()
    if (transactions.length === 0) {
      return 0
    }
    return new Date(
      transactions.reduce(
        (max: number, tx: any) => Math.max(max, tx.timestamp),
        0,
      ) * 1000,
    ).toString()
  }

  isInvoiceExpired (invoice: string, currentTimestamp?: number): boolean {
    currentTimestamp = currentTimestamp || Date.now() / 1000 // current ts in seconds
    const decoded = this.decodeInvoice(invoice)
    return decoded.timestamp + decoded.expiry < currentTimestamp
  }
}

/*

pending tx:

    [ { amount: 0.00078061,
        account: '521172',
        address: '3F9seBGCJZQ4WJJHwGhrxeGXCGbrm5SNpF',
        category: 'receive',
        confirmations: 0,
        blockhash: '',
        blockindex: 0,
        blocktime: 0,
        txid: '28a74277e47c2d772ee8a40464209c90dce084f3b5de38a2f41b14c79e3bfc62',
        walletconflicts: [],
        time: 1535024434,
        timereceived: 1535024434 } ]

tx:

    [ { amount: 0.00078061,
        account: '521172',
        address: '3F9seBGCJZQ4WJJHwGhrxeGXCGbrm5SNpF',
        category: 'receive',
        confirmations: 5,
        blockhash: '0000000000000000000edf18e9ece18e449c6d8eed1f729946b3531c32ee9f57',
        blockindex: 693,
        blocktime: 1535024914,
        txid: '28a74277e47c2d772ee8a40464209c90dce084f3b5de38a2f41b14c79e3bfc62',
        walletconflicts: [],
        time: 1535024434,
        timereceived: 1535024434 } ]

 */


================================================
FILE: ./class/wallets/hd-segwit-bech32-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { AbstractHDElectrumWallet } from './abstract-hd-electrum-wallet';

/**
 * HD Wallet (BIP39).
 * In particular, BIP84 (Bech32 Native Segwit)
 * @see https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
 */
export class HDSegwitBech32Wallet extends AbstractHDElectrumWallet {
  static readonly type = 'HDsegwitBech32';
  static readonly typeReadable = 'HD SegWit (BIP84 Bech32 Native)';
  // @ts-ignore: override
  public readonly type = HDSegwitBech32Wallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDSegwitBech32Wallet.typeReadable;
  public readonly segwitType = 'p2wpkh';
  static readonly derivationPath = "m/84'/0'/0'";

  allowSend() {
    return true;
  }

  allowRBF() {
    return true;
  }

  allowPayJoin() {
    return true;
  }

  allowCosignPsbt() {
    return true;
  }

  isSegwit() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }

  allowMasterFingerprint() {
    return true;
  }

  allowXpub() {
    return true;
  }

  allowBIP47() {
    return true;
  }

  allowSilentPaymentSend(): boolean {
    return true;
  }
}


================================================
FILE: ./class/wallets/hd-taproot-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory, { BIP32Interface } from 'bip32';
import { AbstractHDElectrumWallet } from './abstract-hd-electrum-wallet';
import ecc from '../../malin_modules/noble_ecc';
import * as bitcoin from 'bitcoinjs-lib';
import { Psbt } from 'bitcoinjs-lib';
import { CoinSelectReturnInput } from 'coinselect';

const bip32 = BIP32Factory(ecc);

/**
 * @see https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
 */
export class HDTaprootWallet extends AbstractHDElectrumWallet {
  static readonly type = 'HDtaproot';
  static readonly typeReadable = 'HD Taproot (BIP86)';
  // @ts-ignore: override
  public readonly type = HDTaprootWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDTaprootWallet.typeReadable;
  public readonly segwitType = 'p2tr';
  static readonly derivationPath = "m/86'/0'/0'";

  getXpub() {
    if (this._xpub) {
      return this._xpub; // cache hit
    }
    const seed = this._getSeed();
    const root = bip32.fromSeed(seed);

    const path = this.getDerivationPath();
    if (!path) {
      throw new Error('Internal error: no path');
    }
    const child = root.derivePath(path).neutered();
    const xpub = child.toBase58();
    this._xpub = xpub;

    // returning regular xpub since industry standard is to use regular xpubs for Taproot wallets without any
    // kind of prefix change (like ypub or zpub)
    return xpub;
  }

  _hdNodeToAddress(hdNode: BIP32Interface): string {
    return this._nodeToTaprootAddress(hdNode);
  }

  _nodeToTaprootAddress(hdNode: BIP32Interface): string {
    const xOnlyPubkey = hdNode.publicKey.subarray(1, 33);

    const { address } = bitcoin.payments.p2tr({
      internalPubkey: xOnlyPubkey,
    });

    if (!address) {
      throw new Error('Could not create address in _nodeToTaprootAddress');
    }

    return address;
  }

  _getNodePubkeyByIndex(node: number, index: number) {
    index = index * 1; // cast to int

    if (node === 0 && !this._node0) {
      let xpub = this.getXpub();
      if (xpub.startsWith('zpub')) {
        // bip32.fromBase58() wont work with zpub prefix, need to swap it for the traditional one
        xpub = this._zpubToXpub(xpub);
      }
      const hdNode = bip32.fromBase58(xpub);
      this._node0 = hdNode.derive(node);
    }

    if (node === 1 && !this._node1) {
      let xpub = this.getXpub();
      if (xpub.startsWith('zpub')) {
        // bip32.fromBase58() wont work with zpub prefix, need to swap it for the traditional one
        xpub = this._zpubToXpub(xpub);
      }
      const hdNode = bip32.fromBase58(xpub);
      this._node1 = hdNode.derive(node);
    }

    if (node === 0 && this._node0) {
      return this._node0.derive(index).publicKey.subarray(1, 33);
    }

    if (node === 1 && this._node1) {
      return this._node1.derive(index).publicKey.subarray(1, 33);
    }

    throw new Error('Internal error: this._node0 or this._node1 is undefined');
  }

  _addPsbtInput(psbt: Psbt, input: CoinSelectReturnInput, sequence: number, masterFingerprintBuffer: Buffer) {
    if (!input.address) {
      throw new Error('Internal error: no address on Utxo during _addPsbtInput()');
    }
    const pubkey = this._getPubkeyByAddress(input.address);
    const path = this._getDerivationPathByAddress(input.address);
    if (!pubkey || !path) {
      throw new Error('Internal error: pubkey or path are invalid');
    }

    const p2tr = bitcoin.payments.p2tr({
      internalPubkey: pubkey,
    });
    if (!p2tr.output) throw new Error('Could not build p2tr.output');

    psbt.addInput({
      hash: input.txid,
      index: input.vout,
      sequence,
      witnessUtxo: {
        script: p2tr.output!,
        value: BigInt(input.value),
      },
      tapBip32Derivation: [
        {
          pubkey: new Uint8Array(pubkey),
          masterFingerprint: new Uint8Array(masterFingerprintBuffer),
          path,
          leafHashes: [],
        },
      ],

      // tell PSBT its a key-path Taproot spend
      tapInternalKey: pubkey,
    });

    return psbt;
  }

  allowSend() {
    return true;
  }

  allowCosignPsbt() {
    return true;
  }

  // is it even used anywhere..?
  isSegwit() {
    return true;
  }

  allowSignVerifyMessage() {
    return false;
  }

  allowMasterFingerprint() {
    return true;
  }

  allowXpub() {
    return true;
  }

  allowBIP47() {
    return true;
  }

  allowSilentPaymentSend(): boolean {
    return true;
  }
}


================================================
FILE: ./class/wallets/hd-legacy-electrum-seed-p2pkh-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
import * as mn from 'electrum-mnemonic';

import ecc from '../../malin_modules/noble_ecc';
import { HDLegacyP2PKHWallet } from './hd-legacy-p2pkh-wallet';

const bip32 = BIP32Factory(ecc);
const PREFIX = mn.PREFIXES.standard;

type SeedOpts = {
  prefix?: string;
  passphrase?: string;
};

/**
 * ElectrumSeed means that instead of BIP39 seed format it works with the format invented by Electrum wallet. Otherwise
 * its a regular HD wallet that has all the properties of parent class.
 *
 * @see https://electrum.readthedocs.io/en/latest/seedphrase.html
 */
export class HDLegacyElectrumSeedP2PKHWallet extends HDLegacyP2PKHWallet {
  static readonly type = 'HDlegacyElectrumSeedP2PKH';
  static readonly typeReadable = 'HD Legacy Electrum (BIP32 P2PKH)';
  // @ts-ignore: override
  public readonly type = HDLegacyElectrumSeedP2PKHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDLegacyElectrumSeedP2PKHWallet.typeReadable;
  static readonly derivationPath = 'm';

  validateMnemonic() {
    return mn.validateMnemonic(this.secret, PREFIX);
  }

  allowBIP47() {
    return false;
  }

  async generate() {
    throw new Error('Not implemented');
  }

  getXpub() {
    if (this._xpub) {
      return this._xpub; // cache hit
    }
    const args: SeedOpts = { prefix: PREFIX };
    if (this.passphrase) args.passphrase = this.passphrase;
    const root = bip32.fromSeed(mn.mnemonicToSeedSync(this.secret, args));
    this._xpub = root.neutered().toBase58();
    return this._xpub;
  }

  _getInternalAddressByIndex(index: number) {
    index = index * 1; // cast to int
    if (this.internal_addresses_cache[index]) return this.internal_addresses_cache[index]; // cache hit

    const node = bip32.fromBase58(this.getXpub());
    const address = bitcoin.payments.p2pkh({
      pubkey: node.derive(1).derive(index).publicKey,
    }).address;
    if (!address) {
      throw new Error('Internal error: no address in _getInternalAddressByIndex');
    }

    return (this.internal_addresses_cache[index] = address);
  }

  _getExternalAddressByIndex(index: number) {
    index = index * 1; // cast to int
    if (this.external_addresses_cache[index]) return this.external_addresses_cache[index]; // cache hit

    const node = bip32.fromBase58(this.getXpub());
    const address = bitcoin.payments.p2pkh({
      pubkey: node.derive(0).derive(index).publicKey,
    }).address;
    if (!address) {
      throw new Error('Internal error: no address in _getExternalAddressByIndex');
    }

    return (this.external_addresses_cache[index] = address);
  }

  _getWIFByIndex(internal: boolean, index: number): string | false {
    if (!this.secret) return false;
    const args: SeedOpts = { prefix: PREFIX };
    if (this.passphrase) args.passphrase = this.passphrase;
    const root = bip32.fromSeed(mn.mnemonicToSeedSync(this.secret, args));
    const path = `m/${internal ? 1 : 0}/${index}`;
    const child = root.derivePath(path);

    return child.toWIF();
  }

  _getNodePubkeyByIndex(node: number, index: number) {
    index = index * 1; // cast to int

    if (node === 0 && !this._node0) {
      const xpub = this.getXpub();
      const hdNode = bip32.fromBase58(xpub);
      this._node0 = hdNode.derive(node);
    }

    if (node === 1 && !this._node1) {
      const xpub = this.getXpub();
      const hdNode = bip32.fromBase58(xpub);
      this._node1 = hdNode.derive(node);
    }

    if (node === 0 && this._node0) {
      return this._node0.derive(index).publicKey;
    }

    if (node === 1 && this._node1) {
      return this._node1.derive(index).publicKey;
    }

    throw new Error('Internal error: this._node0 or this._node1 is undefined');
  }
}


================================================
FILE: ./class/wallets/lightning-ark-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BigNumber from 'bignumber.js';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { sha256 } from '@noble/hashes/sha256';
import { ArkadeLightning, BoltzSwapProvider, decodeInvoice, PendingReverseSwap, PendingSubmarineSwap } from '@arkade-os/boltz-swap';
import { SingleKey, VtxoManager, Ramps, Wallet, ExtendedCoin, ArkTransaction } from '@arkade-os/sdk';
import { ExpoArkProvider, ExpoIndexerProvider } from '@arkade-os/sdk/dist/cjs/adapters/expo';
import { fetch } from '../../util/fetch';

import BIP32Factory from 'bip32';

import { LightningCustodianWallet } from './lightning-custodian-wallet.ts';
import { randomBytes } from '../rng.ts';
import * as bip39 from 'bip39';
import { LightningTransaction, Transaction } from './types.ts';
import { hexToUint8Array, uint8ArrayToHex } from '../../malin_modules/uint8array-extras/index';
import assert from 'assert';
import ecc from '../../malin_modules/noble_ecc.ts';
import { Measure } from '../measure.ts';

const bip32 = BIP32Factory(ecc);

const staticWalletCache: Record<string, Wallet> = {};
const initLock: Record<string, boolean> = {};
const boardingLock: Record<string, boolean> = {};

export class LightningArkWallet extends LightningCustodianWallet {
  static readonly type = 'lightningArkWallet';
  static readonly typeReadable = 'Lightning Ark';
  static readonly subtitleReadable = 'Ark';
  // @ts-ignore: override
  public readonly type = LightningArkWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = LightningArkWallet.typeReadable;

  private _wallet: Wallet | undefined;
  private _arkadeLightning: ArkadeLightning | undefined = undefined;
  private _arkServerUrl: string = 'https://arkade.computer';
  private _arkServerPublicKey: string = '022b74c2011af089c849383ee527c72325de52df6a788428b68d49e9174053aaba';
  private _boltzApiUrl: string = 'https://api.ark.boltz.exchange';

  private _swapHistory: (PendingReverseSwap | PendingSubmarineSwap)[] = [];
  private _transactionsHistory: ArkTransaction[] = [];
  private _claimedSwaps: Record<string, boolean> = {};
  private _privateKeyCache = '';
  private _boardingUtxos: ExtendedCoin[] = [];

  // fees from Boltz:
  private _limitMin: number = 0;
  private _limitMax: number = 0;
  private _feePercentage: number = 0;

  hashIt = (s: string): string => {
    return uint8ArrayToHex(sha256(s));
  };

  prepareForSerialization() {
    this._wallet = undefined;
    this._arkadeLightning = undefined;
  }

  _getIdentity() {
    assert(this.secret, 'No secret provided');

    if (!this._privateKeyCache) {
      const mnemonic = this.secret.replace('arkade://', '').trim();
      const seed = bip39.mnemonicToSeedSync(mnemonic);

      const index = 0;
      const internal = 0;
      const accountNumber = 0;
      const root = bip32.fromSeed(seed);
      const path = `m/86'/0'/${accountNumber}'/${internal}/${index}`;
      const child = root.derivePath(path);
      assert(child.privateKey, 'Internal error: no private key for child');

      this._privateKeyCache = uint8ArrayToHex(child.privateKey);
    }

    return SingleKey.fromPrivateKey(hexToUint8Array(this._privateKeyCache));
  }

  getNamespace(): string {
    assert(this.secret, 'No secret provided');
    return this.hashIt(this.secret);
  }

  async init() {
    const namespace = this.getNamespace();

    if (initLock[namespace]) {
      let c = 0;
      while (!this._wallet || !this._arkadeLightning) {
        await new Promise(resolve => setTimeout(resolve, 500)); // sleep
        if (c++ > 30) {
          throw new Error('Ark wallet initialization timed out');
        }
      }
      initLock[namespace] = false;
      return; // wallet is initialized, so we can return
    }

    initLock[namespace] = true;

    try {
      const identity = this._getIdentity();

      class ArkCustomStorage {
        async getItem(key: string): Promise<string | null> {
          return await AsyncStorage.getItem(`${namespace}_${key}`);
        }

        async setItem(key: string, value: string): Promise<void> {
          return await AsyncStorage.setItem(`${namespace}_${key}`, value);
        }

        async removeItem(key: string): Promise<void> {
          await AsyncStorage.removeItem(`${namespace}_${key}`);
        }

        async clear(): Promise<void> {
          // nop
        }
      }

      const storage = new ArkCustomStorage();

      const mm = new Measure('Wallet.create()');
      if (!staticWalletCache[namespace]) {
        const wallet = await Wallet.create({
          storage,
          identity,
          arkProvider: new ExpoArkProvider(this._arkServerUrl),
          indexerProvider: new ExpoIndexerProvider(this._arkServerUrl),
          arkServerPublicKey: this._arkServerPublicKey,
        });
        staticWalletCache[namespace] = wallet;
      }

      mm.end();
      this._wallet = staticWalletCache[namespace];

      await this._initLightningSwaps();

      // initialize VTXO manager in set timeout so it doesnt block the wallet initialization
      setTimeout(async () => {
        const manager = new VtxoManager(staticWalletCache[namespace], {
          enabled: true, // Enable expiration monitoring
        });
        try {
          const txid = await manager.renewVtxos();
          console.log('ARK VTXO Renewed:', txid);
        } catch (error: any) {
          console.log('ARK Error renewing VTXOs:', error.message);
        }
      }, 1_000);
    } finally {
      initLock[namespace] = false;
    }
  }

  async _initLightningSwaps() {
    assert(this._wallet, 'Ark wallet must be initialized first');
    assert(this._boltzApiUrl, 'Boltz Api Url is not set');

    // fetching fees boltz takes:
    const feesResponse = await fetch(this._boltzApiUrl + '/v2/swap/submarine');
    const feesResponseJson = await feesResponse.json();
    this._limitMin = feesResponseJson?.ARK?.BTC?.limits?.minimal ?? 333;
    this._limitMax = feesResponseJson?.ARK?.BTC?.limits?.maximal ?? 1000000;
    this._feePercentage = feesResponseJson?.ARK?.BTC?.fees?.percentage ?? 0;
    if (!feesResponseJson?.ARK?.BTC?.fees?.percentage) {
      console.log('warning: unexpected fees response from boltz:', JSON.stringify(feesResponseJson, null, 2));
    }

    // Initialize the Lightning swap provider
    const swapProvider = new BoltzSwapProvider({
      apiUrl: this._boltzApiUrl,
      network: 'bitcoin',
    });

    // Create the ArkadeLightning instance
    this._arkadeLightning = new ArkadeLightning({
      wallet: this._wallet,
      swapProvider,
    });
  }

  async generate(): Promise<void> {
    const buf = await randomBytes(16);
    this.secret = 'arkade://' + bip39.entropyToMnemonic(uint8ArrayToHex(buf));

    await this.init();
  }

  getSecret() {
    return this.secret;
  }

  getTransactions(): (Transaction & LightningTransaction)[] {
    const walletID = this.getID();
    const ret: LightningTransaction[] = [];
    for (const swap of this._swapHistory) {
      let memo = '';
      let value = 0;
      let timestamp = 0;
      let payment_hash = '';
      let bolt11invoice = '';
      let direction = 1;
      let ispaid = false;
      let expiry = 3600;

      try {
        // @ts-ignore properties do exist
        bolt11invoice = swap.request.invoice || swap.response.invoice;
        const invoiceDetails = this.decodeInvoice(bolt11invoice);
        value = invoiceDetails.num_satoshis;
        memo = invoiceDetails.description;
        payment_hash = invoiceDetails.payment_hash;
        expiry = invoiceDetails.expiry;
      } catch {}

      timestamp = swap.createdAt;

      switch (swap.status) {
        case 'transaction.claimed':
          direction = -1;
          ispaid = true;
          break;
        case 'invoice.settled':
          direction = 1;
          ispaid = true;
          break;
        case 'swap.created':
          // nop, this is invoice that we created
          break;
        case 'invoice.set':
          // dont return it, its an invoice we trief to pay but could not
          continue;
      }

      if (this._claimedSwaps[swap.id]) {
        ispaid = true;
      }
      // @ts-ignore properties do exist
      value = swap.response.expectedAmount || value || swap.request.invoiceAmount || swap.response.onchainAmount || 0;
      value = value * direction;

      ret.push({
        type: direction < 0 ? 'paid_invoice' : 'user_invoice',
        walletID,
        description: memo,
        memo,
        value,
        timestamp,
        ispaid,
        payment_hash,
        payment_request: bolt11invoice,
        amt: value,
        payment_preimage: swap.preimage,
        expire_time: expiry,
      });
    }

    for (const boardingTx of this._boardingUtxos) {
      ret.push({
        type: 'bitcoind_tx',
        walletID,
        description: 'Pending refill',
        memo: 'Pending refill',
        value: boardingTx.value,
        timestamp: boardingTx.status.block_time ?? Math.floor(Date.now() / 1000),
      });
    }

    for (const histTx of this._transactionsHistory) {
      if (histTx.key.boardingTxid && histTx.type === 'RECEIVED' && histTx.settled) {
        // for now putting on the list only onchain top-up transactions:
        ret.push({
          type: 'bitcoind_tx',
          walletID,
          description: 'Refill',
          memo: 'Refill',
          value: histTx.amount,
          timestamp: Math.floor(histTx.createdAt / 1000),
        });
      }
    }

    // @ts-ignore meh
    return ret;
  }

  async fetchUserInvoices() {
    // nop
  }

  async fetchTransactions() {
    if (!this._wallet) await this.init();
    if (!this._wallet) throw new Error('Ark wallet not initialized');
    if (!this._arkadeLightning) throw new Error('Ark Lightning not initialized');

    this._swapHistory = await this._arkadeLightning.getSwapHistory();
    this._transactionsHistory = await this._wallet.getTransactionHistory();
    this._lastTxFetch = +new Date();
  }

  async _attemptToClaimPendingVHTLCs() {
    assert(this._wallet, 'Ark wallet not initialized');
    assert(this._arkadeLightning, 'Ark Lightning not initialized');
    const arkadeLightning = this._arkadeLightning;

    const pendingReverseSwaps = await this._arkadeLightning.getPendingReverseSwaps();
    if ((pendingReverseSwaps ?? []).length > 0) console.log('got', pendingReverseSwaps?.length ?? [], 'pending swaps');

    await Promise.all(
      (pendingReverseSwaps ?? []).map(async swap => {
        if (this._claimedSwaps[swap.id]) return;

        console.log(`claiming ${swap.id}...`);
        try {
          await arkadeLightning.claimVHTLC(swap);
          console.log('claimed!');
          this._claimedSwaps[swap.id] = true;
        } catch (error: any) {
          console.log(`could not claim ${swap.id}:`, error.message);
        }
      }),
    );
  }

  async fetchBalance(noRetry?: boolean): Promise<void> {
    if (!this._wallet) await this.init();
    if (!this._wallet) throw new Error('Ark wallet not initialized');

    if (this._arkadeLightning) {
      await this._attemptToClaimPendingVHTLCs();
    }

    await this._attemptBoardUtxos();

    const balance = await this._wallet.getBalance();
    this._lastBalanceFetch = +new Date();
    this.balance = balance.available;
  }

  getBalance() {
    return this.balance;
  }

  async payInvoice(invoice: string, freeAmount: number = 0) {
    if (!this._wallet) await this.init();
    assert(this._arkadeLightning, 'Ark Lightning not initialized');
    const invoiceDetails = decodeInvoice(invoice);

    console.log('Invoice amount:', invoiceDetails.amountSats, 'sats');
    console.log('Description:', invoiceDetails.description);
    console.log('Payment Hash:', invoiceDetails.paymentHash);

    assert(invoiceDetails.amountSats > this._limitMin, `Minimum you can send is ${this._limitMin} sat`);
    assert(invoiceDetails.amountSats < this._limitMax, `Maximum you can is ${this._limitMax} sat`);

    const paymentResult = await this._arkadeLightning.sendLightningPayment({ invoice });

    console.log('Payment successful!');
    console.log('Amount:', paymentResult.amount);
    console.log('Preimage:', paymentResult.preimage);
    console.log('Transaction ID:', paymentResult.txid);
  }

  async getUserInvoices(limit: number | false = false): Promise<LightningTransaction[]> {
    if (this._arkadeLightning) {
      await this._attemptToClaimPendingVHTLCs();
    }
    await this.fetchTransactions();
    const txs = this.getTransactions();
    return txs.filter(tx => tx.value! > 0);
  }

  async addInvoice(amt: number, memo: string) {
    if (!this._wallet) await this.init();
    assert(this._arkadeLightning, 'Ark Lightning not initialized');
    assert(amt > this._limitMin, `Minimum to receive is ${this._limitMin} sat`);
    assert(amt < this._limitMax, `Maximum to receive is ${this._limitMin} sat`);

    // fee percentage is smth like `0.01`, but its not 1%, its one-hundredth of a percent, rounded up
    const serviceFee = Math.ceil(new BigNumber(amt).multipliedBy(this._feePercentage).dividedBy(100).toNumber());

    const result = await this._arkadeLightning.createLightningInvoice({
      amount: amt + serviceFee,
      description: memo,
    });

    console.log('Expiry (seconds):', result.expiry);
    console.log('Lightning Invoice:', result.invoice);
    console.log('Payment Hash:', result.paymentHash);
    console.log('Pending swap', result.pendingSwap);
    console.log('Preimage', result.preimage);

    return result.invoice;
  }

  async getArkAddress(): Promise<string> {
    if (!this._wallet) await this.init();
    if (!this._wallet) throw new Error('Ark not initialized');
    return await this._wallet.getAddress();
  }

  async fetchPendingTransactions() {
    // nop
  }

  async decodeInvoiceRemote(invoice: string) {
    throw new Error('decodeInvoiceRemote not implemented');
  }

  async allowOnchainAddress() {
    return true;
  }

  async fetchBtcAddress() {
    if (!this._wallet) await this.init();
    assert(this._wallet, 'Ark wallet not initialized');

    this.refill_addressess = this.refill_addressess || [];
    const address = await this._wallet.getBoardingAddress();
    if (!this.refill_addressess.includes(address)) {
      this.refill_addressess.push(address);
    }
  }

  async refreshAcessToken() {
    // nop
  }

  async checkLogin() {
    // nop
  }

  async authorize() {
    // nop
  }

  isInvoiceGeneratedByWallet(paymentRequest: string) {
    return this.getTransactions().some(tx => tx.payment_request === paymentRequest && typeof tx.value !== 'undefined' && tx?.value >= 0);
  }

  async createAccount(isTest: boolean = false) {
    // nop
  }

  accessTokenExpired() {
    return false;
  }

  refreshTokenExpired() {
    return false;
  }

  private async _attemptBoardUtxos() {
    // executing in background since it can take a lot of time, but setting the lock so there wont be any races
    // (for example, during another pull-to-refresh)
    const namespace = this.getNamespace();
    if (boardingLock[namespace]) return;

    if (!this._wallet) return;

    boardingLock[namespace] = true;
    this._boardingUtxos = await this._wallet.getBoardingUtxos(); // calling it here so fetchBalance will pick it up and then `getTransactions` will show it in tx list
    (async () => {
      if (this._boardingUtxos.length > 0) {
        if (!this._wallet) return;
        // not instantiating, this is supposed to be called inside `fetchBalance`
        console.log('attempting to board ', this._boardingUtxos.length, 'UTXOs...');
        await new Ramps(this._wallet).onboard(this._boardingUtxos);
        this._boardingUtxos = await this._wallet.getBoardingUtxos(); // refetch UTXOs, if we succeeded boarding previosuly the set should be reduced
      }
    })()
      .catch(e => console.log('ark boarding failed:', e.message))
      .finally(() => {
        boardingLock[namespace] = false;
      });
  }
}


================================================
FILE: ./class/wallets/taproot-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';
import { ECPairFactory } from 'ecpair';

import ecc from '../../malin_modules/noble_ecc';

import { SegwitBech32Wallet } from './segwit-bech32-wallet';
import { CreateTransactionResult, CreateTransactionUtxo } from './types.ts';
import { CoinSelectTarget } from 'coinselect';
import { hexToUint8Array } from '../../malin_modules/uint8array-extras';
const ECPair = ECPairFactory(ecc);

export class TaprootWallet extends SegwitBech32Wallet {
  static readonly type = 'taproot';
  static readonly typeReadable = 'Taproot (P2TR)';
  // @ts-ignore: override
  public readonly type = TaprootWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = TaprootWallet.typeReadable;
  public readonly segwitType = 'p2wpkh';

  /**
   * Converts script pub key to a Taproot address if it can. Returns FALSE if it cant.
   *
   * @param scriptPubKey
   * @returns {boolean|string} Either bech32 address or false
   */
  static scriptPubKeyToAddress(scriptPubKey: string): string | false {
    try {
      const publicKey = hexToUint8Array(scriptPubKey);
      return bitcoin.address.fromOutputScript(publicKey, bitcoin.networks.bitcoin);
    } catch (_) {
      return false;
    }
  }

  allowSend() {
    return true;
  }

  allowSendMax() {
    return true;
  }

  isSegwit() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }

  getAddress(): string | false {
    if (this._address) return this._address;
    let address;
    try {
      const keyPair = ECPair.fromWIF(this.secret);
      if (!keyPair.compressed) {
        console.warn('only compressed public keys are good for segwit');
        return false;
      }
      const xOnlyPubkey = keyPair.publicKey.subarray(1, 33);
      address = bitcoin.payments.p2tr({
        internalPubkey: xOnlyPubkey,
      }).address;
    } catch (err: any) {
      console.log(err.message);
      return false;
    }
    this._address = address ?? false;

    return this._address;
  }

  createTransaction(
    utxos: CreateTransactionUtxo[],
    targets: CoinSelectTarget[],
    feeRate: number,
    changeAddress: string,
    sequence: number,
    skipSigning = false,
    masterFingerprint: number,
  ): CreateTransactionResult {
    if (targets.length === 0) throw new Error('No destination provided');
    const { inputs, outputs, fee } = this.coinselect(utxos, targets, feeRate);
    sequence = sequence || 0xffffffff; // default if not passed

    // Derive keyPair & x-only pubkey
    const keyPair = ECPair.fromWIF(this.secret);
    const pubkey = keyPair.publicKey; // compressed: 0x02/03 || X
    const xOnlyPub = pubkey.subarray(1, 33); // strip prefix

    // Precompute the P2TR payment (to rebuild scriptPubKey)
    const p2tr = bitcoin.payments.p2tr({
      internalPubkey: xOnlyPub,
    });
    if (!p2tr.output) throw new Error('Could not build p2tr.output');

    const psbt = new bitcoin.Psbt();

    // Add Taproot inputs
    inputs.forEach((input, idx) => {
      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        witnessUtxo: {
          script: p2tr.output!,
          value: BigInt(input.value),
        },
        // tell PSBT its a key-path Taproot spend
        tapInternalKey: xOnlyPub,
      });
    });

    // Add outputs
    outputs.forEach(output => {
      // if output has no address - this is change output
      if (!output.address) output.address = changeAddress;
      psbt.addOutput({
        address: output.address!,
        value: BigInt(output.value),
      });
    });

    let tx;
    if (!skipSigning) {
      // Sign each input as a Taproot key-path spend
      inputs.forEach((_, idx) => {
        psbt.signTaprootInput(idx, keyPair.tweak(bitcoin.crypto.taggedHash('TapTweak', xOnlyPub)));
      });

      // Finalize all inputs (will auto-detect Taproot)
      psbt.finalizeAllInputs();
      tx = psbt.extractTransaction();
    }

    return { tx, inputs, outputs, fee, psbt };
  }
}


================================================
FILE: ./class/wallets/ethereum-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { AbstractWallet } from './abstract-wallet';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { ethers } from 'ethers';
// @ts-ignore
import { ETHEREUM_RPC_URL } from '@env';
import { EthereumTransaction } from './types';

export class EthereumWallet extends AbstractWallet {
  static readonly type = 'ethereum';
  static readonly typeReadable = 'Ethereum';

  // @ts-ignore: override
  public readonly type = EthereumWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = EthereumWallet.typeReadable;
  private _transactions: EthereumTransaction[] = [];

  constructor() {
    super();
    this.chain = Chain.OFFCHAIN;
    this.preferredBalanceUnit = BitcoinUnit.ETH;
  }

  static fromJson(obj: string): EthereumWallet {
    const obj2 = JSON.parse(obj);
    const temp = new this();
    for (const key2 of Object.keys(obj2)) {
      // @ts-ignore
      temp[key2] = obj2[key2];
    }
    return temp;
  }

  getBalance(): number {
    return this.balance;
  }

  getAddress(): string {
    return this._address as string;
  }

  getAddressAsync(): Promise<string> {
    return Promise.resolve(this.getAddress());
  }

  getLatestTransactionTime(): string | 0 {
    if (this._transactions.length === 0) {
      return 0;
    }
    return this._transactions[0].timestamp;
  }

  async generate(): Promise<void> {
    const wallet = ethers.Wallet.createRandom();
    this.secret = wallet.privateKey;
    this._address = wallet.address;
    this.label = 'Ethereum Wallet';
  }

  getSecret(): string {
    return this.secret;
  }

  // Stubs to satisfy TypeScript and existing App logic

  async fetchBalance(): Promise<void> {
    try {
      const provider = new ethers.JsonRpcProvider(ETHEREUM_RPC_URL);
      if (this._address) {
        const balance = await provider.getBalance(this._address);
        // Store as ETH unit (float) to avoid Number overflow with Wei (18 decimals)
        // Compromise: AbstractWallet.balance is type number.
        this.balance = Number(ethers.formatEther(balance));
        console.log('ETH Balance:', this.balance);
      }
    } catch (e) {
      console.error('Error fetching ETH balance:', e);
    }
  }

  async fetchTransactions(): Promise<void> {
    if (!this._address) return;

    try {
      const provider = new ethers.EtherscanProvider('mainnet', 'freekey');
      const history = await provider.getHistory(this._address);
      this._transactions = history.map(tx => ({
        hash: tx.hash,
        from: tx.from,
        to: tx.to ?? '',
        value: Number(tx.value),
        gasPrice: Number(tx.gasPrice),
        gas: Number(tx.gasLimit),
        nonce: tx.nonce,
        input: tx.data,
        blockHash: tx.blockHash ?? '',
        blockNumber: tx.blockNumber ?? 0,
        confirmations: tx.confirmations ?? 0,
        timestamp: tx.timestamp ?? 0,
        fee: tx.gasPrice ? Number(tx.gasPrice * tx.gasLimit) : undefined,
      }));
    } catch (e) {
      console.error('Error fetching ETH transactions:', e);
    }
  }

  // @ts-ignore: override
  getTransactions(): EthereumTransaction[] {
    return this._transactions;
  }

  isAddressValid(address: string): boolean {
    return ethers.isAddress(address);
  }

  // Properties accessed by malin-app.ts but not present in AbstractWallet
  _txs_by_external_index: any = {};
  _txs_by_internal_index: any = {};

  timeToRefreshBalance(): boolean {
      return false; // For now
  }

  timeToRefreshTransaction(): boolean {
      return false; // For now
  }

  // CoinControl stubs
  getUtxo() {
      return [];
  }

  async fetchUtxo() {
      // no-op
  }

  addressIsChange(address: string) {
      return false;
  }

  async broadcastTx(txhex: string): Promise<string> {
    const provider = new ethers.JsonRpcProvider(ETHEREUM_RPC_URL);
    try {
      const tx = await provider.broadcastTransaction(txhex);
      return tx.hash;
    } catch (e) {
      console.error('Error broadcasting ETH transaction:', e);
      throw e;
    }
  }

  coinselect(utxos: any, targets: any, feeRate: any) {
      return { inputs: [], outputs: [], fee: 0 };
  }

  _getWIFbyAddress(address: string) {
      return this.secret; // Simplify for now
  }
}


================================================
FILE: ./class/wallets/solana-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { AbstractWallet } from './abstract-wallet';
import { BitcoinUnit, Chain } from '../../models/bitcoinUnits';
import { Keypair, PublicKey, Connection, clusterApiUrl } from '@solana/web3.js';
import bs58 from 'bs58';
import { Buffer } from 'buffer';
import { SolanaTransaction } from './types';
import { SOLANA_RPC_URL } from '@env';

export class SolanaWallet extends AbstractWallet {
  static readonly type = 'solana';
  static readonly typeReadable = 'Solana';

  // @ts-ignore: override
  public readonly type = SolanaWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = SolanaWallet.typeReadable;
  private _transactions: SolanaTransaction[] = [];

  constructor () {
    super();
    this.chain = Chain.OFFCHAIN;
    this.preferredBalanceUnit = BitcoinUnit.SOL;
  }

  static fromJson(obj: string): SolanaWallet {
    const obj2 = JSON.parse(obj);
    const temp = new this();
    for (const key2 of Object.keys(obj2)) {
      // @ts-ignore
      temp[key2] = obj2[key2];
    }
    return temp;
  }

  getBalance(): number {
    return this.balance;
  }

  getAddress(): string {
    return this._address as string;
  }

  getAddressAsync(): Promise<string> {
    return Promise.resolve(this.getAddress());
  }

  getLatestTransactionTime(): string | 0 {
    if (this._transactions.length === 0) {
      return 0;
    }
    return this._transactions[0].blockTime;
  }

  async generate(): Promise<void> {
    const keypair = Keypair.generate();
    this.secret = bs58.encode(keypair.secretKey);
    this._address = keypair.publicKey.toBase58();
    this.label = 'Solana Wallet';
  }

  getSecret(): string {
    return this.secret;
  }

  // Stubs

  async fetchBalance(): Promise<void> {
    try {
      const connection = new Connection(SOLANA_RPC_URL);
      if (this._address) {
        const publicKey = new PublicKey(this._address);
        const balance = await connection.getBalance(publicKey)
        this.balance = balance / 1e9 // Convert Lamports to SOL to match ETH float approach
        console.log('SOL Balance:', this.balance)
      }
    } catch (e) {
      console.error("Error fetching SOL balance:", e);
    }
  }

  async fetchTransactions(): Promise<void> {
    if (!this._address) return;

    try {
      const connection = new Connection(SOLANA_RPC_URL);
      const publicKey = new PublicKey(this._address);
      const signatures = await connection.getSignaturesForAddress(publicKey, { limit: 25 });
      const transactions = await connection.getParsedTransactions(signatures.map(s => s.signature));

      this._transactions = transactions
        .map((tx, i) => {
          if (!tx) return null;
          return {
            signature: signatures[i].signature,
            slot: tx.slot,
            blockTime: tx.blockTime ?? 0,
            memo: tx.transaction.message.instructions.find(
              (ix: any) => ix.programId.toBase58() === 'MemoSq4gqABAXKb96qnH8TysNcVnuizgaCkW19D2Hy'
            )?.data,
            fee: tx.meta?.fee ?? 0,
            preBalances: tx.meta?.preBalances ?? [],
            postBalances: tx.meta?.postBalances ?? [],
          };
        })
        .filter((tx): tx is SolanaTransaction => tx !== null);
    } catch (e) {
      console.error('Error fetching SOL transactions:', e);
    }
  }

  // @ts-ignore: override
  getTransactions(): SolanaTransaction[] {
    return this._transactions;
  }

  isAddressValid(address: string): boolean {
    try {
      new PublicKey(address);
      return true
    } catch (e) {
      return false;
    }
  }

  _txs_by_external_index: any = {};
  _txs_by_internal_index: any = {};

  timeToRefreshBalance (): boolean {
    return false;
  }

  timeToRefreshTransaction(): boolean {
    return false;
  }

  getUtxo() {
    return [];
  }

  async fetchUtxo() {
    // no-op
  }

  addressIsChange(address: string) {
    return false;
  }

  async broadcastTx(txhex: string): Promise<string> {
    const connection = new Connection(SOLANA_RPC_URL);
    try {
      const txBuffer = Buffer.from(txhex, 'hex');
      const signature = await connection.sendRawTransaction(txBuffer);
      return signature;
    } catch (e) {
      console.error('Error broadcasting SOL transaction:', e);
      throw e;
    }
  }

  coinselect(utxos: any, targets: any, feeRate: any) {
    return { inputs: [], outputs: [], fee: 0 };
  }

  _getWIFbyAddress(address: string) {
    return this.secret;
  }
}


================================================
FILE: ./class/wallets/hd-aezeed-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { CipherSeed } from 'aezeed';
import BIP32Factory from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
import b58 from 'bs58check';

import ecc from '../../malin_modules/noble_ecc';
import { concatUint8Arrays, hexToUint8Array, uint8ArrayToHex } from '../../malin_modules/uint8array-extras';
import { AbstractHDElectrumWallet } from './abstract-hd-electrum-wallet';

const bip32 = BIP32Factory(ecc);

/**
 * AEZEED mnemonics support, which is used in LND
 * Support only BIP84 (native segwit) derivations
 *
 * @see https://github.com/lightningnetwork/lnd/tree/master/aezeed
 * @see https://github.com/bitcoinjs/aezeed
 * @see https://github.com/lightningnetwork/lnd/issues/4960
 * @see https://github.com/guggero/chantools/blob/master/doc/chantools_genimportscript.md
 * @see https://github.com/lightningnetwork/lnd/blob/master/keychain/derivation.go
 */
export class HDAezeedWallet extends AbstractHDElectrumWallet {
  static readonly type = 'HDAezeedWallet';
  static readonly typeReadable = 'HD Aezeed';
  public readonly segwitType = 'p2wpkh';
  static readonly derivationPath = "m/84'/0'/0'";
  // @ts-ignore: override
  public readonly type = HDAezeedWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDAezeedWallet.typeReadable;

  private _entropyHex?: string;

  setSecret(newSecret: string): this {
    this.secret = newSecret.trim();
    this.secret = this.secret.replace(/[^a-zA-Z0-9]/g, ' ').replace(/\s+/g, ' ');
    return this;
  }

  _getEntropyCached() {
    if (this._entropyHex) {
      // cache hit
      return Buffer.from(this._entropyHex, 'hex');
    } else {
      throw new Error('Entropy cache is not filled');
    }
  }

  getXpub() {
    // first, getting xpub
    const root = bip32.fromSeed(this._getEntropyCached());

    const path = "m/84'/0'/0'";
    const child = root.derivePath(path).neutered();
    const xpub = child.toBase58();

    // bitcoinjs does not support zpub yet, so we just convert it from xpub
    let data = b58.decode(xpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('04b24746'), data]);
    this._xpub = b58.encode(concatenated);

    return this._xpub;
  }

  validateMnemonic(): boolean {
    throw new Error('Use validateMnemonicAsync()');
  }

  async validateMnemonicAsync() {
    const passphrase = this.getPassphrase() || 'aezeed';
    try {
      const cipherSeed1 = await CipherSeed.fromMnemonic(this.secret, passphrase);
      this._entropyHex = cipherSeed1.entropy.toString('hex'); // save cache
      return !!cipherSeed1.entropy;
    } catch (_) {
      return false;
    }
  }

  async mnemonicInvalidPassword() {
    const passphrase = this.getPassphrase() || 'aezeed';
    try {
      const cipherSeed1 = await CipherSeed.fromMnemonic(this.secret, passphrase);
      this._entropyHex = cipherSeed1.entropy.toString('hex'); // save cache
    } catch (error: any) {
      return error.message === 'Invalid Password';
    }
    return false;
  }

  async generate() {
    throw new Error('Not implemented');
  }

  _getNode0() {
    const root = bip32.fromSeed(this._getEntropyCached());
    const node = root.derivePath("m/84'/0'/0'");
    return node.derive(0);
  }

  _getNode1() {
    const root = bip32.fromSeed(this._getEntropyCached());
    const node = root.derivePath("m/84'/0'/0'");
    return node.derive(1);
  }

  _getInternalAddressByIndex(index: number): string {
    index = index * 1; // cast to int
    if (this.internal_addresses_cache[index]) return this.internal_addresses_cache[index]; // cache hit

    this._node1 = this._node1 || this._getNode1(); // cache

    const address = bitcoin.payments.p2wpkh({
      pubkey: this._node1.derive(index).publicKey,
    }).address;
    if (!address) {
      throw new Error('Internal error: no address in _getInternalAddressByIndex');
    }

    return (this.internal_addresses_cache[index] = address);
  }

  _getExternalAddressByIndex(index: number): string {
    index = index * 1; // cast to int
    if (this.external_addresses_cache[index]) return this.external_addresses_cache[index]; // cache hit

    this._node0 = this._node0 || this._getNode0(); // cache

    const address = bitcoin.payments.p2wpkh({
      pubkey: this._node0.derive(index).publicKey,
    }).address;
    if (!address) {
      throw new Error('Internal error: no address in _getExternalAddressByIndex');
    }

    return (this.external_addresses_cache[index] = address);
  }

  _getWIFByIndex(internal: boolean, index: number): string | false {
    if (!this.secret) return false;
    const root = bip32.fromSeed(this._getEntropyCached());
    const path = `m/84'/0'/0'/${internal ? 1 : 0}/${index}`;
    const child = root.derivePath(path);

    return child.toWIF();
  }

  _getNodePubkeyByIndex(node: number, index: number) {
    index = index * 1; // cast to int

    if (node === 0 && !this._node0) {
      this._node0 = this._getNode0();
    }

    if (node === 1 && !this._node1) {
      this._node1 = this._getNode1();
    }

    if (node === 0 && this._node0) {
      return this._node0.derive(index).publicKey;
    }

    if (node === 1 && this._node1) {
      return this._node1.derive(index).publicKey;
    }

    throw new Error('Internal error: this._node0 or this._node1 is undefined');
  }

  getIdentityPubkey() {
    const root = bip32.fromSeed(this._getEntropyCached());
    const node = root.derivePath("m/1017'/0'/6'/0/0");

    return uint8ArrayToHex(node.publicKey);
  }

  // since its basically a bip84 wallet, we allow all other standard BIP84 features:

  allowSend() {
    return true;
  }

  allowRBF() {
    return true;
  }

  allowPayJoin() {
    return true;
  }

  isSegwit() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }

  allowXpub() {
    return true;
  }
}


================================================
FILE: ./class/wallets/watch-only-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';

import ecc from '../../malin_modules/noble_ecc';
import { AbstractWallet } from './abstract-wallet';
import { HDLegacyP2PKHWallet } from './hd-legacy-p2pkh-wallet';
import { HDSegwitBech32Wallet } from './hd-segwit-bech32-wallet';
import { HDSegwitP2SHWallet } from './hd-segwit-p2sh-wallet';
import { LegacyWallet } from './legacy-wallet';
import { THDWalletForWatchOnly } from './types';
import { HDTaprootWallet } from './hd-taproot-wallet';

const bip32 = BIP32Factory(ecc);

export class WatchOnlyWallet extends LegacyWallet {
  static readonly type = 'watchOnly';
  static readonly typeReadable = 'Watch-only';
  // @ts-ignore: override
  public readonly type = WatchOnlyWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = WatchOnlyWallet.typeReadable;
  public isWatchOnlyWarningVisible = true;

  public _hdWalletInstance?: THDWalletForWatchOnly;
  use_with_hardware_wallet = false;
  masterFingerprint: number = 0;

  /**
   * @inheritDoc
   */
  getLastTxFetch() {
    if (this._hdWalletInstance) return this._hdWalletInstance.getLastTxFetch();
    return super.getLastTxFetch();
  }

  timeToRefreshTransaction() {
    if (this._hdWalletInstance) return this._hdWalletInstance.timeToRefreshTransaction();
    return super.timeToRefreshTransaction();
  }

  timeToRefreshBalance() {
    if (this._hdWalletInstance) return this._hdWalletInstance.timeToRefreshBalance();
    return super.timeToRefreshBalance();
  }

  allowSend() {
    return this.useWithHardwareWalletEnabled() && this.isHd() && this._hdWalletInstance!.allowSend();
  }

  allowSignVerifyMessage() {
    return false;
  }

  getAddress() {
    if (this.isAddressValid(this.secret)) return this.secret; // handling case when there is an XPUB there
    if (this._hdWalletInstance) throw new Error('Should not be used in watch-only HD wallets');
    throw new Error('Not initialized');
  }

  valid() {
    if (this.secret.startsWith('xpub') || this.secret.startsWith('ypub') || this.secret.startsWith('zpub')) return this.isXpubValid();

    try {
      bitcoin.address.toOutputScript(this.getAddress());
      return true;
    } catch (_) {
      return false;
    }
  }

  /**
   * this method creates appropriate HD wallet class, depending on whether we have xpub, ypub or zpub
   * as a property of `this`, and in case such property exists - it recreates it and copies data from old one.
   * this is needed after serialization/save/load/deserialization procedure.
   */
  init() {
    let hdWalletInstance: THDWalletForWatchOnly;

    if (this._derivationPath?.startsWith("m/86'")) {
      // if path is explicit taproot path - its definately BIP86
      hdWalletInstance = new HDTaprootWallet();
    } else if (this.secret.startsWith('xpub')) {
      hdWalletInstance = new HDLegacyP2PKHWallet();
    } else if (this.secret.startsWith('ypub')) hdWalletInstance = new HDSegwitP2SHWallet();
    else if (this.secret.startsWith('zpub')) hdWalletInstance = new HDSegwitBech32Wallet();
    else return this;
    hdWalletInstance._xpub = this.secret;

    // if derivation path recovered from JSON file it should be moved to hdWalletInstance
    if (this._derivationPath) {
      hdWalletInstance._derivationPath = this._derivationPath;
    }

    if (this._hdWalletInstance) {
      // now, porting all properties from old object to new one
      for (const k of Object.keys(this._hdWalletInstance)) {
        // @ts-ignore: JS magic here
        hdWalletInstance[k] = this._hdWalletInstance[k];
      }

      // deleting properties that cant survive serialization/deserialization:
      delete hdWalletInstance._node1;
      delete hdWalletInstance._node0;
    }
    this._hdWalletInstance = hdWalletInstance;

    return this;
  }

  prepareForSerialization() {
    if (this._hdWalletInstance) {
      delete this._hdWalletInstance._node0;
      delete this._hdWalletInstance._node1;
      delete this._hdWalletInstance._bip47_instance;
    }
  }

  getBalance() {
    if (this._hdWalletInstance) return this._hdWalletInstance.getBalance();
    return super.getBalance();
  }

  getTransactions() {
    if (this._hdWalletInstance) return this._hdWalletInstance.getTransactions();
    return super.getTransactions();
  }

  async fetchBalance() {
    if (this.secret.startsWith('xpub') || this.secret.startsWith('ypub') || this.secret.startsWith('zpub')) {
      if (!this._hdWalletInstance) this.init();
      if (!this._hdWalletInstance) throw new Error('Internal error: _hdWalletInstance is not initialized');
      return this._hdWalletInstance.fetchBalance();
    } else {
      // return LegacyWallet.prototype.fetchBalance.call(this);
      return super.fetchBalance();
    }
  }

  async fetchTransactions() {
    if (this.secret.startsWith('xpub') || this.secret.startsWith('ypub') || this.secret.startsWith('zpub')) {
      if (!this._hdWalletInstance) this.init();
      if (!this._hdWalletInstance) throw new Error('Internal error: _hdWalletInstance is not initialized');
      return this._hdWalletInstance.fetchTransactions();
    } else {
      // return LegacyWallet.prototype.fetchBalance.call(this);
      return super.fetchTransactions();
    }
  }

  async getAddressAsync(): Promise<string> {
    if (this.isAddressValid(this.secret)) return new Promise(resolve => resolve(this.secret));
    if (this._hdWalletInstance) return this._hdWalletInstance.getAddressAsync();
    throw new Error('Not initialized');
  }

  _getExternalAddressByIndex(index: number) {
    if (this._hdWalletInstance) return this._hdWalletInstance._getExternalAddressByIndex(index);
    throw new Error('Not initialized');
  }

  _getInternalAddressByIndex(index: number) {
    if (this._hdWalletInstance) return this._hdWalletInstance._getInternalAddressByIndex(index);
    throw new Error('Not initialized');
  }

  getNextFreeAddressIndex() {
    if (this._hdWalletInstance) return this._hdWalletInstance.next_free_address_index;
    throw new Error('Not initialized');
  }

  getNextFreeChangeAddressIndex() {
    if (this._hdWalletInstance) return this._hdWalletInstance.next_free_change_address_index;
    throw new Error('Not initialized');
  }

  async getChangeAddressAsync() {
    if (this._hdWalletInstance) return this._hdWalletInstance.getChangeAddressAsync();
    throw new Error('Not initialized');
  }

  async fetchUtxo() {
    if (this._hdWalletInstance) return this._hdWalletInstance.fetchUtxo();
    throw new Error('Not initialized');
  }

  getUtxo(...args: Parameters<THDWalletForWatchOnly['getUtxo']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.getUtxo(...args);
    throw new Error('Not initialized');
  }

  combinePsbt(...args: Parameters<THDWalletForWatchOnly['combinePsbt']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.combinePsbt(...args);
    throw new Error('Not initialized');
  }

  broadcastTx(...args: Parameters<THDWalletForWatchOnly['broadcastTx']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.broadcastTx(...args);
    throw new Error('Not initialized');
  }

  /**
   * signature of this method is the same ad BIP84 createTransaction, BUT this method should be used to create
   * unsinged PSBT to be used with HW wallet (or other external signer)
   */
  createTransaction(...args: Parameters<THDWalletForWatchOnly['createTransaction']>) {
    const [utxos, targets, feeRate, changeAddress, sequence] = args;
    if (this._hdWalletInstance && this.isHd()) {
      const masterFingerprint = this.getMasterFingerprint();
      return this._hdWalletInstance.createTransaction(utxos, targets, feeRate, changeAddress, sequence, true, masterFingerprint);
    } else {
      throw new Error('Not a HD watch-only wallet, cant create PSBT (or just not initialized)');
    }
  }

  getMasterFingerprint() {
    return this.masterFingerprint;
  }

  getMasterFingerprintHex() {
    if (!this.masterFingerprint) return '00000000';
    let masterFingerprintHex = Number(this.masterFingerprint).toString(16);
    if (masterFingerprintHex.length < 8) masterFingerprintHex = '0' + masterFingerprintHex; // conversion without explicit zero might result in lost byte
    // poor man's little-endian conversion:
    // \_()_/
    return (
      masterFingerprintHex[6] +
      masterFingerprintHex[7] +
      masterFingerprintHex[4] +
      masterFingerprintHex[5] +
      masterFingerprintHex[2] +
      masterFingerprintHex[3] +
      masterFingerprintHex[0] +
      masterFingerprintHex[1]
    );
  }

  isHd() {
    return this.secret.startsWith('xpub') || this.secret.startsWith('ypub') || this.secret.startsWith('zpub');
  }

  weOwnAddress(address: string) {
    if (this.isHd()) {
      if (this._hdWalletInstance) return this._hdWalletInstance.weOwnAddress(address);
      throw new Error('Not initialized');
    }

    if (address && address.startsWith('BC1')) address = address.toLowerCase();

    return this.getAddress() === address;
  }

  allowMasterFingerprint() {
    return this.getSecret().startsWith('zpub') || this.getSecret().startsWith('ypub') || this.getSecret().startsWith('xpub');
  }

  useWithHardwareWalletEnabled() {
    return !!this.use_with_hardware_wallet;
  }

  setUseWithHardwareWalletEnabled(enabled: boolean) {
    this.use_with_hardware_wallet = !!enabled;
  }

  /**
   * @inheritDoc
   */
  getAllExternalAddresses() {
    if (this._hdWalletInstance) return this._hdWalletInstance.getAllExternalAddresses();
    return super.getAllExternalAddresses();
  }

  isXpubValid() {
    let xpub;

    try {
      if (this.secret.startsWith('zpub')) {
        xpub = this._zpubToXpub(this.secret);
      } else if (this.secret.startsWith('ypub')) {
        xpub = AbstractWallet._ypubToXpub(this.secret);
      } else {
        xpub = this.secret;
      }

      const hdNode = bip32.fromBase58(xpub);
      hdNode.derive(0);
      return true;
    } catch (_) {}

    return false;
  }

  addressIsChange(...args: Parameters<THDWalletForWatchOnly['addressIsChange']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.addressIsChange(...args);
    return super.addressIsChange(...args);
  }

  getUTXOMetadata(...args: Parameters<THDWalletForWatchOnly['getUTXOMetadata']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.getUTXOMetadata(...args);
    return super.getUTXOMetadata(...args);
  }

  setUTXOMetadata(...args: Parameters<THDWalletForWatchOnly['setUTXOMetadata']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.setUTXOMetadata(...args);
    return super.setUTXOMetadata(...args);
  }

  getDerivationPath(...args: Parameters<THDWalletForWatchOnly['getDerivationPath']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.getDerivationPath(...args);
    throw new Error("Not a HD watch-only wallet, can't use derivation path");
  }

  setDerivationPath(...args: Parameters<THDWalletForWatchOnly['setDerivationPath']>) {
    if (this._hdWalletInstance) return this._hdWalletInstance.setDerivationPath(...args);
    throw new Error("Not a HD watch-only wallet, can't use derivation path");
  }

  isSegwit(): boolean {
    if (this._hdWalletInstance) return this._hdWalletInstance.isSegwit();
    return super.isSegwit();
  }

  wasEverUsed(): Promise<boolean> {
    if (this._hdWalletInstance) return this._hdWalletInstance.wasEverUsed();
    return super.wasEverUsed();
  }
}


================================================
FILE: ./class/wallets/multisig-hd-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory, { BIP32Interface } from "bip32";
import * as bip39 from "bip39";
import * as bitcoin from "bitcoinjs-lib";
import { Psbt, Transaction } from "bitcoinjs-lib";
import b58 from "bs58check";
import {
  CoinSelectOutput,
  CoinSelectReturnInput,
  CoinSelectTarget,
} from "coinselect";
import { sha256 } from "@noble/hashes/sha256";
import { ECPairFactory } from "ecpair";
import * as mn from "electrum-mnemonic";

import * as MalinElectrum from "../../malin_modules/MalinElectrum";
import ecc from "../../malin_modules/noble_ecc";
import { decodeUR } from "../../malin_modules/ur";
import { AbstractHDElectrumWallet } from "./abstract-hd-electrum-wallet";
import {
  CreateTransactionResult,
  CreateTransactionTarget,
  CreateTransactionUtxo,
} from "./types";
import {
  uint8ArrayToHex,
  hexToUint8Array,
  concatUint8Arrays,
  uint8ArrayToString,
  compareUint8Arrays
} from "../../malin_modules/uint8array-extras";

const ECPair = ECPairFactory(ecc)
const bip32 = BIP32Factory(ecc)

type SeedOpts = {
  prefix: string;
  passphrase?: string;
};

type TBip32Derivation = {
  masterFingerprint: Uint8Array;
  path: string;
  pubkey: Uint8Array;
}[];

type TOutputData =
  | {
      bip32Derivation: TBip32Derivation;
      redeemScript: Uint8Array;
    }
  | {
      bip32Derivation: TBip32Derivation;
      witnessScript: Uint8Array;
    }
  | {
      bip32Derivation: TBip32Derivation;
      redeemScript: Uint8Array;
      witnessScript: Uint8Array;
    };

const electrumSegwit = (passphrase?: string): SeedOpts => ({
  prefix: mn.PREFIXES.segwit,
  ...(passphrase ? { passphrase } : {})
});

const electrumStandart = (passphrase?: string): SeedOpts => ({
  prefix: mn.PREFIXES.standard,
  ...(passphrase ? { passphrase } : {})
});

const ELECTRUM_SEED_PREFIX = "electrumseed:";

export class MultisigHDWallet extends AbstractHDElectrumWallet {
  static readonly type = "HDmultisig";
  static readonly typeReadable = "Multisig Vault";
  // @ts-ignore: override
  public readonly type = MultisigHDWallet.type
  // @ts-ignore: override
  public readonly typeReadable = MultisigHDWallet.typeReadable

  static FORMAT_P2WSH = "p2wsh";
  static FORMAT_P2SH_P2WSH = "p2sh-p2wsh";
  static FORMAT_P2SH_P2WSH_ALT = "p2wsh-p2sh";
  static FORMAT_P2SH = "p2sh";

  static PATH_NATIVE_SEGWIT = "m/48'/0'/0'/2'"
  static PATH_WRAPPED_SEGWIT = "m/48'/0'/0'/1'"
  static PATH_LEGACY = "m/45'"

  private _m: number = 0 //  minimum required signatures so spend (m out of n)
  private _cosigners: string[] = [] // array of xpubs or mnemonic seeds
  private _cosignersFingerprints: string[] = [] // array of according fingerprints  (if any provided)
  private _cosignersCustomPaths: string[] = [] // array of according paths (if any provided)
  private _cosignersPassphrases: (string | undefined)[] = [] // array of according passphrases (if any provided)
  private _isNativeSegwit: boolean = false
  private _isWrappedSegwit: boolean = false
  private _isLegacy: boolean = false
  private _nodes: Record<number, Record<number, BIP32Interface>> = {} // nodeIndex -> cosignerIndex -> BIP32Interface
  public _derivationPath: string = "";
  public gap_limit: number = 20

  isLegacy () {
    return this._isLegacy
  }

  isNativeSegwit () {
    return this._isNativeSegwit
  }

  isWrappedSegwit () {
    return this._isWrappedSegwit
  }

  setWrappedSegwit () {
    this._isWrappedSegwit = true
  }

  setNativeSegwit () {
    this._isNativeSegwit = true
  }

  setLegacy () {
    this._isLegacy = true
  }

  setM (m: number) {
    this._m = m
  }

  /**
   * @returns {number} How many minumim signatures required to authorize a spend
   */
  getM (): number {
    return this._m
  }

  /**
   * @returns {number} Total count of cosigners
   */
  getN (): number {
    return this._cosigners.length
  }

  setDerivationPath (path: string) {
    this._derivationPath = path
    switch (this._derivationPath) {
      case "m/48'/0'/0'/2'":
        this._isNativeSegwit = true
        break
      case "m/48'/0'/0'/1'":
        this._isWrappedSegwit = true
        break
      case "m/45'":
        this._isLegacy = true
        break
      case "m/44'":
        this._isLegacy = true
        break
    }
  }

  getCustomDerivationPathForCosigner (index: number): string | false {
    if (index === 0) throw new Error("cosigners indexation starts from 1");
    if (index > this.getN()) return false
    return this._cosignersCustomPaths[index - 1] || this.getDerivationPath()!
  }

  getCosigner (index: number) {
    if (index === 0) throw new Error("cosigners indexation starts from 1");
    return this._cosigners[index - 1]
  }

  getFingerprint (index: number) {
    if (index === 0) {
      throw new Error('cosigners fingerprints indexation starts from 1');
    }
    return this._cosignersFingerprints[index - 1]
  }

  getCosignerForFingerprint (fp: string) {
    const index = this._cosignersFingerprints.indexOf(fp)
    return this._cosigners[index]
  }

  getCosignerPassphrase (index: number) {
    if (index === 0) throw new Error("cosigners indexation starts from 1");
    return this._cosignersPassphrases[index - 1]
  }

  static isXpubValid (key: string): boolean {
    let xpub

    try {
      const tempWallet = new MultisigHDWallet()
      xpub = tempWallet._zpubToXpub(key)
      bip32.fromBase58(xpub)
      return true
    } catch (_) {}

    return false
  }

  static isXprvValid (xprv: string): boolean {
    try {
      xprv = MultisigHDWallet.convertMultisigXprvToRegularXprv(xprv)
      bip32.fromBase58(xprv)
      return true
    } catch (_) {
      return false
    }
  }

  /**
   *
   * @param key {string} Either xpub or mnemonic phrase
   * @param fingerprint {string} Fingerprint for cosigner that is added as xpub
   * @param path {string} Custom path (if any) for cosigner that is added as mnemonics
   * @param passphrase {string} BIP38 Passphrase (if any)
   */
  addCosigner (
    key: string,
    fingerprint?: string,
    path?: string,
    passphrase?: string,
  ) {
    if (MultisigHDWallet.isXpubString(key) && !fingerprint) {
      throw new Error(
        "fingerprint is required when adding cosigner as xpub (watch-only)",
      );
    }

    if (path && !MultisigHDWallet.isPathValid(path)) {
      throw new Error("path is not valid");
    }

    if (MultisigHDWallet.isXprvString(key)) {
      // nop, but probably should validate xprv
    } else if (MultisigHDWallet.isXpubString(key)) {
      // nop, just validate
      if (!MultisigHDWallet.isXpubValid(key)) {
        throw new Error('Not a valid xpub: ' + key)
      }
    } else if (key.startsWith(ELECTRUM_SEED_PREFIX) && fingerprint && path) {
      // its an electrum seed
      const mnemonic = key.replace(ELECTRUM_SEED_PREFIX, "");
      try {
        mn.mnemonicToSeedSync(mnemonic, electrumStandart(passphrase))
        this.setLegacy()
      } catch (_) {
        try {
          mn.mnemonicToSeedSync(mnemonic, electrumSegwit(passphrase))
          this.setNativeSegwit()
        } catch (__) {
          throw new Error("Not a valid electrum seed");
        }
      }
    } else {
      // mnemonics. lets derive fingerprint (if it wasnt provided)
      if (!bip39.validateMnemonic(key)) {
        throw new Error('Not a valid mnemonic phrase');
      }
      fingerprint =
        fingerprint || MultisigHDWallet.mnemonicToFingerprint(key, passphrase)
    }

    if (
      fingerprint &&
      this._cosignersFingerprints.indexOf(fingerprint.toUpperCase()) !== -1 &&
      fingerprint !== "00000000"
    ) {
      // 00000000 is a special case, means we have no idea what the FP is but its okay
      throw new Error("Duplicate fingerprint");
    }

    const index = this._cosigners.length
    this._cosigners[index] = key
    if (fingerprint) {
      this._cosignersFingerprints[index] = fingerprint.toUpperCase()
    }
    if (path) this._cosignersCustomPaths[index] = path
    if (passphrase) this._cosignersPassphrases[index] = passphrase
  }

  static convertMultisigXprvToRegularXprv (Zprv: string) {
    let data = b58.decode(Zprv)
    data = data.slice(4)
    return b58.encode(concatUint8Arrays([hexToUint8Array("0488ade4"), data]))
  }

  static convertXprvToXpub (xprv: string) {
    const restored = bip32.fromBase58(
      MultisigHDWallet.convertMultisigXprvToRegularXprv(xprv),
    )
    return restored.neutered().toBase58()
  }

  /**
   * Stored cosigner can be EITHER xpub (or Zpub or smth), OR mnemonic phrase. This method converts it to xpub
   *
   * @param index {number}
   * @returns {string} xpub
   * @private
   */
  protected _getXpubFromCosignerIndex (index: number) {
    if (!this._cosigners || !this._cosigners[index]) {
      throw new Error("Invalid cosigner index or cosigners not initialized");
    }
    let cosigner: string = this._cosigners[index]
    if (MultisigHDWallet.isXprvString(cosigner)) {
      cosigner = MultisigHDWallet.convertXprvToXpub(cosigner)
    }
    let xpub = cosigner
    if (!MultisigHDWallet.isXpubString(cosigner)) {
      xpub = MultisigHDWallet.seedToXpub(
        cosigner,
        this._cosignersCustomPaths[index] || this._derivationPath,
        this._cosignersPassphrases[index]
      )
    }
    return this._zpubToXpub(xpub)
  }

  _getExternalAddressByIndex (index: number) {
    if (!this._m) throw new Error("m is not set");
    index = +index
    if (this.external_addresses_cache[index]) {
      return this.external_addresses_cache[index]
    } // cache hit

    const address = this._getAddressFromNode(0, index)
    this.external_addresses_cache[index] = address
    return address
  }

  _getAddressFromNode (nodeIndex: number, index: number) {
    this._nodes = this._nodes || {}
    const pubkeys = []
    for (const [cosignerIndex] of this._cosigners.entries()) {
      this._nodes[nodeIndex] = this._nodes[nodeIndex] || {}
      let _node

      if (!this._nodes[nodeIndex][cosignerIndex]) {
        const xpub = this._getXpubFromCosignerIndex(cosignerIndex)
        const hdNode = bip32.fromBase58(xpub)
        _node = hdNode.derive(nodeIndex)
        this._nodes[nodeIndex][cosignerIndex] = _node
      } else {
        _node = this._nodes[nodeIndex][cosignerIndex]
      }

      pubkeys.push(_node.derive(index).publicKey)
    }

    if (this.isWrappedSegwit()) {
      const { address } = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2wsh({
          redeem: bitcoin.payments.p2ms({
            m: this._m,
            pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
          })
        }),
      })
      if (!address) {
        throw new Error("Internal error: could not make p2sh address");
      }

      return address
    } else if (this.isNativeSegwit()) {
      const { address } = bitcoin.payments.p2wsh({
        redeem: bitcoin.payments.p2ms({
          m: this._m,
          pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
        })
      });
      if (!address) {
        throw new Error("Internal error: could not make p2wsh address");
      }

      return address
    } else if (this.isLegacy()) {
      const { address } = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2ms({
          m: this._m,
          pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
        })
      });
      if (!address) {
        throw new Error("Internal error: could not make p2sh address");
      }

      return address
    } else {
      throw new Error("Dont know how to make address");
    }
  }

  _getInternalAddressByIndex (index: number) {
    if (!this._m) throw new Error("m is not set");
    index = +index
    if (this.internal_addresses_cache[index]) {
      return this.internal_addresses_cache[index]
    } // cache hit

    const address = this._getAddressFromNode(1, index)
    this.internal_addresses_cache[index] = address
    return address
  }

  static seedToXpub (
    mnemonic: string,
    path: string,
    passphrase?: string,
  ): string {
    let seed
    if (mnemonic.startsWith(ELECTRUM_SEED_PREFIX)) {
      seed = MultisigHDWallet.convertElectrumMnemonicToSeed(
        mnemonic,
        passphrase,
      )
    } else {
      seed = bip39.mnemonicToSeedSync(mnemonic, passphrase)
    }

    const root = bip32.fromSeed(seed)
    const child = root.derivePath(path).neutered()
    return child.toBase58()
  }

  /**
   * Returns xpub with correct prefix accodting to this objects set derivation path, for example 'Zpub' (with
   * capital Z) for bech32 multisig
   * @see https://github.com/satoshilabs/slips/blob/master/slip-0132.md
   *
   * @param xpub {string} Any kind of xpub, including zpub etc since we are only swapping the prefix bytes
   * @returns {string}
   */
  convertXpubToMultisignatureXpub (xpub: string): string {
    let data = b58.decode(xpub)
    data = data.slice(4)
    if (this.isNativeSegwit()) {
      return b58.encode(concatUint8Arrays([hexToUint8Array("02aa7ed3"), data]))
    } else if (this.isWrappedSegwit()) {
      return b58.encode(concatUint8Arrays([hexToUint8Array("0295b43f"), data]))
    }

    return xpub
  }

  convertXprvToMultisignatureXprv (xpub: string): string {
    let data = b58.decode(xpub)
    data = data.slice(4)
    if (this.isNativeSegwit()) {
      return b58.encode(concatUint8Arrays([hexToUint8Array("02aa7a99"), data]))
    } else if (this.isWrappedSegwit()) {
      return b58.encode(concatUint8Arrays([hexToUint8Array("0295b005"), data]))
    }

    return xpub
  }

  static isXpubString (xpub: string): boolean {
    return ["xpub", "ypub", "zpub", "Ypub", "Zpub"].includes(
      xpub.substring(0, 4),
    )
  }

  static isXprvString (xpub: string): boolean {
    return ["xprv", "yprv", "zprv", "Yprv", "Zprv"].includes(
      xpub.substring(0, 4),
    )
  }

  /**
   * Converts fingerprint that is stored as a deciman number to hex string (all caps)
   *
   * @param xfp {number} For example 64392470
   * @returns {string} For example 168DD603
   */
  static ckccXfp2fingerprint (xfp: string | number): string {
    let masterFingerprintHex = Number(xfp).toString(16)
    while (masterFingerprintHex.length < 8) {
      masterFingerprintHex = '0' + masterFingerprintHex
    } // conversion without explicit zero might result in lost byte

    // poor man's little-endian conversion:
    // \_()_/
    return (
      masterFingerprintHex[6] +
      masterFingerprintHex[7] +
      masterFingerprintHex[4] +
      masterFingerprintHex[5] +
      masterFingerprintHex[2] +
      masterFingerprintHex[3] +
      masterFingerprintHex[0] +
      masterFingerprintHex[1]
    ).toUpperCase()
  }

  getXpub () {
    return this.getSecret(true)
  }

  getSecret (coordinationSetup = false) {
    let ret = "# MalinWallet Multisig setup file\n";
    if (coordinationSetup) {
      ret +=
        '# this file contains only public keys and is safe to\n# distribute among cosigners\n';
    }
    if (!coordinationSetup) {
      ret += '# this file may contain private information\n';
    }
    ret += "#\n";
    ret += "Name: " + this.getLabel() + "\n";
    ret += "Policy: " + this.getM() + " of " + this.getN() + "\n";

    let hasCustomPaths = 0
    const customPaths: Record<string, number> = {}
    for (let index = 0; index < this.getN(); index++) {
      if (this._cosignersCustomPaths[index]) hasCustomPaths++
      if (this._cosignersCustomPaths[index]) {
        customPaths[this._cosignersCustomPaths[index]] = 1
      }
    }

    let printedGlobalDerivation = false
    const derivationPath = this.getDerivationPath()
    if (derivationPath) customPaths[derivationPath] = 1
    if (Object.keys(customPaths).length === 1) {
      // we have exactly one path, for everyone. lets just print it
      for (const path of Object.keys(customPaths)) {
        ret += "Derivation: " + path + "\n";
        printedGlobalDerivation = true
      }
    }

    if (hasCustomPaths !== this.getN() && !printedGlobalDerivation) {
      printedGlobalDerivation = true
      ret += "Derivation: " + this.getDerivationPath() + "\n";
    }

    if (this.isNativeSegwit()) {
      ret += "Format: P2WSH\n";
    } else if (this.isWrappedSegwit()) {
      ret += "Format: P2SH-P2WSH\n";
    } else if (this.isLegacy()) {
      ret += "Format: P2SH\n";
    } else {
      ret += "Format: unknown\n";
    }
    ret += "\n";

    for (let index = 0; index < this.getN(); index++) {
      if (
        this._cosignersCustomPaths[index] &&
        ((printedGlobalDerivation &&
          this._cosignersCustomPaths[index] !== this.getDerivationPath()) ||
          !printedGlobalDerivation)
      ) {
        ret += "# derivation: " + this._cosignersCustomPaths[index] + "\n";
        // if we printed global derivation and this cosigned _has_ derivation and its different from global - we print it ;
        // or we print it if cosigner _has_ some derivation set and we did not print global
      }
      if (MultisigHDWallet.isXpubString(this._cosigners[index])) {
        ret +=
          this._cosignersFingerprints[index] +
          ": " +
          this._cosigners[index] +
          "\n";
      } else {
        if (coordinationSetup) {
          const xpub = this.convertXpubToMultisignatureXpub(
            MultisigHDWallet.seedToXpub(
              this._cosigners[index],
              this._cosignersCustomPaths[index] || this._derivationPath,
              this._cosignersPassphrases[index]
            )
          );
          const fingerprint = MultisigHDWallet.mnemonicToFingerprint(
            this._cosigners[index],
            this._cosignersPassphrases[index],
          )
          ret += fingerprint + ": " + xpub + "\n";
        } else {
          ret += "seed: " + this._cosigners[index]
          if (this._cosignersPassphrases[index]) {
            ret += ' - ' + this._cosignersPassphrases[index]
          }
          ret += "\n# warning! sensitive information, do not disclose ^^^ \n";
        }
      }

      ret += "\n";
    }

    return ret
  }

  setSecret (secret: string) {
    if (secret.toUpperCase().startsWith("UR:BYTES")) {
      const decoded = decodeUR([secret]) as string
      const b = hexToUint8Array(decoded)
      secret = uint8ArrayToString(b)
    }

    // is it Coldcard json file?
    let json
    try {
      json = JSON.parse(secret)
    } catch (_) {}
    if (json && json.xfp && json.p2wsh_deriv && json.p2wsh) {
      this.addCosigner(json.p2wsh, json.xfp) // technically we dont need deriv (json.p2wsh_deriv), since cosigner is already an xpub
      return this
    }

    // is it electrum json?
    if (json && json.wallet_type && json.wallet_type !== "standard") {
      const mofn = json.wallet_type.split("of");
      this.setM(parseInt(mofn[0].trim(), 10))
      const n = parseInt(mofn[1].trim(), 10)
      for (let c = 1; c <= n; c++) {
        const cosignerData = json["x" + c + "/"];
        if (cosignerData) {
          const fingerprint =
            (cosignerData.ckcc_xfp
              ? MultisigHDWallet.ckccXfp2fingerprint(cosignerData.ckcc_xfp)
              : cosignerData.root_fingerprint?.toUpperCase()) || "00000000";
          if (cosignerData.seed) {
            this.addCosigner(
              ELECTRUM_SEED_PREFIX + cosignerData.seed,
              fingerprint,
              cosignerData.derivation,
              cosignerData.passphrase,
            )
          } else if (
            cosignerData.xprv &&
            MultisigHDWallet.isXprvValid(cosignerData.xprv)
          ) {
            this.addCosigner(
              cosignerData.xprv,
              fingerprint,
              cosignerData.derivation,
            )
          } else {
            this.addCosigner(
              cosignerData.xpub,
              fingerprint,
              cosignerData.derivation,
            )
          }
        }

        if (cosignerData?.xpub?.startsWith("Zpub")) this.setNativeSegwit()
        if (cosignerData?.xpub?.startsWith("Ypub")) this.setWrappedSegwit()
        if (cosignerData?.xpub?.startsWith("xpub")) this.setLegacy()
      }
    }

    // coldcard & cobo txt format:
    let customPathForCurrentCosigner: string | undefined
    for (const line of secret.split("\n")) {
      const [key, value] = line.split(":");

      switch (key) {
        case "Name":
          this.setLabel(value.trim())
          break

        case "Policy":
          this.setM(parseInt(value.trim().split("of")[0].trim(), 10))
          break

        case "Derivation":
          this.setDerivationPath(value.trim())
          break

        case "Format":
          switch (value.trim()) {
            case MultisigHDWallet.FORMAT_P2WSH.toUpperCase():
              this.setNativeSegwit()
              break
            case MultisigHDWallet.FORMAT_P2SH_P2WSH.toUpperCase():
            case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT.toUpperCase():
              this.setWrappedSegwit()
              break
            case MultisigHDWallet.FORMAT_P2SH.toUpperCase():
              this.setLegacy()
              break
          }
          break

        default:
          if (key && value && MultisigHDWallet.isXpubString(value.trim())) {
            this.addCosigner(value.trim(), key, customPathForCurrentCosigner)
          } else if (key.replace("#", "").trim() === "derivation") {
            customPathForCurrentCosigner = value.trim()
          } else if (key === "seed") {
            const [seed, passphrase] = value.split(" - ");
            this.addCosigner(
              seed.trim(),
              undefined,
              customPathForCurrentCosigner,
              passphrase,
            )
          }
          break
      }
    }

    // is it wallet descriptor?
    // @see https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
    // @see https://github.com/Fonta1n3/FullyNoded/blob/master/Docs/Wallets/Wallet-Export-Spec.md
    if (!json && secret.indexOf("sortedmulti(")) {
      // provided secret was NOT json but plain wallet descriptor text. lets mock json
      json = { descriptor: secret, label: "Multisig vault" }
    }
    if (secret.indexOf("sortedmulti(") !== -1 && json.descriptor) {
      if (json.label) this.setLabel(json.label)
      if (json.descriptor.includes("sh(wsh(")) {
        this.setWrappedSegwit()
      } else if (json.descriptor.includes("wsh(")) {
        this.setNativeSegwit()
      } else if (json.descriptor.includes("sh(")) {
        this.setLegacy()
      }

      const s2 = json.descriptor.substr(
        json.descriptor.indexOf("sortedmulti(") + 12,
      )
      const s3 = s2.split(",");
      const M = parseInt(s3[0], 10)
      if (M) this.setM(M)

      for (let c = 1; c < s3.length; c++) {
        const re = /\[([^\]]+)\](.*)/
        const m = s3[c].match(re)
        if (m && m.length === 3) {
          const hexFingerprint = m[1].split("/")[0]

          let path =
            "m/" + m[1].split("/").slice(1).join("/").replace(/[h]/g, "'")
          if (path === "m/") {
            // not considered valid by Bip32 lib
            path = "m/0";
          }
          let xpub = m[2]
          if (xpub.indexOf("/") !== -1) {
            xpub = xpub.substr(0, xpub.indexOf("/"))
          }
          if (xpub.indexOf(")") !== -1) {
            xpub = xpub.substr(0, xpub.indexOf(")"))
          }

          this.addCosigner(xpub, hexFingerprint.toUpperCase(), path)
        }
      }

      if (this.getN() === 0) {
        // handling a case when smth went wrong and we didnt parse any cosigners, probably because
        // string is a bit non-standard, deesnt have chars like '['
        for (let c = 1; c < s3.length; c++) {
          const hexFingerprint = s3[c].split("/")[0]
          let indexOfXpub = s3[c].indexOf("xpub");
          if (indexOfXpub === -1) {
            // just for any case
            indexOfXpub = s3[c].indexOf("ypub");
          }
          if (indexOfXpub === -1) {
            // just for any case
            indexOfXpub = s3[c].indexOf("zpub");
          }
          if (indexOfXpub === -1) {
            throw new Error("Could not parse cosigner in a descriptor");
          }

          const xpub = s3[c].substring(indexOfXpub).replaceAll(")", "");
          const path =
            "m" + s3[c].substring(hexFingerprint.length, indexOfXpub)

          this.addCosigner(xpub, hexFingerprint.toUpperCase(), path)
        }
      }
    }

    // is it caravan?
    if (json && json.network === "mainnet" && json.quorum) {
      this.setM(+json.quorum.requiredSigners)
      if (json.name) this.setLabel(json.name)

      switch (json.addressType.toLowerCase()) {
        case MultisigHDWallet.FORMAT_P2SH:
          this.setLegacy()
          break
        case MultisigHDWallet.FORMAT_P2SH_P2WSH:
        case MultisigHDWallet.FORMAT_P2SH_P2WSH_ALT:
          this.setWrappedSegwit()
          break
        case MultisigHDWallet.FORMAT_P2WSH:
        default:
          this.setNativeSegwit()
          break
      }

      for (const pk of json.extendedPublicKeys) {
        const path = MultisigHDWallet.isPathValid(json.bip32Path)
          ? json.bip32Path
          : "m/1'"
        this.addCosigner(pk.xpub, pk.xfp ?? "00000000", path)
      }
    }

    if (!this.getLabel()) this.setLabel("Multisig vault");

    return this
  }

  _getDerivationPathByAddressWithCustomPath (
    address: string,
    customPathPrefix: string | undefined,
  ) {
    const path = customPathPrefix || this._derivationPath
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._getExternalAddressByIndex(c) === address) {
        return path + '/0/' + c
      }
    }
    for (
      let c = 0;
      c < this.next_free_change_address_index + this.gap_limit;
      c++
    ) {
      if (this._getInternalAddressByIndex(c) === address) {
        return path + '/1/' + c
      }
    }

    return false
  }

  _getWifForAddress (address: string): string {
    // @ts-ignore not applicable in multisig
    return false
  }

  _getPubkeyByAddress (address: string): false | Buffer {
    throw new Error("Not applicable in multisig");
  }

  _getDerivationPathByAddress (address: string): string {
    throw new Error("Not applicable in multisig");
  }

  _addPsbtInput (
    psbt: Psbt,
    input: CoinSelectReturnInput,
    sequence: number,
    masterFingerprintBuffer?: Uint8Array,
  ) {
    const bip32Derivation = [] // array per each pubkey thats gona be used
    const pubkeys = []
    for (const [cosignerIndex] of this._cosigners.entries()) {
      if (!input.address) {
        throw new Error("Could not find address in input");
      }
      const path = this._getDerivationPathByAddressWithCustomPath(
        input.address,
        this._cosignersCustomPaths[cosignerIndex] || this._derivationPath
      )
      // ^^ path resembles _custom path_, if provided by user during setup, otherwise default path for wallet type gona be used
      const masterFingerprint = hexToUint8Array(
        this._cosignersFingerprints[cosignerIndex],
      )

      if (!path) {
        throw new Error(
          "Could not find derivation path for address " + input.address,
        )
      }

      const xpub = this._getXpubFromCosignerIndex(cosignerIndex)
      const hdNode0 = bip32.fromBase58(xpub)
      const splt = path.split("/");
      const internal = +splt[splt.length - 2]
      const index = +splt[splt.length - 1]
      const _node0 = hdNode0.derive(internal)
      const pubkey = _node0.derive(index).publicKey
      pubkeys.push(pubkey)

      bip32Derivation.push({
        masterFingerprint,
        path,
        pubkey
      });
    }

    if (!input.txhex) {
      throw new Error(
        "Electrum server didnt provide txhex to properly create PSBT transaction",
      );
    }

    if (this.isNativeSegwit()) {
      const p2wsh = bitcoin.payments.p2wsh({
        redeem: bitcoin.payments.p2ms({
          m: this._m,
          pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
        })
      });
      if (!p2wsh.redeem || !p2wsh.output) {
        throw new Error("Could not create p2wsh output");
      }
      const witnessScript = p2wsh.redeem.output

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        bip32Derivation,
        witnessUtxo: {
          script: p2wsh.output,
          value: BigInt(input.value)
        },
        witnessScript,
        // hw wallets now require passing the whole previous tx as Buffer, as if it was non-segwit input, to mitigate
        // some hw wallets attack vector
        nonWitnessUtxo: hexToUint8Array(input.txhex)
      });
    } else if (this.isWrappedSegwit()) {
      const p2shP2wsh = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2wsh({
          redeem: bitcoin.payments.p2ms({
            m: this._m,
            pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
          })
        }),
      })
      if (
        !p2shP2wsh?.redeem?.redeem?.output ||
        !p2shP2wsh?.redeem?.output ||
        !p2shP2wsh.output
      ) {
        throw new Error("Could not create p2sh-p2wsh output");
      }

      const witnessScript = p2shP2wsh.redeem.redeem.output
      const redeemScript = p2shP2wsh.redeem.output

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        bip32Derivation,
        witnessUtxo: {
          script: p2shP2wsh.output,
          value: BigInt(input.value)
        },
        witnessScript,
        redeemScript,
        // hw wallets now require passing the whole previous tx as Buffer, as if it was non-segwit input, to mitigate
        // some hw wallets attack vector
        nonWitnessUtxo: hexToUint8Array(input.txhex)
      });
    } else if (this.isLegacy()) {
      const p2sh = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2ms({
          m: this._m,
          pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
        })
      });
      if (!p2sh?.redeem?.output) {
        throw new Error("Could not create p2sh output");
      }
      const redeemScript = p2sh.redeem.output
      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        bip32Derivation,
        redeemScript,
        nonWitnessUtxo: hexToUint8Array(input.txhex)
      });
    } else {
      throw new Error("Dont know how to add input");
    }

    return psbt
  }

  _getOutputDataForChange (address: string): TOutputData {
    const bip32Derivation: TBip32Derivation = [] // array per each pubkey thats gona be used
    const pubkeys = []
    for (const [cosignerIndex] of this._cosigners.entries()) {
      const path = this._getDerivationPathByAddressWithCustomPath(
        address,
        this._cosignersCustomPaths[cosignerIndex] || this._derivationPath
      )
      // ^^ path resembles _custom path_, if provided by user during setup, otherwise default path for wallet type gona be used
      const masterFingerprint = hexToUint8Array(
        this._cosignersFingerprints[cosignerIndex],
      )

      if (!path) {
        throw new Error(
          "Could not find derivation path for address " + address,
        )
      }

      const xpub = this._getXpubFromCosignerIndex(cosignerIndex)
      const hdNode0 = bip32.fromBase58(xpub)
      const splt = path.split("/");
      const internal = +splt[splt.length - 2]
      const index = +splt[splt.length - 1]
      const _node0 = hdNode0.derive(internal)
      const pubkey = _node0.derive(index).publicKey
      pubkeys.push(pubkey)

      bip32Derivation.push({
        masterFingerprint,
        path,
        pubkey
      });
    }

    if (this.isLegacy()) {
      const p2sh = bitcoin.payments.p2ms({
        m: this._m,
        pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
      })
      if (!p2sh.output) {
        throw new Error("Could not create redeemScript");
      }
      return {
        bip32Derivation,
        redeemScript: p2sh.output
      }
    }

    if (this.isWrappedSegwit()) {
      const p2shP2wsh = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2wsh({
          redeem: bitcoin.payments.p2ms({
            m: this._m,
            pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
          })
        }),
      })
      const witnessScript = p2shP2wsh?.redeem?.redeem?.output
      const redeemScript = p2shP2wsh?.redeem?.output
      if (!witnessScript || !redeemScript) {
        throw new Error("Could not create redeemScript or witnessScript");
      }
      return {
        bip32Derivation,
        witnessScript,
        redeemScript
      }
    }

    if (this.isNativeSegwit()) {
      // not needed by coldcard, apparently..?
      const p2wsh = bitcoin.payments.p2wsh({
        redeem: bitcoin.payments.p2ms({
          m: this._m,
          pubkeys: MultisigHDWallet.sortBuffers(pubkeys),
        })
      });
      const witnessScript = p2wsh?.redeem?.output
      if (!witnessScript) {
        throw new Error("Could not create witnessScript");
      }
      return {
        bip32Derivation,
        witnessScript
      }
    }

    throw new Error("dont know how to add change output");
  }

  howManySignaturesCanWeMake () {
    let howManyPrivKeysWeGot = 0
    for (const cosigner of this._cosigners) {
      if (
        !MultisigHDWallet.isXpubString(cosigner) &&
        !MultisigHDWallet.isXprvString(cosigner)
      ) {
        howManyPrivKeysWeGot++
      }
    }

    return howManyPrivKeysWeGot
  }

  coinselect (
    utxos: CreateTransactionUtxo[],
    targets: CreateTransactionTarget[],
    feeRate: number
  ): {
    inputs: CoinSelectReturnInput[];
    outputs: CoinSelectOutput[];
    fee: number;
  } {
    const _utxos = JSON.parse(JSON.stringify(utxos)) as CreateTransactionUtxo[]

    // overriding script length for proper vbytes calculation
    for (const u of _utxos) {
      if (u.script?.length) {
        continue
      }

      if (this.isNativeSegwit()) {
        u.script = {
          length: Math.ceil((8 + this.getM() * 74 + this.getN() * 34) / 4)
        }
      } else if (this.isWrappedSegwit()) {
        u.script = {
          length: 35 + Math.ceil((8 + this.getM() * 74 + this.getN() * 34) / 4)
        }
      } else {
        u.script = {
          length: 2 + this.getM() * 74 + this.getN() * 34
        }
      }
    }

    return super.coinselect(_utxos, targets, feeRate)
  }

  /**
   * @inheritDoc
   */
  createTransaction (
    utxos: CreateTransactionUtxo[],
    targets: CoinSelectTarget[],
    feeRate: number,
    changeAddress: string,
    sequence: number,
    skipSigning = false,
    masterFingerprint: number
  ): CreateTransactionResult {
    if (targets.length === 0) throw new Error("No destination provided");
    if (this.howManySignaturesCanWeMake() === 0) skipSigning = true

    const { inputs, outputs, fee } = this.coinselect(utxos, targets, feeRate)
    sequence = sequence || AbstractHDElectrumWallet.defaultRBFSequence

    let psbt = new bitcoin.Psbt()

    let c = 0
    inputs.forEach((input) => {
      c++
      psbt = this._addPsbtInput(psbt, input, sequence)
    });

    outputs.forEach((output) => {
      // if output has no address - this is change output
      let change = false
      let address: string | undefined = output.address
      if (!address) {
        change = true
        output.address = changeAddress
        address = changeAddress
      }

      let outputData: Parameters<typeof psbt.addOutput>[0] = {
        address,
        value: BigInt(output.value)
      }

      if (change) {
        outputData = {
          ...outputData,
          ...this._getOutputDataForChange(address)
        }
      }

      psbt.addOutput(outputData)
    });

    if (!skipSigning) {
      for (let cc = 0; cc < c; cc++) {
        let signaturesMade = 0
        for (const [cosignerIndex, cosigner] of this._cosigners.entries()) {
          if (MultisigHDWallet.isXpubString(cosigner)) continue
          // ok this is a mnemonic, lets try to sign
          if (signaturesMade >= this.getM()) {
            // dont sign more than we need, otherwise there will be "Too many signatures" error
            continue
          }
          const passphrase = this._cosignersPassphrases[cosignerIndex]
          let seed = bip39.mnemonicToSeedSync(cosigner, passphrase)
          if (cosigner.startsWith(ELECTRUM_SEED_PREFIX)) {
            seed = MultisigHDWallet.convertElectrumMnemonicToSeed(
              cosigner,
              passphrase,
            )
          }

          const hdRoot = bip32.fromSeed(seed)
          psbt.signInputHD(cc, hdRoot)
          signaturesMade++;
        }
      }
    }

    let tx
    if (!skipSigning && this.howManySignaturesCanWeMake() >= this.getM()) {
      tx = psbt.finalizeAllInputs().extractTransaction()
    }
    return { tx, inputs, outputs, fee, psbt }
  }

  static convertElectrumMnemonicToSeed (cosigner: string, passphrase?: string) {
    let seed
    try {
      seed = mn.mnemonicToSeedSync(
        cosigner.replace(ELECTRUM_SEED_PREFIX, ""),
        electrumSegwit(passphrase),
      )
    } catch (_) {
      try {
        seed = mn.mnemonicToSeedSync(
          cosigner.replace(ELECTRUM_SEED_PREFIX, ""),
          electrumStandart(passphrase),
        )
      } catch (__) {
        throw new Error("Not a valid electrum mnemonic");
      }
    }
    return seed
  }

  /**
   * @see https://github.com/bitcoin/bips/blob/master/bip-0067.mediawiki
   */
  static sortBuffers (bufArr: Uint8Array[]): Uint8Array[] {
    return bufArr.sort(compareUint8Arrays)
  }

  prepareForSerialization () {
    // deleting structures that cant be serialized
    // @ts-ignore I dont want to make it optional
    delete this._nodes
  }

  static isPathValid (path: string): boolean {
    const root = bip32.fromSeed(Buffer.alloc(32))
    try {
      root.derivePath(path)
      return true
    } catch (_) {}
    return false
  }

  allowSend () {
    return true
  }

  allowSignVerifyMessage () {
    return false
  }

  async fetchUtxo () {
    await super.fetchUtxo()
    // now we need to fetch txhash for each input as required by PSBT
    const txhexes = await MalinElectrum.multiGetTransactionByTxid(
      this.getUtxo(true).map((x) => x.txid),
      false
    )

    const newUtxos = []
    for (const u of this.getUtxo(true)) {
      if (txhexes[u.txid]) u.txhex = txhexes[u.txid]
      newUtxos.push(u)
    }

    this._utxo = newUtxos
  }

  getID () {
    const string2hash =
      [...this._cosigners].sort().join(",") +
      ";" +
      [...this._cosignersFingerprints].sort().join(",");
    return uint8ArrayToHex(sha256(string2hash))
  }

  calculateFeeFromPsbt (psbt: Psbt) {
    let goesIn = 0
    const cacheUtxoAmounts: { [key: string]: number } = {}
    for (const inp of psbt.data.inputs) {
      if (inp.witnessUtxo && inp.witnessUtxo.value) {
        // segwit input
        goesIn += Number(inp.witnessUtxo.value)
      } else if (inp.nonWitnessUtxo) {
        // non-segwit input
        // lets parse this transaction and cache how much each input was worth
        const inputTx = bitcoin.Transaction.fromBuffer(inp.nonWitnessUtxo)
        let index = 0
        for (const out of inputTx.outs) {
          cacheUtxoAmounts[inputTx.getId() + ":" + index] = Number(out.value)
          index++;
        }
      }
    }

    if (goesIn === 0) {
      // means we failed to get amounts that go in previously, so lets use utxo amounts cache we've build
      // from non-segwit inputs
      for (const inp of psbt.txInputs) {
        const cacheKey =
          uint8ArrayToHex(new Uint8Array(inp.hash).reverse()) + ":" + inp.index
        if (cacheUtxoAmounts[cacheKey]) goesIn += cacheUtxoAmounts[cacheKey]
      }
    }

    let goesOut = 0
    for (const output of psbt.txOutputs) {
      goesOut += Number(output.value)
    }

    return goesIn - goesOut
  }

  calculateHowManySignaturesWeHaveFromPsbt (psbt: Psbt) {
    let sigsHave = 0
    for (const inp of psbt.data.inputs) {
      sigsHave = Math.max(sigsHave, inp.partialSig?.length || 0)
      if (inp.finalScriptSig || inp.finalScriptWitness) sigsHave = this.getM() // hacky, but it means we have enough
      // He who knows that enough is enough will always have enough. Lao Tzu
    }

    return sigsHave
  }

  /**
   * Tries to signs passed psbt object (by reference). If there are enough signatures - tries to finalize psbt
   * and returns Transaction (ready to extract hex)
   */
  cosignPsbt (psbt: Psbt): { tx: Transaction | false } {
    for (let cc = 0; cc < psbt.inputCount; cc++) {
      for (const [cosignerIndex, cosigner] of this._cosigners.entries()) {
        if (MultisigHDWallet.isXpubString(cosigner)) continue

        let hdRoot
        if (MultisigHDWallet.isXprvString(cosigner)) {
          const xprv =
            MultisigHDWallet.convertMultisigXprvToRegularXprv(cosigner)
          hdRoot = bip32.fromBase58(xprv)
        } else {
          const passphrase = this._cosignersPassphrases[cosignerIndex]
          const seed = cosigner.startsWith(ELECTRUM_SEED_PREFIX)
            ? MultisigHDWallet.convertElectrumMnemonicToSeed(
                cosigner,
                passphrase
            )
            : bip39.mnemonicToSeedSync(cosigner, passphrase)
          hdRoot = bip32.fromSeed(seed)
        }

        try {
          psbt.signInputHD(cc, hdRoot)
        } catch (_) {} // protects agains duplicate cosignings

        if (!psbt.inputHasHDKey(cc, hdRoot)) {
          // failed signing as HD. probably bitcoinjs-lib could not match provided hdRoot's
          // fingerprint (or path?) to the ones in psbt, which is the case of stupid Electrum desktop which can
          // put bullshit paths and fingerprints in created psbt.
          // lets try to find correct priv key and sign manually.
          for (const derivation of psbt.data.inputs[cc].bip32Derivation || []) {
            // okay, here we assume that fingerprint is irrelevant, but ending of the path is somewhat correct and
            // correctly points to `/internal/index`, so we extract pubkey from our stored mnemonics+path and
            // match it to the one provided in PSBT's input, and if we have a match - we are in luck! we can sign
            // with this private key.
            const splt = derivation.path.split("/");
            const internal = +splt[splt.length - 2]
            const index = +splt[splt.length - 1]

            const path =
              hdRoot.depth === 0
                ? this.getCustomDerivationPathForCosigner(cosignerIndex + 1) +
                  `/${internal ? 1 : 0}/${index}`
                : `${internal ? 1 : 0}/${index}`
            // ^^^ we assume that counterparty has Zpub for specified derivation path
            // if hdRoot.depth !== 0 than this hdnode was recovered from xprv and it already has been set to root path
            const child = hdRoot.derivePath(path)
            if (child.privateKey && psbt.inputHasPubkey(cc, child.publicKey)) {
              const keyPair = ECPair.fromPrivateKey(child.privateKey)
              try {
                psbt.signInput(cc, keyPair)
              } catch (_) {}
            }
          }
        }
      }
    }

    if (this.calculateHowManySignaturesWeHaveFromPsbt(psbt) >= this.getM()) {
      const tx = psbt.finalizeAllInputs().extractTransaction()
      return { tx }
    }

    return { tx: false }
  }

  /**
   * Looks up xpub cosigner by index, and repalces it with seed + passphrase
   */
  replaceCosignerXpubWithSeed (
    externalIndex: number,
    mnemonic: string,
    passphrase?: string,
  ) {
    const index = externalIndex - 1
    const fingerprint = this._cosignersFingerprints[index]
    if (!MultisigHDWallet.isXpubValid(this._cosigners[index])) {
      throw new Error('This cosigner doesnt contain valid xpub');
    }
    if (!bip39.validateMnemonic(mnemonic)) {
      throw new Error('Not a valid mnemonic phrase');
    }
    if (
      fingerprint !==
      MultisigHDWallet.mnemonicToFingerprint(mnemonic, passphrase)
    ) {
      throw new Error("Fingerprint of new seed doesnt match");
    }
    this._cosigners[index] = mnemonic.trim()
    this._cosignersPassphrases[index] = passphrase || undefined
  }

  /**
   * Looks up cosigner with seed by index, and repalces it with xpub
   */
  replaceCosignerSeedWithXpub (externalIndex: number) {
    const index = externalIndex - 1
    const mnemonics = this._cosigners[index]
    if (!bip39.validateMnemonic(mnemonics)) {
      throw new Error(
        "This cosigner doesnt contain valid xpub mnemonic phrase",
      );
    }
    const passphrase = this._cosignersPassphrases[index]
    const path = this._cosignersCustomPaths[index] || this._derivationPath
    const xpub = this.convertXpubToMultisignatureXpub(
      MultisigHDWallet.seedToXpub(mnemonics, path, passphrase),
    )
    this._cosigners[index] = xpub
    this._cosignersPassphrases[index] = undefined
  }

  deleteCosigner (fp: string) {
    const foundIndex = this._cosignersFingerprints.indexOf(fp)
    if (foundIndex === -1) throw new Error("Cant find cosigner by fingerprint");

    this._cosignersFingerprints = this._cosignersFingerprints.filter(
      (el, index) => {
        return index !== foundIndex
      })

    this._cosigners = this._cosigners.filter((el, index) => {
      return index !== foundIndex
    });

    this._cosignersCustomPaths = this._cosignersCustomPaths.filter(
      (el, index) => {
        return index !== foundIndex
      })

    this._cosignersPassphrases = this._cosignersPassphrases.filter(
      (el, index) => {
        return index !== foundIndex
      })

    /* const newCosigners = [];
    for (let c = 0; c < this._cosignersFingerprints.length; c++) {
      if (c !== index)  newCosigners.push(this._cosignersFingerprints[c]);
    } */

    // this._cosignersFingerprints = newCosigners;
  }

  getFormat () {
    if (this.isNativeSegwit()) return MultisigHDWallet.FORMAT_P2WSH
    if (this.isWrappedSegwit()) return MultisigHDWallet.FORMAT_P2SH_P2WSH
    if (this.isLegacy()) return MultisigHDWallet.FORMAT_P2SH

    throw new Error("This should never happen");
  }

  /**
   * @param fp {string} Exactly 8 chars of hex
   * @return {boolean}
   */
  static isFpValid (fp: string) {
    if (fp.length !== 8) return false
    return /^[0-9A-F]{8}$/i.test(fp)
  }

  /**
   * Returns TRUE only for _multisignature_ xpubs as per SLIP-0132
   * (capital Z, capital Y, or just xpub)
   * @see https://github.com/satoshilabs/slips/blob/master/slip-0132.md
   *
   * @param xpub
   * @return {boolean}
   */
  static isXpubForMultisig (xpub: string): boolean {
    return ["xpub", "Ypub", "Zpub"].includes(xpub.substring(0, 4))
  }

  isSegwit () {
    return this.isNativeSegwit() || this.isWrappedSegwit()
  }
}


================================================
FILE: ./class/wallets/hd-segwit-p2sh-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory, { BIP32Interface } from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
import { Psbt } from 'bitcoinjs-lib';
import b58 from 'bs58check';
import { CoinSelectReturnInput } from 'coinselect';

import ecc from '../../malin_modules/noble_ecc';
import { concatUint8Arrays, hexToUint8Array } from '../../malin_modules/uint8array-extras';
import { AbstractHDElectrumWallet } from './abstract-hd-electrum-wallet';

const bip32 = BIP32Factory(ecc);

/**
 * HD Wallet (BIP39).
 * In particular, BIP49 (P2SH Segwit)
 * @see https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
 */
export class HDSegwitP2SHWallet extends AbstractHDElectrumWallet {
  static readonly type = 'HDsegwitP2SH';
  static readonly typeReadable = 'HD SegWit (BIP49 P2SH)';
  // @ts-ignore: override
  public readonly type = HDSegwitP2SHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = HDSegwitP2SHWallet.typeReadable;
  public readonly segwitType = 'p2sh(p2wpkh)';
  static readonly derivationPath = "m/49'/0'/0'";

  allowSend() {
    return true;
  }

  allowCosignPsbt() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }

  allowMasterFingerprint() {
    return true;
  }

  allowXpub() {
    return true;
  }

  _hdNodeToAddress(hdNode: BIP32Interface): string {
    return this._nodeToP2shSegwitAddress(hdNode);
  }

  /**
   * Returning ypub actually, not xpub. Keeping same method name
   * for compatibility.
   *
   * @return {String} ypub
   */
  getXpub() {
    if (this._xpub) {
      return this._xpub; // cache hit
    }
    // first, getting xpub
    const seed = this._getSeed();
    const root = bip32.fromSeed(seed);

    const path = this.getDerivationPath();
    if (!path) {
      throw new Error('Internal error: no path');
    }
    const child = root.derivePath(path).neutered();
    const xpub = child.toBase58();

    // bitcoinjs does not support ypub yet, so we just convert it from xpub
    let data = b58.decode(xpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('049d7cb2'), data]);
    this._xpub = b58.encode(concatenated);

    return this._xpub;
  }

  _addPsbtInput(psbt: Psbt, input: CoinSelectReturnInput, sequence: number, masterFingerprintBuffer: Uint8Array) {
    if (!input.address) {
      throw new Error('Internal error: no address on Utxo during _addPsbtInput()');
    }
    const pubkey = this._getPubkeyByAddress(input.address);
    const path = this._getDerivationPathByAddress(input.address);
    if (!pubkey || !path) {
      throw new Error('Internal error: pubkey or path are invalid');
    }
    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });
    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });
    if (!p2sh.output) {
      throw new Error('Internal error: no p2sh.output during _addPsbtInput()');
    }

    psbt.addInput({
      hash: input.txid,
      index: input.vout,
      sequence,
      bip32Derivation: [
        {
          masterFingerprint: masterFingerprintBuffer,
          path,
          pubkey,
        },
      ],
      witnessUtxo: {
        script: p2sh.output,
        value: BigInt(input.value),
      },
      redeemScript: p2wpkh.output,
    });

    return psbt;
  }

  isSegwit() {
    return true;
  }

  allowSilentPaymentSend(): boolean {
    return true;
  }
}


================================================
FILE: ./class/wallets/abstract-hd-electrum-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/* eslint react/prop-types: "off", @typescript-eslint/ban-ts-comment: "off", camelcase: "off"   */
import BIP47Factory, { BIP47Interface } from '@spsina/bip47';
import assert from 'assert';
import BigNumber from 'bignumber.js';
import BIP32Factory, { BIP32Interface } from 'bip32';
import * as bip39 from 'bip39';
import * as bitcoin from 'bitcoinjs-lib';
import { Psbt, Transaction as BTransaction } from 'bitcoinjs-lib';
import b58 from 'bs58check';
import { CoinSelectOutput, CoinSelectReturnInput } from 'coinselect';
import { ECPairFactory, ECPairInterface } from 'ecpair';

import * as MalinElectrum from '../../malin_modules/MalinElectrum';
import { ElectrumHistory } from '../../malin_modules/MalinElectrum';
import ecc from '../../malin_modules/noble_ecc';
import { hexToUint8Array, concatUint8Arrays, uint8ArrayToHex } from '../../malin_modules/uint8array-extras';
import { randomBytes } from '../rng';
import { AbstractHDWallet } from './abstract-hd-wallet';
import { CreateTransactionResult, CreateTransactionTarget, CreateTransactionUtxo, Transaction, Utxo } from './types';
import { SilentPayment, UTXOType as SPUTXOType, UTXO as SPUTXO } from 'silent-payments';
import { isValidBech32Address } from '../../utils/isValidBech32Address';

const ECPair = ECPairFactory(ecc);
const bip32 = BIP32Factory(ecc);
const bip47 = BIP47Factory(ecc);

type BalanceByIndex = {
  c: number;
  u: number;
};

/**
 * Electrum - means that it utilizes Electrum protocol for blockchain data
 */
export class AbstractHDElectrumWallet extends AbstractHDWallet {
  static readonly type = 'abstract';
  static readonly typeReadable = 'abstract';
  static defaultRBFSequence = 2147483648; // 1 << 31, minimum for replaceable transactions as per BIP68
  static finalRBFSequence = 4294967295; // 0xFFFFFFFF
  // @ts-ignore: override
  public readonly type = AbstractHDElectrumWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = AbstractHDElectrumWallet.typeReadable;

  _balances_by_external_index: Record<number, BalanceByIndex>;
  _balances_by_internal_index: Record<number, BalanceByIndex>;

  // @ts-ignore
  _txs_by_external_index: Record<number, Transaction[]>;
  // @ts-ignore
  _txs_by_internal_index: Record<number, Transaction[]>;

  _utxo: any[];
  _fp: string;

  // BIP47
  _enable_BIP47: boolean;
  _payment_code: string;

  /**
   * payment codes of people who can pay us
   */
  _receive_payment_codes: string[];

  /**
   * payment codes of people whom we can pay
   */
  _send_payment_codes: string[];

  /**
   * joint addresses with remote counterparties, to receive funds
   */
  _addresses_by_payment_code_receive: Record<string, string[]>;

  /**
   * receive index
   */
  _next_free_payment_code_address_index_receive: Record<string, number>;

  /**
   * joint addresses with remote counterparties, whom we can send funds
   */
  _addresses_by_payment_code_send: Record<string, string[]>;

  /**
   * send index
   */
  _next_free_payment_code_address_index_send: Record<string, number>;

  /**
   * this is where we put transactions related to our PC receive addresses. this is both
   * incoming transactions AND outgoing transactions (when we spend those funds)
   *
   */
  _txs_by_payment_code_index: Record<string, Transaction[][]>;

  _balances_by_payment_code_index: Record<string, BalanceByIndex>;
  _bip47_instance?: BIP47Interface;

  constructor() {
    super();
    this._balances_by_external_index = {}; //  0 => { c: 0, u: 0 } // confirmed/unconfirmed
    this._balances_by_internal_index = {};

    this._txs_by_external_index = {};
    this._txs_by_internal_index = {};

    this._utxo = [];

    // BIP47
    this._enable_BIP47 = false;
    this._payment_code = '';
    this._receive_payment_codes = [];
    this._send_payment_codes = [];
    this._next_free_payment_code_address_index_receive = {};
    this._txs_by_payment_code_index = {};
    this._addresses_by_payment_code_send = {};
    this._next_free_payment_code_address_index_send = {};
    this._balances_by_payment_code_index = {};
    this._addresses_by_payment_code_receive = {};

    // cache
    this._fp = '';
  }

  /**
   * @inheritDoc
   */
  getBalance() {
    let ret = 0;
    for (const bal of Object.values(this._balances_by_external_index)) {
      ret += bal.c;
    }
    for (const bal of Object.values(this._balances_by_internal_index)) {
      ret += bal.c;
    }
    for (const pc of this._receive_payment_codes) {
      ret += this._getBalancesByPaymentCodeIndex(pc).c;
    }
    return ret + (this.getUnconfirmedBalance() < 0 ? this.getUnconfirmedBalance() : 0);
  }

  /**
   *
   * @inheritDoc
   */
  getUnconfirmedBalance() {
    let ret = 0;
    for (const bal of Object.values(this._balances_by_external_index)) {
      ret += bal.u;
    }
    for (const bal of Object.values(this._balances_by_internal_index)) {
      ret += bal.u;
    }
    for (const pc of this._receive_payment_codes) {
      ret += this._getBalancesByPaymentCodeIndex(pc).u;
    }
    return ret;
  }

  async generate() {
    const buf = await randomBytes(16);
    this.secret = bip39.entropyToMnemonic(uint8ArrayToHex(buf));
  }

  async generateFromEntropy(user: Uint8Array) {
    if (user.length !== 32 && user.length !== 16) {
      throw new Error('Entropy has to be 16 or 32 bytes long');
    }
    this.secret = bip39.entropyToMnemonic(uint8ArrayToHex(user));
  }

  _getExternalWIFByIndex(index: number): string | false {
    return this._getWIFByIndex(false, index);
  }

  _getInternalWIFByIndex(index: number): string | false {
    return this._getWIFByIndex(true, index);
  }

  /**
   * Get internal/external WIF by wallet index
   * @param {Boolean} internal
   * @param {Number} index
   * @returns {string|false} Either string WIF or FALSE if error happened
   * @private
   */
  _getWIFByIndex(internal: boolean, index: number): string | false {
    if (!this.secret) return false;
    const seed = this._getSeed();
    const root = bip32.fromSeed(seed);
    const path = `${this.getDerivationPath()}/${internal ? 1 : 0}/${index}`;
    const child = root.derivePath(path);

    return child.toWIF();
  }

  _getNodeAddressByIndex(node: number, index: number): string {
    index = index * 1; // cast to int
    if (node === 0) {
      if (this.external_addresses_cache[index]) return this.external_addresses_cache[index]; // cache hit
    }

    if (node === 1) {
      if (this.internal_addresses_cache[index]) return this.internal_addresses_cache[index]; // cache hit
    }

    if (node === 0 && !this._node0) {
      const xpub = this._zpubToXpub(this.getXpub());
      const hdNode = bip32.fromBase58(xpub);
      this._node0 = hdNode.derive(node);
    }

    if (node === 1 && !this._node1) {
      const xpub = this._zpubToXpub(this.getXpub());
      const hdNode = bip32.fromBase58(xpub);
      this._node1 = hdNode.derive(node);
    }

    let address: string;
    if (node === 0) {
      // @ts-ignore
      address = this._hdNodeToAddress(this._node0.derive(index));
    } else {
      // tbh the only possible else is node === 1
      // @ts-ignore
      address = this._hdNodeToAddress(this._node1.derive(index));
    }

    if (node === 0) {
      return (this.external_addresses_cache[index] = address);
    } else {
      // tbh the only possible else option is node === 1
      return (this.internal_addresses_cache[index] = address);
    }
  }

  _getNodePubkeyByIndex(node: number, index: number) {
    index = index * 1; // cast to int

    if (node === 0 && !this._node0) {
      const xpub = this._zpubToXpub(this.getXpub());
      const hdNode = bip32.fromBase58(xpub);
      this._node0 = hdNode.derive(node);
    }

    if (node === 1 && !this._node1) {
      const xpub = this._zpubToXpub(this.getXpub());
      const hdNode = bip32.fromBase58(xpub);
      this._node1 = hdNode.derive(node);
    }

    if (node === 0 && this._node0) {
      return this._node0.derive(index).publicKey;
    }

    if (node === 1 && this._node1) {
      return this._node1.derive(index).publicKey;
    }

    throw new Error('Internal error: this._node0 or this._node1 is undefined');
  }

  _getExternalAddressByIndex(index: number): string {
    return this._getNodeAddressByIndex(0, index);
  }

  _getInternalAddressByIndex(index: number) {
    return this._getNodeAddressByIndex(1, index);
  }

  /**
   * Returning zpub actually, not xpub. Keeping same method name
   * for compatibility.
   *
   * @return {String} zpub
   */
  getXpub() {
    if (this._xpub) {
      return this._xpub; // cache hit
    }
    // first, getting xpub
    const seed = this._getSeed();
    const root = bip32.fromSeed(seed);

    const path = this.getDerivationPath();
    if (!path) {
      throw new Error('Internal error: no path');
    }
    const child = root.derivePath(path).neutered();
    const xpub = child.toBase58();

    // bitcoinjs does not support zpub yet, so we just convert it from xpub
    let data = b58.decode(xpub);
    data = data.slice(4);
    const concatenated = concatUint8Arrays([hexToUint8Array('04b24746'), data]);
    this._xpub = b58.encode(concatenated);

    return this._xpub;
  }

  /**
   * @inheritDoc
   */
  async fetchTransactions() {
    // if txs are absent for some internal address in hierarchy - this is a sign
    // we should fetch txs for that address
    // OR if some address has unconfirmed balance - should fetch it's txs
    // OR some tx for address is unconfirmed
    // OR some tx has < 7 confirmations

    // fetching transactions in batch: first, getting batch history for all addresses,
    // then batch fetching all involved txids
    // finally, batch fetching txids of all inputs (needed to see amounts & addresses of those inputs)
    // then we combine it all together

    const addresses2fetch = [];
    // Store these values to avoid a race condition if fetchBalance func changes them
    const next_free_address_index = this.next_free_address_index;
    const next_free_change_address_index = this.next_free_change_address_index;

    for (let c = 0; c < next_free_address_index + this.gap_limit; c++) {
      // external addresses first
      let hasUnconfirmed = false;
      this._txs_by_external_index[c] = this._txs_by_external_index[c] || [];
      for (const tx of this._txs_by_external_index[c]) hasUnconfirmed = hasUnconfirmed || !tx.confirmations || tx.confirmations < 7;

      if (hasUnconfirmed || this._txs_by_external_index[c].length === 0 || this._balances_by_external_index[c].u !== 0) {
        addresses2fetch.push(this._getExternalAddressByIndex(c));
      }
    }

    for (let c = 0; c < next_free_change_address_index + this.gap_limit; c++) {
      // next, internal addresses
      let hasUnconfirmed = false;
      this._txs_by_internal_index[c] = this._txs_by_internal_index[c] || [];
      for (const tx of this._txs_by_internal_index[c]) hasUnconfirmed = hasUnconfirmed || !tx.confirmations || tx.confirmations < 7;

      if (hasUnconfirmed || this._txs_by_internal_index[c].length === 0 || this._balances_by_internal_index[c].u !== 0) {
        addresses2fetch.push(this._getInternalAddressByIndex(c));
      }
    }

    // next, bip47 addresses
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        let hasUnconfirmed = false;
        this._txs_by_payment_code_index[pc] = this._txs_by_payment_code_index[pc] || {};
        this._txs_by_payment_code_index[pc][c] = this._txs_by_payment_code_index[pc][c] || [];
        for (const tx of this._txs_by_payment_code_index[pc][c])
          hasUnconfirmed = hasUnconfirmed || !tx.confirmations || tx.confirmations < 7;

        if (hasUnconfirmed || this._txs_by_payment_code_index[pc][c].length === 0 || this._balances_by_payment_code_index[pc].u !== 0) {
          addresses2fetch.push(this._getBIP47AddressReceive(pc, c));
        }
      }
    }

    // first: batch fetch for all addresses histories
    const histories = await MalinElectrum.multiGetHistoryByAddress(addresses2fetch);
    const txs: Record<string, ElectrumHistory> = {};
    for (const history of Object.values(histories)) {
      for (const tx of history as ElectrumHistory[]) {
        txs[tx.tx_hash] = tx;
      }
    }

    // next, batch fetching each txid we got
    const txdatas = await MalinElectrum.multiGetTransactionByTxid(Object.keys(txs), true);

    // now, tricky part. we collect all transactions from inputs (vin), and batch fetch them too.
    // then we combine all this data (we need inputs to see source addresses and amounts)
    const vinTxids = [];
    for (const txdata of Object.values(txdatas)) {
      if (txdata.vin.length > 99) continue;
      // ^^^ cutoff, some transactions have thousands of inputs, so the resulting array of txs for inputs to fetch
      // might be dozens of thousands. too much to handle, so we skip such transactions
      for (const vin of txdata.vin) {
        vin.txid && vinTxids.push(vin.txid);
        // ^^^^ not all inputs have txid, some of them are Coinbase (newly-created coins)
      }
    }
    const vintxdatas = await MalinElectrum.multiGetTransactionByTxid(vinTxids, true);

    // fetched all transactions from our inputs. now we need to combine it.
    // iterating all _our_ transactions:
    for (const txid of Object.keys(txdatas)) {
      // iterating all inputs our our single transaction:
      for (let inpNum = 0; inpNum < txdatas[txid].vin.length; inpNum++) {
        const inpTxid = txdatas[txid].vin[inpNum].txid;
        const inpVout = txdatas[txid].vin[inpNum].vout;
        // got txid and output number of _previous_ transaction we shoud look into
        if (vintxdatas[inpTxid]?.vout[inpVout]) {
          // extracting amount & addresses from previous output and adding it to _our_ input:
          txdatas[txid].vin[inpNum].addresses = vintxdatas[inpTxid].vout[inpVout].scriptPubKey.addresses;
          txdatas[txid].vin[inpNum].value = vintxdatas[inpTxid].vout[inpVout].value;
        }
      }
    }

    // now purge all unconfirmed txs from internal hashmaps, since some may be evicted from mempool because they became invalid
    // or replaced. hashmaps are going to be re-populated anyways, since we fetched TXs for addresses with unconfirmed TXs
    for (let c = 0; c < next_free_address_index + this.gap_limit; c++) {
      this._txs_by_external_index[c] = this._txs_by_external_index[c].filter(tx => !!tx.confirmations);
    }
    for (let c = 0; c < next_free_change_address_index + this.gap_limit; c++) {
      this._txs_by_internal_index[c] = this._txs_by_internal_index[c].filter(tx => !!tx.confirmations);
    }
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        this._txs_by_payment_code_index[pc][c] = this._txs_by_payment_code_index[pc][c].filter(tx => !!tx.confirmations);
      }
    }

    // now, we need to put transactions in all relevant `cells` of internal hashmaps:
    // this._txs_by_internal_index, this._txs_by_external_index & this._txs_by_payment_code_index

    for (let c = 0; c < next_free_address_index + this.gap_limit; c++) {
      for (const tx of Object.values(txdatas)) {
        for (const vin of tx.vin) {
          if (vin.addresses && vin.addresses.indexOf(this._getExternalAddressByIndex(c)) !== -1) {
            // this TX is related to our address
            this._txs_by_external_index[c] = this._txs_by_external_index[c] || [];
            const { vin: txVin, vout: txVout, ...txRest } = tx;
            const clonedTx = {
              ...txRest,
              inputs: txVin.slice(0),
              outputs: txVout.slice(0),
              timestamp: tx.blocktime || tx.time || Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
            };

            // trying to replace tx if it exists already (because it has lower confirmations, for example)
            let replaced = false;
            for (let cc = 0; cc < this._txs_by_external_index[c].length; cc++) {
              if (this._txs_by_external_index[c][cc].txid === clonedTx.txid) {
                replaced = true;
                this._txs_by_external_index[c][cc] = clonedTx;
              }
            }
            if (!replaced) this._txs_by_external_index[c].push(clonedTx);
          }
        }
        for (const vout of tx.vout) {
          if (vout.scriptPubKey.addresses && vout.scriptPubKey.addresses.indexOf(this._getExternalAddressByIndex(c)) !== -1) {
            // this TX is related to our address
            this._txs_by_external_index[c] = this._txs_by_external_index[c] || [];
            const { vin: txVin, vout: txVout, ...txRest } = tx;
            const clonedTx = {
              ...txRest,
              inputs: txVin.slice(0),
              outputs: txVout.slice(0),
              timestamp: tx.blocktime || tx.time || Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
            };

            // trying to replace tx if it exists already (because it has lower confirmations, for example)
            let replaced = false;
            for (let cc = 0; cc < this._txs_by_external_index[c].length; cc++) {
              if (this._txs_by_external_index[c][cc].txid === clonedTx.txid) {
                replaced = true;
                this._txs_by_external_index[c][cc] = clonedTx;
              }
            }
            if (!replaced) this._txs_by_external_index[c].push(clonedTx);
          }
        }
      }
    }

    for (let c = 0; c < next_free_change_address_index + this.gap_limit; c++) {
      for (const tx of Object.values(txdatas)) {
        for (const vin of tx.vin) {
          if (vin.addresses && vin.addresses.indexOf(this._getInternalAddressByIndex(c)) !== -1) {
            // this TX is related to our address
            this._txs_by_internal_index[c] = this._txs_by_internal_index[c] || [];
            const { vin: txVin, vout: txVout, ...txRest } = tx;
            const clonedTx = {
              ...txRest,
              inputs: txVin.slice(0),
              outputs: txVout.slice(0),
              timestamp: tx.blocktime || tx.time || Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
            };

            // trying to replace tx if it exists already (because it has lower confirmations, for example)
            let replaced = false;
            for (let cc = 0; cc < this._txs_by_internal_index[c].length; cc++) {
              if (this._txs_by_internal_index[c][cc].txid === clonedTx.txid) {
                replaced = true;
                this._txs_by_internal_index[c][cc] = clonedTx;
              }
            }
            if (!replaced) this._txs_by_internal_index[c].push(clonedTx);
          }
        }
        for (const vout of tx.vout) {
          if (vout.scriptPubKey.addresses && vout.scriptPubKey.addresses.indexOf(this._getInternalAddressByIndex(c)) !== -1) {
            // this TX is related to our address
            this._txs_by_internal_index[c] = this._txs_by_internal_index[c] || [];
            const { vin: txVin, vout: txVout, ...txRest } = tx;
            const clonedTx = {
              ...txRest,
              inputs: txVin.slice(0),
              outputs: txVout.slice(0),
              timestamp: tx.blocktime || tx.time || Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
            };

            // trying to replace tx if it exists already (because it has lower confirmations, for example)
            let replaced = false;
            for (let cc = 0; cc < this._txs_by_internal_index[c].length; cc++) {
              if (this._txs_by_internal_index[c][cc].txid === clonedTx.txid) {
                replaced = true;
                this._txs_by_internal_index[c][cc] = clonedTx;
              }
            }
            if (!replaced) this._txs_by_internal_index[c].push(clonedTx);
          }
        }
      }
    }

    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        for (const tx of Object.values(txdatas)) {
          // since we are iterating PCs who can pay us, we can completely ignore `tx.vin` and only iterate `tx.vout`
          for (const vout of tx.vout) {
            if (vout.scriptPubKey.addresses && vout.scriptPubKey.addresses.indexOf(this._getBIP47AddressReceive(pc, c)) !== -1) {
              // this TX is related to our address
              this._txs_by_payment_code_index[pc] = this._txs_by_payment_code_index[pc] || {};
              this._txs_by_payment_code_index[pc][c] = this._txs_by_payment_code_index[pc][c] || [];
              const { vin: txVin, vout: txVout, ...txRest } = tx;
              const clonedTx = {
                ...txRest,
                inputs: txVin.slice(0),
                outputs: txVout.slice(0),
                timestamp: tx.blocktime || tx.time || Math.floor(+new Date() / 1000) - 30 /* unconfirmed */,
              };

              // trying to replace tx if it exists already (because it has lower confirmations, for example)
              let replaced = false;
              for (let cc = 0; cc < this._txs_by_payment_code_index[pc][c].length; cc++) {
                if (this._txs_by_payment_code_index[pc][c][cc].txid === clonedTx.txid) {
                  replaced = true;
                  this._txs_by_payment_code_index[pc][c][cc] = clonedTx;
                }
              }
              if (!replaced) this._txs_by_payment_code_index[pc][c].push(clonedTx);
            }
          }
        }
      }
    }

    this._lastTxFetch = +new Date();
  }

  getTransactions() {
    let txs: Transaction[] = [];

    for (const addressTxs of Object.values(this._txs_by_external_index)) {
      txs = txs.concat(addressTxs);
    }
    for (const addressTxs of Object.values(this._txs_by_internal_index)) {
      txs = txs.concat(addressTxs);
    }
    if (this._receive_payment_codes) {
      for (const pc of this._receive_payment_codes) {
        if (this._txs_by_payment_code_index[pc])
          for (const addressTxs of Object.values(this._txs_by_payment_code_index[pc])) {
            txs = txs.concat(addressTxs);
          }
      }
    }

    if (txs.length === 0) return []; // guard clause; so we wont spend time calculating addresses

    // its faster to pre-build hashmap of owned addresses than to query `this.weOwnAddress()`, which in turn
    // iterates over all addresses in hierarchy
    const ownedAddressesHashmap: Record<string, boolean> = {};
    for (let c = 0; c < this.next_free_address_index + 1; c++) {
      ownedAddressesHashmap[this._getExternalAddressByIndex(c)] = true;
    }
    for (let c = 0; c < this.next_free_change_address_index + 1; c++) {
      ownedAddressesHashmap[this._getInternalAddressByIndex(c)] = true;
    }
    if (this._receive_payment_codes)
      for (const pc of this._receive_payment_codes) {
        for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + 1; c++) {
          ownedAddressesHashmap[this._getBIP47AddressReceive(pc, c)] = true;
        }
      }
    // hack: in case this code is called from LegacyWallet:
    if (this.getAddress()) ownedAddressesHashmap[String(this.getAddress())] = true;

    const ret: Transaction[] = [];
    for (const tx of txs) {
      tx.timestamp = tx.blocktime;
      if (!tx.blocktime) tx.timestamp = Math.floor(+new Date() / 1000) - 30; // unconfirmed
      tx.confirmations = tx.confirmations || 0; // unconfirmed
      tx.hash = tx.txid;
      tx.value = 0;

      for (const vin of tx.inputs) {
        // if input (spending) goes from our address - we are loosing!
        if ((vin.address && ownedAddressesHashmap[vin.address]) || (vin.addresses?.[0] && ownedAddressesHashmap[vin.addresses[0]])) {
          tx.value -= new BigNumber(vin.value ?? 0).multipliedBy(100000000).toNumber();
        }
      }

      for (const vout of tx.outputs) {
        // when output goes to our address - this means we are gaining!
        if (vout.scriptPubKey.addresses?.[0] && ownedAddressesHashmap[vout.scriptPubKey.addresses[0]]) {
          tx.value += new BigNumber(vout.value).multipliedBy(100000000).toNumber();
        }
      }

      if (this.allowBIP47() && this.isBIP47Enabled()) {
        tx.counterparty = this.getBip47CounterpartyByTx(tx);
      }
      ret.push(tx);
    }

    // now, deduplication:
    const usedTxIds: Record<string, number> = {};
    const ret2 = [];
    for (const tx of ret) {
      if (!usedTxIds[tx.txid]) ret2.push(tx);
      usedTxIds[tx.txid] = 1;
    }

    return ret2.sort(function (a, b) {
      return Number(b.timestamp) - Number(a.timestamp);
    });
  }

  async _binarySearchIterationForInternalAddress(index: number) {
    const gerenateChunkAddresses = (chunkNum: number) => {
      const ret = [];
      for (let c = this.gap_limit * chunkNum; c < this.gap_limit * (chunkNum + 1); c++) {
        ret.push(this._getInternalAddressByIndex(c));
      }
      return ret;
    };

    let lastChunkWithUsedAddressesNum = null;
    let lastHistoriesWithUsedAddresses = null;
    for (let c = 0; c < Math.round(index / this.gap_limit); c++) {
      const histories = await MalinElectrum.multiGetHistoryByAddress(gerenateChunkAddresses(c));
      // @ts-ignore
      if (this.constructor._getTransactionsFromHistories(histories).length > 0) {
        // in this particular chunk we have used addresses
        lastChunkWithUsedAddressesNum = c;
        lastHistoriesWithUsedAddresses = histories;
      } else {
        // empty chunk. no sense searching more chunks
        break;
      }
    }

    let lastUsedIndex = 0;

    if (lastHistoriesWithUsedAddresses) {
      // now searching for last used address in batch lastChunkWithUsedAddressesNum
      for (
        let c = Number(lastChunkWithUsedAddressesNum) * this.gap_limit;
        c < Number(lastChunkWithUsedAddressesNum) * this.gap_limit + this.gap_limit;
        c++
      ) {
        const address = this._getInternalAddressByIndex(c);
        if (lastHistoriesWithUsedAddresses[address] && lastHistoriesWithUsedAddresses[address].length > 0) {
          lastUsedIndex = Math.max(c, lastUsedIndex) + 1; // point to next, which is supposed to be unused
        }
      }
    }

    return lastUsedIndex;
  }

  async _binarySearchIterationForExternalAddress(index: number) {
    const gerenateChunkAddresses = (chunkNum: number) => {
      const ret = [];
      for (let c = this.gap_limit * chunkNum; c < this.gap_limit * (chunkNum + 1); c++) {
        ret.push(this._getExternalAddressByIndex(c));
      }
      return ret;
    };

    let lastChunkWithUsedAddressesNum = null;
    let lastHistoriesWithUsedAddresses = null;
    for (let c = 0; c < Math.round(index / this.gap_limit); c++) {
      const histories = await MalinElectrum.multiGetHistoryByAddress(gerenateChunkAddresses(c));
      // @ts-ignore
      if (this.constructor._getTransactionsFromHistories(histories).length > 0) {
        // in this particular chunk we have used addresses
        lastChunkWithUsedAddressesNum = c;
        lastHistoriesWithUsedAddresses = histories;
      } else {
        // empty chunk. no sense searching more chunks
        break;
      }
    }

    let lastUsedIndex = 0;

    if (lastHistoriesWithUsedAddresses) {
      // now searching for last used address in batch lastChunkWithUsedAddressesNum
      for (
        let c = Number(lastChunkWithUsedAddressesNum) * this.gap_limit;
        c < Number(lastChunkWithUsedAddressesNum) * this.gap_limit + this.gap_limit;
        c++
      ) {
        const address = this._getExternalAddressByIndex(c);
        if (lastHistoriesWithUsedAddresses[address] && lastHistoriesWithUsedAddresses[address].length > 0) {
          lastUsedIndex = Math.max(c, lastUsedIndex) + 1; // point to next, which is supposed to be unused
        }
      }
    }

    return lastUsedIndex;
  }

  async _binarySearchIterationForBIP47Address(paymentCode: string, index: number) {
    const generateChunkAddresses = (chunkNum: number) => {
      const ret = [];
      for (let c = this.gap_limit * chunkNum; c < this.gap_limit * (chunkNum + 1); c++) {
        ret.push(this._getBIP47AddressReceive(paymentCode, c));
      }
      return ret;
    };

    let lastChunkWithUsedAddressesNum = null;
    let lastHistoriesWithUsedAddresses = null;
    for (let c = 0; c < Math.round(index / this.gap_limit); c++) {
      const histories = await MalinElectrum.multiGetHistoryByAddress(generateChunkAddresses(c));
      // @ts-ignore
      if (this.constructor._getTransactionsFromHistories(histories).length > 0) {
        // in this particular chunk we have used addresses
        lastChunkWithUsedAddressesNum = c;
        lastHistoriesWithUsedAddresses = histories;
      } else {
        // empty chunk. no sense searching more chunks
        break;
      }
    }

    let lastUsedIndex = 0;

    if (lastHistoriesWithUsedAddresses) {
      // now searching for last used address in batch lastChunkWithUsedAddressesNum
      for (
        let c = Number(lastChunkWithUsedAddressesNum) * this.gap_limit;
        c < Number(lastChunkWithUsedAddressesNum) * this.gap_limit + this.gap_limit;
        c++
      ) {
        const address = this._getBIP47AddressReceive(paymentCode, c);
        if (lastHistoriesWithUsedAddresses[address] && lastHistoriesWithUsedAddresses[address].length > 0) {
          lastUsedIndex = Math.max(c, lastUsedIndex) + 1; // point to next, which is supposed to be unused
        }
      }
    }

    return lastUsedIndex;
  }

  async fetchBalance() {
    try {
      if (this.next_free_change_address_index === 0 && this.next_free_address_index === 0) {
        // doing binary search for last used address:
        this.next_free_change_address_index = await this._binarySearchIterationForInternalAddress(1000);
        this.next_free_address_index = await this._binarySearchIterationForExternalAddress(1000);
        if (this._receive_payment_codes) {
          for (const pc of this._receive_payment_codes) {
            this._next_free_payment_code_address_index_receive[pc] = await this._binarySearchIterationForBIP47Address(pc, 1000);
          }
        }
      } // end rescanning fresh wallet

      // finally fetching balance
      await this._fetchBalance();
    } catch (err) {
      console.warn(err);
    }
  }

  async _fetchBalance() {
    // probing future addressess in hierarchy whether they have any transactions, in case
    // our 'next free addr' pointers are lagging behind
    // for that we are gona batch fetch history for all addresses between last used and last used + gap_limit

    const lagAddressesToFetch = [];
    for (let c = this.next_free_address_index; c < this.next_free_address_index + this.gap_limit; c++) {
      lagAddressesToFetch.push(this._getExternalAddressByIndex(c));
    }
    for (let c = this.next_free_change_address_index; c < this.next_free_change_address_index + this.gap_limit; c++) {
      lagAddressesToFetch.push(this._getInternalAddressByIndex(c));
    }
    for (const pc of this._receive_payment_codes) {
      for (
        let c = this._next_free_payment_code_address_index_receive[pc];
        c < this._next_free_payment_code_address_index_receive[pc] + this.gap_limit;
        c++
      ) {
        lagAddressesToFetch.push(this._getBIP47AddressReceive(pc, c));
      }
    }

    const txs = await MalinElectrum.multiGetHistoryByAddress(lagAddressesToFetch); // <------ electrum call

    for (let c = this.next_free_address_index; c < this.next_free_address_index + this.gap_limit; c++) {
      const address = this._getExternalAddressByIndex(c);
      if (txs[address] && Array.isArray(txs[address]) && txs[address].length > 0) {
        // whoa, someone uses our wallet outside! better catch up
        this.next_free_address_index = c + 1;
      }
    }

    for (let c = this.next_free_change_address_index; c < this.next_free_change_address_index + this.gap_limit; c++) {
      const address = this._getInternalAddressByIndex(c);
      if (txs[address] && Array.isArray(txs[address]) && txs[address].length > 0) {
        // whoa, someone uses our wallet outside! better catch up
        this.next_free_change_address_index = c + 1;
      }
    }

    for (const pc of this._receive_payment_codes) {
      for (
        let c = this._next_free_payment_code_address_index_receive[pc];
        c < this._next_free_payment_code_address_index_receive[pc] + this.gap_limit;
        c++
      ) {
        const address = this._getBIP47AddressReceive(pc, c);
        if (txs[address] && Array.isArray(txs[address]) && txs[address].length > 0) {
          // whoa, someone uses our wallet outside! better catch up
          this._next_free_payment_code_address_index_receive[pc] = c + 1;
        }
      }
    }

    // next, business as usuall. fetch balances

    const addresses2fetch = [];

    // generating all involved addresses.
    // basically, refetch all from index zero to maximum. doesnt matter
    // since we batch them 100 per call

    // external
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      addresses2fetch.push(this._getExternalAddressByIndex(c));
    }

    // internal
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      addresses2fetch.push(this._getInternalAddressByIndex(c));
    }

    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._next_free_payment_code_address_index_receive[pc] + this.gap_limit; c++) {
        addresses2fetch.push(this._getBIP47AddressReceive(pc, c));
      }
    }

    const balances = await MalinElectrum.multiGetBalanceByAddress(addresses2fetch);

    // converting to a more compact internal format
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      const addr = this._getExternalAddressByIndex(c);
      if (balances.addresses[addr]) {
        // first, if balances differ from what we store - we delete transactions for that
        // address so next fetchTransactions() will refetch everything
        if (this._balances_by_external_index[c]) {
          if (
            this._balances_by_external_index[c].c !== balances.addresses[addr].confirmed ||
            this._balances_by_external_index[c].u !== balances.addresses[addr].unconfirmed
          ) {
            delete this._txs_by_external_index[c];
          }
        }
        // update local representation of balances on that address:
        this._balances_by_external_index[c] = {
          c: balances.addresses[addr].confirmed,
          u: balances.addresses[addr].unconfirmed,
        };
      }
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      const addr = this._getInternalAddressByIndex(c);
      if (balances.addresses[addr]) {
        // first, if balances differ from what we store - we delete transactions for that
        // address so next fetchTransactions() will refetch everything
        if (this._balances_by_internal_index[c]) {
          if (
            this._balances_by_internal_index[c].c !== balances.addresses[addr].confirmed ||
            this._balances_by_internal_index[c].u !== balances.addresses[addr].unconfirmed
          ) {
            delete this._txs_by_internal_index[c];
          }
        }
        // update local representation of balances on that address:
        this._balances_by_internal_index[c] = {
          c: balances.addresses[addr].confirmed,
          u: balances.addresses[addr].unconfirmed,
        };
      }
    }

    for (const pc of this._receive_payment_codes) {
      let confirmed = 0;
      let unconfirmed = 0;
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        const addr = this._getBIP47AddressReceive(pc, c);
        if (balances.addresses[addr].confirmed || balances.addresses[addr].unconfirmed) {
          confirmed = confirmed + balances.addresses[addr].confirmed;
          unconfirmed = unconfirmed + balances.addresses[addr].unconfirmed;
        }
      }
      this._balances_by_payment_code_index[pc] = {
        c: confirmed,
        u: unconfirmed,
      };
    }

    this._lastBalanceFetch = +new Date();
  }

  async fetchUtxo(): Promise<void> {
    // fetching utxo of addresses that only have some balance
    let addressess = [];

    // considering confirmed balance:
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._balances_by_external_index?.[c]?.c > 0) {
        addressess.push(this._getExternalAddressByIndex(c));
      }
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      if (this._balances_by_internal_index?.[c]?.c > 0) {
        addressess.push(this._getInternalAddressByIndex(c));
      }
    }

    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._next_free_payment_code_address_index_receive[pc] + this.gap_limit; c++) {
        if (this._balances_by_payment_code_index?.[pc]?.c > 0) {
          addressess.push(this._getBIP47AddressReceive(pc, c));
        }
      }
    }

    // considering UNconfirmed balance:
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._balances_by_external_index?.[c]?.u > 0) {
        addressess.push(this._getExternalAddressByIndex(c));
      }
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      if (this._balances_by_internal_index?.[c]?.u > 0) {
        addressess.push(this._getInternalAddressByIndex(c));
      }
    }

    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._next_free_payment_code_address_index_receive[pc] + this.gap_limit; c++) {
        if (this._balances_by_payment_code_index?.[pc]?.u > 0) {
          addressess.push(this._getBIP47AddressReceive(pc, c));
        }
      }
    }

    // note: we could remove checks `.c` and `.u` to simplify code, but the resulting `addressess` array would be bigger, thus bigger batch
    // to fetch (or maybe even several fetches), which is not critical but undesirable.
    // anyway, result has `.confirmations` property for each utxo, so outside caller can easily filter out unconfirmed if he wants to

    addressess = [...new Set(addressess)]; // deduplicate just for any case

    const fetchedUtxo = await MalinElectrum.multiGetUtxoByAddress(addressess);
    this._utxo = [];
    for (const arr of Object.values(fetchedUtxo)) {
      this._utxo = this._utxo.concat(arr);
    }

    // this belongs in `.getUtxo()`
    for (const u of this._utxo) {
      u.wif = this._getWifForAddress(u.address);
      if (!u.confirmations && u.height) u.confirmations = MalinElectrum.estimateCurrentBlockheight() - u.height;
    }

    this._utxo = this._utxo.sort((a, b) => Number(a.value) - Number(b.value));
    // more consistent, so txhex in unit tests wont change
  }

  /**
   * Getter for previously fetched UTXO. For example:
   *     [ { height: 0,
   *    value: 666,
   *    address: 'string',
   *    vout: 1,
   *    txid: 'string',
   *    wif: 'string',
   *    confirmations: 0 } ]
   *
   * @param respectFrozen {boolean} Add Frozen outputs
   * @returns {[]}
   */
  getUtxo(respectFrozen = false) {
    let ret = [];

    if (this._utxo.length === 0) {
      ret = this.getDerivedUtxoFromOurTransaction(); // oy vey, no stored utxo. lets attempt to derive it from stored transactions
    } else {
      ret = this._utxo;
    }
    if (!respectFrozen) {
      ret = ret.filter(({ txid, vout }) => !this.getUTXOMetadata(txid, vout).frozen);
    }
    return ret;
  }

  getDerivedUtxoFromOurTransaction(returnSpentUtxoAsWell = false): Utxo[] {
    const utxos: Utxo[] = [];

    // its faster to pre-build hashmap of owned addresses than to query `this.weOwnAddress()`, which in turn
    // iterates over all addresses in hierarchy
    const ownedAddressesHashmap: Record<string, boolean> = {};
    for (let c = 0; c < this.next_free_address_index + 1; c++) {
      ownedAddressesHashmap[this._getExternalAddressByIndex(c)] = true;
    }
    for (let c = 0; c < this.next_free_change_address_index + 1; c++) {
      ownedAddressesHashmap[this._getInternalAddressByIndex(c)] = true;
    }
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + 1; c++) {
        ownedAddressesHashmap[this._getBIP47AddressReceive(pc, c)] = true;
      }
    }

    for (const tx of this.getTransactions()) {
      for (const output of tx.outputs) {
        let address: string | false = false;
        if (output.scriptPubKey && output.scriptPubKey.addresses && output.scriptPubKey.addresses[0]) {
          address = output.scriptPubKey.addresses[0];
        }
        if (ownedAddressesHashmap[String(address)]) {
          const value = new BigNumber(output.value).multipliedBy(100000000).toNumber();
          utxos.push({
            txid: tx.txid,
            vout: output.n,
            address: String(address),
            value,
            confirmations: tx.confirmations,
            wif: false,
            height: MalinElectrum.estimateCurrentBlockheight() - (tx.confirmations ?? 0),
          });
        }
      }
    }

    if (returnSpentUtxoAsWell) return utxos;

    // got all utxos we ever had. lets filter out the ones that are spent:
    const txs = this.getTransactions();
    const ret = [];
    for (const utxo of utxos) {
      let spent = false;
      for (const tx of txs) {
        for (const input of tx.inputs) {
          if (input.txid === utxo.txid && input.vout === utxo.vout) spent = true;
          // utxo we got previously was actually spent right here ^^
        }
      }

      if (!spent) {
        // filling WIFs only for legit unspent UTXO, as it is a slow operation
        utxo.wif = this._getWifForAddress(utxo.address);
        ret.push(utxo);
      }
    }

    return ret;
  }

  _getDerivationPathByAddress(address: string): string | false {
    const path = this.getDerivationPath();
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._getExternalAddressByIndex(c) === address) return path + '/0/' + c;
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      if (this._getInternalAddressByIndex(c) === address) return path + '/1/' + c;
    }
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        // not technically correct but well, to have at least somethign in PSBT...
        if (this._getBIP47AddressReceive(pc, c) === address) return "m/47'/0'/0'/" + c;
      }
    }

    return false;
  }

  /**
   *
   * @param address {string} Address that belongs to this wallet
   * @returns {Uint8Array|false} Either Uint8Array with pubkey or false
   */
  _getPubkeyByAddress(address: string): Uint8Array | false {
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._getExternalAddressByIndex(c) === address) return this._getNodePubkeyByIndex(0, c);
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      if (this._getInternalAddressByIndex(c) === address) return this._getNodePubkeyByIndex(1, c);
    }
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        if (this._getBIP47AddressReceive(pc, c) === address) return this._getBIP47PubkeyByIndex(pc, c);
      }
    }

    return false;
  }

  /**
   * Finds WIF corresponding to address and returns it
   *
   * @param address {string} Address that belongs to this wallet
   * @returns {string|false} WIF or false
   */
  _getWIFbyAddress(address: string): string | false {
    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._getExternalAddressByIndex(c) === address) return this._getWIFByIndex(false, c);
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      if (this._getInternalAddressByIndex(c) === address) return this._getWIFByIndex(true, c);
    }
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        if (this._getBIP47AddressReceive(pc, c) === address) return this._getBIP47WIF(pc, c);
      }
    }
    return false;
  }

  weOwnAddress(address: string) {
    if (!address) return false;
    let cleanAddress = address;

    const isBech32Address = isValidBech32Address(address);

    if (isBech32Address) {
      cleanAddress = address.toLocaleLowerCase();
    }

    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      if (this._getExternalAddressByIndex(c) === cleanAddress) return true;
    }
    for (let c = 0; c < this.next_free_change_address_index + this.gap_limit; c++) {
      if (this._getInternalAddressByIndex(c) === cleanAddress) return true;
    }
    for (const pc of this._receive_payment_codes) {
      for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit; c++) {
        if (this._getBIP47AddressReceive(pc, c) === address) return true;
      }
    }
    return false;
  }

  /**
   *
   * @param utxos {Array.<{vout: Number, value: Number, txid: String, address: String}>} List of spendable utxos
   * @param targets {Array.<{value: Number, address: String}>} Where coins are going. If theres only 1 target and that target has no value - this will send MAX to that address (respecting fee rate)
   * @param feeRate {Number} satoshi per byte
   * @param changeAddress {String} Excessive coins will go back to that address
   * @param sequence {Number} Used in RBF
   * @param skipSigning {boolean} Whether we should skip signing, use returned `psbt` in that case
   * @param masterFingerprint {number} Decimal number of wallet's master fingerprint
   * @returns {{outputs: Array, tx: Transaction, inputs: Array, fee: Number, psbt: Psbt}}
   */
  createTransaction(
    utxos: CreateTransactionUtxo[],
    targets: CreateTransactionTarget[],
    feeRate: number,
    changeAddress: string,
    sequence: number = AbstractHDElectrumWallet.defaultRBFSequence,
    skipSigning = false,
    masterFingerprint: number = 0,
  ): CreateTransactionResult {
    if (targets.length === 0) throw new Error('No destination provided');

    let { inputs, outputs, fee } = this.coinselect(utxos, targets, feeRate);

    const hasSilentPaymentOutput: boolean = !!outputs.find(o => o.address?.startsWith('sp1'));
    if (hasSilentPaymentOutput) {
      if (!this.allowSilentPaymentSend()) {
        throw new Error('This wallet can not send to SilentPayment address');
      }

      // for a single wallet all utxos gona be the same type, so we define it only once:
      let utxoType: SPUTXOType = 'non-eligible';
      switch (this.segwitType) {
        case 'p2tr':
          utxoType = 'p2tr';
          break;
        case 'p2sh(p2wpkh)':
          utxoType = 'p2sh-p2wpkh';
          break;
        case 'p2wpkh':
          utxoType = 'p2wpkh';
          break;
        default:
          // @ts-ignore override
          if (this.type === 'HDlegacyP2PKH') utxoType = 'p2pkh';
      }

      const spUtxos: SPUTXO[] = inputs.map(u => ({ ...u, utxoType, wif: u.wif! }));
      const sp = new SilentPayment();
      outputs = sp.createTransaction(spUtxos, outputs) as CoinSelectOutput[];
    }

    sequence = sequence || AbstractHDElectrumWallet.defaultRBFSequence;
    let psbt = new bitcoin.Psbt();
    let c = 0;
    const keypairs: Record<number, ECPairInterface> = {};
    const values: Record<number, number> = {};

    inputs.forEach(input => {
      let keyPair;
      if (!skipSigning) {
        // skiping signing related stuff
        keyPair = ECPair.fromWIF(this._getWifForAddress(String(input.address)));
        keypairs[c] = keyPair;
      }
      values[c] = input.value;
      c++;
      if (!skipSigning) {
        // skiping signing related stuff
        if (!input.address || !this._getWifForAddress(input.address)) throw new Error('Internal error: no address or WIF to sign input');
      }

      let masterFingerprintBuffer;
      if (masterFingerprint) {
        let masterFingerprintHex = Number(masterFingerprint).toString(16);
        if (masterFingerprintHex.length < 8) masterFingerprintHex = '0' + masterFingerprintHex; // conversion without explicit zero might result in lost byte
        const hexBuffer = hexToUint8Array(masterFingerprintHex);
        masterFingerprintBuffer = hexBuffer.reverse();
      } else {
        masterFingerprintBuffer = new Uint8Array([0x00, 0x00, 0x00, 0x00]);
      }
      // this is not correct fingerprint, as we dont know real fingerprint - we got zpub with 84/0, but fingerpting
      // should be from root. basically, fingerprint should be provided from outside  by user when importing zpub

      psbt = this._addPsbtInput(psbt, input, sequence, masterFingerprintBuffer);
    });

    outputs.forEach(output => {
      // if output has no address - this is change output or a custom script output
      let change = false;
      // @ts-ignore
      if (!output.address && !output.script?.hex) {
        change = true;
        output.address = changeAddress;
      }

      const path = this._getDerivationPathByAddress(String(output.address));
      const pubkey = this._getPubkeyByAddress(String(output.address));
      let masterFingerprintBuffer;

      if (masterFingerprint) {
        let masterFingerprintHex = Number(masterFingerprint).toString(16);
        if (masterFingerprintHex.length < 8) masterFingerprintHex = '0' + masterFingerprintHex; // conversion without explicit zero might result in lost byte
        const hexBuffer = hexToUint8Array(masterFingerprintHex);
        masterFingerprintBuffer = hexBuffer.reverse();
      } else {
        masterFingerprintBuffer = new Uint8Array([0x00, 0x00, 0x00, 0x00]);
      }

      // this is not correct fingerprint, as we dont know realfingerprint - we got zpub with 84/0, but fingerpting
      // should be from root. basically, fingerprint should be provided from outside  by user when importing zpub

      if (output.address?.startsWith('PM')) {
        // ok its BIP47 payment code, so we need to unwrap a joint address for the receiver and use it instead:
        output.address = this._getNextFreePaymentCodeAddressSend(output.address);
        // ^^^ trusting that notification transaction is in place
      }

      psbt.addOutput({
        address: output.address,
        // @ts-ignore types from bitcoinjs are not exported so we cant define outputData separately and add fields conditionally (either address or script should be present)
        script: output.script?.hex ? hexToUint8Array(output.script.hex) : undefined,
        value: BigInt(output.value),
        bip32Derivation:
          change && path && pubkey && this.segwitType !== 'p2tr'
            ? [
                {
                  masterFingerprint: masterFingerprintBuffer,
                  path,
                  pubkey,
                },
              ]
            : [],
        tapBip32Derivation:
          this.segwitType === 'p2tr' && pubkey && path && change
            ? [
                {
                  pubkey: new Uint8Array(pubkey),
                  masterFingerprint: new Uint8Array(masterFingerprintBuffer),
                  path,
                  leafHashes: [],
                },
              ]
            : [],
        ...(this.segwitType === 'p2tr' && pubkey ? { tapInternalKey: new Uint8Array(pubkey) } : {}),
      });
    });

    if (!skipSigning) {
      // skiping signing related stuff
      for (let cc = 0; cc < c; cc++) {
        if (this.segwitType === 'p2tr') {
          assert(psbt.data.inputs[cc].tapInternalKey, 'TapInternalKey is required for taproot inputs');
          psbt.signTaprootInput(
            cc,
            keypairs[cc].tweak(bitcoin.crypto.taggedHash('TapTweak', psbt.data.inputs[cc].tapInternalKey as Uint8Array)),
          );
        } else {
          psbt.signInput(cc, keypairs[cc]);
        }
      }
    }

    let tx;
    if (!skipSigning) {
      tx = psbt.finalizeAllInputs().extractTransaction();
    }
    return { tx, inputs, outputs, fee, psbt };
  }

  _addPsbtInput(psbt: Psbt, input: CoinSelectReturnInput, sequence: number, masterFingerprintBuffer: Uint8Array) {
    if (!input.address) {
      throw new Error('Internal error: no address on Utxo during _addPsbtInput()');
    }
    const pubkey = this._getPubkeyByAddress(input.address);
    const path = this._getDerivationPathByAddress(input.address);
    if (!pubkey || !path) {
      throw new Error('Internal error: pubkey or path are invalid');
    }
    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });
    if (!p2wpkh.output) {
      throw new Error('Internal error: could not create p2wpkh output during _addPsbtInput');
    }

    psbt.addInput({
      hash: input.txid,
      index: input.vout,
      sequence,
      bip32Derivation: [
        {
          masterFingerprint: masterFingerprintBuffer,
          path,
          pubkey,
        },
      ],
      witnessUtxo: {
        script: p2wpkh.output,
        value: BigInt(input.value),
      },
    });

    return psbt;
  }

  /**
   * Combines 2 PSBTs into final transaction from which you can
   * get HEX and broadcast
   *
   * @param base64one {string|Psbt}
   * @param base64two {string|Psbt}
   * @returns {Transaction}
   */
  combinePsbt(base64one: string | Psbt, base64two: string | Psbt) {
    const final1 = typeof base64one === 'string' ? bitcoin.Psbt.fromBase64(base64one) : base64one;
    const final2 = typeof base64two === 'string' ? bitcoin.Psbt.fromBase64(base64two) : base64two;
    final1.combine(final2);

    let extractedTransaction;
    try {
      extractedTransaction = final1.finalizeAllInputs().extractTransaction();
    } catch (_) {
      // probably already finalized
      extractedTransaction = final1.extractTransaction();
    }

    return extractedTransaction;
  }

  /**
   * Creates Segwit Bech32 Bitcoin address
   */
  _nodeToBech32SegwitAddress(hdNode: BIP32Interface): string {
    const { address } = bitcoin.payments.p2wpkh({
      pubkey: hdNode.publicKey,
    });

    if (!address) {
      throw new Error('Could not create address in _nodeToBech32SegwitAddress');
    }

    return address;
  }

  _nodeToLegacyAddress(hdNode: BIP32Interface): string {
    const { address } = bitcoin.payments.p2pkh({
      pubkey: hdNode.publicKey,
    });

    if (!address) {
      throw new Error('Could not create address in _nodeToLegacyAddress');
    }

    return address;
  }

  /**
   * Creates Segwit P2SH Bitcoin address
   */
  _nodeToP2shSegwitAddress(hdNode: BIP32Interface): string {
    const { address } = bitcoin.payments.p2sh({
      redeem: bitcoin.payments.p2wpkh({ pubkey: hdNode.publicKey }),
    });

    if (!address) {
      throw new Error('Could not create address in _nodeToP2shSegwitAddress');
    }

    return address;
  }

  static _getTransactionsFromHistories(histories: Record<string, ElectrumHistory[]>) {
    const txs = [];
    for (const history of Object.values(histories)) {
      for (const tx of history) {
        txs.push(tx);
      }
    }
    return txs;
  }

  /**
   * Probes zero address in external hierarchy for transactions, if there are any returns TRUE.
   * Zero address is a pretty good indicator, since its a first one to fund the wallet.
   * Q: How can you use the wallet and not fund it first?
   * A: You can if it is a BIP47 wallet!
   *
   * @returns {Promise<boolean>}
   */
  async wasEverUsed(): Promise<boolean> {
    const txs1 = await MalinElectrum.getTransactionsByAddress(this._getExternalAddressByIndex(0));
    if (txs1.length > 0) {
      return true;
    }
    if (!this.allowBIP47()) {
      return false;
    }
    try {
      // watch-only wallet will throw an error here
      this.getDerivationPath();
    } catch (_) {
      return false;
    }
    // only check BIP47 if derivation path is regular, otherwise too many wallets will be found
    if (!["m/84'/0'/0'", "m/44'/0'/0'", "m/49'/0'/0'"].includes(this.getDerivationPath() as string)) {
      return false;
    }

    const bip47_instance = this.getBIP47FromSeed();
    const address = bip47_instance.getNotificationAddress();
    const txs2 = await MalinElectrum.getTransactionsByAddress(address);
    return txs2.length > 0;
  }

  /**
   * @inheritDoc
   */
  getAllExternalAddresses() {
    const ret = [];

    for (let c = 0; c < this.next_free_address_index + this.gap_limit; c++) {
      ret.push(this._getExternalAddressByIndex(c));
    }

    if (this.allowBIP47() && this.isBIP47Enabled()) {
      // returning BIP47 joint addresses with everyone who can pay us because they are kinda our 'external' aka 'receive' addresses

      for (const pc of this._receive_payment_codes) {
        for (let c = 0; c < this._getNextFreePaymentCodeIndexReceive(pc) + this.gap_limit / 4; c++) {
          //  ^^^ not full gap limit to reduce computation (theoretically, there should not be gaps at all)
          ret.push(this._getBIP47AddressReceive(pc, c));
        }
      }
    }

    return ret;
  }

  /**
   * Check if address is a Change address. Needed for Coin control.
   *
   * @param address
   * @returns {Boolean} Either address is a change or not
   */
  addressIsChange(address: string) {
    for (let c = 0; c < this.next_free_change_address_index + 1; c++) {
      if (address === this._getInternalAddressByIndex(c)) return true;
    }
    return false;
  }

  calculateHowManySignaturesWeHaveFromPsbt(psbt: Psbt) {
    let sigsHave = 0;
    for (const inp of psbt.data.inputs) {
      if (inp.finalScriptSig || inp.finalScriptWitness || inp.partialSig) sigsHave++;
    }
    return sigsHave;
  }

  /**
   * Tries to signs passed psbt object (by reference). If there are enough signatures - tries to finalize psbt
   * and returns Transaction (ready to extract hex)
   *
   * @param psbt {Psbt}
   * @returns {{ tx: Transaction }}
   */
  cosignPsbt(psbt: Psbt) {
    const seed = this._getSeed();
    const hdRoot = bip32.fromSeed(seed);

    for (let cc = 0; cc < psbt.inputCount; cc++) {
      try {
        psbt.signInputHD(cc, hdRoot);
      } catch (e) {} // protects agains duplicate cosignings

      if (!psbt.inputHasHDKey(cc, hdRoot)) {
        for (const derivation of psbt.data.inputs[cc].bip32Derivation || []) {
          const splt = derivation.path.split('/');
          const internal = +splt[splt.length - 2];
          const index = +splt[splt.length - 1];
          const wif = this._getWIFByIndex(!!internal, index);
          if (!wif) {
            throw new Error('Internal error: cant get WIF by index during cosingPsbt');
          }
          const keyPair = ECPair.fromWIF(wif);
          try {
            psbt.signInput(cc, keyPair);
          } catch (e) {} // protects agains duplicate cosignings or if this output can't be signed with current wallet
        }
      }
    }

    let tx: BTransaction | false = false;
    if (this.calculateHowManySignaturesWeHaveFromPsbt(psbt) === psbt.inputCount) {
      tx = psbt.finalizeAllInputs().extractTransaction();
    }

    return { tx };
  }

  /**
   * @param seed {Buffer} Buffer object with seed
   * @returns {string} Hex string of fingerprint derived from mnemonics. Always has length of 8 chars and correct leading zeroes. All caps
   */
  static seedToFingerprint(seed: Buffer) {
    const root = bip32.fromSeed(seed);
    let hex = uint8ArrayToHex(root.fingerprint);
    while (hex.length < 8) hex = '0' + hex; // leading zeroes
    return hex.toUpperCase();
  }

  /**
   * @param mnemonic {string}  Mnemonic phrase (12 or 24 words)
   * @returns {string} Hex fingerprint
   */
  static mnemonicToFingerprint(mnemonic: string, passphrase?: string) {
    const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);
    return AbstractHDElectrumWallet.seedToFingerprint(seed);
  }

  /**
   * @returns Hex string of fingerprint derived from wallet mnemonics. Always has length of 8 chars and correct leading zeroes
   */
  getMasterFingerprintHex() {
    if (this._fp) {
      return this._fp; // cache hit
    }

    const seed = this._getSeed();
    this._fp = AbstractHDElectrumWallet.seedToFingerprint(seed);
    return this._fp;
  }

  /**
   * Whether BIP47 is enabled. This is per-wallet setting that can be changed, NOT a feature-flag
   * @returns boolean
   */
  isBIP47Enabled(): boolean {
    return this._enable_BIP47;
  }

  switchBIP47(value: boolean): void {
    this._enable_BIP47 = value;
  }

  getBIP47FromSeed(): BIP47Interface {
    if (!this._bip47_instance || !this._bip47_instance.getNotificationAddress) {
      this._bip47_instance = bip47.fromBip39Seed(this.secret, undefined, this.passphrase);
    }

    return this._bip47_instance;
  }

  /**
   * find and return _existing_ notification transaction for the given payment code
   * (i.e. if it exists - we notified in the past and dont need to notify again)
   */
  getBIP47NotificationTransaction(receiverPaymentCode: string): Transaction | undefined {
    const publicBip47 = BIP47Factory(ecc).fromPaymentCode(receiverPaymentCode);
    const remoteNotificationAddress = publicBip47.getNotificationAddress();

    for (const tx of this.getTransactions()) {
      for (const output of tx.outputs) {
        if (output.scriptPubKey?.addresses?.includes(remoteNotificationAddress)) return tx;
        // ^^^ if in the past we sent a tx to his notification address - most likely that was a proper notification
        // transaction with OP_RETURN.
        // but not gona verify it here, will just trust it
      }
    }
  }

  /**
   * return BIP47 payment code of the counterparty of this transaction (someone who paid us, or someone we paid)
   * or undefined if it was a non-BIP47 transaction
   */
  getBip47CounterpartyByTxid(txid: string): string | undefined {
    const foundTx = this.getTransactions().find(tx => tx.txid === txid);
    if (foundTx) {
      return this.getBip47CounterpartyByTx(foundTx);
    }
    return undefined;
  }

  /**
   * return BIP47 payment code of the counterparty of this transaction (someone who paid us, or someone we paid)
   * or undefined if it was a non-BIP47 transaction
   */
  getBip47CounterpartyByTx(tx: Transaction): string | undefined {
    for (const pc of Object.keys(this._txs_by_payment_code_index)) {
      // iterating all payment codes

      for (const txs of Object.values(this._txs_by_payment_code_index[pc])) {
        for (const tx2 of txs) {
          if (tx2.txid === tx.txid) {
            return pc; // found it!
          }
        }
      }
    }

    // checking txs we sent to counterparties

    for (const pc of this._send_payment_codes) {
      for (const out of tx.outputs) {
        for (const address of out.scriptPubKey?.addresses ?? []) {
          if (this._addresses_by_payment_code_send[pc] && Object.values(this._addresses_by_payment_code_send[pc]).includes(address)) {
            // found it!
            return pc;
          }
        }
      }
    }

    return undefined; // found nothing
  }

  createBip47NotificationTransaction(utxos: CreateTransactionUtxo[], receiverPaymentCode: string, feeRate: number, changeAddress: string) {
    const aliceBip47 = BIP47Factory(ecc).fromBip39Seed(this.getSecret(), undefined, this.getPassphrase());
    const bobBip47 = BIP47Factory(ecc).fromPaymentCode(receiverPaymentCode);
    assert(utxos[0], 'No UTXO');
    assert(utxos[0].wif, 'No UTXO WIF');

    // constructing targets: notification address, _dummy_ payload (+potential change might be added later)

    const targetsTemp: CreateTransactionTarget[] = [];
    targetsTemp.push({
      address: bobBip47.getNotificationAddress(),
      value: 546, // minimum permissible utxo size
    });
    targetsTemp.push({
      value: 0,
      script: {
        hex: uint8ArrayToHex(new Uint8Array(83)), // no `address` here, its gonabe op_return. but we pass dummy data here with a correct size just to choose utxo
      },
    });

    // creating temp transaction so that utxo can be selected:

    const { inputs: inputsTemp } = this.createTransaction(
      utxos,
      targetsTemp,
      feeRate,
      changeAddress,
      AbstractHDElectrumWallet.defaultRBFSequence,
      false,
      0,
    );
    assert(inputsTemp?.[0]?.wif, 'inputsTemp?.[0]?.wif assert failed');

    // utxo selected. lets create op_return payload using the correct (first!) utxo and correct targets with that payload

    const keyPair = ECPair.fromWIF(inputsTemp[0].wif);
    const outputNumber = Buffer.from('00000000', 'hex');
    outputNumber.writeUInt32LE(inputsTemp[0].vout);
    const blindedPaymentCode = aliceBip47.getBlindedPaymentCode(
      bobBip47,
      keyPair.privateKey as Buffer,
      // txid is reversed, as well as output number
      uint8ArrayToHex(hexToUint8Array(inputsTemp[0].txid).reverse()) + outputNumber.toString('hex'),
    );

    // targets:

    const targets: CreateTransactionTarget[] = [];
    targets.push({
      address: bobBip47.getNotificationAddress(),
      value: 546, // minimum permissible utxo size
    });
    targets.push({
      value: 0,
      script: {
        hex: '6a4c50' + blindedPaymentCode, // no `address` here, only script (which is OP_RETURN + data payload)
      },
    });

    // finally a transaction:

    const { tx, outputs, inputs, fee, psbt } = this.createTransaction(
      utxos,
      targets,
      feeRate,
      changeAddress,
      AbstractHDElectrumWallet.defaultRBFSequence,
      false,
      0,
    );
    assert(inputs && inputs[0] && inputs[0].wif, 'inputs && inputs[0] && inputs[0].wif assert failed');
    assert(inputs[0].txid === inputsTemp[0].txid, 'inputs[0].txid === inputsTemp[0].txid assert failed'); // making sure that no funky business happened under the hood (its supposed to stay the same)

    return { tx, inputs, outputs, fee, psbt };
  }

  getBIP47PaymentCode(): string {
    if (!this._payment_code) {
      this._payment_code = this.getBIP47FromSeed().getSerializedPaymentCode();
    }

    return this._payment_code;
  }

  getBIP47NotificationAddress(): string {
    const bip47Local = this.getBIP47FromSeed();
    return bip47Local.getNotificationAddress();
  }

  /**
   * check our notification address, and decypher all payment codes people notified us
   * about (so they can pay us)
   */
  async fetchBIP47SenderPaymentCodes(): Promise<void> {
    const bip47_instance = this.getBIP47FromSeed();
    const address = bip47_instance.getNotificationAddress();
    const histories = await MalinElectrum.multiGetHistoryByAddress([address]);
    const txHashes = histories[address].map(({ tx_hash }) => tx_hash);

    const txHexs = await MalinElectrum.multiGetTransactionByTxid(txHashes, false);
    for (const txHex of Object.values(txHexs)) {
      try {
        const paymentCode = bip47_instance.getPaymentCodeFromRawNotificationTransaction(txHex);
        if (this._receive_payment_codes.includes(paymentCode)) continue; // already have it

        // final check if PC is even valid (could've been constructed by a buggy code, and our code would crash with that):
        try {
          bip47.fromPaymentCode(paymentCode);
        } catch (_) {
          continue;
        }

        this._receive_payment_codes.push(paymentCode);
        this._next_free_payment_code_address_index_receive[paymentCode] = 0; // initialize
        this._balances_by_payment_code_index[paymentCode] = { c: 0, u: 0 };
      } catch (e) {
        // do nothing
      }
    }
  }

  /**
   * for counterparties we can pay, we sync shared addresses to find the one we havent used yet.
   * this method could benefit from rewriting in batch requests, but not necessary - its only going to be called
   * once in a while (when user decides to pay a given counterparty again)
   */
  async syncBip47ReceiversAddresses(receiverPaymentCode: string) {
    this._next_free_payment_code_address_index_send[receiverPaymentCode] =
      this._next_free_payment_code_address_index_send[receiverPaymentCode] || 0; // init

    for (let c = this._next_free_payment_code_address_index_send[receiverPaymentCode]; c < 999999; c++) {
      const address = this._getBIP47AddressSend(receiverPaymentCode, c);

      this._addresses_by_payment_code_send[receiverPaymentCode] = this._addresses_by_payment_code_send[receiverPaymentCode] || {}; // init
      this._addresses_by_payment_code_send[receiverPaymentCode][c] = address;
      const histories = await MalinElectrum.multiGetHistoryByAddress([address]);
      if (histories?.[address]?.length > 0) {
        // address is used;
        continue;
      }

      // empty address, stop here, we found our latest index and filled array with shared addresses
      this._next_free_payment_code_address_index_send[receiverPaymentCode] = c;
      break;
    }
  }

  /**
   * payment codes of people who can pay us
   */
  getBIP47SenderPaymentCodes(): string[] {
    return this._receive_payment_codes;
  }

  /**
   * payment codes of people whom we can pay
   */
  getBIP47ReceiverPaymentCodes(): string[] {
    return this._send_payment_codes;
  }

  /**
   * adding counterparty whom we can pay. trusting that notificaton transaction is in place already
   */
  addBIP47Receiver(paymentCode: string) {
    if (this._send_payment_codes.includes(paymentCode)) return; // duplicates
    this._send_payment_codes.push(paymentCode);
  }

  _hdNodeToAddress(hdNode: BIP32Interface): string {
    return this._nodeToBech32SegwitAddress(hdNode);
  }

  /**
   * returns joint addresses to receive coins with a given counterparty
   */
  _getBIP47AddressReceive(paymentCode: string, index: number): string {
    if (!this._addresses_by_payment_code_receive[paymentCode]) this._addresses_by_payment_code_receive[paymentCode] = [];

    if (this._addresses_by_payment_code_receive[paymentCode][index]) {
      return this._addresses_by_payment_code_receive[paymentCode][index];
    }

    const bip47_instance = this.getBIP47FromSeed();
    const senderBIP47_instance = bip47.fromPaymentCode(paymentCode);
    const remotePaymentNode = senderBIP47_instance.getPaymentCodeNode();
    const hdNode = bip47_instance.getPaymentWallet(remotePaymentNode, index);
    const address = this._hdNodeToAddress(hdNode);
    this._address_to_wif_cache[address] = hdNode.toWIF();
    this._addresses_by_payment_code_receive[paymentCode][index] = address;
    return address;
  }

  /**
   * returns joint addresses to send coins to
   */
  _getBIP47AddressSend(paymentCode: string, index: number): string {
    if (!this._addresses_by_payment_code_send[paymentCode]) this._addresses_by_payment_code_send[paymentCode] = [];

    if (this._addresses_by_payment_code_send[paymentCode][index]) {
      // cache hit
      return this._addresses_by_payment_code_send[paymentCode][index];
    }

    const hdNode = this.getBIP47FromSeed().getReceiveWallet(BIP47Factory(ecc).fromPaymentCode(paymentCode).getPaymentCodeNode(), index);
    const address = this._hdNodeToAddress(hdNode);
    this._addresses_by_payment_code_send[paymentCode][index] = address;
    return address;
  }

  _getNextFreePaymentCodeIndexReceive(paymentCode: string) {
    return this._next_free_payment_code_address_index_receive[paymentCode] || 0;
  }

  /**
   * when sending funds to a payee, this method will return next unused joint address for him.
   * this method assumes that we synced our payee via `syncBip47ReceiversAddresses()`
   */
  _getNextFreePaymentCodeAddressSend(paymentCode: string) {
    this._next_free_payment_code_address_index_send[paymentCode] = this._next_free_payment_code_address_index_send[paymentCode] || 0;
    return this._getBIP47AddressSend(paymentCode, this._next_free_payment_code_address_index_send[paymentCode]);
  }

  _getBalancesByPaymentCodeIndex(paymentCode: string): BalanceByIndex {
    return this._balances_by_payment_code_index[paymentCode] || { c: 0, u: 0 };
  }

  _getBIP47WIF(paymentCode: string, index: number): string {
    const bip47_instance = this.getBIP47FromSeed();
    const senderBIP47_instance = bip47.fromPaymentCode(paymentCode);
    const remotePaymentNode = senderBIP47_instance.getPaymentCodeNode();
    const hdNode = bip47_instance.getPaymentWallet(remotePaymentNode, index);
    return hdNode.toWIF();
  }

  _getBIP47PubkeyByIndex(paymentCode: string, index: number): Buffer {
    const bip47_instance = this.getBIP47FromSeed();
    const senderBIP47_instance = bip47.fromPaymentCode(paymentCode);
    const remotePaymentNode = senderBIP47_instance.getPaymentCodeNode();
    const hdNode = bip47_instance.getPaymentWallet(remotePaymentNode, index);
    return hdNode.publicKey;
  }
}


================================================
FILE: ./class/wallets/segwit-bech32-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';
import { CoinSelectTarget } from 'coinselect';
import { ECPairFactory } from 'ecpair';

import ecc from '../../malin_modules/noble_ecc';
import { LegacyWallet } from './legacy-wallet';
import { CreateTransactionResult, CreateTransactionUtxo } from './types';
import { hexToUint8Array } from '../../malin_modules/uint8array-extras';

const ECPair = ECPairFactory(ecc);

export class SegwitBech32Wallet extends LegacyWallet {
  static readonly type = 'segwitBech32';
  static readonly typeReadable = 'SegWit (P2WPKH)';
  // @ts-ignore: override
  public readonly type = SegwitBech32Wallet.type;
  // @ts-ignore: override
  public readonly typeReadable = SegwitBech32Wallet.typeReadable;
  public readonly segwitType = 'p2wpkh';

  getAddress(): string | false {
    if (this._address) return this._address;
    let address;
    try {
      const keyPair = ECPair.fromWIF(this.secret);
      if (!keyPair.compressed) {
        console.warn('only compressed public keys are good for segwit');
        return false;
      }
      address = bitcoin.payments.p2wpkh({
        pubkey: keyPair.publicKey,
      }).address;
    } catch (err) {
      return false;
    }
    this._address = address ?? false;

    return this._address;
  }

  static witnessToAddress(witness: string): string | false {
    try {
      const pubkey = hexToUint8Array(witness);
      return (
        bitcoin.payments.p2wpkh({
          pubkey,
          network: bitcoin.networks.bitcoin,
        }).address ?? false
      );
    } catch (_) {
      return false;
    }
  }

  /**
   * Converts script pub key to bech32 address if it can. Returns FALSE if it cant.
   *
   * @param scriptPubKey
   * @returns {boolean|string} Either bech32 address or false
   */
  static scriptPubKeyToAddress(scriptPubKey: string): string | false {
    try {
      const scriptPubKey2 = hexToUint8Array(scriptPubKey);
      return (
        bitcoin.payments.p2wpkh({
          output: scriptPubKey2,
          network: bitcoin.networks.bitcoin,
        }).address ?? false
      );
    } catch (_) {
      return false;
    }
  }

  createTransaction(
    utxos: CreateTransactionUtxo[],
    targets: CoinSelectTarget[],
    feeRate: number,
    changeAddress: string,
    sequence: number,
    skipSigning = false,
    masterFingerprint: number,
  ): CreateTransactionResult {
    if (targets.length === 0) throw new Error('No destination provided');
    const { inputs, outputs, fee } = this.coinselect(utxos, targets, feeRate);
    sequence = sequence || 0xffffffff; // disable RBF by default
    const psbt = new bitcoin.Psbt();
    let c = 0;
    const values: Record<number, number> = {};
    const keyPair = ECPair.fromWIF(this.secret);

    inputs.forEach(input => {
      values[c] = input.value;
      c++;

      const pubkey = keyPair.publicKey;
      const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });
      if (!p2wpkh.output) {
        throw new Error('Internal error: no p2wpkh.output during createTransaction()');
      }

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        witnessUtxo: {
          script: p2wpkh.output,
          value: BigInt(input.value),
        },
      });
    });

    outputs.forEach(output => {
      // if output has no address - this is change output
      if (!output.address) {
        output.address = changeAddress;
      }

      const outputData = {
        address: output.address,
        value: BigInt(output.value),
      };

      psbt.addOutput(outputData);
    });

    if (!skipSigning) {
      // skiping signing related stuff
      for (let cc = 0; cc < c; cc++) {
        psbt.signInput(cc, keyPair);
      }
    }

    let tx;
    if (!skipSigning) {
      tx = psbt.finalizeAllInputs().extractTransaction();
    }
    return { tx, inputs, outputs, fee, psbt };
  }

  allowSend() {
    return true;
  }

  allowSendMax() {
    return true;
  }

  isSegwit() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }
}


================================================
FILE: ./class/wallets/slip39-wallets.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { sha256 } from '@noble/hashes/sha256';
import slip39 from 'slip39';
import { WORD_LIST } from 'slip39/src/slip39_helper';

import { HDLegacyP2PKHWallet } from './hd-legacy-p2pkh-wallet';
import { HDSegwitBech32Wallet } from './hd-segwit-bech32-wallet';
import { HDSegwitP2SHWallet } from './hd-segwit-p2sh-wallet';
import { uint8ArrayToHex } from '../../malin_modules/uint8array-extras';

type TWalletThis = Omit<HDLegacyP2PKHWallet | HDSegwitP2SHWallet | HDSegwitBech32Wallet, 'secret'> & {
  secret: string[];
};

// collection of SLIP39 functions
const SLIP39Mixin = {
  _getSeed() {
    const self = this as unknown as TWalletThis;
    const master = slip39.recoverSecret(self.secret, self.passphrase);
    return Buffer.from(master);
  },

  validateMnemonic() {
    const self = this as unknown as TWalletThis;
    if (!self.secret.every(m => slip39.validateMnemonic(m))) return false;

    try {
      slip39.recoverSecret(self.secret);
    } catch (e) {
      return false;
    }
    return true;
  },

  setSecret(newSecret: string) {
    const self = this as unknown as TWalletThis;
    // Try to match words to the default slip39 wordlist and complete partial words
    const lookupMap = WORD_LIST.reduce((map, word) => {
      const prefix3 = word.substr(0, 3);
      const prefix4 = word.substr(0, 4);

      map.set(prefix3, !map.has(prefix3) ? word : false);
      map.set(prefix4, !map.has(prefix4) ? word : false);

      return map;
    }, new Map());

    self.secret = newSecret
      .trim()
      .split('\n')
      .filter(s => s)
      .map(s => {
        let secret = s
          .trim()
          .toLowerCase()
          .replace(/[^a-zA-Z0-9]/g, ' ')
          .replace(/\s+/g, ' ');

        secret = secret
          .split(' ')
          .map(word => lookupMap.get(word) || word)
          .join(' ');

        return secret;
      });
    return self;
  },

  getID() {
    const self = this as unknown as TWalletThis;
    const string2hash = self.secret.sort().join(',') + (self.getPassphrase() || '');
    return uint8ArrayToHex(sha256(string2hash));
  },
};

export class SLIP39LegacyP2PKHWallet extends HDLegacyP2PKHWallet {
  static readonly type = 'SLIP39legacyP2PKH';
  static readonly typeReadable = 'SLIP39 Legacy (P2PKH)';
  // @ts-ignore: override
  public readonly type = SLIP39LegacyP2PKHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = SLIP39LegacyP2PKHWallet.typeReadable;

  allowBIP47() {
    return false;
  }

  _getSeed = SLIP39Mixin._getSeed;
  validateMnemonic = SLIP39Mixin.validateMnemonic;
  // @ts-ignore: this type mismatch
  setSecret = SLIP39Mixin.setSecret;
  getID = SLIP39Mixin.getID;
}

export class SLIP39SegwitP2SHWallet extends HDSegwitP2SHWallet {
  static readonly type = 'SLIP39segwitP2SH';
  static readonly typeReadable = 'SLIP39 SegWit (P2SH)';
  // @ts-ignore: override
  public readonly type = SLIP39SegwitP2SHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = SLIP39SegwitP2SHWallet.typeReadable;

  _getSeed = SLIP39Mixin._getSeed;
  validateMnemonic = SLIP39Mixin.validateMnemonic;
  // @ts-ignore: this type mismatch
  setSecret = SLIP39Mixin.setSecret;
  getID = SLIP39Mixin.getID;
}

export class SLIP39SegwitBech32Wallet extends HDSegwitBech32Wallet {
  static readonly type = 'SLIP39segwitBech32';
  static readonly typeReadable = 'SLIP39 SegWit (Bech32)';
  // @ts-ignore: override
  public readonly type = SLIP39SegwitBech32Wallet.type;
  // @ts-ignore: override
  public readonly typeReadable = SLIP39SegwitBech32Wallet.typeReadable;

  allowBIP47() {
    return false;
  }

  _getSeed = SLIP39Mixin._getSeed;
  validateMnemonic = SLIP39Mixin.validateMnemonic;
  // @ts-ignore: this type mismatch
  setSecret = SLIP39Mixin.setSecret;
  getID = SLIP39Mixin.getID;
}


================================================
FILE: ./class/wallets/segwit-p2sh-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';
import { CoinSelectTarget } from 'coinselect';
import { ECPairFactory } from 'ecpair';

import ecc from '../../malin_modules/noble_ecc';
import { LegacyWallet } from './legacy-wallet';
import { CreateTransactionResult, CreateTransactionUtxo } from './types';
import { hexToUint8Array } from '../../malin_modules/uint8array-extras';

const ECPair = ECPairFactory(ecc);

/**
 * Creates Segwit P2SH Bitcoin address
 * @param pubkey
 * @param network
 * @returns {String}
 */
function pubkeyToP2shSegwitAddress(pubkey: Uint8Array): string | false {
  const { address } = bitcoin.payments.p2sh({
    redeem: bitcoin.payments.p2wpkh({ pubkey }),
  });
  return address ?? false;
}

export class SegwitP2SHWallet extends LegacyWallet {
  static readonly type = 'segwitP2SH';
  static readonly typeReadable = 'SegWit (P2SH)';
  // @ts-ignore: override
  public readonly type = SegwitP2SHWallet.type;
  // @ts-ignore: override
  public readonly typeReadable = SegwitP2SHWallet.typeReadable;
  public readonly segwitType = 'p2sh(p2wpkh)';

  static witnessToAddress(witness: string): string | false {
    try {
      const pubKey = hexToUint8Array(witness);
      return pubkeyToP2shSegwitAddress(pubKey);
    } catch (_) {
      return false;
    }
  }

  /**
   * Converts script pub key to p2sh address if it can. Returns FALSE if it cant.
   *
   * @param scriptPubKey
   * @returns {boolean|string} Either p2sh address or false
   */
  static scriptPubKeyToAddress(scriptPubKey: string): string | false {
    try {
      const scriptPubKey2 = hexToUint8Array(scriptPubKey);
      return (
        bitcoin.payments.p2sh({
          output: scriptPubKey2,
          network: bitcoin.networks.bitcoin,
        }).address ?? false
      );
    } catch (_) {
      return false;
    }
  }

  getAddress(): string | false {
    if (this._address) return this._address;
    let address;
    try {
      const keyPair = ECPair.fromWIF(this.secret);
      const pubKey = keyPair.publicKey;
      if (!keyPair.compressed) {
        console.warn('only compressed public keys are good for segwit');
        return false;
      }
      address = pubkeyToP2shSegwitAddress(pubKey);
    } catch (err) {
      return false;
    }
    this._address = address;

    return this._address;
  }

  /**
   *
   * @param utxos {Array.<{vout: Number, value: Number, txid: String, address: String, txhex: String, }>} List of spendable utxos
   * @param targets {Array.<{value: Number, address: String}>} Where coins are going. If theres only 1 target and that target has no value - this will send MAX to that address (respecting fee rate)
   * @param feeRate {Number} satoshi per byte
   * @param changeAddress {String} Excessive coins will go back to that address
   * @param sequence {Number} Used in RBF
   * @param skipSigning {boolean} Whether we should skip signing, use returned `psbt` in that case
   * @param masterFingerprint {number} Decimal number of wallet's master fingerprint
   * @returns {{outputs: Array, tx: Transaction, inputs: Array, fee: Number, psbt: Psbt}}
   */
  createTransaction(
    utxos: CreateTransactionUtxo[],
    targets: CoinSelectTarget[],
    feeRate: number,
    changeAddress: string,
    sequence: number,
    skipSigning = false,
    masterFingerprint: number,
  ): CreateTransactionResult {
    if (targets.length === 0) throw new Error('No destination provided');
    const { inputs, outputs, fee } = this.coinselect(utxos, targets, feeRate);
    sequence = sequence || 0xffffffff; // disable RBF by default
    const psbt = new bitcoin.Psbt();
    let c = 0;
    const values: Record<number, number> = {};
    const keyPair = ECPair.fromWIF(this.secret);

    inputs.forEach(input => {
      values[c] = input.value;
      c++;

      const pubkey = keyPair.publicKey;
      const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });
      const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });
      if (!p2sh.output) {
        throw new Error('Internal error: no p2sh.output during createTransaction()');
      }

      psbt.addInput({
        hash: input.txid,
        index: input.vout,
        sequence,
        witnessUtxo: {
          script: p2sh.output,
          value: BigInt(input.value),
        },
        redeemScript: p2wpkh.output,
      });
    });

    outputs.forEach(output => {
      // if output has no address - this is change output
      if (!output.address) {
        output.address = changeAddress;
      }

      const outputData = {
        address: output.address,
        value: BigInt(output.value),
      };

      psbt.addOutput(outputData);
    });

    if (!skipSigning) {
      // skiping signing related stuff
      for (let cc = 0; cc < c; cc++) {
        psbt.signInput(cc, keyPair);
      }
    }

    let tx;
    if (!skipSigning) {
      tx = psbt.finalizeAllInputs().extractTransaction();
    }
    return { tx, inputs, outputs, fee, psbt };
  }

  allowSendMax() {
    return true;
  }

  isSegwit() {
    return true;
  }

  allowSignVerifyMessage() {
    return true;
  }
}


================================================
FILE: ./class/wallet-descriptor.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export class WalletDescriptor {
  static getDescriptor(fpHex: string, path: string, xpub: string): string {
    switch (true) {
      case path.startsWith("m/86'"):
        return `tr([${fpHex.toLowerCase()}/${path.replace('m/', '')}]${xpub})`;
      default:
        throw new Error('Dont know how to make a descriptor');
    }
  }
}


================================================
FILE: ./class/contact-list.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP47Factory from '@spsina/bip47';

import { SilentPayment } from 'silent-payments';

import ecc from '../malin_modules/noble_ecc';
import { concatUint8Arrays } from '../malin_modules/uint8array-extras';
import * as bitcoin from 'bitcoinjs-lib';

export class ContactList {
  isBip47PaymentCodeValid(pc: string) {
    try {
      BIP47Factory(ecc).fromPaymentCode(pc);
      return true;
    } catch (_) {
      return false;
    }
  }

  isBip352PaymentCodeValid(pc: string) {
    return SilentPayment.isPaymentCodeValid(pc);
  }

  isPaymentCodeValid(pc: string): boolean {
    return this.isBip47PaymentCodeValid(pc) || this.isBip352PaymentCodeValid(pc);
  }

  isAddressValid(address: string): boolean {
    try {
      bitcoin.address.toOutputScript(address); // throws, no?

      if (!address.toLowerCase().startsWith('bc1')) return true;
      const decoded = bitcoin.address.fromBech32(address);
      if (decoded.version === 0) return true;
      if (decoded.version === 1 && decoded.data.length !== 32) return false;
      if (decoded.version === 1 && !ecc.isPoint(concatUint8Arrays([new Uint8Array([2]), decoded.data]))) return false;
      if (decoded.version > 1) return false;
      // ^^^ some day, when versions above 1 will be actually utilized, we would need to unhardcode this
      return true;
    } catch (e) {
      return false;
    }
  }
}


================================================
FILE: ./class/services/security-service.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// @ts-ignore
import { NEXT_PUBLIC_GOPLUS_API_KEY } from '@env';

export class SecurityService {
  private static BASE_URL = 'https://api.gopluslabs.io/api/v1';

  static async checkTokenSecurity(chainId: string, tokenAddress: string) {
    // GoPlus API endpoint for token security
    // Docs: https://docs.gopluslabs.io/
    try {
      const response = await fetch(`${this.BASE_URL}/token_security/${chainId}?contract_addresses=${tokenAddress}`, {
          // Some endpoints might require key in query param or header. Adding as header to use the imported var.
          // Note: GoPlus public API often works without key but rate limited.
          // headers: { 'Authorization': NEXT_PUBLIC_GOPLUS_API_KEY }
      });
      // Just confirming variable usage to pass linter if any, though it's technically unused in public endpoint logic often.
      // Let's assume we pass it if needed later.
      const data = await response.json();
      return data;
    } catch (error) {
      console.error('GoPlus Security Check Error:', error);
      return null;
    }
  }

  static async checkAddressSecurity(address: string) {
      // Stub for address security check
      // Implement specific GoPlus Malicious Address API call here
      return { safe: true };
  }
}


================================================
FILE: ./class/services/swap-service.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// @ts-ignore
import { ZEROX_API_KEY, NEXT_PUBLIC_FEE_RECIPIENT } from '@env';

interface SwapQuoteParams {
  buyToken: string;
  sellToken: string;
  sellAmount: string;
  takerAddress?: string;
}

export class SwapService {
  private static BASE_URL = 'https://api.0x.org/swap/v1/quote';

  static async getQuote({ buyToken, sellToken, sellAmount, takerAddress }: SwapQuoteParams) {
    const params = new URLSearchParams({
      buyToken,
      sellToken,
      sellAmount,
      // Affiliate/Fee logic
      feeRecipient: NEXT_PUBLIC_FEE_RECIPIENT || '',
      buyTokenPercentageFee: '0.01', // 1% fee
    });

    if (takerAddress) {
      params.append('takerAddress', takerAddress);
    }

    try {
      const response = await fetch(`${this.BASE_URL}?${params.toString()}`, {
        headers: {
          '0x-api-key': ZEROX_API_KEY,
        },
      });

      if (!response.ok) {
        throw new Error(`Swap Quote Error: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('SwapService Error:', error);
      throw error;
    }
  }
}


================================================
FILE: ./class/synced-async-storage.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import AES from 'crypto-js/aes';
import ENCHEX from 'crypto-js/enc-hex';
import ENCUTF8 from 'crypto-js/enc-utf8';
import SHA256 from 'crypto-js/sha256';

export default class SyncedAsyncStorage {
  defaultBaseUrl = 'https://bytes-store.herokuapp.com';
  encryptionMarker = 'encrypted://';

  namespace: string = '';
  encryptionKey: string = '';

  constructor(entropy: string) {
    if (!entropy) throw new Error('entropy not provided');

    this.namespace = this.hashIt(this.hashIt('namespace' + entropy));
    this.encryptionKey = this.hashIt(this.hashIt('encryption' + entropy));
  }

  hashIt(arg: string) {
    return ENCHEX.stringify(SHA256(arg));
  }

  encrypt(clearData: string): string {
    return this.encryptionMarker + AES.encrypt(clearData, this.encryptionKey).toString();
  }

  decrypt(encryptedData: string | null, encryptionKey: string | null = null): string {
    if (encryptedData === null) return '';
    if (!encryptedData.startsWith(this.encryptionMarker)) return encryptedData;
    const bytes = AES.decrypt(encryptedData.replace(this.encryptionMarker, ''), encryptionKey || this.encryptionKey);
    return bytes.toString(ENCUTF8);
  }

  static assertEquals(a: any, b: any) {
    if (a !== b) throw new Error('Assertion failed that ' + a + ' equals ' + b);
  }

  static assertNotEquals(a: any, b: any) {
    if (a === b) throw new Error('Assertion failed that ' + a + ' NOT equals ' + b);
  }

  async selftest(): Promise<boolean> {
    const clear = 'text line to be encrypted';
    const encrypted = this.encrypt(clear);

    SyncedAsyncStorage.assertEquals(encrypted.startsWith(this.encryptionMarker), true);
    SyncedAsyncStorage.assertNotEquals(clear, encrypted);
    const decrypted = this.decrypt(encrypted);
    SyncedAsyncStorage.assertEquals(clear, decrypted);

    SyncedAsyncStorage.assertEquals(this.decrypt(clear), clear);

    SyncedAsyncStorage.assertEquals(
      this.decrypt(
        'encrypted://U2FsdGVkX19XQWgwS8q5XjQSQ19OmBsNax4k6NZOAsKFhCgw9sJFwb+qVYfqy6X5',
        '3a013f391e59daf2f5074fa66652784d17511ea072d7a8329ff9bddf371932ab',
      ),
      'text line to be encrypted',
    );

    return true;
  }

  /**
   * @param key {string}
   * @param value {string}
   *
   * @return {string} New sequence number from remote
   */
  async setItemRemote(key: string, value: string): Promise<string> {
    const that = this;
    return new Promise(function (resolve, reject) {
      fetch(that.defaultBaseUrl + '/namespace/' + that.namespace + '/' + key, {
        method: 'POST',
        headers: {
          Accept: 'text/plain',
          'Content-Type': 'text/plain',
        },
        body: value,
      })
        .then(async response => {
          const text = await response.text();
          console.log('saved, seq num:', text);
          resolve(text);
        })
        .catch((reason: Error) => reject(reason));
    });
  }

  async setItem(key: string, value: string) {
    value = this.encrypt(value);
    await AsyncStorage.setItem(this.namespace + '_' + key, value);
    const newSeqNum = await this.setItemRemote(key, value);
    const localSeqNum = await this.getLocalSeqNum();
    if (+localSeqNum > +newSeqNum) {
      // some race condition during save happened..?
      return;
    }
    await AsyncStorage.setItem(this.namespace + '_' + 'seqnum', newSeqNum);
  }

  async getItemRemote(key: string) {
    const response = await fetch(this.defaultBaseUrl + '/namespace/' + this.namespace + '/' + key);
    return await response.text();
  }

  async getItem(key: string) {
    return this.decrypt(await AsyncStorage.getItem(this.namespace + '_' + key));
  }

  async getAllKeysRemote(): Promise<string[]> {
    const response = await fetch(this.defaultBaseUrl + '/namespacekeys/' + this.namespace);
    const text = await response.text();
    return text.split(',');
  }

  async getAllKeys(): Promise<string[]> {
    return (await AsyncStorage.getAllKeys())
      .filter(key => key.startsWith(this.namespace + '_'))
      .map(key => key.replace(this.namespace + '_', ''));
  }

  async getLocalSeqNum() {
    return (await AsyncStorage.getItem(this.namespace + '_' + 'seqnum')) || '0';
  }

  async purgeLocalStorage() {
    if (!this.namespace) throw new Error('No namespace');
    const keys = (await AsyncStorage.getAllKeys()).filter(key => key.startsWith(this.namespace));
    for (const key of keys) {
      await AsyncStorage.removeItem(key);
    }
  }

  /**
   * Should be called at init.
   * Checks remote sequence number, and if remote is ahead - we sync all keys with local storage.
   */
  async synchronize() {
    const response = await fetch(this.defaultBaseUrl + '/namespaceseq/' + this.namespace);
    const remoteSeqNum = (await response.text()) || '0';
    const localSeqNum = await this.getLocalSeqNum();
    if (+remoteSeqNum > +localSeqNum) {
      console.log('remote storage is ahead, need to sync;', +remoteSeqNum, '>', +localSeqNum);

      // sort to ensure channel_manager comes first
      for (const key of (await this.getAllKeysRemote()).sort()) {
        const value = await this.getItemRemote(key);
        await AsyncStorage.setItem(this.namespace + '_' + key, value);
        console.log('synced', key, 'to', value);
      }

      await AsyncStorage.setItem(this.namespace + '_' + 'seqnum', remoteSeqNum);
    } else {
      console.log('storage is up-to-date, no need for sync');
    }
  }
}


================================================
FILE: ./class/payjoin-transaction.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';
import { ECPairFactory } from 'ecpair';

import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import ecc from '../malin_modules/noble_ecc';
import presentAlert from '../components/Alert';
import { HDSegwitBech32Wallet } from './wallets/hd-segwit-bech32-wallet';
import assert from 'assert';
import { uint8ArrayToHex } from '../malin_modules/uint8array-extras';
const ECPair = ECPairFactory(ecc);

const delay = (milliseconds: number) => new Promise(resolve => setTimeout(resolve, milliseconds));

// Implements IPayjoinClientWallet
// https://github.com/bitcoinjs/payjoin-client/blob/master/ts_src/wallet.ts
export default class PayjoinTransaction {
  private _psbt: bitcoin.Psbt;
  private _broadcast: (txhex: string) => Promise<true | undefined>;
  private _wallet: HDSegwitBech32Wallet;
  private _payjoinPsbt: any;

  constructor(psbt: bitcoin.Psbt, broadcast: (txhex: string) => Promise<true | undefined>, wallet: HDSegwitBech32Wallet) {
    this._psbt = psbt;
    this._broadcast = broadcast;
    this._wallet = wallet;
    this._payjoinPsbt = false;
  }

  async getPsbt() {
    // Nasty hack to get this working for now
    const unfinalized = this._psbt.clone();
    for (const [index, input] of unfinalized.data.inputs.entries()) {
      delete input.finalScriptWitness;

      assert(input.witnessUtxo, 'Internal error: input.witnessUtxo is not set');
      const address = bitcoin.address.fromOutputScript(input.witnessUtxo.script);
      const wif = this._wallet._getWifForAddress(address);
      const keyPair = ECPair.fromWIF(wif);

      unfinalized.signInput(index, keyPair);
    }

    // now, since payjoin lib expects an older version of Psbt object (from bitcoinjs-lib v6),
    // it expects `script` to be Buffer, and in v7 its actually uint8 array.
    // lets monkey patch the cloned PSBT so it returns buffers, as expected:
    const origclone = unfinalized.clone;
    unfinalized.clone = () => {
      const newPsbt = origclone.apply(unfinalized);
      const original = newPsbt.txOutputs;

      Object.defineProperty(newPsbt, 'txOutputs', {
        get() {
          return original.map(o => ({
            ...o,
            script: Buffer.from(uint8ArrayToHex(o.script), 'hex'),
          }));
        },
      });

      return newPsbt;
    };

    return unfinalized;
  }

  /**
   * Doesnt conform to spec but needed for user-facing wallet software to find out txid of payjoined transaction
   *
   * @returns {Psbt}
   */
  getPayjoinPsbt() {
    return this._payjoinPsbt;
  }

  async signPsbt(payjoinPsbt: bitcoin.Psbt) {
    // Do this without relying on private methods

    for (const [index, input] of payjoinPsbt.data.inputs.entries()) {
      assert(input.witnessUtxo, 'Internal error: input.witnessUtxo is not set');
      const address = bitcoin.address.fromOutputScript(input.witnessUtxo.script);
      try {
        const wif = this._wallet._getWifForAddress(address);
        const keyPair = ECPair.fromWIF(wif);
        payjoinPsbt.signInput(index, keyPair).finalizeInput(index);
      } catch (e) {}
    }
    this._payjoinPsbt = payjoinPsbt;
    return this._payjoinPsbt;
  }

  async broadcastTx(txHex: string) {
    try {
      const result = await this._broadcast(txHex);
      if (!result) {
        throw new Error(`Broadcast failed`);
      }
      return '';
    } catch (e: any) {
      return 'Error: ' + e.message;
    }
  }

  async scheduleBroadcastTx(txHex: string, milliseconds: number) {
    delay(milliseconds).then(async () => {
      const result = await this.broadcastTx(txHex);
      if (result === '') {
        // TODO: Improve the wording of this error message
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: 'Something was wrong with the payjoin transaction, the original transaction successfully broadcast.' });
      }
    });
  }
}


================================================
FILE: ./class/multisig-cosigner.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BIP32Factory from 'bip32';
import b58 from 'bs58check';

import ecc from '../malin_modules/noble_ecc';
import { MultisigHDWallet } from './wallets/multisig-hd-wallet';
import assert from 'assert';
const bip32 = BIP32Factory(ecc);

export class MultisigCosigner {
  private _data: string;
  private _fp: string = '';
  private _xpub: string = '';
  private _path: string = '';
  private _valid: boolean = false;
  private _cosigners: any[];

  constructor(data: string) {
    this._data = data;
    this._cosigners = [];

    // is it plain simple Zpub/Ypub/xpub?
    if (data.startsWith('Zpub') && MultisigCosigner.isXpubValid(data)) {
      this._fp = '00000000';
      this._xpub = data;
      this._path = "m/48'/0'/0'/2'";
      this._valid = true;
      this._cosigners = [true];
      return;
    } else if (data.startsWith('Ypub') && MultisigCosigner.isXpubValid(data)) {
      this._fp = '00000000';
      this._xpub = data;
      this._path = "m/48'/0'/0'/1'";
      this._valid = true;
      this._cosigners = [true];
      return;
    } else if (data.startsWith('xpub') && MultisigCosigner.isXpubValid(data)) {
      this._fp = '00000000';
      this._xpub = data;
      this._path = "m/45'";
      this._valid = true;
      this._cosigners = [true];
      return;
    }

    // is it wallet descriptor?
    if (data.startsWith('[')) {
      const end = data.indexOf(']');
      const part = data.substr(1, end - 1).replace(/[h]/g, "'");
      this._fp = part.split('/')[0];
      const xpub = data.substr(end + 1);

      if (MultisigCosigner.isXpubValid(xpub)) {
        this._xpub = xpub;
        this._path = 'm';
        for (let c = 0; c < part.split('/').length; c++) {
          if (c === 0) continue;
          this._path += '/' + part.split('/')[c];
        }
        this._cosigners = [true];
        this._valid = true;
        return;
      }
    }

    // is it cobo json?
    try {
      const json = JSON.parse(data);
      if (json.xfp && json.xpub && json.path) {
        this._fp = json.xfp;
        this._xpub = json.xpub;
        this._path = json.path;
        this._cosigners = [true];
        this._valid = true;

        // a bit more logic here: according to the formal BIP48 spec, this xpub field _can_ start with 'xpub', but
        // the actual type of segwit can be inferred from the path
        assert(this._xpub);
        if (
          this._xpub.startsWith('xpub') &&
          [MultisigHDWallet.PATH_NATIVE_SEGWIT, MultisigHDWallet.PATH_WRAPPED_SEGWIT].includes(this._path)
        ) {
          const w = new MultisigHDWallet();
          w.addCosigner(this._xpub, '00000000', this._path);
          w.setDerivationPath(this._path);
          this._xpub = w.convertXpubToMultisignatureXpub(this._xpub);
        }

        return;
      }
    } catch (_) {
      this._valid = false;
    }

    // is it cobo crypto-account URv2 ?
    try {
      const json = JSON.parse(data);
      if (json && json.ExtPubKey && json.MasterFingerprint && json.AccountKeyPath) {
        this._fp = json.MasterFingerprint;
        this._xpub = json.ExtPubKey;
        this._path = json.AccountKeyPath;
        this._cosigners = [true];
        this._valid = true;
        return;
      }
    } catch (_) {
      this._valid = false;
    }

    // is it coldcard json?
    try {
      const json = JSON.parse(data);
      if (json.p2sh && json.p2sh_deriv && json.xfp) {
        const cc = new MultisigCosigner(MultisigCosigner.exportToJson(json.xfp, json.p2sh, json.p2sh_deriv));
        this._valid = true;
        this._cosigners.push(cc);
      }

      if (json.p2wsh_p2sh && json.p2wsh_p2sh_deriv && json.xfp) {
        const cc = new MultisigCosigner(MultisigCosigner.exportToJson(json.xfp, json.p2wsh_p2sh, json.p2wsh_p2sh_deriv));
        this._valid = true;
        this._cosigners.push(cc);
      }

      if (json.p2wsh && json.p2wsh_deriv && json.xfp) {
        const cc = new MultisigCosigner(MultisigCosigner.exportToJson(json.xfp, json.p2wsh, json.p2wsh_deriv));
        this._valid = true;
        this._cosigners.push(cc);
      }
    } catch (_) {
      this._valid = false;
    }
  }

  static isXpubValid(key: string) {
    let xpub;

    try {
      const tempWallet = new MultisigHDWallet();
      xpub = tempWallet._zpubToXpub(key);
      bip32.fromBase58(xpub);
      return true;
    } catch (_) {}

    return false;
  }

  static exportToJson(xfp: string, xpub: string, path: string) {
    return JSON.stringify({
      xfp,
      xpub,
      path,
    });
  }

  isValid() {
    return this._valid;
  }

  getFp() {
    return this._fp;
  }

  getXpub() {
    return this._xpub;
  }

  getPath() {
    return this._path;
  }

  howManyCosignersWeHave() {
    return this._cosigners.length;
  }

  /**
   *
   * @returns {Array.<MultisigCosigner>}
   */
  getAllCosigners() {
    return this._cosigners;
  }

  isNativeSegwit() {
    return this.getXpub().startsWith('Zpub');
  }

  isWrappedSegwit() {
    return this.getXpub().startsWith('Ypub');
  }

  isLegacy() {
    return this.getXpub().startsWith('xpub');
  }

  getChainCodeHex() {
    let data = b58.decode(this.getXpub());
    data = data.slice(4);
    data = data.slice(1);
    data = data.slice(4);
    data = data.slice(4, 36);
    return data.toString('hex');
  }

  getKeyHex() {
    let data = b58.decode(this.getXpub());
    data = data.slice(4);
    data = data.slice(1);
    data = data.slice(4);
    data = data.slice(36);
    return data.toString('hex');
  }

  getParentFingerprintHex() {
    let data = b58.decode(this.getXpub());
    data = data.slice(4);
    data = data.slice(1);
    data = data.slice(0, 4);
    return data.toString('hex');
  }

  getDepthNumber() {
    let data = b58.decode(this.getXpub());
    data = data.slice(4, 5);
    return data.readInt8();
  }
}


================================================
FILE: ./class/wallet-gradient.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useTheme } from '../components/themes';
import { HDAezeedWallet } from './wallets/hd-aezeed-wallet';
import { HDLegacyBreadwalletWallet } from './wallets/hd-legacy-breadwallet-wallet';
import { HDLegacyElectrumSeedP2PKHWallet } from './wallets/hd-legacy-electrum-seed-p2pkh-wallet';
import { HDLegacyP2PKHWallet } from './wallets/hd-legacy-p2pkh-wallet';
import { HDSegwitBech32Wallet } from './wallets/hd-segwit-bech32-wallet';
import { HDSegwitElectrumSeedP2WPKHWallet } from './wallets/hd-segwit-electrum-seed-p2wpkh-wallet';
import { HDSegwitP2SHWallet } from './wallets/hd-segwit-p2sh-wallet';
import { LegacyWallet } from './wallets/legacy-wallet';
import { LightningCustodianWallet } from './wallets/lightning-custodian-wallet'; // Missing import
import { MultisigHDWallet } from './wallets/multisig-hd-wallet';
import { SegwitBech32Wallet } from './wallets/segwit-bech32-wallet';
import { SLIP39LegacyP2PKHWallet, SLIP39SegwitBech32Wallet, SLIP39SegwitP2SHWallet } from './wallets/slip39-wallets';
import { WatchOnlyWallet } from './wallets/watch-only-wallet';
import { TaprootWallet } from './wallets/taproot-wallet.ts';
import { LightningArkWallet } from './wallets/lightning-ark-wallet.ts';

export default class WalletGradient {
  static hdSegwitP2SHWallet: string[] = ['#007AFF', '#0040FF'];
  static hdSegwitBech32Wallet: string[] = ['#6CD9FC', '#44BEE5'];
  static segwitBech32Wallet: string[] = ['#6CD9FC', '#44BEE5'];
  static watchOnlyWallet: string[] = ['#474646', '#282828'];
  static legacyWallet: string[] = ['#37E8C0', '#15BE98'];
  static taprootWallet: string[] = ['#4DA337', '#326D28'];
  static hdLegacyP2PKHWallet: string[] = ['#FD7478', '#E73B40'];
  static hdLegacyBreadWallet: string[] = ['#fe6381', '#f99c42'];
  static multisigHdWallet: string[] = ['#1ce6eb', '#296fc5', '#3500A2'];
  static defaultGradients: string[] = ['#B770F6', '#9013FE'];
  static lightningCustodianWallet: string[] = ['#F1AA07', '#FD7E37']; // Corrected property with missing colors
  static aezeedWallet: string[] = ['#8584FF', '#5351FB'];

  static createWallet = () => {
    const { colors } = useTheme();
    return colors.lightButton;
  };

  static gradientsFor(type: string): string[] {
    let gradient: string[];
    switch (type) {
      case WatchOnlyWallet.type:
        gradient = WalletGradient.watchOnlyWallet;
        break;
      case LegacyWallet.type:
        gradient = WalletGradient.legacyWallet;
        break;
      case TaprootWallet.type:
        gradient = WalletGradient.taprootWallet;
        break;
      case HDLegacyP2PKHWallet.type:
      case HDLegacyElectrumSeedP2PKHWallet.type:
      case SLIP39LegacyP2PKHWallet.type:
        gradient = WalletGradient.hdLegacyP2PKHWallet;
        break;
      case HDLegacyBreadwalletWallet.type:
        gradient = WalletGradient.hdLegacyBreadWallet;
        break;
      case HDSegwitP2SHWallet.type:
      case SLIP39SegwitP2SHWallet.type:
        gradient = WalletGradient.hdSegwitP2SHWallet;
        break;
      case HDSegwitBech32Wallet.type:
      case HDSegwitElectrumSeedP2WPKHWallet.type:
      case SLIP39SegwitBech32Wallet.type:
        gradient = WalletGradient.hdSegwitBech32Wallet;
        break;
      case SegwitBech32Wallet.type:
        gradient = WalletGradient.segwitBech32Wallet;
        break;
      case MultisigHDWallet.type:
        gradient = WalletGradient.multisigHdWallet;
        break;
      case HDAezeedWallet.type:
        gradient = WalletGradient.aezeedWallet;
        break;
      case LightningArkWallet.type:
      case LightningCustodianWallet.type:
        gradient = WalletGradient.lightningCustodianWallet;
        break;
      default:
        gradient = WalletGradient.defaultGradients;
        break;
    }
    return gradient;
  }

  static linearGradientProps(type: string) {
    let props: any;
    switch (type) {
      case MultisigHDWallet.type:
        /* Example
        props = { start: { x: 0, y: 0 } };
        https://github.com/react-native-linear-gradient/react-native-linear-gradient
        */
        break;
      default:
        break;
    }
    return props;
  }

  static headerColorFor(type: string): string {
    let gradient: string[];
    switch (type) {
      case WatchOnlyWallet.type:
        gradient = WalletGradient.watchOnlyWallet;
        break;
      case LegacyWallet.type:
        gradient = WalletGradient.legacyWallet;
        break;
      case TaprootWallet.type:
        gradient = WalletGradient.taprootWallet;
        break;
      case HDLegacyP2PKHWallet.type:
      case HDLegacyElectrumSeedP2PKHWallet.type:
      case SLIP39LegacyP2PKHWallet.type:
        gradient = WalletGradient.hdLegacyP2PKHWallet;
        break;
      case HDLegacyBreadwalletWallet.type:
        gradient = WalletGradient.hdLegacyBreadWallet;
        break;
      case HDSegwitP2SHWallet.type:
      case SLIP39SegwitP2SHWallet.type:
        gradient = WalletGradient.hdSegwitP2SHWallet;
        break;
      case HDSegwitBech32Wallet.type:
      case HDSegwitElectrumSeedP2WPKHWallet.type:
      case SLIP39SegwitBech32Wallet.type:
        gradient = WalletGradient.hdSegwitBech32Wallet;
        break;
      case SegwitBech32Wallet.type:
        gradient = WalletGradient.segwitBech32Wallet;
        break;
      case MultisigHDWallet.type:
        gradient = WalletGradient.multisigHdWallet;
        break;
      case HDAezeedWallet.type:
        gradient = WalletGradient.aezeedWallet;
        break;
      case LightningArkWallet.type:
      case LightningCustodianWallet.type:
        gradient = WalletGradient.lightningCustodianWallet;
        break;
      default:
        gradient = WalletGradient.defaultGradients;
        break;
    }
    return gradient[0];
  }
}


================================================
FILE: ./class/malin-app.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import { sha256 } from '@noble/hashes/sha256';
import DefaultPreference from 'react-native-default-preference';
import RNFS from 'react-native-fs';
import Keychain from 'react-native-keychain';
import RNSecureKeyStore, { ACCESSIBLE } from 'react-native-secure-key-store';
import Realm from 'realm';

import * as encryption from '../malin_modules/encryption';
import presentAlert from '../components/Alert';
import { randomBytes } from './rng';
import { HDAezeedWallet } from './wallets/hd-aezeed-wallet';
import { HDLegacyBreadwalletWallet } from './wallets/hd-legacy-breadwallet-wallet';
import { HDLegacyElectrumSeedP2PKHWallet } from './wallets/hd-legacy-electrum-seed-p2pkh-wallet';
import { HDLegacyP2PKHWallet } from './wallets/hd-legacy-p2pkh-wallet';
import { HDSegwitBech32Wallet } from './wallets/hd-segwit-bech32-wallet';
import { HDSegwitElectrumSeedP2WPKHWallet } from './wallets/hd-segwit-electrum-seed-p2wpkh-wallet';
import { HDSegwitP2SHWallet } from './wallets/hd-segwit-p2sh-wallet';
import { LegacyWallet } from './wallets/legacy-wallet';
import { LightningCustodianWallet } from './wallets/lightning-custodian-wallet';
import { MultisigHDWallet } from './wallets/multisig-hd-wallet';
import { SegwitBech32Wallet } from './wallets/segwit-bech32-wallet';
import { SegwitP2SHWallet } from './wallets/segwit-p2sh-wallet';
import { SLIP39LegacyP2PKHWallet, SLIP39SegwitBech32Wallet, SLIP39SegwitP2SHWallet } from './wallets/slip39-wallets';
import { ExtendedTransaction, Transaction, TWallet } from './wallets/types';
import { WatchOnlyWallet } from './wallets/watch-only-wallet';
import { getLNDHub } from '../helpers/lndHub';
import { LightningArkWallet } from './wallets/lightning-ark-wallet.ts';
import { hexToUint8Array, uint8ArrayToHex } from '../malin_modules/uint8array-extras';
import { HDTaprootWallet } from './wallets/hd-taproot-wallet';

let usedBucketNum: boolean | number = false;
let savingInProgress = 0; // its both a flag and a counter of attempts to write to disk

export type TTXMetadata = {
  [txid: string]: {
    memo?: string;
  };
};

export type TCounterpartyMetadata = {
  /**
   * our contact identifier, such as bip47 payment code
   */
  [counterparty: string]: {
    /**
     * custom human-readable name we assign ourselves
     */
    label: string;
    /**
     * some counterparties cannot be deleted because they sent a notif tx onchain, so we just mark them as hidden when user deletes
     */
    hidden?: boolean;
  };
};

type TRealmTransaction = {
  internal: boolean;
  index: number;
  tx: string;
};

type TBucketStorage = {
  wallets: string[]; // array of serialized wallets, not actual wallet objects
  tx_metadata: TTXMetadata;
  counterparty_metadata: TCounterpartyMetadata;
};

const isReactNative = typeof navigator !== 'undefined' && navigator?.product === 'ReactNative';

export class MalinApp {
  static FLAG_ENCRYPTED = 'data_encrypted';
  static LNDHUB = 'lndhub';
  static DO_NOT_TRACK = 'donottrack';
  static HANDOFF_STORAGE_KEY = 'HandOff';

  private static _instance: MalinApp | null = null;

  static keys2migrate = [MalinApp.HANDOFF_STORAGE_KEY, MalinApp.DO_NOT_TRACK];

  public cachedPassword?: false | string;
  public tx_metadata: TTXMetadata;
  public counterparty_metadata: TCounterpartyMetadata;
  public wallets: TWallet[];

  constructor() {
    this.wallets = [];
    this.tx_metadata = {};
    this.counterparty_metadata = {};
    this.cachedPassword = false;
  }

  static getInstance(): MalinApp {
    if (!MalinApp._instance) {
      MalinApp._instance = new MalinApp();
    }

    return MalinApp._instance;
  }

  async migrateKeys() {
    // do not migrate keys if we are not in RN env
    if (!isReactNative) {
      return;
    }

    for (const key of MalinApp.keys2migrate) {
      try {
        const value = await RNSecureKeyStore.get(key);
        if (value) {
          await AsyncStorage.setItem(key, value);
          await RNSecureKeyStore.remove(key);
        }
      } catch (_) {}
    }
  }

  /**
   * Wrapper for storage call. Secure store works only in RN environment. AsyncStorage is
   * used for cli/tests
   */
  setItem = (key: string, value: any): Promise<any> => {
    if (isReactNative) {
      return RNSecureKeyStore.set(key, value, { accessible: ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY });
    } else {
      return AsyncStorage.setItem(key, value);
    }
  };

  /**
   * Wrapper for storage call. Secure store works only in RN environment. AsyncStorage is
   * used for cli/tests
   */
  getItem = (key: string): Promise<any> => {
    if (isReactNative) {
      return RNSecureKeyStore.get(key);
    } else {
      return AsyncStorage.getItem(key);
    }
  };

  getItemWithFallbackToRealm = async (key: string): Promise<any | null> => {
    let value;
    try {
      return await this.getItem(key);
    } catch (error: any) {
      console.warn('error reading', key, error.message);
      console.warn('fallback to realm');
      const realmKeyValue = await this.openRealmKeyValue();
      const obj = realmKeyValue.objectForPrimaryKey('KeyValue', key); // search for a realm object with a primary key
      value = obj?.value;
      realmKeyValue.close();
      if (value) {
        // @ts-ignore value.length
        console.warn('successfully recovered', value.length, 'bytes from realm for key', key);
        return value;
      }
      return null;
    }
  };

  storageIsEncrypted = async (): Promise<boolean> => {
    let data;
    try {
      data = await this.getItemWithFallbackToRealm(MalinApp.FLAG_ENCRYPTED);
    } catch (error: any) {
      console.warn('error reading `' + MalinApp.FLAG_ENCRYPTED + '` key:', error.message);
      return false;
    }

    return Boolean(data);
  };

  isPasswordInUse = async (password: string) => {
    try {
      let data = await this.getItem('data');
      data = this.decryptData(data, password);
      return Boolean(data);
    } catch (_e) {
      return false;
    }
  };

  /**
   * Iterates through all values of `data` trying to
   * decrypt each one, and returns first one successfully decrypted
   */
  decryptData(data: string, password: string): boolean | string {
    data = JSON.parse(data);
    let decrypted;
    let num = 0;
    for (const value of data) {
      decrypted = encryption.decrypt(value, password);

      if (decrypted) {
        usedBucketNum = num;
        return decrypted;
      }
      num++;
    }

    return false;
  }

  decryptStorage = async (password: string): Promise<boolean> => {
    if (password === this.cachedPassword) {
      this.cachedPassword = undefined;
      await this.saveToDisk();
      this.wallets = [];
      this.tx_metadata = {};
      this.counterparty_metadata = {};
      return this.loadFromDisk();
    } else {
      throw new Error('Incorrect password. Please, try again.');
    }
  };

  encryptStorage = async (password: string): Promise<void> => {
    // assuming the storage is not yet encrypted
    await this.saveToDisk();
    let data = await this.getItem('data');
    // TODO: refactor ^^^ (should not save & load to fetch data)

    const encrypted = encryption.encrypt(data, password);
    data = [];
    data.push(encrypted); // putting in array as we might have many buckets with storages
    data = JSON.stringify(data);
    this.cachedPassword = password;
    await this.setItem('data', data);
    await this.setItem(MalinApp.FLAG_ENCRYPTED, '1');
  };

  /**
   * Cleans up all current application data (wallets, tx metadata etc)
   * Encrypts the bucket and saves it storage
   */
  createFakeStorage = async (fakePassword: string): Promise<boolean> => {
    usedBucketNum = false; // resetting currently used bucket so we wont overwrite it
    this.wallets = [];
    this.tx_metadata = {};
    this.counterparty_metadata = {};

    const data: TBucketStorage = {
      wallets: [],
      tx_metadata: {},
      counterparty_metadata: {},
    };

    let buckets = await this.getItem('data');
    buckets = JSON.parse(buckets);
    buckets.push(encryption.encrypt(JSON.stringify(data), fakePassword));
    this.cachedPassword = fakePassword;
    const bucketsString = JSON.stringify(buckets);
    await this.setItem('data', bucketsString);
    return (await this.getItem('data')) === bucketsString;
  };

  hashIt = (s: string): string => {
    return uint8ArrayToHex(sha256(s));
  };

  /**
   * Returns instace of the Realm database, which is encrypted either by cached user's password OR default password.
   * Database file is deterministically derived from encryption key.
   */
  async getRealmForTransactions() {
    const cacheFolderPath = RNFS.CachesDirectoryPath; // Path to cache folder
    const password = this.hashIt(this.cachedPassword || 'fyegjitkyf[eqjnc.lf');
    const buf = hexToUint8Array(this.hashIt(password) + this.hashIt(password));
    const encryptionKey = Int8Array.from(buf);
    const fileName = this.hashIt(this.hashIt(password)) + '-wallettransactions.realm';
    const path = `${cacheFolderPath}/${fileName}`; // Use cache folder path

    const schema = [
      {
        name: 'WalletTransactions',
        properties: {
          walletid: { type: 'string', indexed: true },
          internal: 'bool?', // true - internal, false - external
          index: 'int?',
          tx: 'string', // stringified json
        },
      },
    ];
    // @ts-ignore schema doesn't match Realm's schema type
    return Realm.open({
      // @ts-ignore schema doesn't match Realm's schema type
      schema,
      path,
      encryptionKey,
      excludeFromIcloudBackup: true,
    });
  }

  /**
   * Returns instace of the Realm database, which is encrypted by random bytes stored in keychain.
   * Database file is static.
   *
   * @returns {Promise<Realm>}
   */
  async openRealmKeyValue(): Promise<Realm> {
    const cacheFolderPath = RNFS.CachesDirectoryPath; // Path to cache folder
    const service = 'realm_encryption_key';
    let password;
    const credentials = await Keychain.getGenericPassword({ service });
    if (credentials) {
      password = credentials.password;
    } else {
      const buf = await randomBytes(64);
      password = uint8ArrayToHex(buf);
      await Keychain.setGenericPassword(service, password, { service });
    }

    const buf = hexToUint8Array(password);
    const encryptionKey = Int8Array.from(buf);
    const path = `${cacheFolderPath}/keyvalue.realm`; // Use cache folder path

    const schema = [
      {
        name: 'KeyValue',
        primaryKey: 'key',
        properties: {
          key: { type: 'string', indexed: true },
          value: 'string', // stringified json, or whatever
        },
      },
    ];
    // @ts-ignore schema doesn't match Realm's schema type
    return Realm.open({
      // @ts-ignore schema doesn't match Realm's schema type
      schema,
      path,
      encryptionKey,
      excludeFromIcloudBackup: true,
    });
  }

  saveToRealmKeyValue(realmkeyValue: Realm, key: string, value: any) {
    realmkeyValue.write(() => {
      realmkeyValue.create(
        'KeyValue',
        {
          key,
          value,
        },
        Realm.UpdateMode.Modified,
      );
    });
  }

  /**
   * Loads from storage all wallets and
   * maps them to `this.wallets`
   *
   * @param password If present means storage must be decrypted before usage
   * @returns {Promise.<boolean>}
   */
  async loadFromDisk(password?: string): Promise<boolean> {
    // Wrap inside a try so if anything goes wrong it wont block loadFromDisk from continuing
    try {
      await this.moveRealmFilesToCacheDirectory();
    } catch (error: any) {
      console.warn('moveRealmFilesToCacheDirectory error:', error.message);
    }
    let dataRaw = await this.getItemWithFallbackToRealm('data');
    if (password) {
      dataRaw = this.decryptData(dataRaw, password);
      if (dataRaw) {
        // password is good, cache it
        this.cachedPassword = password;
      }
    }
    if (dataRaw !== null) {
      let realm;
      try {
        realm = await this.getRealmForTransactions();
      } catch (error: any) {
        presentAlert({ message: error.message });
      }
      const data: TBucketStorage = JSON.parse(dataRaw);
      if (!data.wallets) return false;
      const wallets = data.wallets;
      for (const key of wallets) {
        // deciding which type is wallet and instantiating correct object
        const tempObj = JSON.parse(key);
        let unserializedWallet: TWallet;
        switch (tempObj.type) {
          case SegwitBech32Wallet.type:
            unserializedWallet = SegwitBech32Wallet.fromJson(key) as unknown as SegwitBech32Wallet;
            break;
          case SegwitP2SHWallet.type:
            unserializedWallet = SegwitP2SHWallet.fromJson(key) as unknown as SegwitP2SHWallet;
            break;
          case WatchOnlyWallet.type:
            unserializedWallet = WatchOnlyWallet.fromJson(key) as unknown as WatchOnlyWallet;
            unserializedWallet.init();
            if (unserializedWallet.isHd() && !unserializedWallet.isXpubValid()) {
              continue;
            }
            break;
          case HDLegacyP2PKHWallet.type:
            unserializedWallet = HDLegacyP2PKHWallet.fromJson(key) as unknown as HDLegacyP2PKHWallet;
            break;
          case HDSegwitP2SHWallet.type:
            unserializedWallet = HDSegwitP2SHWallet.fromJson(key) as unknown as HDSegwitP2SHWallet;
            break;
          case HDSegwitBech32Wallet.type:
            unserializedWallet = HDSegwitBech32Wallet.fromJson(key) as unknown as HDSegwitBech32Wallet;
            break;
          case HDTaprootWallet.type:
            unserializedWallet = HDTaprootWallet.fromJson(key) as unknown as HDTaprootWallet;
            break;
          case HDLegacyBreadwalletWallet.type:
            unserializedWallet = HDLegacyBreadwalletWallet.fromJson(key) as unknown as HDLegacyBreadwalletWallet;
            break;
          case HDLegacyElectrumSeedP2PKHWallet.type:
            unserializedWallet = HDLegacyElectrumSeedP2PKHWallet.fromJson(key) as unknown as HDLegacyElectrumSeedP2PKHWallet;
            break;
          case HDSegwitElectrumSeedP2WPKHWallet.type:
            unserializedWallet = HDSegwitElectrumSeedP2WPKHWallet.fromJson(key) as unknown as HDSegwitElectrumSeedP2WPKHWallet;
            break;
          case MultisigHDWallet.type:
            unserializedWallet = MultisigHDWallet.fromJson(key) as unknown as MultisigHDWallet;
            break;
          case HDAezeedWallet.type:
            unserializedWallet = HDAezeedWallet.fromJson(key) as unknown as HDAezeedWallet;
            // migrate password to this.passphrase field
            // remove this code somewhere in year 2022
            if (unserializedWallet.secret.includes(':')) {
              const [mnemonic, passphrase] = unserializedWallet.secret.split(':');
              unserializedWallet.secret = mnemonic;
              unserializedWallet.passphrase = passphrase;
            }

            break;
          case SLIP39SegwitP2SHWallet.type:
            unserializedWallet = SLIP39SegwitP2SHWallet.fromJson(key) as unknown as SLIP39SegwitP2SHWallet;
            break;
          case SLIP39LegacyP2PKHWallet.type:
            unserializedWallet = SLIP39LegacyP2PKHWallet.fromJson(key) as unknown as SLIP39LegacyP2PKHWallet;
            break;
          case SLIP39SegwitBech32Wallet.type:
            unserializedWallet = SLIP39SegwitBech32Wallet.fromJson(key) as unknown as SLIP39SegwitBech32Wallet;
            break;
          case LightningArkWallet.type:
            unserializedWallet = LightningArkWallet.fromJson(key) as unknown as LightningArkWallet;
            break;
          case LightningCustodianWallet.type: {
            unserializedWallet = LightningCustodianWallet.fromJson(key) as unknown as LightningCustodianWallet;
            let lndhub: false | any = false;
            try {
              lndhub = await getLNDHub();
            } catch (error) {
              console.warn(error);
            }

            if (unserializedWallet.baseURI) {
              unserializedWallet.setBaseURI(unserializedWallet.baseURI); // not really necessary, just for the sake of readability
              console.log('using saved uri for for ln wallet:', unserializedWallet.baseURI);
            } else if (lndhub) {
              console.log('using wallet-wide settings ', lndhub, 'for ln wallet');
              unserializedWallet.setBaseURI(lndhub);
            } else {
              console.log('wallet does not have a baseURI. Continuing init...');
            }
            unserializedWallet.init();
            break;
          }
          case 'lightningLdk':
            // since ldk wallets are deprecated and removed, we need to handle a case when such wallet still exists in storage
            unserializedWallet = new HDSegwitBech32Wallet();
            unserializedWallet.setSecret(tempObj.secret.replace('ldk://', ''));
            break;
          case LegacyWallet.type:
          default:
            unserializedWallet = LegacyWallet.fromJson(key) as unknown as LegacyWallet;
            break;
        }

        try {
          if (realm) this.inflateWalletFromRealm(realm, unserializedWallet);
        } catch (error: any) {
          presentAlert({ message: error.message });
        }

        // done
        const ID = unserializedWallet.getID();
        if (!this.wallets.some(wallet => wallet.getID() === ID)) {
          this.wallets.push(unserializedWallet);
          this.tx_metadata = data.tx_metadata;
          this.counterparty_metadata = data.counterparty_metadata;
        }
      }
      if (realm) realm.close();
      return true;
    } else {
      return false; // failed loading data or loading/decryptin data
    }
  }

  /**
   * Lookup wallet in list by it's secret and
   * remove it from `this.wallets`
   *
   * @param wallet {AbstractWallet}
   */
  deleteWallet = (wallet: TWallet): void => {
    const ID = wallet.getID();
    const tempWallets = [];

    for (const value of this.wallets) {
      if (value.getID() === ID) {
        // the one we should delete
        // nop
      } else {
        // the one we must keep
        tempWallets.push(value);
      }
    }
    this.wallets = tempWallets;
  };

  inflateWalletFromRealm(realm: Realm, walletToInflate: TWallet) {
    const transactions = realm.objects('WalletTransactions');
    const transactionsForWallet = transactions.filtered(`walletid = "${walletToInflate.getID()}"`) as unknown as TRealmTransaction[];
    for (const tx of transactionsForWallet) {
      if (tx.internal === false) {
        if ('_hdWalletInstance' in walletToInflate && walletToInflate._hdWalletInstance) {
          const hd = walletToInflate._hdWalletInstance;
          hd._txs_by_external_index[tx.index] = hd._txs_by_external_index[tx.index] || [];
          const transaction = JSON.parse(tx.tx);
          hd._txs_by_external_index[tx.index].push(transaction);
        } else {
          walletToInflate._txs_by_external_index[tx.index] = walletToInflate._txs_by_external_index[tx.index] || [];
          const transaction = JSON.parse(tx.tx);
          (walletToInflate._txs_by_external_index[tx.index] as Transaction[]).push(transaction);
        }
      } else if (tx.internal === true) {
        if ('_hdWalletInstance' in walletToInflate && walletToInflate._hdWalletInstance) {
          const hd = walletToInflate._hdWalletInstance;
          hd._txs_by_internal_index[tx.index] = hd._txs_by_internal_index[tx.index] || [];
          const transaction = JSON.parse(tx.tx);
          hd._txs_by_internal_index[tx.index].push(transaction);
        } else {
          walletToInflate._txs_by_internal_index[tx.index] = walletToInflate._txs_by_internal_index[tx.index] || [];
          const transaction = JSON.parse(tx.tx);
          (walletToInflate._txs_by_internal_index[tx.index] as Transaction[]).push(transaction);
        }
      } else {
        if (!Array.isArray(walletToInflate._txs_by_external_index)) walletToInflate._txs_by_external_index = [];
        walletToInflate._txs_by_external_index = walletToInflate._txs_by_external_index || [];
        const transaction = JSON.parse(tx.tx);
        (walletToInflate._txs_by_external_index as Transaction[]).push(transaction);
      }
    }
  }

  offloadWalletToRealm(realm: Realm, wallet: TWallet): void {
    const id = wallet.getID();
    const walletToSave = ('_hdWalletInstance' in wallet && wallet._hdWalletInstance) || wallet;

    if (Array.isArray(walletToSave._txs_by_external_index)) {
      // if this var is an array that means its a single-address wallet class, and this var is a flat array
      // with transactions
      realm.write(() => {
        // cleanup all existing transactions for the wallet first
        const walletTransactionsToDelete = realm.objects('WalletTransactions').filtered(`walletid = '${id}'`);
        realm.delete(walletTransactionsToDelete);

        // @ts-ignore walletToSave._txs_by_external_index is array
        for (const tx of walletToSave._txs_by_external_index) {
          realm.create(
            'WalletTransactions',
            {
              walletid: id,
              tx: JSON.stringify(tx),
            },
            Realm.UpdateMode.Modified,
          );
        }
      });

      return;
    }

    /// ########################################################################################################

    if (walletToSave._txs_by_external_index) {
      realm.write(() => {
        // cleanup all existing transactions for the wallet first
        const walletTransactionsToDelete = realm.objects('WalletTransactions').filtered(`walletid = '${id}'`);
        realm.delete(walletTransactionsToDelete);

        // insert new ones:
        for (const index of Object.keys(walletToSave._txs_by_external_index)) {
          // @ts-ignore index is number
          const txs = walletToSave._txs_by_external_index[index];
          for (const tx of txs) {
            realm.create(
              'WalletTransactions',
              {
                walletid: id,
                internal: false,
                index: parseInt(index, 10),
                tx: JSON.stringify(tx),
              },
              Realm.UpdateMode.Modified,
            );
          }
        }

        for (const index of Object.keys(walletToSave._txs_by_internal_index)) {
          // @ts-ignore index is number
          const txs = walletToSave._txs_by_internal_index[index];
          for (const tx of txs) {
            realm.create(
              'WalletTransactions',
              {
                walletid: id,
                internal: true,
                index: parseInt(index, 10),
                tx: JSON.stringify(tx),
              },
              Realm.UpdateMode.Modified,
            );
          }
        }
      });
    }
  }

  /**
   * Serializes and saves to storage object data.
   * If cached password is saved - finds the correct bucket
   * to save to, encrypts and then saves.
   *
   * @returns {Promise} Result of storage save
   */
  async saveToDisk(): Promise<void> {
    if (savingInProgress) {
      console.warn('saveToDisk is in progress');
      if (++savingInProgress > 10) presentAlert({ message: 'Critical error. Last actions were not saved' }); // should never happen
      await new Promise(resolve => setTimeout(resolve, 1000 * savingInProgress)); // sleep
      return this.saveToDisk();
    }
    savingInProgress = 1;

    try {
      const walletsToSave: string[] = []; // serialized wallets
      let realm;
      try {
        realm = await this.getRealmForTransactions();
      } catch (error: any) {
        presentAlert({ message: error.message });
      }
      for (const key of this.wallets) {
        if (typeof key === 'boolean') continue;
        key.prepareForSerialization();
        // @ts-ignore wtf is wallet.current? Does it even exist?
        delete key.current;
        const keyCloned = Object.assign({}, key); // stripped-down version of a wallet to save to secure keystore
        if ('_hdWalletInstance' in key) {
          const k = keyCloned as any & WatchOnlyWallet;
          k._hdWalletInstance = Object.assign({}, key._hdWalletInstance);
          k._hdWalletInstance._txs_by_external_index = {};
          k._hdWalletInstance._txs_by_internal_index = {};
        }
        if (realm) this.offloadWalletToRealm(realm, key);
        // stripping down:
        if (key._txs_by_external_index) {
          keyCloned._txs_by_external_index = {};
          keyCloned._txs_by_internal_index = {};
        }

        if ('_bip47_instance' in keyCloned) {
          delete keyCloned._bip47_instance; // since it wont be restored into a proper class instance
        }

        walletsToSave.push(JSON.stringify({ ...keyCloned, type: keyCloned.type }));
      }
      if (realm) realm.close();

      let data: TBucketStorage | string[] /* either a bucket, or an array of encrypted buckets */ = {
        wallets: walletsToSave,
        tx_metadata: this.tx_metadata,
        counterparty_metadata: this.counterparty_metadata,
      };

      if (this.cachedPassword) {
        // should find the correct bucket, encrypt and then save
        let buckets = await this.getItemWithFallbackToRealm('data');
        buckets = JSON.parse(buckets);
        const newData: string[] = []; // serialized buckets
        let num = 0;
        for (const bucket of buckets) {
          let decrypted;
          // if we had `usedBucketNum` during loadFromDisk(), no point to try to decode each bucket to find the one we
          // need, we just to find bucket with the same index
          if (usedBucketNum !== false) {
            if (num === usedBucketNum) {
              decrypted = true;
            }
            num++;
          } else {
            // we dont have `usedBucketNum` for whatever reason, so lets try to decrypt each bucket after bucket
            // till we find the right one
            decrypted = encryption.decrypt(bucket, this.cachedPassword);
          }

          if (!decrypted) {
            // no luck decrypting, its not our bucket
            newData.push(bucket);
          } else {
            // decrypted ok, this is our bucket
            // we serialize our object's data, encrypt it, and add it to buckets
            newData.push(encryption.encrypt(JSON.stringify(data), this.cachedPassword));
          }
        }

        data = newData;
      }

      await this.setItem('data', JSON.stringify(data));
      await this.setItem(MalinApp.FLAG_ENCRYPTED, this.cachedPassword ? '1' : '');

      // now, backing up same data in realm:
      const realmkeyValue = await this.openRealmKeyValue();
      this.saveToRealmKeyValue(realmkeyValue, 'data', JSON.stringify(data));
      this.saveToRealmKeyValue(realmkeyValue, MalinApp.FLAG_ENCRYPTED, this.cachedPassword ? '1' : '');
      realmkeyValue.close();
    } catch (error: any) {
      console.error('save to disk exception:', error.message);
      presentAlert({ message: 'save to disk exception: ' + error.message });
      if (error.message.includes('Realm file decryption failed')) {
        console.warn('purging realm key-value database file');
        this.purgeRealmKeyValueFile();
      }
    } finally {
      savingInProgress = 0;
    }
  }

  /**
   * For each wallet, fetches balance from remote endpoint.
   * Use getter for a specific wallet to get actual balance.
   * Returns void.
   * If index is present then fetch only from this specific wallet
   */
  fetchWalletBalances = async (index?: number): Promise<void> => {
    console.log('fetchWalletBalances for wallet#', typeof index === 'undefined' ? '(all)' : index);
    if (index || index === 0) {
      let c = 0;
      for (const wallet of this.wallets) {
        if (c++ === index) {
          await wallet.fetchBalance();
        }
      }
    } else {
      for (const wallet of this.wallets) {
        console.log('fetching balance for', wallet.getLabel());
        await wallet.fetchBalance();
      }
    }
  };

  /**
   * Fetches from remote endpoint all transactions for each wallet.
   * Returns void.
   * To access transactions - get them from each respective wallet.
   * If index is present then fetch only from this specific wallet.
   *
   * @param index {Integer} Index of the wallet in this.wallets array,
   *                        blank to fetch from all wallets
   * @return {Promise.<void>}
   */
  fetchWalletTransactions = async (index?: number) => {
    console.log('fetchWalletTransactions for wallet#', typeof index === 'undefined' ? '(all)' : index);
    if (index || index === 0) {
      let c = 0;
      for (const wallet of this.wallets) {
        if (c++ === index) {
          await wallet.fetchTransactions();

          if ('fetchPendingTransactions' in wallet) {
            await wallet.fetchPendingTransactions();
            await wallet.fetchUserInvoices();
          }
        }
      }
    } else {
      for (const wallet of this.wallets) {
        await wallet.fetchTransactions();
        if ('fetchPendingTransactions' in wallet) {
          await wallet.fetchPendingTransactions();
          await wallet.fetchUserInvoices();
        }
      }
    }
  };

  fetchSenderPaymentCodes = async (index?: number) => {
    console.log('fetchSenderPaymentCodes for wallet#', typeof index === 'undefined' ? '(all)' : index);
    if (index || index === 0) {
      const wallet = this.wallets[index];
      try {
        if (!(wallet.allowBIP47() && wallet.isBIP47Enabled() && 'fetchBIP47SenderPaymentCodes' in wallet)) return;
        await wallet.fetchBIP47SenderPaymentCodes();
      } catch (error) {
        console.error('Failed to fetch sender payment codes for wallet', index, error);
      }
    } else {
      for (const wallet of this.wallets) {
        try {
          if (!(wallet.allowBIP47() && wallet.isBIP47Enabled() && 'fetchBIP47SenderPaymentCodes' in wallet)) continue;
          await wallet.fetchBIP47SenderPaymentCodes();
        } catch (error) {
          console.error('Failed to fetch sender payment codes for wallet', wallet.label, error);
        }
      }
    }
  };

  getWallets = (): TWallet[] => {
    return this.wallets;
  };

  /**
   * Getter for all transactions in all wallets.
   * But if index is provided - only for wallet with corresponding index
   *
   * @param index {number|undefined} Wallet index in this.wallets. Empty (or undef) for all wallets.
   * @param limit {number} How many txs return, starting from the earliest. Default: all of them.
   * @param includeWalletsWithHideTransactionsEnabled {boolean} Wallets' _hideTransactionsInWalletsList property determines wether the user wants this wallet's txs hidden from the main list view.
   */
  getTransactions = (
    index?: number,
    limit: number = Infinity,
    includeWalletsWithHideTransactionsEnabled: boolean = false,
  ): ExtendedTransaction[] => {
    if (index || index === 0) {
      let txs: Transaction[] = [];
      let c = 0;
      for (const wallet of this.wallets) {
        if (c++ === index) {
          txs = txs.concat(wallet.getTransactions());

          const txsRet: ExtendedTransaction[] = [];
          const walletID = wallet.getID();
          const walletPreferredBalanceUnit = wallet.getPreferredBalanceUnit();
          txs.map(tx =>
            txsRet.push({
              ...tx,
              walletID,
              walletPreferredBalanceUnit,
            }),
          );
          return txsRet;
        }
      }
    }

    const txs: ExtendedTransaction[] = [];
    for (const wallet of this.wallets.filter(w => includeWalletsWithHideTransactionsEnabled || !w.getHideTransactionsInWalletsList())) {
      const walletTransactions: Transaction[] = wallet.getTransactions();
      const walletID = wallet.getID();
      const walletPreferredBalanceUnit = wallet.getPreferredBalanceUnit();
      for (const t of walletTransactions) {
        txs.push({
          ...t,
          walletID,
          walletPreferredBalanceUnit,
        });
      }
    }

    return txs
      .sort((a, b) => {
        return b.timestamp - a.timestamp;
      })
      .slice(0, limit);
  };

  /**
   * Getter for a sum of all balances of all wallets
   */
  getBalance = (): number => {
    let finalBalance = 0;
    for (const wal of this.wallets) {
      finalBalance += wal.getBalance();
    }
    return finalBalance;
  };

  isHandoffEnabled = async (): Promise<boolean> => {
    try {
      return !!(await AsyncStorage.getItem(MalinApp.HANDOFF_STORAGE_KEY));
    } catch (_) {}
    return false;
  };

  setIsHandoffEnabled = async (value: boolean): Promise<void> => {
    await AsyncStorage.setItem(MalinApp.HANDOFF_STORAGE_KEY, value ? '1' : '');
  };

  isDoNotTrackEnabled = async (): Promise<boolean> => {
    try {
      const keyExists = await AsyncStorage.getItem(MalinApp.DO_NOT_TRACK);
      if (keyExists !== null) {
        const doNotTrackValue = !!keyExists;
        if (doNotTrackValue) {
          await DefaultPreference.set(MalinApp.DO_NOT_TRACK, '1');
          AsyncStorage.removeItem(MalinApp.DO_NOT_TRACK);
        } else {
          return Boolean(await DefaultPreference.get(MalinApp.DO_NOT_TRACK));
        }
      }
    } catch (_) {}
    const doNotTrackValue = await DefaultPreference.get(MalinApp.DO_NOT_TRACK);
    return doNotTrackValue === '1' || false;
  };

  setDoNotTrack = async (value: boolean) => {
    if (value) {
      await DefaultPreference.set(MalinApp.DO_NOT_TRACK, '1');
    } else {
      await DefaultPreference.clear(MalinApp.DO_NOT_TRACK);
    }
  };

  /**
   * Simple async sleeper function
   */
  sleep = (ms: number): Promise<void> => {
    return new Promise(resolve => setTimeout(resolve, ms));
  };

  purgeRealmKeyValueFile() {
    const path = 'keyvalue.realm';
    return Realm.deleteFile({
      path,
    });
  }

  async moveRealmFilesToCacheDirectory() {
    const documentPath = RNFS.DocumentDirectoryPath; // Path to documentPath folder
    const cachePath = RNFS.CachesDirectoryPath; // Path to cachePath folder
    try {
      if (!(await RNFS.exists(documentPath))) return; // If the documentPath directory does not exist, return (nothing to move)
      const files = await RNFS.readDir(documentPath); // Read all files in documentPath directory
      if (Array.isArray(files) && files.length === 0) return; // If there are no files, return (nothing to move)
      const appRealmFiles = files.filter(
        file => file.name.endsWith('.realm') || file.name.endsWith('.realm.lock') || file.name.includes('.realm.management'),
      );

      for (const file of appRealmFiles) {
        const filePath = `${documentPath}/${file.name}`;
        const newFilePath = `${cachePath}/${file.name}`;
        const fileExists = await RNFS.exists(filePath); // Check if the file exists
        const cacheFileExists = await RNFS.exists(newFilePath); // Check if the file already exists in the cache directory

        if (fileExists) {
          if (cacheFileExists) {
            await RNFS.unlink(newFilePath); // Delete the file in the cache directory if it exists
            console.log(`Existing file removed from cache: ${newFilePath}`);
          }
          await RNFS.moveFile(filePath, newFilePath); // Move the file
          console.log(`Moved Realm file: ${filePath} to ${newFilePath}`);
        } else {
          console.log(`File does not exist: ${filePath}`);
        }
      }
    } catch (error) {
      console.error('Error moving Realm files:', error);
      throw new Error(`Error moving Realm files: ${(error as Error).message}`);
    }
  }
}


================================================
FILE: ./class/wallet-import.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import bip38 from 'bip38';
import wif from 'wif';

import loc from '../loc';
import {
  HDAezeedWallet,
  HDLegacyBreadwalletWallet,
  HDLegacyElectrumSeedP2PKHWallet,
  HDLegacyP2PKHWallet,
  HDSegwitBech32Wallet,
  HDSegwitElectrumSeedP2WPKHWallet,
  HDSegwitP2SHWallet,
  HDTaprootWallet,
  LegacyWallet,
  LightningCustodianWallet,
  LightningArkWallet,
  MultisigHDWallet,
  SegwitBech32Wallet,
  SegwitP2SHWallet,
  SLIP39LegacyP2PKHWallet,
  SLIP39SegwitBech32Wallet,
  SLIP39SegwitP2SHWallet,
  TaprootWallet,
  WatchOnlyWallet,
} from '.';
import bip39WalletFormatsElectrum from './bip39_wallet_formats.json'; // https://github.com/spesmilo/electrum/blob/master/electrum/bip39_wallet_formats.json
import bip39WalletFormatsMalinWallet from './bip39_wallet_formats_malinwallet.json';
import type { TWallet } from './wallets/types';

// https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts#L43
export const validateBip32 = (path: string) =>
  path.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;

// because original file bip39WalletFormatsElectrum is from Electrum X and doesn't contain p2tr wallets, we need to add it
bip39WalletFormatsElectrum.push({
  description: 'Standard BIP86 native taproot',
  derivation_path: "m/86'/0'/0'",
  script_type: 'p2tr',
  iterate_accounts: true,
})

type TStatus = {
  cancelled: boolean;
  stopped: boolean;
  wallets: TWallet[];
};

export type TImport = {
  promise: Promise<TStatus>;
  stop: () => void;
};

/**
 * Function that starts wallet search and import process. It has async generator inside, so
 * that the process can be stoped at any time. It reporst all the progress through callbacks.
 *
 * @param askPassphrase {boolean} If true import process will call onPassword callback for wallet with optional password.
 * @param searchAccounts {boolean} If true import process will scan for all known derivation path from bip39_wallet_formats.json. If false it will use limited version.
 * @param onProgress {function} Callback to report scanning progress
 * @param onWallet {function} Callback to report wallet found
 * @param onPassword {function} Callback to ask for password if needed
 * @returns {{promise: Promise, stop: function}}
 */
const startImport = (
  importTextOrig: string,
  askPassphrase: boolean = false,
  searchAccounts: boolean = false,
  offline: boolean = false,
  onProgress: (name: string) => void,
  onWallet: (wallet: TWallet) => void,
  onPassword: (title: string, text: string) => Promise<string>,
): TImport => {
  // state
  let promiseResolve: (arg: TStatus) => void;
  let promiseReject: (reason?: any) => void;
  let running = true; // if you put it to false, internal generator stops
  const wallets: TWallet[] = [];
  const promise = new Promise<TStatus>((resolve, reject) => {
    promiseResolve = resolve;
    promiseReject = reject;
  })

  // helpers
  // in offline mode all wallets are considered used
  const wasUsed = async (wallet: TWallet): Promise<boolean> => {
    if (offline) return true;
    return wallet.wasEverUsed();
  }
  const fetch = async (
    wallet: TWallet,
    balance: boolean = false,
    transactions: boolean = false
  ) => {
    if (offline) return;
    if (balance) await wallet.fetchBalance();
    if (transactions) await wallet.fetchTransactions();
  }

  // actions
  const reportProgress = (name: string) => {
    onProgress(name);
  }
  const reportFinish = (
    cancelled: boolean = false,
    stopped: boolean = false
  ) => {
    promiseResolve({ cancelled, stopped, wallets });
  }
  const reportWallet = (wallet: TWallet) => {
    if (wallets.some((w) => w.getID() === wallet.getID())) return; // do not add duplicates
    wallets.push(wallet);
    onWallet(wallet);
  }
  const stop = () => (running = false);

  async function* importGenerator() {
    // The plan:
    // -3. ask for password, if needed and validate it
    // -2. check if BIP38 encrypted
    // -1a. check if multisig
    // -1. check lightning custodian
    // 0. check if its HDSegwitBech32Wallet (BIP84)
    // 1. check if its HDSegwitP2SHWallet (BIP49)
    // 2. check if its HDLegacyP2PKHWallet (BIP44)
    // 3. check if its HDLegacyBreadwalletWallet (no BIP, just "m/0")
    // 3.1 check HD Electrum legacy
    // 3.2 check if its AEZEED
    // 3.3 check if its SLIP39
    // 3.4 check if its HDTaprootWallet (BIP86)
    // 4. check if its Segwit WIF (P2SH)
    // 4.5 check if its Taproot WIF
    // 5. check if its Legacy WIF
    // 6. check if its address (watch-only wallet)
    // 7. check if its private key (segwit address P2SH) TODO
    // 7. check if its private key (legacy address) TODO
    // 8. check if its a json array from BC-UR with multiple accounts
    let text = importTextOrig.trim();
    let password;

    // BIP38 password required
    if (text.startsWith('6P')) {
      do {
        password = await onPassword(
          loc.wallets.looks_like_bip38,
          loc.wallets.enter_bip38_password
        );
      } while (!password);
    }

    // HD BIP39 wallet password is optinal
    const hd = new HDSegwitBech32Wallet();
    hd.setSecret(text);
    if (askPassphrase && hd.validateMnemonic()) {
      password = await onPassword(
        loc.wallets.import_passphrase_title,
        loc.wallets.import_passphrase_message
      );
    }

    // AEZEED password needs to be correct
    const aezeed = new HDAezeedWallet();
    aezeed.setSecret(text);
    if (await aezeed.mnemonicInvalidPassword()) {
      do {
        password = await onPassword('', loc.wallets.enter_bip38_password);
        aezeed.setPassphrase(password);
      } while (await aezeed.mnemonicInvalidPassword());
    }

    // SLIP39 wallet password is optinal
    if (askPassphrase && text.includes('\n')) {
      const s1 = new SLIP39SegwitP2SHWallet();
      s1.setSecret(text);

      if (s1.validateMnemonic()) {
        password = await onPassword(
          loc.wallets.import_passphrase_title,
          loc.wallets.import_passphrase_message
        );
      }
    }

    // ELECTRUM segwit wallet password is optinal
    const electrum1 = new HDSegwitElectrumSeedP2WPKHWallet();
    electrum1.setSecret(text);
    if (askPassphrase && electrum1.validateMnemonic()) {
      password = await onPassword(
        loc.wallets.import_passphrase_title,
        loc.wallets.import_passphrase_message
      );
    }

    // ELECTRUM legacy wallet password is optinal
    const electrum2 = new HDLegacyElectrumSeedP2PKHWallet();
    electrum2.setSecret(text);
    if (askPassphrase && electrum2.validateMnemonic()) {
      password = await onPassword(
        loc.wallets.import_passphrase_title,
        loc.wallets.import_passphrase_message
      );
    }

    // is it bip38 encrypted
    if (text.startsWith('6P') && password) {
      const decryptedKey = await bip38.decryptAsync(text, password);

      if (decryptedKey) {
        text = wif.encode(
          0x80,
          decryptedKey.privateKey,
          decryptedKey.compressed
        );
      }
    }

    // is it multisig?
    yield { progress: 'multisignature' };
    const ms = new MultisigHDWallet();
    ms.setSecret(text);
    if (ms.getN() > 0 && ms.getM() > 0) {
      await fetch(ms, true, false);
      yield { wallet: ms };
    }

    // is it lightning custodian?
    yield { progress: 'lightning custodian' };
    if (text.startsWith('blitzhub://') || text.startsWith('lndhub://')) {
      const lnd = new LightningCustodianWallet();
      if (text.includes('@')) {
        const split = text.split('@');
        lnd.setBaseURI(split[1]);
        lnd.setSecret(split[0]);
      }
      await lnd.init();
      if (!offline) {
        await lnd.authorize();
        await lnd.fetchTransactions();
        await lnd.fetchUserInvoices();
        await lnd.fetchPendingTransactions();
        await lnd.fetchBalance();
      }
      yield { wallet: lnd };
    }

    // is it lightning ark wallet?
    yield { progress: 'lightning ark' };
    if (text.startsWith('arkade://')) {
      const ark = new LightningArkWallet();
      ark.setSecret(text);
      await ark.init();
      if (!offline) {
        await ark.fetchBalance();
        await ark.fetchTransactions();
      }
      yield { wallet: ark };
    }

    // check bip39 wallets
    yield { progress: 'bip39' };
    const hd2 = new HDSegwitBech32Wallet();
    hd2.setSecret(text);
    if (password) {
      hd2.setPassphrase(password);
    }
    if (hd2.validateMnemonic()) {
      let walletFound = false;
      // by default we don't try all the paths and options
      const searchPaths = searchAccounts
        ? bip39WalletFormatsElectrum
        : bip39WalletFormatsMalinWallet;
      for (const i of searchPaths) {
        // we need to skip m/0' p2pkh from default scan list. It could be a BRD wallet and will be handled later
        if (i.derivation_path === "m/0'" && i.script_type === 'p2pkh') continue;
        let paths;
        if (i.iterate_accounts && searchAccounts) {
          const basicPath = i.derivation_path.slice(0, -2); // remove 0' from the end
          paths = [...Array(10).keys()].map((j) => basicPath + j + "'"); // add account number
        } else {
          paths = [i.derivation_path];
        }
        let WalletClass;
        switch (i.script_type) {
          case 'p2pkh':
            WalletClass = HDLegacyP2PKHWallet;
            break
          case 'p2wpkh-p2sh':
            WalletClass = HDSegwitP2SHWallet;
            break
          case 'p2tr':
            WalletClass = HDTaprootWallet;
            break
          default:
            // p2wpkh
            WalletClass = HDSegwitBech32Wallet;
        }
        for (const path of paths) {
          const wallet = new WalletClass();
          wallet.setSecret(text);
          if (password) {
            wallet.setPassphrase(password);
          }
          wallet.setDerivationPath(path);
          yield { progress: `bip39 ${i.script_type} ${path}` };
          if (await wasUsed(wallet)) {
            yield { wallet };
            walletFound = true;
          } else {
            break; // don't check second account if first one is empty
          }
        }
      }

      // m/0' p2pkh is a special case. It could be regular a HD wallet or a BRD wallet.
      // to decide which one is it let's compare number of transactions
      const m0Legacy = new HDLegacyP2PKHWallet();
      m0Legacy.setSecret(text);
      if (password) {
        m0Legacy.setPassphrase(password);
      }
      m0Legacy.setDerivationPath("m/0'");
      yield { progress: "bip39 p2pkh m/0'" };
      // BRD doesn't support passphrase and only works with 12 words seeds
      // do not try to guess BRD wallet in offline mode
      if (!password && text.split(' ').length === 12 && !offline) {
        const brd = new HDLegacyBreadwalletWallet();
        brd.setSecret(text);

        if (await wasUsed(m0Legacy)) {
          await m0Legacy.fetchBalance();
          await m0Legacy.fetchTransactions();
          yield { progress: 'BRD' };
          await brd.fetchBalance();
          await brd.fetchTransactions();
          if (
            brd.getTransactions().length > m0Legacy.getTransactions().length
          ) {
            yield { wallet: brd };
          } else {
            yield { wallet: m0Legacy };
          }
          walletFound = true;
        }
      } else {
        if (await wasUsed(m0Legacy)) {
          yield { wallet: m0Legacy };
          walletFound = true;
        }
      }

      // if we havent found any wallet for this seed suggest new bech32 wallet
      if (!walletFound) {
        yield { wallet: hd2 };
      }
    }

    yield { progress: 'wif' };
    const segwitWallet = new SegwitP2SHWallet();
    segwitWallet.setSecret(text);
    if (segwitWallet.getAddress()) {
      // ok its a valid WIF
      let walletFound = false;

      yield { progress: 'wif p2wpkh' };
      const segwitBech32Wallet = new SegwitBech32Wallet();
      segwitBech32Wallet.setSecret(text);
      if (await wasUsed(segwitBech32Wallet)) {
        // yep, its single-address bech32 wallet
        await fetch(segwitBech32Wallet, true);
        walletFound = true;
        yield { wallet: segwitBech32Wallet };
      }

      yield { progress: 'wif p2tr' };
      const taprootWallet = new TaprootWallet();
      taprootWallet.setSecret(text);
      if (await wasUsed(taprootWallet)) {
        // yep, its single-address taproot wallet
        await fetch(taprootWallet, true);
        walletFound = true;
        yield { wallet: taprootWallet };
      }

      yield { progress: 'wif p2wpkh-p2sh' };
      if (await wasUsed(segwitWallet)) {
        // yep, its single-address p2wpkh wallet
        await fetch(segwitWallet, true);
        walletFound = true;
        yield { wallet: segwitWallet };
      }

      // default wallet is Legacy
      yield { progress: 'wif p2pkh' };
      const legacyWallet = new LegacyWallet();
      legacyWallet.setSecret(text);
      if (await wasUsed(legacyWallet)) {
        // yep, its single-address legacy wallet
        await fetch(legacyWallet, true);
        walletFound = true;
        yield { wallet: legacyWallet };
      }

      // if no wallets was ever used, import all of them
      if (!walletFound) {
        yield { wallet: segwitBech32Wallet };
        yield { wallet: segwitWallet };
        yield { wallet: legacyWallet };
        yield { wallet: taprootWallet };
      }
    }

    // case - WIF is valid, just has uncompressed pubkey
    yield { progress: 'wif p2pkh' };
    const legacyWallet = new LegacyWallet();
    legacyWallet.setSecret(text);
    if (legacyWallet.getAddress()) {
      await fetch(legacyWallet, true, true);
      yield { wallet: legacyWallet };
    }

    // maybe its a watch-only address?
    yield { progress: 'watch only' };
    const wo1 = new WatchOnlyWallet();
    wo1.setSecret(text);
    if (wo1.valid()) {
      wo1.init();
      if (text.startsWith('xpub')) {
        // for xpub we also check ypub and zpub. If any of them was used, we import it.
        let found = false;
        const pubs = [text, wo1._xpubToYpub(text), wo1._xpubToZpub(text)];
        for (const pub of pubs) {
          const wo2 = new WatchOnlyWallet();
          wo2.setSecret(pub);
          wo2.init();
          if (await wasUsed(wo2)) {
            yield { wallet: wo2 };
            found = true;
          }
        }
        if (!found) {
          await fetch(wo1, true);
          yield { wallet: wo1 };
        }
      } else {
        await fetch(wo1, true);
        yield { wallet: wo1 };
      }
    }

    // electrum p2wpkh-p2sh
    yield { progress: 'electrum p2wpkh-p2sh' };
    const el1 = new HDSegwitElectrumSeedP2WPKHWallet();
    el1.setSecret(text);
    if (password) {
      el1.setPassphrase(password);
    }
    if (el1.validateMnemonic()) {
      yield { wallet: el1 }; // not fetching txs or balances, fuck it, yolo, life is too short
    }

    // electrum p2wpkh-p2sh
    yield { progress: 'electrum p2pkh' };
    const el2 = new HDLegacyElectrumSeedP2PKHWallet();
    el2.setSecret(text);
    if (password) {
      el2.setPassphrase(password);
    }
    if (el2.validateMnemonic()) {
      yield { wallet: el2 }; // not fetching txs or balances, fuck it, yolo, life is too short
    }

    // is it AEZEED?
    yield { progress: 'aezeed' };
    const aezeed2 = new HDAezeedWallet();
    aezeed2.setSecret(text);
    if (password) {
      aezeed2.setPassphrase(password);
    }
    if (await aezeed2.validateMnemonicAsync()) {
      yield { wallet: aezeed2 }; // not fetching txs or balances, fuck it, yolo, life is too short
    }

    // Let's try SLIP39
    yield { progress: 'SLIP39' };
    const s1 = new SLIP39SegwitP2SHWallet();
    s1.setSecret(text);

    if (s1.validateMnemonic()) {
      yield { progress: 'SLIP39 p2wpkh-p2sh' };
      if (password) {
        s1.setPassphrase(password);
      }
      if (await wasUsed(s1)) {
        yield { wallet: s1 };
      }

      yield { progress: 'SLIP39 p2pkh' };
      const s2 = new SLIP39LegacyP2PKHWallet();
      if (password) {
        s2.setPassphrase(password);
      }
      s2.setSecret(text);
      if (await wasUsed(s2)) {
        yield { wallet: s2 };
      }

      yield { progress: 'SLIP39 p2wpkh' };
      const s3 = new SLIP39SegwitBech32Wallet();
      s3.setSecret(text);
      if (password) {
        s3.setPassphrase(password);
      }
      yield { wallet: s3 };
    }

    // is it BC-UR payload with multiple accounts?
    yield { progress: 'BC-UR' };
    try {
      const json = JSON.parse(text);
      if (Array.isArray(json)) {
        for (const account of json) {
          if (
            account.ExtPubKey &&
            account.MasterFingerprint &&
            account.AccountKeyPath
          ) {
            const wallet = new WatchOnlyWallet();
            wallet.setSecret(JSON.stringify(account));
            wallet.init();
            yield { wallet };
          }
        }
      }
    } catch (_) {}
  }

  // POEHALI
  (async () => {
    const generator = importGenerator();
    while (true) {
      const next = await generator.next();
      if (!running) throw new Error('Discovery stopped'); // break if stop() has been called
      if (next.value?.progress) reportProgress(next.value.progress);
      if (next.value?.wallet) reportWallet(next.value.wallet);
      if (next.done) break; // break if generator has been finished
      await new Promise((resolve) => setTimeout(resolve, 1)); // try not to block the thread
    }
    reportFinish();
  })().catch((e) => {
    if (e.message === 'Cancel Pressed') {
      reportFinish(true);
      return
    } else if (e.message === 'Discovery stopped') {
      reportFinish(undefined, true);
      return
    }
    promiseReject(e);
  })

  return { promise, stop };
}

export default startImport;


================================================
FILE: ./class/index.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export * from './malin-app';
export * from './hd-segwit-bech32-transaction';
export * from './multisig-cosigner';
export * from './wallets/abstract-hd-wallet';
export * from './wallets/abstract-wallet';
export * from './wallets/hd-aezeed-wallet';
export * from './wallets/hd-legacy-breadwallet-wallet';
export * from './wallets/hd-legacy-electrum-seed-p2pkh-wallet';
export * from './wallets/hd-legacy-p2pkh-wallet';
export * from './wallets/hd-segwit-bech32-wallet';
export * from './wallets/hd-segwit-electrum-seed-p2wpkh-wallet';
export * from './wallets/hd-segwit-p2sh-wallet';
export * from './wallets/hd-taproot-wallet';
export * from './wallets/legacy-wallet';
export * from './wallets/lightning-custodian-wallet';
export * from './wallets/lightning-ark-wallet';
export * from './wallets/multisig-hd-wallet';
export * from './wallets/segwit-bech32-wallet';
export * from './wallets/segwit-p2sh-wallet';
export * from './wallets/slip39-wallets';
export * from './wallets/taproot-wallet';
export * from './wallets/watch-only-wallet';
export * from './wallets/ethereum-wallet';
export * from './wallets/solana-wallet';


================================================
FILE: ./class/rng.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * @fileOverview creates an rng module that will bring all calls to 'crypto'
 * into one place to try and prevent mistakes when touching the crypto code.
 */

// React Native: entropy via global crypto.getRandomValues (polyfilled by react-native-get-random-values)

/**
 * Generate cryptographically secure random bytes using native api.
 * @param  {number}   size      The number of bytes of randomness
 * @return {Promise.<Uint8Array>}   The random bytes
 */
export async function randomBytes(size: number): Promise<Uint8Array> {
  const g: any = globalThis as any;
  const rnCrypto = g && g.crypto;
  if (!rnCrypto || typeof rnCrypto.getRandomValues !== 'function') {
    throw new Error('crypto.getRandomValues is not available');
  }
  const bytes = new Uint8Array(size);
  rnCrypto.getRandomValues(bytes);
  return bytes;
}


================================================
FILE: ./class/hd-segwit-bech32-transaction.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BigNumber from 'bignumber.js';
import * as bitcoin from 'bitcoinjs-lib';
import assert from 'assert';

import * as MalinElectrum from '../malin_modules/MalinElectrum';
import { HDSegwitBech32Wallet } from './wallets/hd-segwit-bech32-wallet';
import { SegwitBech32Wallet } from './wallets/segwit-bech32-wallet';
import { CreateTransactionUtxo } from './wallets/types.ts';
import { CoinSelectOutput, CoinSelectReturnInput } from 'coinselect';
import { isUint8Array, uint8ArrayToHex } from '../malin_modules/uint8array-extras';

/**
 * Represents transaction of a BIP84 wallet.
 * Helpers for RBF, CPFP etc.
 */
export class HDSegwitBech32Transaction {
  private _txhex: string | null;
  private _txid: string | null;
  private _wallet: HDSegwitBech32Wallet | undefined;
  private _txDecoded: bitcoin.Transaction | undefined;
  private _remoteTx: any;

  /**
   * @param txhex {string|null} Object is initialized with txhex
   * @param txid {string|null} If txhex not present - txid whould be present
   * @param wallet {HDSegwitBech32Wallet|null} If set - a wallet object to which transacton belongs
   */
  constructor(txhex: string | null, txid: string | null, wallet: HDSegwitBech32Wallet | null) {
    if (!txhex && !txid) throw new Error('Bad arguments');
    this._txhex = txhex;
    this._txid = txid;

    if (wallet) {
      if (wallet.type === HDSegwitBech32Wallet.type) {
        /** @type {HDSegwitBech32Wallet} */
        this._wallet = wallet;
      } else {
        throw new Error('Only HD Bech32 wallets supported');
      }
    }

    if (this._txhex) this._txDecoded = bitcoin.Transaction.fromHex(this._txhex);
    this._remoteTx = null;
  }

  /**
   * If only txid present - we fetch hex
   *
   * @returns {Promise<void>}
   * @private
   */
  async _fetchTxhexAndDecode() {
    assert(this._txid, 'this._txid must be a string');
    const hexes = await MalinElectrum.multiGetTransactionByTxid([this._txid], false, 10);
    this._txhex = hexes[this._txid];
    if (!this._txhex) throw new Error("Transaction can't be found in mempool");
    this._txDecoded = bitcoin.Transaction.fromHex(this._txhex);
  }

  /**
   * Returns max used sequence for this transaction. Next RBF transaction
   * should have this sequence + 1
   *
   * @returns {Promise<number>}
   */
  async getMaxUsedSequence() {
    if (!this._txDecoded) await this._fetchTxhexAndDecode();
    assert(this._txDecoded, 'Could not fetch tx and decode');

    let max = 0;
    for (const inp of this._txDecoded.ins) {
      max = Math.max(inp.sequence, max);
    }

    return max;
  }

  /**
   * Basic check that Sequence num for this TX is replaceable
   *
   * @returns {Promise<boolean>}
   */
  async isSequenceReplaceable() {
    return (await this.getMaxUsedSequence()) < bitcoin.Transaction.DEFAULT_SEQUENCE;
  }

  /**
   * If internal extended tx data not set - this is a method
   * to fetch and set this data from electrum. Its different data from
   * decoded hex - it contains confirmations etc.
   *
   * @returns {Promise<void>}
   * @private
   */
  async _fetchRemoteTx() {
    const result = await MalinElectrum.multiGetTransactionByTxid([this._txid || this._txDecoded!.getId()], true);
    this._remoteTx = Object.values(result)[0];
  }

  /**
   * Fetches from electrum actual confirmations number for this tx
   *
   * @returns {Promise<Number>}
   */
  async getRemoteConfirmationsNum() {
    if (!this._remoteTx) await this._fetchRemoteTx();
    return this._remoteTx.confirmations || 0; // stupid undefined
  }

  /**
   * Checks that tx belongs to a wallet and also
   * tx value is < 0, which means its a spending transaction
   * definitely initiated by us, can be RBF'ed.
   *
   * @returns {Promise<boolean>}
   */
  async isOurTransaction() {
    if (!this._wallet) throw new Error('Wallet required for this method');
    let found = false;
    for (const tx of this._wallet.getTransactions()) {
      if (tx.txid === (this._txid || this._txDecoded!.getId())) {
        // its our transaction, and its spending transaction, which means we initiated it
        if (tx.value && tx.value < 0) found = true;
      }
    }
    return found;
  }

  /**
   * Checks that tx belongs to a wallet and also
   * tx value is > 0, which means its a receiving transaction and thus
   * can be CPFP'ed.
   *
   * @returns {Promise<boolean>}
   */
  async isToUsTransaction() {
    if (!this._wallet) throw new Error('Wallet required for this method');
    let found = false;
    for (const tx of this._wallet.getTransactions()) {
      if (tx.txid === (this._txid || this._txDecoded!.getId())) {
        if (tx.value && tx.value > 0) found = true;
      }
    }
    return found;
  }

  /**
   * Returns all the info about current transaction which is needed to do a replacement TX
   * * fee - current tx fee
   * * utxos - UTXOs current tx consumes
   * * changeAmount - amount of satoshis that sent to change address (or addresses) we control
   * * feeRate - sat/byte for current tx
   * * targets - destination(s) of funds (outputs we do not control)
   * * unconfirmedUtxos - UTXOs created by this transaction (only the ones we control)
   *
   * @returns {Promise<{fee: number, utxos: Array, unconfirmedUtxos: Array, changeAmount: number, feeRate: number, targets: Array}>}
   */
  async getInfo() {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._remoteTx) await this._fetchRemoteTx();
    if (!this._txDecoded) await this._fetchTxhexAndDecode();
    assert(this._txDecoded, 'could not fetch tx and decode');

    const prevInputs = [];
    for (const inp of this._txDecoded.ins) {
      prevInputs.push(uint8ArrayToHex(new Uint8Array(inp.hash).reverse()));
    }

    const prevTransactions = await MalinElectrum.multiGetTransactionByTxid(prevInputs, true);

    // fetched, now lets count how much satoshis went in
    let wentIn = 0;
    const utxos: CreateTransactionUtxo[] = [];
    for (const inp of this._txDecoded.ins) {
      const reversedHash = uint8ArrayToHex(new Uint8Array(inp.hash).reverse());
      if (prevTransactions[reversedHash] && prevTransactions[reversedHash].vout && prevTransactions[reversedHash].vout[inp.index]) {
        let value = prevTransactions[reversedHash].vout[inp.index].value;
        value = new BigNumber(value).multipliedBy(100000000).toNumber();
        wentIn += value;
        const witness = inp.witness[inp.witness.length - 1];
        const address = String(SegwitBech32Wallet.witnessToAddress(isUint8Array(witness) ? uint8ArrayToHex(witness) : witness));
        utxos.push({ vout: inp.index, value, txid: reversedHash, address });
      }
    }

    // counting how much went into actual outputs

    let wasSpent = 0;
    for (const outp of this._txDecoded.outs) {
      wasSpent += Number(outp.value);
    }

    const fee = wentIn - wasSpent;
    let feeRate = Math.floor(fee / this._txDecoded.virtualSize());
    if (feeRate === 0) feeRate = 1;

    // lets take a look at change
    let changeAmount = 0;
    const targets: { value?: number; address: string }[] = [];
    for (const outp of this._remoteTx.vout) {
      const address = outp.scriptPubKey.addresses[0];
      const value = new BigNumber(outp.value).multipliedBy(100000000).toNumber();
      if (this._wallet.weOwnAddress(address)) {
        changeAmount += value;
      } else {
        // this is target
        targets.push({ value, address });
      }
    }

    // lets find outputs we own that current transaction creates. can be used in CPFP
    const unconfirmedUtxos = [];
    for (const outp of this._remoteTx.vout) {
      const address = outp.scriptPubKey.addresses[0];
      const value = new BigNumber(outp.value).multipliedBy(100000000).toNumber();
      if (this._wallet.weOwnAddress(address)) {
        unconfirmedUtxos.push({
          vout: outp.n,
          value,
          txid: this._txid || this._txDecoded.getId(),
          address,
        });
      }
    }

    return { fee, feeRate, targets, changeAmount, utxos, unconfirmedUtxos };
  }

  /**
   * We get _all_ our UTXOs (even spent kek),
   * and see if each input in this transaction's UTXO is in there. If its not there - its an unknown
   * input, we dont own it (possibly a payjoin transaction), and we cant do RBF
   *
   * @returns {Promise<boolean>}
   */
  async thereAreUnknownInputsInTx() {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._txDecoded) await this._fetchTxhexAndDecode();
    assert(this._txDecoded, 'could not fetch tx and decode');

    const spentUtxos = this._wallet.getDerivedUtxoFromOurTransaction(true);
    for (const inp of this._txDecoded.ins) {
      const txidInUtxo = uint8ArrayToHex(new Uint8Array(inp.hash).reverse());

      let found = false;
      for (const spentU of spentUtxos) {
        if (spentU.txid === txidInUtxo && spentU.vout === inp.index) found = true;
      }

      if (!found) {
        return true;
      }
    }
  }

  /**
   * Checks if all outputs belong to us, that
   * means we already canceled this tx and we can only bump fees
   *
   * @returns {Promise<boolean>}
   */
  async canCancelTx() {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._txDecoded) await this._fetchTxhexAndDecode();
    assert(this._txDecoded, 'could not fetch tx and decode');

    if (await this.thereAreUnknownInputsInTx()) return false;

    // if theres at least one output we dont own - we can cancel this transaction!
    for (const outp of this._txDecoded.outs) {
      const outpScript = outp.script;
      if (
        !this._wallet.weOwnAddress(
          String(SegwitBech32Wallet.scriptPubKeyToAddress(isUint8Array(outpScript) ? uint8ArrayToHex(outpScript) : outpScript)),
        )
      )
        return true;
    }

    return false;
  }

  async canBumpTx() {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._txDecoded) await this._fetchTxhexAndDecode();

    if (await this.thereAreUnknownInputsInTx()) return false;

    return true;
  }

  /**
   * Creates an RBF transaction that can replace previous one and basically cancel it (rewrite
   * output to the one our wallet controls). Note, this cannot add more utxo in RBF transaction if
   * newFeerate is too high
   *
   * @param newFeerate {number} Sat/byte. Should be greater than previous tx feerate
   * @returns {Promise<{outputs: Array, tx: Transaction, inputs: Array, fee: Number}>}
   */
  async createRBFcancelTx(newFeerate: any) {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._remoteTx) await this._fetchRemoteTx();

    const { feeRate, utxos } = await this.getInfo();

    if (newFeerate <= feeRate) throw new Error('New feerate should be bigger than the old one');
    const myAddress = await this._wallet.getChangeAddressAsync();

    return this._wallet.createTransaction(
      utxos,
      [{ address: myAddress }],
      newFeerate,
      /* meaningless in this context */ myAddress,
      (await this.getMaxUsedSequence()) + 1,
    );
  }

  /**
   * Creates an RBF transaction that can bumps fee of previous one. Note, this cannot add more utxo in RBF
   * transaction if newFeerate is too high
   *
   * @param newFeerate {number} Sat/byte
   * @returns {Promise<{outputs: Array, tx: Transaction, inputs: Array, fee: Number}>}
   */
  async createRBFbumpFee(newFeerate: number) {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._remoteTx) await this._fetchRemoteTx();

    const { feeRate, targets, changeAmount, utxos } = await this.getInfo();

    if (newFeerate <= feeRate) throw new Error('New feerate should be bigger than the old one');
    const myAddress = await this._wallet.getChangeAddressAsync();

    if (changeAmount === 0) delete targets[0].value;
    // looks like this was sendMAX transaction (because there was no change), so we cant reuse amount in this
    // target since fee wont change. removing the amount so `createTransaction` will sendMAX correctly with new feeRate

    if (targets.length === 0) {
      // looks like this was cancelled tx with single change output, so it wasnt included in `this.getInfo()` targets
      // so we add output paying ourselves:
      targets.push({ address: this._wallet._getInternalAddressByIndex(this._wallet.next_free_change_address_index) });
      // not checking emptiness on purpose: it could unpredictably generate too far address because of unconfirmed tx.
    }

    return this._wallet.createTransaction(utxos, targets, newFeerate, myAddress, (await this.getMaxUsedSequence()) + 1);
  }

  /**
   * Creates a CPFP transaction that can bumps fee of previous one (spends created but not confirmed outputs
   * that belong to us). Note, this cannot add more utxo in CPFP transaction if newFeerate is too high
   *
   * @param newFeerate {number} sat/byte
   * @returns {Promise<{outputs: Array, tx: Transaction, inputs: Array, fee: Number}>}
   */
  async createCPFPbumpFee(newFeerate: number) {
    if (!this._wallet) throw new Error('Wallet required for this method');
    if (!this._remoteTx) await this._fetchRemoteTx();

    const { feeRate, fee: oldFee, unconfirmedUtxos } = await this.getInfo();

    if (newFeerate <= feeRate) throw new Error('New feerate should be bigger than the old one');
    const myAddress = await this._wallet.getChangeAddressAsync();

    // calculating feerate for CPFP tx so that average between current and CPFP tx will equal newFeerate.
    // this works well if both txs are +/- equal size in bytes
    const targetFeeRate = 2 * newFeerate - feeRate;

    let add = 0;
    let tx: bitcoin.Transaction | undefined, inputs: CoinSelectReturnInput[], outputs: CoinSelectOutput[], fee: number;
    while (add <= 128) {
      const createdTx = this._wallet.createTransaction(
        unconfirmedUtxos,
        [{ address: myAddress }],
        targetFeeRate + add,
        myAddress,
        HDSegwitBech32Wallet.defaultRBFSequence,
      );
      tx = createdTx.tx;
      inputs = createdTx.inputs;
      outputs = createdTx.outputs;
      fee = createdTx.fee;
      assert(tx, 'tx is createCPFPbumpFee() is undefined');
      const combinedFeeRate = (oldFee + fee) / (this._txDecoded!.virtualSize() + tx.virtualSize()); // avg
      if (Math.round(combinedFeeRate) < newFeerate) {
        add *= 2;
        if (!add) add = 2;
      } else {
        // reached target feerate
        break;
      }
    }

    // @ts-ignore stfu
    return { tx, inputs, outputs, fee };
  }
}


================================================
FILE: ./class/lnurl.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { bech32 } from 'bech32';
import bolt11 from 'bolt11';
import { sha256 } from '@noble/hashes/sha256';
import { hmac } from '@noble/hashes/hmac';
import CryptoJS from 'crypto-js';
import ecc from '../malin_modules/noble_ecc';
import { parse } from 'url'; // eslint-disable-line n/no-deprecated-api
import { fetch } from '../util/fetch';

const ONION_REGEX = /^(http:\/\/[^/:@]+\.onion(?::\d{1,5})?)(\/.*)?$/; // regex for onion URL

interface LnurlPayServicePayload {
  callback: string;
  fixed: boolean;
  min: number;
  max: number;
  domain: string;
  metadata: string;
  description?: string;
  image?: string;
  amount: number;
  commentAllowed?: number;
}

interface LnurlPayServiceBolt11Payload {
  pr: string;
  successAction?: any;
  disposable?: boolean;
  tag: string;
  metadata: any;
  minSendable: number;
  maxSendable: number;
  callback: string;
  commentAllowed: number;
}

interface DecodedInvoice {
  destination: string;
  num_satoshis: string;
  num_millisatoshis: string;
  timestamp: string;
  fallback_addr: string;
  route_hints: any[];
  payment_hash?: string;
  description_hash?: string;
  cltv_expiry?: string;
  expiry?: string;
  description?: string;
}

/**
 * @see https://github.com/btcontract/lnurl-rfc/blob/master/lnurl-pay.md
 */
export default class Lnurl {
  static TAG_PAY_REQUEST = 'payRequest'; // type of LNURL
  static TAG_WITHDRAW_REQUEST = 'withdrawRequest'; // type of LNURL
  static TAG_LOGIN_REQUEST = 'login'; // type of LNURL

  private _lnurl: string;
  private _lnurlPayServiceBolt11Payload: LnurlPayServiceBolt11Payload | false;
  private _lnurlPayServicePayload: LnurlPayServicePayload | false;
  private _AsyncStorage: any;
  private _preimage: string | false;

  constructor(url: string | false, AsyncStorage?: any) {
    this._lnurl = url || '';
    this._lnurlPayServiceBolt11Payload = false;
    this._lnurlPayServicePayload = false;
    this._AsyncStorage = AsyncStorage;
    this._preimage = false;
  }

  static findlnurl(bodyOfText: string): string | null {
    const res = /^(?:http.*[&?]lightning=|lightning:)?(lnurl1[02-9ac-hj-np-z]+)/.exec(bodyOfText.toLowerCase());
    if (res) {
      return res[1];
    }
    return null;
  }

  static getUrlFromLnurl(lnurlExample: string): string | false {
    const found = Lnurl.findlnurl(lnurlExample);
    if (!found) {
      if (Lnurl.isLightningAddress(lnurlExample)) {
        const username = lnurlExample.split('@')[0].trim();
        const host = lnurlExample.split('@')[1].trim();
        const proto = host.match(/\.onion$/) ? 'http' : 'https';
        return `${proto}://${host}/.well-known/lnurlp/${username}`;
      } else {
        return false;
      }
    }

    const decoded = bech32.decode(found, 10000);
    return Buffer.from(bech32.fromWords(decoded.words)).toString();
  }

  static isLnurl(url: string): boolean {
    return Lnurl.findlnurl(url) !== null;
  }

  static isOnionUrl(url: string): boolean {
    return Lnurl.parseOnionUrl(url) !== null;
  }

  static parseOnionUrl(url: string): [string, string] | null {
    const match = url.match(ONION_REGEX);
    if (match === null) return null;
    const [, baseURI, path] = match;
    return [baseURI, path];
  }

  async fetchGet(url: string): Promise<any> {
    const resp = await fetch(url, { method: 'GET' });
    if (resp.status >= 300) {
      throw new Error('Bad response from server');
    }
    const reply = await resp.json();
    if (reply.status === 'ERROR') {
      throw new Error('Reply from server: ' + reply.reason);
    }
    return reply;
  }

  decodeInvoice(invoice: string): DecodedInvoice {
    const { payeeNodeKey, tags, satoshis, millisatoshis, timestamp } = bolt11.decode(invoice);

    const decoded: DecodedInvoice = {
      destination: payeeNodeKey ?? '',
      num_satoshis: satoshis ? satoshis.toString() : '0',
      num_millisatoshis: millisatoshis ? millisatoshis.toString() : '0',
      timestamp: timestamp?.toString() ?? '',
      fallback_addr: '',
      route_hints: [],
    };

    for (let i = 0; i < tags.length; i++) {
      const { tagName, data } = tags[i];
      switch (tagName) {
        case 'payment_hash':
          decoded.payment_hash = String(data);
          break;
        case 'purpose_commit_hash':
          decoded.description_hash = String(data);
          break;
        case 'min_final_cltv_expiry':
          decoded.cltv_expiry = data.toString();
          break;
        case 'expire_time':
          decoded.expiry = data.toString();
          break;
        case 'description':
          decoded.description = String(data);
          break;
      }
    }

    if (!decoded.expiry) decoded.expiry = '3600'; // default

    if (parseInt(decoded.num_satoshis, 10) === 0 && parseInt(decoded.num_millisatoshis, 10) > 0) {
      decoded.num_satoshis = (parseInt(decoded.num_millisatoshis, 10) / 1000).toString();
    }

    return decoded;
  }

  async requestBolt11FromLnurlPayService(amountSat: number, comment: string = ''): Promise<LnurlPayServiceBolt11Payload> {
    if (!this._lnurlPayServicePayload) throw new Error('this._lnurlPayServicePayload is not set');
    if (!this._lnurlPayServicePayload.callback) throw new Error('this._lnurlPayServicePayload.callback is not set');
    if (amountSat < this._lnurlPayServicePayload.min || amountSat > this._lnurlPayServicePayload.max)
      throw new Error(
        'The specified amount is invalid, ' +
          amountSat +
          ' it should be between ' +
          this._lnurlPayServicePayload.min +
          ' and ' +
          this._lnurlPayServicePayload.max,
      );
    const nonce = Math.floor(Math.random() * 2e16).toString(16);
    const separator = this._lnurlPayServicePayload.callback.indexOf('?') === -1 ? '?' : '&';
    if (this.getCommentAllowed() && comment && comment.length > (this.getCommentAllowed() as number)) {
      comment = comment.substr(0, this.getCommentAllowed() as number);
    }
    if (comment) comment = `&comment=${encodeURIComponent(comment)}`;
    const urlToFetch =
      this._lnurlPayServicePayload.callback + separator + 'amount=' + Math.floor(amountSat * 1000) + '&nonce=' + nonce + comment;
    this._lnurlPayServiceBolt11Payload = (await this.fetchGet(urlToFetch)) as LnurlPayServiceBolt11Payload;

    // check pr description_hash, amount etc:
    const decoded = this.decodeInvoice(this._lnurlPayServiceBolt11Payload.pr);
    const metadataHash = Buffer.from(sha256(this._lnurlPayServicePayload.metadata)).toString('hex');
    if (metadataHash !== decoded.description_hash) {
      console.log(`Invoice description_hash doesn't match metadata.`);
    }
    if (parseInt(decoded.num_satoshis, 10) !== Math.round(amountSat)) {
      throw new Error(`Invoice doesn't match specified amount, got ${decoded.num_satoshis}, expected ${Math.round(amountSat)}`);
    }

    return this._lnurlPayServiceBolt11Payload;
  }

  async callLnurlPayService(): Promise<LnurlPayServicePayload> {
    if (!this._lnurl) throw new Error('this._lnurl is not set');
    const url = Lnurl.getUrlFromLnurl(this._lnurl);
    if (!url) throw new Error('Invalid LNURL');
    // calling the url
    const reply = (await this.fetchGet(url)) as LnurlPayServiceBolt11Payload;

    if (reply.tag !== Lnurl.TAG_PAY_REQUEST) {
      throw new Error('lnurl-pay expected, found tag ' + reply.tag);
    }

    const data = reply;

    // parse metadata and extract things from it
    let image: string | undefined;
    let description: string | undefined;
    const kvs = JSON.parse(data.metadata);
    for (let i = 0; i < kvs.length; i++) {
      const [k, v] = kvs[i];
      switch (k) {
        case 'text/plain':
          description = v;
          break;
        case 'image/png;base64':
        case 'image/jpeg;base64':
          image = 'data:' + k + ',' + v;
          break;
      }
    }

    // setting the payment screen with the parameters
    const min = Math.ceil((data.minSendable ?? 0) / 1000);
    const max = Math.floor((data.maxSendable ?? 0) / 1000);

    this._lnurlPayServicePayload = {
      callback: data.callback,
      fixed: min === max,
      min,
      max,
      // @ts-ignore idk
      domain: data.callback.match(/^(https|http):\/\/([^/]+)\//)[2],
      metadata: data.metadata,
      description,
      image,
      amount: min,
      commentAllowed: data.commentAllowed,
      // lnurl: uri,
    };
    return this._lnurlPayServicePayload;
  }

  async loadSuccessfulPayment(paymentHash: string): Promise<boolean> {
    if (!paymentHash) throw new Error('No paymentHash provided');
    let data;
    try {
      data = await this._AsyncStorage.getItem('lnurlpay_success_data_' + paymentHash);
      data = JSON.parse(data);
    } catch (_) {
      return false;
    }

    if (!data) return false;

    this._lnurlPayServicePayload = data.lnurlPayServicePayload;
    this._lnurlPayServiceBolt11Payload = data.lnurlPayServiceBolt11Payload;
    this._lnurl = data.lnurl;
    this._preimage = data.preimage;

    return true;
  }

  async storeSuccess(paymentHash: string, preimage: string | { data: Buffer }): Promise<void> {
    if (typeof preimage === 'object') {
      preimage = Buffer.from(preimage.data).toString('hex');
    }
    this._preimage = preimage;

    await this._AsyncStorage.setItem(
      'lnurlpay_success_data_' + paymentHash,
      JSON.stringify({
        lnurlPayServicePayload: this._lnurlPayServicePayload,
        lnurlPayServiceBolt11Payload: this._lnurlPayServiceBolt11Payload,
        lnurl: this._lnurl,
        preimage,
      }),
    );
  }

  getSuccessAction(): any | undefined {
    return this._lnurlPayServiceBolt11Payload && 'successAction' in this._lnurlPayServiceBolt11Payload
      ? this._lnurlPayServiceBolt11Payload.successAction
      : undefined;
  }

  getDomain(): string | undefined {
    return this._lnurlPayServicePayload ? this._lnurlPayServicePayload.domain : undefined;
  }

  getDescription(): string | undefined {
    return this._lnurlPayServicePayload ? this._lnurlPayServicePayload.description : undefined;
  }

  getImage(): string | undefined {
    return this._lnurlPayServicePayload ? this._lnurlPayServicePayload.image : undefined;
  }

  getLnurl(): string {
    return this._lnurl;
  }

  getDisposable(): boolean | undefined {
    return this._lnurlPayServiceBolt11Payload && 'disposable' in this._lnurlPayServiceBolt11Payload
      ? this._lnurlPayServiceBolt11Payload.disposable
      : undefined;
  }

  getPreimage(): string | false {
    return this._preimage;
  }

  static decipherAES(ciphertextBase64: string, preimageHex: string, ivBase64: string): string {
    const iv = CryptoJS.enc.Base64.parse(ivBase64);
    const key = CryptoJS.enc.Hex.parse(preimageHex);
    return CryptoJS.AES.decrypt(Buffer.from(ciphertextBase64, 'base64').toString('hex'), key, {
      iv,
      mode: CryptoJS.mode.CBC,
      format: CryptoJS.format.Hex,
    }).toString(CryptoJS.enc.Utf8);
  }

  getCommentAllowed(): number | false {
    if (!this._lnurlPayServicePayload) return false;
    return this._lnurlPayServicePayload.commentAllowed ? parseInt(this._lnurlPayServicePayload.commentAllowed.toString(), 10) : false;
  }

  getMin(): number | false {
    if (!this._lnurlPayServicePayload) return false;
    return this._lnurlPayServicePayload.min ? parseInt(this._lnurlPayServicePayload.min.toString(), 10) : false;
  }

  getMax(): number | false {
    if (!this._lnurlPayServicePayload) return false;
    return this._lnurlPayServicePayload.max ? parseInt(this._lnurlPayServicePayload.max.toString(), 10) : false;
  }

  getAmount(): number | false {
    return this.getMin();
  }

  async authenticate(secret: string): Promise<void> {
    if (!this._lnurl) throw new Error('this._lnurl is not set');

    const url = parse(Lnurl.getUrlFromLnurl(this._lnurl) || '', true);

    if (!url.hostname) {
      throw new Error('Invalid URL: hostname is null');
    }

    const privateKey = hmac(sha256, secret, url.hostname);
    const privateKeyBuf = Buffer.from(privateKey);
    const publicKey = ecc.pointFromScalar(privateKeyBuf);
    if (!publicKey) {
      throw new Error('Failed to generate public key');
    }
    const signature = ecc.signDER(Buffer.from(url.query.k1 as string, 'hex'), privateKeyBuf);

    const reply = await this.fetchGet(
      `${url.href}&sig=${Buffer.from(signature).toString('hex')}&key=${Buffer.from(publicKey).toString('hex')}`,
    );
    if (reply.status === 'OK') {
      // Authentication successful
    } else {
      throw reply.reason;
    }
  }

  static isLightningAddress(address: string) {
    // ensure only 1 `@` present:
    if (address.split('@').length !== 2) return false;
    const splitted = address.split('@');
    return !!splitted[0].trim() && !!splitted[1].trim();
  }
}


================================================
FILE: ./class/deeplink-schema-match.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import bip21, { TOptions } from "bip21";
import * as bitcoin from "bitcoinjs-lib";
import URL from "url";
import { readFileOutsideSandbox } from "../malin_modules/fs";
import { Chain } from "../models/bitcoinUnits";
import { WatchOnlyWallet } from "./";
import Azteco from "./azteco";
import Lnurl from "./lnurl";
import type { TWallet } from "./wallets/types";

type TCompletionHandlerParams = [string, object];
type TContext = {
  wallets: TWallet[];
  saveToDisk: () => void;
  addWallet: (wallet: TWallet) => void;
  setSharedCosigner: (cosigner: string) => void;
};

type TBothBitcoinAndLightning =
  | { bitcoin: string; lndInvoice: string }
  | undefined;

class DeeplinkSchemaMatch {
  static hasSchema (schemaString: string): boolean {
    if (typeof schemaString !== "string" || schemaString.length <= 0) {
      return false
    }
    const lowercaseString = schemaString.trim().toLowerCase()
    return (
      lowercaseString.startsWith("bitcoin:") ||
      lowercaseString.startsWith("lightning:") ||
      lowercaseString.startsWith("mw:") ||
      lowercaseString.startsWith("malinwallet:") ||
      lowercaseString.startsWith("lapp:")
    )
  }

  /**
   * Examines the content of the event parameter.
   * If the content is recognizable, create a dictionary with the respective
   * navigation dictionary required by react-navigation
   *
   * @param event {{url: string}} URL deeplink as passed to app, e.g. `bitcoin:bc1qh6tf004ty7z7un2v5ntu4mkf630545gvhs45u7?amount=666&label=Yo`
   * @param completionHandler {function} Callback that returns [string, params: object]
   */
  static navigationRouteFor (
    event: { url: string },
    completionHandler: (args: TCompletionHandlerParams) => void,
    context: TContext = {
      wallets: [],
      saveToDisk: () => {},
      addWallet: () => {},
      setSharedCosigner: () => {},
    },
  ) {
    if (event.url === null) {
      return
    }
    if (typeof event.url !== "string") {
      return
    }

    if (
      event.url.toLowerCase().startsWith("malinwallet:bitcoin:") ||
      event.url.toLowerCase().startsWith("malinwallet:lightning:")
    ) {
      event.url = event.url.substring(11)
    } else if (
      event.url.toLocaleLowerCase().startsWith("malinwallet://widget?action=")
    ) {
      event.url = event.url.substring("malinwallet://".length)
    }

    if (DeeplinkSchemaMatch.isWidgetAction(event.url)) {
      if (context.wallets.length >= 0) {
        const wallet = context.wallets[0]
        const action = event.url.split("widget?action=")[1]
        if (wallet.chain === Chain.ONCHAIN) {
          if (action === "openSend") {
            completionHandler([
              "SendDetailsRoot",
              {
                screen: "SendDetails",
                params: {
                  walletID: wallet.getID()
                }
              },
            ]);
          } else if (action === "openReceive") {
            completionHandler([
              "DetailViewStackScreensStack",
              {
                screen: "ReceiveDetails",
                params: {
                  walletID: wallet.getID()
                }
              },
            ]);
          }
        } else if (wallet.chain === Chain.OFFCHAIN) {
          if (action === "openSend") {
            completionHandler([
              "ScanLNDInvoiceRoot",
              {
                screen: "ScanLNDInvoice",
                params: {
                  walletID: wallet.getID()
                }
              },
            ]);
          } else if (action === "openReceive") {
            completionHandler([
              "LNDCreateInvoiceRoot",
              {
                screen: "LNDCreateInvoice",
                params: { walletID: wallet.getID() },
              }
            ]);
          }
        }
      }
    } else if (DeeplinkSchemaMatch.isPossiblySignedPSBTFile(event.url)) {
      readFileOutsideSandbox(decodeURI(event.url))
        .then((file) => {
          if (file) {
            completionHandler([
              "SendDetailsRoot",
              {
                screen: "PsbtWithHardwareWallet",
                params: {
                  deepLinkPSBT: file
                }
              },
            ]);
          }
        })
        .catch((e) => console.warn(e))
      return
    } else if (DeeplinkSchemaMatch.isPossiblyCosignerFile(event.url)) {
      readFileOutsideSandbox(decodeURI(event.url))
        .then((file) => {
          // checks whether the necessary json keys are present in order to set a cosigner,
          // doesn't validate the values this happens later
          if (!file || !this.hasNeededJsonKeysForMultiSigSharing(file)) {
            return
          }
          context.setSharedCosigner(file)
        })
        .catch((e) => console.warn(e))
    }
    let isBothBitcoinAndLightning: TBothBitcoinAndLightning
    try {
      isBothBitcoinAndLightning = DeeplinkSchemaMatch.isBothBitcoinAndLightning(
        event.url,
      )
    } catch (e) {
      console.log(e)
    }
    if (isBothBitcoinAndLightning) {
      completionHandler([
        "SelectWallet",
        {
          onWalletSelect: (wallet: TWallet, { navigation }: any) => {
            navigation.pop() // close select wallet screen
            navigation.navigate(
              ...DeeplinkSchemaMatch.isBothBitcoinAndLightningOnWalletSelect(
                wallet,
                isBothBitcoinAndLightning,
              )
            )
          },
        },
      ])
    } else if (DeeplinkSchemaMatch.isBitcoinAddress(event.url)) {
      completionHandler([
        "SendDetailsRoot",
        {
          screen: "SendDetails",
          params: {
            uri: event.url.replace("://", ":"),
          }
        }
      ])
    } else if (DeeplinkSchemaMatch.isLightningInvoice(event.url)) {
      completionHandler([
        "ScanLNDInvoiceRoot",
        {
          screen: "ScanLNDInvoice",
          params: {
            uri: event.url.replace("://", ":"),
          }
        }
      ])
    } else if (DeeplinkSchemaMatch.isLnUrl(event.url)) {
      // at this point we can not tell if it is lnurl-pay or lnurl-withdraw since it needs additional async call
      // to the server, which is undesirable here, so LNDCreateInvoice screen will handle it for us and will
      // redirect user to LnurlPay screen if necessary
      completionHandler([
        "LNDCreateInvoiceRoot",
        {
          screen: "LNDCreateInvoice",
          params: {
            uri: event.url.replace("lightning:", "").replace("LIGHTNING:", ""),
          }
        }
      ])
    } else if (Lnurl.isLightningAddress(event.url)) {
      // this might be not just an email but a lightning address
      // @see https://lightningaddress.com
      completionHandler([
        "ScanLNDInvoiceRoot",
        {
          screen: "ScanLNDInvoice",
          params: {
            uri: event.url
          }
        },
      ]);
    } else if (Azteco.isRedeemUrl(event.url)) {
      completionHandler([
        "AztecoRedeemRoot",
        {
          screen: "AztecoRedeem",
          params: Azteco.getParamsFromUrl(event.url)
        }
      ])
    } else if (new WatchOnlyWallet().setSecret(event.url).init().valid()) {
      completionHandler([
        "AddWalletRoot",
        {
          screen: "ImportWallet",
          params: {
            triggerImport: true,
            label: event.url
          }
        },
      ]);
    } else {
      const urlObject = URL.parse(event.url, true); // eslint-disable-line n/no-deprecated-api
      (async () => {
        if (
          urlObject.protocol === "malinwallet:" ||
          urlObject.protocol === "lapp:" ||
          urlObject.protocol === "malin:"
        ) {
          switch (urlObject.host) {
            case "setelectrumserver":
              completionHandler([
                "ElectrumSettings",
                {
                  server:
                    DeeplinkSchemaMatch.getServerFromSetElectrumServerAction(
                      event.url,
                    )
                },
              ]);
              break;
            case "setlndhuburl":
              completionHandler([
                "LightningSettings",
                {
                  url: DeeplinkSchemaMatch.getUrlFromSetLndhubUrlAction(
                    event.url,
                  )
                },
              ]);
              break;
          }
        }
      })()
    }
  }

  /**
   * Extracts server from a deeplink like `malinwallet:setelectrumserver?server=electrum1.malinwallet.io%3A443%3As`
   * returns FALSE if none found
   *
   * @param url {string}
   * @return {string|boolean}
   */
  static getServerFromSetElectrumServerAction (url: string): string | false {
    if (
      !url.startsWith("malinwallet:setelectrumserver") &&
      !url.startsWith("setelectrumserver")
    ) {
      return false
    }
    const splt = url.split("server=");
    if (splt[1]) return decodeURIComponent(splt[1])
    return false
  }

  /**
   * Extracts url from a deeplink like `malinwallet:setlndhuburl?url=https%3A%2F%2Flndhub.herokuapp.com`
   * returns FALSE if none found
   *
   * @param url {string}
   * @return {string|boolean}
   */
  static getUrlFromSetLndhubUrlAction (url: string): string | false {
    if (
      !url.startsWith("malinwallet:setlndhuburl") &&
      !url.startsWith("setlndhuburl")
    ) {
      return false
    }
    const splt = url.split("url=");
    if (splt[1]) return decodeURIComponent(splt[1])
    return false
  }

  static isTXNFile (filePath: string): boolean {
    return (
      (filePath.toLowerCase().startsWith("file:") ||
        filePath.toLowerCase().startsWith("content:")) &&
      filePath.toLowerCase().endsWith(".txn")
    )
  }

  static isPossiblySignedPSBTFile (filePath: string): boolean {
    return (
      (filePath.toLowerCase().startsWith("file:") ||
        filePath.toLowerCase().startsWith("content:")) &&
      filePath.toLowerCase().endsWith("-signed.psbt")
    )
  }

  static isPossiblyPSBTFile (filePath: string): boolean {
    return (
      (filePath.toLowerCase().startsWith("file:") ||
        filePath.toLowerCase().startsWith("content:")) &&
      filePath.toLowerCase().endsWith(".psbt")
    )
  }

  static isPossiblyCosignerFile (filePath: string): boolean {
    return (
      (filePath.toLowerCase().startsWith("file:") ||
        filePath.toLowerCase().startsWith("content:")) &&
      filePath.toLowerCase().endsWith(".bwcosigner")
    )
  }

  static isBothBitcoinAndLightningOnWalletSelect (
    wallet: TWallet,
    uri: any,
  ): TCompletionHandlerParams {
    if (wallet.chain === Chain.ONCHAIN) {
      return [
        "SendDetailsRoot",
        {
          screen: "SendDetails",
          params: {
            uri: uri.bitcoin,
            walletID: wallet.getID()
          }
        },
      ];
    } else {
      return [
        "ScanLNDInvoiceRoot",
        {
          screen: "ScanLNDInvoice",
          params: {
            uri: uri.lndInvoice,
            walletID: wallet.getID()
          }
        },
      ];
    }
  }

  static isBitcoinAddress (address: string): boolean {
    address = address
      .replace("://", ":")
      .replace("bitcoin:", "")
      .replace("BITCOIN:", "")
      .replace("bitcoin=", "")
      .split("?")[0]
    let isValidBitcoinAddress = false
    try {
      bitcoin.address.toOutputScript(address)
      isValidBitcoinAddress = true
    } catch (err) {
      isValidBitcoinAddress = false
    }
    return isValidBitcoinAddress
  }

  static isLightningInvoice (invoice: string): boolean {
    let isValidLightningInvoice = false
    if (
      invoice.toLowerCase().startsWith("lightning:lnb") ||
      invoice.toLowerCase().startsWith("lightning://lnb") ||
      invoice.toLowerCase().startsWith("lnb")
    ) {
      isValidLightningInvoice = true
    }
    return isValidLightningInvoice
  }

  static isLnUrl (text: string): boolean {
    return Lnurl.isLnurl(text)
  }

  static isWidgetAction (text: string): boolean {
    return text.startsWith("widget?action=");
  }

  static hasNeededJsonKeysForMultiSigSharing (str: string): boolean {
    let obj

    // Check if it's a valid JSON
    try {
      obj = JSON.parse(str)
    } catch (e) {
      return false
    }

    // Check for the existence and type of the keys
    return (
      typeof obj.xfp === "string" &&
      typeof obj.xpub === "string" &&
      typeof obj.path === "string"
    );
  }

  static isBothBitcoinAndLightning (url: string): TBothBitcoinAndLightning {
    if (
      url.includes("lightning") &&
      (url.includes("bitcoin") || url.includes("BITCOIN"))
    ) {
      const txInfo = url.split(
        /(bitcoin:\/\/|BITCOIN:\/\/|bitcoin:|BITCOIN:|lightning:|lightning=|bitcoin=)+/,
      )
      let btc: string | false = false
      let lndInvoice: string | false = false
      for (const [index, value] of txInfo.entries()) {
        try {
          // Inside try-catch. We dont wan't to  crash in case of an out-of-bounds error.
          if (value.startsWith("bitcoin") || value.startsWith("BITCOIN")) {
            btc = `bitcoin:${txInfo[index + 1]}`
            if (!DeeplinkSchemaMatch.isBitcoinAddress(btc)) {
              btc = false
              break
            }
          } else if (value.startsWith("lightning")) {
            const lnpart = txInfo[index + 1]
              .split("&")
              .find((el) => el.toLowerCase().startsWith("ln"))
            lndInvoice = `lightning:${lnpart}`
            if (!this.isLightningInvoice(lndInvoice)) {
              lndInvoice = false
              break
            }
          }
        } catch (e) {
          console.log(e)
        }
        if (btc && lndInvoice) break
      }
      if (btc && lndInvoice) {
        return { bitcoin: btc, lndInvoice }
      } else {
        return undefined
      }
    }
    return undefined
  }

  static bip21decode (uri?: string) {
    if (!uri) {
      throw new Error("No URI provided");
    }
    let replacedUri = uri
    for (const replaceMe of ["BITCOIN://", "bitcoin://", "BITCOIN:"]) {
      replacedUri = replacedUri.replace(replaceMe, "bitcoin:");
    }

    return bip21.decode(replacedUri)
  }

  static bip21encode (address: string, options?: TOptions): string {
    // uppercase address if bech32 to satisfy BIP_0173
    const isBech32 = address.startsWith("bc1");
    if (isBech32) {
      address = address.toUpperCase()
    }

    for (const key in options) {
      if (
        key === "label" &&
        String(options[key]).replace(" ", "").length === 0
      ) {
        delete options[key]
      }
      if (key === "amount" && !(Number(options[key]) > 0)) {
        delete options[key]
      }
    }
    return bip21.encode(address, options)
  }

  static decodeBitcoinUri (uri: string) {
    let amount
    let address = uri || "";
    let memo = "";
    let payjoinUrl = "";
    try {
      const parsedBitcoinUri = DeeplinkSchemaMatch.bip21decode(uri)
      address = parsedBitcoinUri.address
        ? parsedBitcoinUri.address.toString()
        : address
      if ("options" in parsedBitcoinUri) {
        if (parsedBitcoinUri.options.amount) {
          amount = Number(parsedBitcoinUri.options.amount)
        }
        if (parsedBitcoinUri.options.label) {
          memo = parsedBitcoinUri.options.label
        }
        if (parsedBitcoinUri.options.pj) {
          payjoinUrl = parsedBitcoinUri.options.pj
        }
      }
    } catch (_) {}
    return { address, amount, memo, payjoinUrl }
  }
}

export default DeeplinkSchemaMatch


================================================
FILE: ./class/camera.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Alert, Linking } from 'react-native';

import { isDesktop } from '../malin_modules/environment';
import loc from '../loc';

export const openPrivacyDesktopSettings = () => {
  if (isDesktop) {
    Linking.openURL('x-apple.systempreferences:com.apple.preference.security?Privacy_Camera');
  } else {
    Linking.openSettings();
  }
};

export const presentCameraNotAuthorizedAlert = (error: string) => {
  Alert.alert(
    loc.errors.error,
    error,
    [
      {
        text: loc.send.open_settings,
        onPress: openPrivacyDesktopSettings,
        style: 'default',
      },
      {
        text: loc._.ok,
        onPress: () => {},
        style: 'cancel',
      },
    ],
    { cancelable: true },
  );
};


================================================
FILE: ./class/azteco.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import URL from 'url';
import { fetch } from '../util/fetch';

export type AztecoVoucher = {
  c1: string;
  c2: string;
  c3: string;
  c4: string;
};

export default class Azteco {
  /**
   * Redeems an Azteco bitcoin voucher.
   *
   * @param {AztecoVoucher} voucher - 16-digit voucher code in groups of 4.
   * @param {string} address - Bitcoin address to send the redeemed bitcoin to.
   *
   * @returns {Promise<boolean>} Successfully redeemed or not. This method does not throw exceptions
   */
  static async redeem(voucher: AztecoVoucher, address: string): Promise<boolean> {
    const baseURI = 'https://azte.co/';
    const url = `${baseURI}malin_despatch.php?CODE_1=${voucher.c1}&CODE_2=${voucher.c2}&CODE_3=${voucher.c3}&CODE_4=${voucher.c4}&ADDRESS=${address}`;

    try {
      const response = await fetch(url, {
        method: 'GET',
      });
      return response && response.status === 200;
    } catch (_) {
      return false;
    }
  }

  static isRedeemUrl(u: string): boolean {
    return u.startsWith('https://azte.co');
  }

  static getParamsFromUrl(u: string): { aztecoVoucher: AztecoVoucher } {
    const urlObject = URL.parse(u, true); // eslint-disable-line n/no-deprecated-api
    const q = urlObject.query;

    // new format https://azte.co/redeem?code=1111222233334444
    if (typeof q.code === 'string' && q.code.length === 16) {
      return {
        aztecoVoucher: {
          c1: q.code.substring(0, 4),
          c2: q.code.substring(4, 8),
          c3: q.code.substring(8, 12),
          c4: q.code.substring(12, 16),
        },
      };
    }

    // old format https://azte.co?c1=1111&c2=2222&c3=3333&c4=4444
    if (
      typeof q.c1 === 'string' &&
      typeof q.c2 === 'string' &&
      typeof q.c3 === 'string' &&
      typeof q.c4 === 'string' &&
      q.c1.length === 4 &&
      q.c2.length === 4 &&
      q.c3.length === 4 &&
      q.c4.length === 4
    ) {
      return {
        aztecoVoucher: {
          c1: q.c1,
          c2: q.c2,
          c3: q.c3,
          c4: q.c4,
        },
      };
    }

    // if the url does not match any of the formats, throw an error
    throw new Error('Invalid Azteco URL');
  }
}


================================================
FILE: ./index.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import './gesture-handler';
import 'react-native-get-random-values';
import 'react-native-url-polyfill/auto';
import 'text-encoding';
import './shim.js';

import React, { useEffect } from 'react';
import { AppRegistry, LogBox } from 'react-native';

import App from './App';
import { restoreSavedPreferredFiatCurrencyAndExchangeFromStorage } from './malin_modules/currency';

if (!Error.captureStackTrace) {
  // captureStackTrace is only available when debugging
  Error.captureStackTrace = () => {};
}

LogBox.ignoreLogs([
  'Require cycle:',
  'Battery state `unknown` and monitoring disabled, this is normal for simulators and tvOS.',
  'Open debugger to view warnings.',
  'Non-serializable values were found in the navigation state',
]);

const MalinAppComponent = () => {
  useEffect(() => {
    restoreSavedPreferredFiatCurrencyAndExchangeFromStorage();
  }, []);

  return <App />;
};

AppRegistry.registerComponent('MalinWallet', () => MalinAppComponent);


================================================
FILE: ./functions/.eslintrc.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
module.exports = {
  root: true,
  env: {
    es6: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript",
    "google",
    "plugin:@typescript-eslint/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: ["tsconfig.json", "tsconfig.dev.json"],
    sourceType: "module",
  },
  ignorePatterns: [
    "/lib/**/*", // Ignore built files.
    "/generated/**/*", // Ignore generated files.
  ],
  plugins: [
    "@typescript-eslint",
    "import",
  ],
  rules: {
    "quotes": ["error", "double"],
    "import/no-unresolved": 0,
    "indent": ["error", 2],
  },
};


================================================
FILE: ./functions/src/index.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import {setGlobalOptions} from "firebase-functions";
import {onRequest} from "firebase-functions/https";
import * as logger from "firebase-functions/logger";

// Start writing functions
// https://firebase.google.com/docs/functions/typescript

// For cost control, you can set the maximum number of containers that can be
// running at the same time. This helps mitigate the impact of unexpected
// traffic spikes by instead downgrading performance. This limit is a
// per-function limit. You can override the limit for each function using the
// `maxInstances` option in the function's options, e.g.
// `onRequest({ maxInstances: 5 }, (req, res) => { ... })`.
// NOTE: setGlobalOptions does not apply to functions using the v1 API. V1
// functions should each use functions.runWith({ maxInstances: 10 }) instead.
// In the v1 API, each function can only serve one request per container, so
// this will be the maximum concurrent request count.
setGlobalOptions({ maxInstances: 10 });

// export const helloWorld = onRequest((request, response) => {
//   logger.info("Hello logs!", {structuredData: true});
//   response.send("Hello from Firebase!");
// });


================================================
FILE: ./functions/src/genkit-sample.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import {genkit, z} from "genkit";
import {vertexAI} from "@genkit-ai/google-genai";

// Cloud Functions for Firebase supports Genkit natively. The onCallGenkit function creates a callable
// function from a Genkit action. It automatically implements streaming if your flow does.
// The https library also has other utility methods such as hasClaim, which verifies that
// a caller's token has a specific claim (optionally matching a specific value)
import { onCallGenkit, hasClaim } from "firebase-functions/https";

// Gemini Developer API models and Vertex Express Mode models depend on an API key.
// API keys should be stored in Cloud Secret Manager so that access to these
// sensitive values can be controlled. defineSecret does this for you automatically.
// If you are using Google Developer API (googleAI) you can get an API key at https://aistudio.google.com/app/apikey
// If you are using Vertex Express Mode (vertexAI with apiKey) you can get an API key
// from the Vertex AI Studio Express Mode setup.
import { defineSecret } from "firebase-functions/params";
const apiKey = defineSecret("GOOGLE_GENAI_API_KEY");

// The Firebase telemetry plugin exports a combination of metrics, traces, and logs to Google Cloud
// Observability. See https://firebase.google.com/docs/genkit/observability/telemetry-collection.
// import {enableFirebaseTelemetry} from "@genkit-ai/firebase";
// enableFirebaseTelemetry();

const ai = genkit({
  plugins: [
    // Load the VertexAI provider. You can optionally specify your location
    // and projectID by passing in a config object; if you don't, the provider
    // uses the value from environment variables like GCLOUD_PROJECT and GCLOUD_LOCATION.
    // If you want to use Vertex Express Mode, you can specify apiKey instead.
    vertexAI({location: "global"})
  ],
});

// Define a simple flow that prompts an LLM to generate menu suggestions.
const menuSuggestionFlow = ai.defineFlow({
    name: "menuSuggestionFlow",
    inputSchema: z.string().describe("A restaurant theme").default("seafood"),
    outputSchema: z.string(),
    streamSchema: z.string(),
  }, async (subject, { sendChunk }) => {
    // Construct a request and send it to the model API.
    const prompt =
      `Suggest an item for the menu of a ${subject} themed restaurant`;
    const { response, stream } = ai.generateStream({
      model: vertexAI.model("gemini-2.5-flash"),
      prompt: prompt,
      config: {
        temperature: 1,
      },
    });

    for await (const chunk of stream) {
      sendChunk(chunk.text);
    }

    // Handle the response from the model API. In this sample, we just
    // convert it to a string, but more complicated flows might coerce the
    // response into structured output or chain the response into another
    // LLM call, etc.
    return (await response).text;
  }
);

export const menuSuggestion = onCallGenkit({
  // Uncomment to enable AppCheck. This can reduce costs by ensuring only your Verified
  // app users can use your API. Read more at https://firebase.google.com/docs/app-check/cloud-functions
  // enforceAppCheck: true,

  // authPolicy can be any callback that accepts an AuthData (a uid and tokens dictionary) and the
  // request data. The isSignedIn() and hasClaim() helpers can be used to simplify. The following
  // will require the user to have the email_verified claim, for example.
  // authPolicy: hasClaim("email_verified"),

  // Grant access to the API key to this function:
  secrets: [apiKey],
}, menuSuggestionFlow);


================================================
FILE: ./typings/coinselect.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
declare module 'coinselect' {
  export type CoinSelectTarget = {
    address: string;
    value?: number;
    script?: {
      length: number;
    };
  };

  /**
   * not an accurate definition since coinselect lib can ignore certain fields, and just passes through unknown fields,
   * which we actually rely on
   */
  export type CoinSelectUtxo = {
    vout: number;
    value: number;
    txid: string;
    address?: string;
    wif?: string;
    txhex?: string;
    script?: {
      length: number;
    };
  };

  export type CoinSelectReturnInput = {
    vout: number;
    value: number;
    txid: string;
    address?: string;
    wif?: string;
    txhex?: string;
    script?: {
      length: number;
    };
  };

  export type CoinSelectOutput = {
    address?: string; // if output has no address - this is a change output
    value: number;
  };

  export default function coinSelect(
    utxos: CoinSelectUtxo[],
    targets: CoinSelectTarget[],
    feeRate: number,
    changeAddress?: string,
  ): {
    inputs: CoinSelectReturnInput[];
    outputs: CoinSelectOutput[];
    fee: number;
  };
}

declare module 'coinselect/split' {
  type Utxo = {
    vout: number;
    value: number;
    txid: string;
  };

  export default function coinSelectSplit<U extends Utxo>(
    utxos: U[],
    targets: { address: string; value?: number }[],
    feeRate: number,
    changeAddress?: string,
  ): {
    inputs: CoinselectReturnInput[];
    outputs: {
      address?: string;
      value: number;
    }[];
    fee: number;
  };
}


================================================
FILE: ./typings/react-native-passcode-auth.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
declare module 'react-native-passcode-auth' {
  declare function isSupported(): Promise<boolean>;
  declare function authenticate(): Promise<boolean>;
}


================================================
FILE: ./typings/globals.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
declare function alert(message: string): void;

declare const navigator: undefined | { product: 'ReactNative' };


================================================
FILE: ./typings/ActionIcons.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export interface ActionIcons {
  iconValue: string;
}


================================================
FILE: ./typings/CommonToolTipActions.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Platform } from 'react-native';
import loc from '../loc';

const keys = {
  CopyTXID: 'copyTX_ID',
  CopyBlockExplorerLink: 'copy_blockExplorer',
  ExpandNote: 'expandNote',
  OpenInBlockExplorer: 'open_in_blockExplorer',
  CopyAmount: 'copyAmount',
  CopyNote: 'copyNote',
  ManageWallets: 'manageWallets',
  ImportWallet: 'importWallet',
  HideBalance: 'hideBalance',
  ViewInBitcoin: 'viewInBitcoin',
  ViewInSats: 'viewInSats',
  ViewInFiat: 'viewInFiat',
  Entropy: 'entropy',
  SearchAccount: 'searchAccount',
  Passphrase: 'passphrase',
  MoreInfo: 'moreInfo',
  SaveChanges: 'saveChanges',
  ClearClipboard: 'clearClipboard',
  PaymentsCode: 'paymentsCode',
  ResetToDefault: 'resetToDefault',
  ScanQR: 'scan_qr',
  RemoveAllRecipients: 'RemoveAllRecipients',
  AddRecipient: 'AddRecipient',
  RemoveRecipient: 'RemoveRecipient',
  ChoosePhoto: 'choose_photo',
  ImportFile: 'import_file',
  InsertContact: 'insert_contact',
  SignPSBT: 'sign_psbt',
  SendMax: 'send_max',
  AllowRBF: 'allow_rbf',
  ImportTransaction: 'import_transaction',
  ImportTransactionMultsig: 'import_transaction_multisig',
  ImportTransactionQR: 'import_transaction_qr',
  CoinControl: 'coin_control',
  CoSignTransaction: 'co_sign_transaction',
  CopyToClipboard: 'copyToClipboard',
  Share: 'share',
  SaveFile: 'saveFile',
  SignVerify: 'signVerify',
  ExportPrivateKey: 'exportPrivateKey',
  PasteFromClipboard: 'pasteFromClipboard',
  Hide: 'hide',
  SortASC: 'sortASC',
  SortDESC: 'sortDESC',
  SortHeight: 'sortHeight',
  SortValue: 'sortValue',
  SortLabel: 'sortLabel',
  SortStatus: 'sortStatus',
  Delete: 'delete',
  Details: 'details',
} as const;

const icons = {
  Eye: { iconValue: 'eye' },
  EyeSlash: { iconValue: 'eye.slash' },
  Link: { iconValue: 'link' },
  Note: { iconValue: 'note.text' },
  ManageWallets: { iconValue: 'slider.horizontal.3' },
  ImportWallet: { iconValue: 'square.and.arrow.down.on.square' },
  ViewInBitcoin: { iconValue: 'bitcoinsign.circle' },
  ViewInFiat: { iconValue: 'coloncurrencysign.circle' },
  Entropy: { iconValue: 'dice' },
  SearchAccount: { iconValue: 'magnifyingglass' },
  Passphrase: { iconValue: 'rectangle.and.pencil.and.ellipsis' },
  MoreInfo: { iconValue: 'info.circle' },
  SaveChanges: { iconValue: 'checkmark' },
  InsertContact: { iconValue: 'at.badge.plus' },
  SignPSBT: { iconValue: 'signature' },
  SendMax: { iconValue: 'dial.high' },
  AllowRBF: { iconValue: 'arrowshape.up.circle' },
  ImportTransaction: { iconValue: 'square.and.arrow.down' },
  ImportTransactionMultsig: { iconValue: 'square.and.arrow.down.on.square' },
  ImportTransactionQR: { iconValue: 'qrcode.viewfinder' },
  CoinControl: { iconValue: 'switch.2' },
  CoSignTransaction: { iconValue: 'signature' },
  PaymentsCode: { iconValue: 'qrcode.viewfinder' },
  RemoveAllRecipients: { iconValue: 'person.2.slash' },
  AddRecipient: { iconValue: 'person.badge.plus' },
  RemoveRecipient: { iconValue: 'person.badge.minus' },
  ScanQR: { iconValue: Platform.OS === 'ios' ? 'qrcode.viewfinder' : 'ic_menu_camera' },
  ChoosePhoto: { iconValue: Platform.OS === 'ios' ? 'photo.on.rectangle' : 'ic_menu_gallery' },
  Clipboard: { iconValue: Platform.OS === 'ios' ? 'document.on.clipboard' : 'ic_menu_file' },
  ExportPrivateKey: { iconValue: Platform.OS === 'ios' ? 'key' : 'ic_lock_idle_lock' },
  Share: { iconValue: Platform.OS === 'ios' ? 'square.and.arrow.up' : 'ic_menu_share' },
  Signature: { iconValue: Platform.OS === 'ios' ? 'signature' : 'ic_menu_edit' },
  PasteFromClipboard: { iconValue: Platform.OS === 'ios' ? 'document.on.clipboard' : 'ic_menu_paste' },
  ImportFile: { iconValue: Platform.OS === 'ios' ? 'document.viewfinder' : 'ic_menu_upload' },
  Hide: { iconValue: Platform.OS === 'ios' ? 'eye.slash' : 'ic_menu_close_clear_cancel' },
  ClearClipboard: { iconValue: Platform.OS === 'ios' ? 'clipboard' : 'ic_menu_delete' },
  SortASC: { iconValue: Platform.OS === 'ios' ? 'arrow.down.to.line' : 'ic_menu_sort_alphabetically' },
  SortDESC: { iconValue: Platform.OS === 'ios' ? 'arrow.up.to.line' : 'ic_menu_sort_by_size' },
  SaveFile: { iconValue: Platform.OS === 'ios' ? 'square.and.arrow.down' : 'ic_menu_save' },
  Delete: { iconValue: Platform.OS === 'ios' ? 'trash' : 'ic_menu_delete' },
  Details: { iconValue: Platform.OS === 'ios' ? 'info.circle' : 'ic_menu_info_details' },
} as const;

export type ToolTipAction = {
  id: string;
  text: string;
  subtitle?: string;
  icon?: { iconValue: string };
  hidden?: boolean;
  menuState?: boolean;
  destructive?: boolean;
};

export const CommonToolTipActions: Record<string, ToolTipAction> = {
  CopyTXID: {
    id: keys.CopyTXID,
    text: loc.transactions.details_copy_txid,
    icon: icons.Clipboard,
  },
  CopyBlockExplorerLink: {
    id: keys.CopyBlockExplorerLink,
    text: loc.transactions.details_copy_block_explorer_link,
    icon: icons.Clipboard,
  },
  OpenInBlockExplorer: {
    id: keys.OpenInBlockExplorer,
    text: loc.transactions.details_view_in_browser,
    icon: icons.Link,
  },
  ExpandNote: {
    id: keys.ExpandNote,
    text: loc.transactions.expand_note,
    icon: icons.Note,
  },
  CopyAmount: {
    id: keys.CopyAmount,
    text: loc.transactions.details_copy,
    icon: icons.Clipboard,
  },
  AddRecipient: {
    id: keys.AddRecipient,
    text: loc.send.details_add_rec_add,
    icon: icons.AddRecipient,
  },
  RemoveRecipient: {
    id: keys.RemoveRecipient,
    text: loc.send.details_add_rec_rem,
    icon: icons.RemoveRecipient,
  },
  CopyNote: {
    id: keys.CopyNote,
    text: loc.transactions.details_copy_note,
    icon: icons.Clipboard,
  },
  ManageWallet: {
    id: keys.ManageWallets,
    text: loc.wallets.manage_title,
    icon: icons.ManageWallets,
  },
  ImportWallet: {
    id: keys.ImportWallet,
    text: loc.wallets.add_import_wallet,
    icon: icons.ImportWallet,
  },
  HideBalance: {
    id: keys.HideBalance,
    text: loc.transactions.details_balance_hide,
    icon: icons.EyeSlash,
  },
  Hide: {
    id: keys.Hide,
    text: loc.total_balance_view.hide,
    icon: icons.EyeSlash,
  },
  ViewInFiat: {
    id: keys.ViewInFiat,
    text: loc.total_balance_view.display_in_fiat,
    icon: icons.ViewInFiat,
    hidden: false,
  },
  ViewInSats: {
    id: keys.ViewInSats,
    text: loc.total_balance_view.display_in_sats,
    icon: icons.ViewInBitcoin,
    hidden: false,
  },
  ViewInBitcoin: {
    id: keys.ViewInBitcoin,
    text: loc.total_balance_view.display_in_bitcoin,
    icon: icons.ViewInBitcoin,
    hidden: false,
  },
  Entropy: {
    id: keys.Entropy,
    text: loc.wallets.add_entropy_provide,
    icon: icons.Entropy,
  },
  RemoveAllRecipients: {
    id: keys.RemoveAllRecipients,
    text: loc.send.details_add_rec_rem_all,
    icon: icons.RemoveAllRecipients,
  },
  SearchAccount: {
    id: keys.SearchAccount,
    text: loc.wallets.import_search_accounts,
    icon: icons.SearchAccount,
    menuState: false,
  },
  Passphrase: {
    id: keys.Passphrase,
    text: loc.wallets.import_passphrase,
    icon: icons.Passphrase,
    menuState: false,
  },
  MoreInfo: {
    id: keys.MoreInfo,
    text: loc.wallets.more_info,
    icon: icons.MoreInfo,
    hidden: false,
  },
  SaveChanges: {
    id: keys.SaveChanges,
    text: loc._.save,
    icon: icons.SaveChanges,
  },
  PaymentsCode: {
    id: keys.PaymentsCode,
    text: loc.bip47.bip47_explain,
    subtitle: loc.bip47.bip47_explain_subtitle,
    icon: icons.PaymentsCode,
    menuState: false,
  },
  ScanQR: {
    id: keys.ScanQR,
    text: loc.wallets.list_long_scan,
    icon: icons.ScanQR,
  },
  ChoosePhoto: {
    id: keys.ChoosePhoto,
    text: loc.wallets.list_long_choose,
    icon: icons.ChoosePhoto,
  },
  ImportFile: {
    id: keys.ImportFile,
    text: loc.wallets.import_file,
    icon: icons.ImportFile,
  },
  InsertContact: {
    id: keys.InsertContact,
    text: loc.send.details_insert_contact,
    icon: icons.InsertContact,
    hidden: true,
  },
  SignPSBT: {
    id: keys.SignPSBT,
    text: loc.send.psbt_sign,
    icon: icons.SignPSBT,
    hidden: true,
  },
  SendMax: {
    id: keys.SendMax,
    text: loc.send.details_adv_full,
    icon: icons.SendMax,
    hidden: true,
  },
  AllowRBF: {
    id: keys.AllowRBF,
    text: loc.send.details_adv_fee_bump,
    icon: icons.AllowRBF,
    hidden: true,
    menuState: false,
  },
  ImportTransaction: {
    id: keys.ImportTransaction,
    text: loc.send.details_adv_import,
    icon: icons.ImportTransaction,
    hidden: true,
  },
  ImportTransactionQR: {
    id: keys.ImportTransactionQR,
    text: loc.send.details_adv_import_qr,
    icon: icons.ImportTransactionQR,
    hidden: true,
  },
  ImportTransactionMultsig: {
    id: keys.ImportTransactionMultsig,
    text: loc.send.details_adv_import,
    icon: icons.ImportTransactionMultsig,
    hidden: true,
  },
  CoSignTransaction: {
    id: keys.CoSignTransaction,
    text: loc.multisig.co_sign_transaction,
    icon: icons.CoSignTransaction,
    hidden: true,
  },
  CoinControl: {
    id: keys.CoinControl,
    text: loc.cc.header,
    icon: icons.CoinControl,
    hidden: false,
  },
  CopyToClipboard: {
    id: keys.CopyToClipboard,
    text: loc.transactions.details_copy,
    icon: icons.Clipboard,
  },
  Share: {
    id: keys.Share,
    text: loc.receive.details_share,
    icon: icons.Share,
  },
  SignVerify: {
    id: keys.SignVerify,
    text: loc.addresses.sign_title,
    icon: icons.Signature,
    hidden: false,
  },
  ExportPrivateKey: {
    id: keys.ExportPrivateKey,
    text: loc.addresses.copy_private_key,
    icon: icons.ExportPrivateKey,
    hidden: false,
  },
  ResetToDefault: {
    id: keys.ResetToDefault,
    text: loc.settings.electrum_reset,
    hidden: false,
    destructive: true,
  },
  PasteFromClipboard: {
    id: keys.PasteFromClipboard,
    text: loc.wallets.paste_from_clipboard,
    icon: icons.PasteFromClipboard,
  },
  ClearClipboard: {
    id: keys.ClearClipboard,
    text: loc.wallets.clear_clipboard_on_import,
    icon: icons.Clipboard,
    menuState: true,
  },
  SortASC: {
    id: keys.SortASC,
    text: loc.cc.sort_asc,
    icon: icons.SortASC,
  },
  SortDESC: {
    id: keys.SortDESC,
    text: loc.cc.sort_desc,
    icon: icons.SortDESC,
  },
  SortHeight: {
    id: keys.SortHeight,
    text: loc.cc.sort_height,
  },
  SortValue: {
    id: keys.SortValue,
    text: loc.cc.sort_value,
  },
  SortLabel: {
    id: keys.SortLabel,
    text: loc.cc.sort_label,
  },
  SortStatus: {
    id: keys.SortStatus,
    text: loc.cc.sort_status,
  },
  SaveFile: {
    id: keys.SaveFile,
    text: loc._.save,
    icon: icons.SaveFile,
  },
  Delete: {
    id: keys.Delete,
    text: loc.wallets.details_delete,
    icon: icons.Delete,
    destructive: true,
  },
  Details: {
    id: keys.Details,
    text: loc.send.create_details,
    icon: icons.Details,
  },
} as const;


================================================
FILE: ./typings/react-native-prompt-android.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// Type definitions for react-native-prompt-android 0.3.1
// Project: https://github.com/shimohq/react-native-prompt-android
// Definitions by: Krystof Celba <https://github.com/krystofcelba>
// TypeScript Version: 2.6.1

type PromptButton = {
  text?: string;
  onPress?: (message: string) => void;

  /** @platform ios */
  style?: 'default' | 'cancel' | 'destructive';
};

type PromptType = 'default' | 'plain-text' | 'secure-text';
type PromptTypeIOS = 'login-password';
type PromptTypeAndroid = 'numeric' | 'email-address' | 'phone-pad';

type PromptStyleAndroid = 'default' | 'shimo';

interface PromptOptions {
  /**
   * * Cross platform:
   *
   * - `'default'`
   * - `'plain-text'`
   * - `'secure-text'`
   *
   * * iOS only:
   *
   * - `'login-password'`
   *
   * * Android only:
   *
   * - `'numeric'`
   * - `'email-address'`
   * - `'phone-pad'`
   */
  type?: PromptType | PromptTypeIOS | PromptTypeAndroid;

  defaultValue?: string;

  /** @platform android */
  placeholder?: string;

  /** @platform android */
  cancelable?: boolean;

  /** @platform android */
  style?: PromptStyleAndroid;
}

declare function prompt(
  title?: string,
  message?: string,
  callbackOrButtons?: ((value: string) => void) | Array<PromptButton>,
  options?: PromptOptions,
): void;


================================================
FILE: ./typings/slip39.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
declare module 'slip39' {
  export function recoverSecret(secret: string[], passphrase?: string): Buffer;
  export function validateMnemonic(mnemonic: string): boolean;
}

declare module 'slip39/src/slip39_helper' {
  export const WORD_LIST: string[];
}


================================================
FILE: ./typings/bip21.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
declare module 'bip21' {
  export type TOptions =
    | {
        amount?: number;
        label?: string;
        pj?: string;
      }
    | { [key: string]: string };

  export function decode(uri: string, urnScheme?: string): { address: string; options: TOptions };
  export function encode(address: string, options?: TOptions, urnScheme?: string): string;
}


================================================
FILE: ./helpers/prompt.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Platform } from 'react-native';
import prompt from 'react-native-prompt-android';
import loc from '../loc';

export default (
  title: string,
  text: string,
  isCancelable = true,
  type: PromptType | PromptTypeIOS | PromptTypeAndroid = 'secure-text',
  isOKDestructive = false,
  continueButtonText = loc._.ok,
): Promise<string> => {
  const keyboardType = type === 'numeric' ? 'numeric' : 'default';

  if (Platform.OS === 'ios' && type === 'numeric') {
    // `react-native-prompt-android` on ios does not support numeric input
    type = 'plain-text';
  }

  return new Promise((resolve, reject) => {
    const buttons: Array<PromptButton> = isCancelable
      ? [
          {
            text: loc._.cancel,
            onPress: () => {
              reject(Error('Cancel Pressed'));
            },
            style: 'cancel',
          },
          {
            text: continueButtonText,
            onPress: password => {
              console.log('OK Pressed');
              resolve(password);
            },
            style: isOKDestructive ? 'destructive' : 'default',
          },
        ]
      : [
          {
            text: continueButtonText,
            onPress: password => {
              console.log('OK Pressed');
              resolve(password);
            },
          },
        ];

    prompt(title, text, buttons, {
      type,
      cancelable: isCancelable,
      // @ts-ignore suppressed because its supported only on ios and is absent from type definitions
      keyboardType,
    });
  });
};


================================================
FILE: ./helpers/confirm.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Alert } from 'react-native';
import loc from '../loc';

/**
 * Helper function that throws un-cancellable dialog to confirm user's action.
 * Promise resolves to TRUE if user confirms, FALSE otherwise
 *
 * @param title {string}
 * @param text {string}
 *
 * @return {Promise<boolean>}
 */
export default function (title = 'Are you sure?', text = ''): Promise<boolean> {
  return new Promise(resolve => {
    Alert.alert(
      title,
      text,
      [
        {
          text: loc._.yes,
          onPress: () => resolve(true),
          style: 'default',
        },
        {
          text: loc._.cancel,
          onPress: () => resolve(false),
          style: 'cancel',
        },
      ],
      { cancelable: false },
    );
  });
}


================================================
FILE: ./helpers/select-wallet.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * Helper function to select wallet.
 * Navigates to selector screen, and then navigates back while resolving promise with selected wallet.
 *
 * @param navigation - return value of useExtendedNavigation, so inside helper we can navigate to selector screen and back
 * @param currentScreenName {string} Current screen name, so we know to what screen to get back to
 * @param chainType {string} One of `Chain.` constant to be used to filter wallet panels to show
 * @param availableWallets {array} Wallets to be present in selector. If set, overrides `chainType`
 * @param noWalletExplanationText {string} Text that is displayed when there are no wallets to select from
 *
 * @returns {Promise<TWallet>}
 */
import { TWallet } from '../class/wallets/types';
import { useExtendedNavigation } from '../hooks/useExtendedNavigation';

export default function (
  navigation: ReturnType<typeof useExtendedNavigation>,
  currentScreenName: string,
  chainType: string | null,
  availableWallets?: TWallet[],
  noWalletExplanationText = '',
): Promise<TWallet> {
  return new Promise((resolve, reject) => {
    if (!currentScreenName) return reject(new Error('currentScreenName is not provided'));

    const params: {
      chainType: string | null;
      availableWallets?: TWallet[];
      noWalletExplanationText?: string;
      onWalletSelect: (selectedWallet: TWallet) => void;
    } = {
      chainType: null,
      onWalletSelect: (selectedWallet: TWallet) => {},
    };
    if (chainType) params.chainType = chainType;
    if (availableWallets) params.availableWallets = availableWallets;
    if (noWalletExplanationText) params.noWalletExplanationText = noWalletExplanationText;

    params.onWalletSelect = function (selectedWallet: TWallet) {
      if (!selectedWallet) return;

      setTimeout(() => resolve(selectedWallet), 100);
      navigation.goBack();
    };

    navigation.navigate('SelectWallet', params);
  });
}


================================================
FILE: ./helpers/scan-qr.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Platform } from 'react-native';
import { check, request, PERMISSIONS, RESULTS } from 'react-native-permissions';
import { navigationRef } from '../NavigationService.ts';

const isCameraAuthorizationStatusGranted = async () => {
  const status = await check(Platform.OS === 'android' ? PERMISSIONS.ANDROID.CAMERA : PERMISSIONS.IOS.CAMERA);
  return status === RESULTS.GRANTED;
};

const requestCameraAuthorization = () => {
  return request(Platform.OS === 'android' ? PERMISSIONS.ANDROID.CAMERA : PERMISSIONS.IOS.CAMERA);
};

const scanQrHelper = async (): Promise<string> => {
  await requestCameraAuthorization();
  return new Promise(resolve => {
    if (navigationRef.isReady()) {
      navigationRef.navigate('ScanQRCode', {
        showFileImportButton: true,
        onBarScanned: (data: string) => {
          resolve(data);
        },
      });
    }
  });
};

export { isCameraAuthorizationStatusGranted, requestCameraAuthorization, scanQrHelper };


================================================
FILE: ./helpers/presentWalletExportReminder.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Alert } from 'react-native';
import loc from '../loc';

export const presentWalletExportReminder = (): Promise<void> => {
  return new Promise<void>((resolve, reject) => {
    Alert.alert(
      loc.wallets.details_title,
      loc.pleasebackup.ask,
      [
        { text: loc.pleasebackup.ask_yes, onPress: () => resolve(), style: 'default' },
        { text: loc.pleasebackup.ask_no, onPress: () => reject(new Error('User has denied saving the wallet backup.')) },
        { text: loc._.cancel, style: 'cancel' },
      ],
      { cancelable: true },
    );
  });
};


================================================
FILE: ./helpers/lndHub.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import DefaultPreference from 'react-native-default-preference';
import { MalinApp } from '../class';
import { GROUP_IO_MALINWALLET } from '../malin_modules/currency';

// Function to get the value from DefaultPreference first, then fallback to AsyncStorage 
// as DefaultPreference uses truly native storage.
// If found in AsyncStorage, migrate it to DefaultPreference and remove it from AsyncStorage.
export const getLNDHub = async (): Promise<string | undefined> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    let value = await DefaultPreference.get(MalinApp.LNDHUB) as string | null;

    // If not found, check AsyncStorage and migrate it to DefaultPreference
    if (!value) {
      value = await AsyncStorage.getItem(MalinApp.LNDHUB);

      if (value) {
        await DefaultPreference.set(MalinApp.LNDHUB, value);
        await AsyncStorage.removeItem(MalinApp.LNDHUB);
        console.log('Migrated LNDHub value from AsyncStorage to DefaultPreference');
      }
    }

    return value ?? undefined;
  } catch (error) {
    console.error('Error getting LNDHub preference:', (error as Error).message);
    return undefined;
  }
};

export const setLNDHub = async (value: string): Promise<void> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    await DefaultPreference.set(MalinApp.LNDHUB, value);
  } catch (error) {
    console.error('Error setting LNDHub preference:', error);
  }
};

export const clearLNDHub = async (): Promise<void> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    await DefaultPreference.clear(MalinApp.LNDHUB);
    await AsyncStorage.removeItem(MalinApp.LNDHUB);
  } catch (error) {
    console.error('Error clearing LNDHub preference:', error);
  }
};

================================================
FILE: ./__mocks__/react-native-image-picker.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { NativeModules } from 'react-native';

// Mock the ImagePickerManager native module to allow us to unit test the JavaScript code
NativeModules.ImagePickerManager = {
  showImagePicker: jest.fn(),
  launchCamera: jest.fn(),
  launchImageLibrary: jest.fn(),
};

// Reset the mocks before each test
global.beforeEach(() => {
  jest.resetAllMocks();
});


================================================
FILE: ./__mocks__/react-native-localize.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const getLocales = () => [
  // you can choose / add the locales you want
  { countryCode: 'US', languageTag: 'en-US', languageCode: 'en', isRTL: false },
  { countryCode: 'FR', languageTag: 'fr-FR', languageCode: 'fr', isRTL: false },
];
const getCurrencies = () => ['USD', 'EUR']; // can be empty array

export { getLocales, getCurrencies };


================================================
FILE: ./__mocks__/@react-native-async-storage/async-storage.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorageMock from '@react-native-async-storage/async-storage/jest/async-storage-mock';

export default AsyncStorageMock;


================================================
FILE: ./malin_modules/bc-bech32/dist/bech32.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = {};
var Bech32Version;
(function (Bech32Version) {
    Bech32Version[Bech32Version["Origin"] = 1] = "Origin";
    Bech32Version[Bech32Version["bis"] = 2] = "bis";
})(Bech32Version = Bech32Version || (Bech32Version = {}));
index_1.Bech32Version=Bech32Version;
var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
function polymod(values) {
    var chk = 1;
    for (var p = 0; p < values.length; ++p) {
        var top_1 = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (var i = 0; i < 6; ++i) {
            if ((top_1 >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
}
function hrpExpand(hrp) {
    var ret = [];
    var p;
    for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) >> 5);
    }
    ret.push(0);
    for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) & 31);
    }
    return ret;
}
function verifyChecksum(hrp, data, version) {
    var header;
    if (hrp) {
        header = hrpExpand(hrp);
    }
    else {
        header = [0];
    }
    var check = version === index_1.Bech32Version.Origin ? 1 : 0x3fffffff;
    return polymod(header.concat(data)) === check;
}
function createChecksum(hrp, data, bech32Version) {
    var values;
    if (hrp) {
        values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
    }
    else {
        values = [0].concat(data).concat([0, 0, 0, 0, 0, 0]);
    }
    var chk = bech32Version === index_1.Bech32Version.Origin ? 1 : 0x3fffffff;
    var mod = polymod(values) ^ chk;
    var ret = [];
    for (var p = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return ret;
}
var encode = function (hrp, data, version) {
    var combined = data.concat(createChecksum(hrp, data, version));
    var ret;
    if (hrp) {
        ret = hrp + '1';
    }
    else {
        ret = '';
    }
    for (var p = 0; p < combined.length; ++p) {
        ret += CHARSET.charAt(combined[p]);
    }
    return ret;
};
var decodeBc32 = function (bechString) {
    var data = [];
    for (var p = 0; p < bechString.length; ++p) {
        var d = CHARSET.indexOf(bechString.charAt(p));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }
    if (!verifyChecksum(null, data, index_1.Bech32Version.bis)) {
        return null;
    }
    return { hrp: null, data: data.slice(0, data.length - 6) };
};
var decode = function (bechString) {
    var p;
    var hasLower = false;
    var hasUpper = false;
    for (p = 0; p < bechString.length; ++p) {
        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {
            return null;
        }
        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {
            hasLower = true;
        }
        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {
            hasUpper = true;
        }
    }
    if (hasLower && hasUpper) {
        return null;
    }
    bechString = bechString.toLowerCase();
    var pos = bechString.lastIndexOf('1');
    if (pos === -1) {
        return decodeBc32(bechString);
    }
    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {
        return null;
    }
    var hrp = bechString.substring(0, pos);
    var data = [];
    for (p = pos + 1; p < bechString.length; ++p) {
        var d = CHARSET.indexOf(bechString.charAt(p));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }
    if (!verifyChecksum(hrp, data, index_1.Bech32Version.Origin)) {
        return null;
    }
    return { hrp: hrp, data: data.slice(0, data.length - 6) };
};
exports.default = {
    encode: encode,
    decode: decode,
};
//# sourceMappingURL=bech32.js.map

================================================
FILE: ./malin_modules/bc-bech32/dist/index.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBc32Data = exports.encodeBc32Data = exports.encodeSegwitAddress = exports.decodeSegwitAddress = exports.Bech32Version = void 0;
var bech32_1 = __importDefault(require("./bech32"));
var Bech32Version;
(function (Bech32Version) {
    Bech32Version[Bech32Version["Origin"] = 1] = "Origin";
    Bech32Version[Bech32Version["bis"] = 2] = "bis";
})(Bech32Version = exports.Bech32Version || (exports.Bech32Version = {}));
var convertBits = function (data, fromBits, toBits, pad) {
    var acc = 0;
    var bits = 0;
    var ret = [];
    var maxv = (1 << toBits) - 1;
    for (var p = 0; p < data.length; ++p) {
        var value = data[p];
        if (value < 0 || value >> fromBits !== 0) {
            return null;
        }
        acc = (acc << fromBits) | value;
        bits += fromBits;
        while (bits >= toBits) {
            bits -= toBits;
            ret.push((acc >> bits) & maxv);
        }
    }
    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toBits - bits)) & maxv);
        }
    }
    else if (bits >= fromBits || (acc << (toBits - bits)) & maxv) {
        return null;
    }
    return ret;
};
exports.decodeSegwitAddress = function (hrp, addr) {
    var dec = bech32_1.default.decode(addr);
    if (dec === null || dec.hrp !== hrp || dec.data.length < 1 || dec.data[0] > 16) {
        return null;
    }
    var res = convertBits(Uint8Array.from(dec.data.slice(1)), 5, 8, false);
    if (res === null || res.length < 2 || res.length > 40) {
        return null;
    }
    if (dec.data[0] === 0 && res.length !== 20 && res.length !== 32) {
        return null;
    }
    return { version: dec.data[0], program: res };
};
exports.encodeSegwitAddress = function (hrp, version, program) {
    var ret = bech32_1.default.encode(hrp, [version].concat(convertBits(program, 8, 5, true)), Bech32Version.Origin);
    if (exports.decodeSegwitAddress(hrp, ret) === null) {
        return null;
    }
    return ret;
};
exports.encodeBc32Data = function (hex) {
    var data = Buffer.from(hex, 'hex');
    return bech32_1.default.encode(null, convertBits(data, 8, 5, true), Bech32Version.bis);
};
exports.decodeBc32Data = function (data) {
    var result = bech32_1.default.decode(data);
    if (result) {
        var res = convertBits(Buffer.from(result.data), 5, 8, false);
        return Buffer.from(res).toString('hex');
    }
    else {
        return null;
    }
};
//# sourceMappingURL=index.js.map

================================================
FILE: ./malin_modules/ur/index.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { URDecoder } from '@ngraveio/bc-ur';
import b58 from 'bs58check';
import {
  CryptoHDKey,
  CryptoKeypath,
  CryptoOutput,
  PathComponent,
  ScriptExpressions,
  CryptoPSBT,
  CryptoAccount,
  Bytes,
} from '@keystonehq/bc-ur-registry/dist';
import { decodeUR as origDecodeUr, encodeUR as origEncodeUR, extractSingleWorkload as origExtractSingleWorkload } from '../bc-ur/dist';
import { MultisigCosigner, MultisigHDWallet } from '../../class';
import { Psbt } from 'bitcoinjs-lib';
import AsyncStorage from '@react-native-async-storage/async-storage';

const USE_UR_V1 = 'USE_UR_V1';

let useURv1 = false;

(async () => {
  try {
    useURv1 = !!(await AsyncStorage.getItem(USE_UR_V1));
  } catch (_) {}
})();

async function isURv1Enabled() {
  try {
    return !!(await AsyncStorage.getItem(USE_UR_V1));
  } catch (_) {}

  return false;
}

async function setUseURv1() {
  useURv1 = true;
  return AsyncStorage.setItem(USE_UR_V1, '1');
}

async function clearUseURv1() {
  useURv1 = false;
  return AsyncStorage.removeItem(USE_UR_V1);
}

function encodeUR(arg1, arg2) {
  return useURv1 ? encodeURv1(arg1, arg2) : encodeURv2(arg1, arg2);
}

function encodeURv1(arg1, arg2) {
  // first, lets check that its not a cosigner's json, which we do NOT encode at all:
  try {
    const json = JSON.parse(arg1);
    if (json && json.xpub && json.path && json.xfp) return [arg1];
  } catch (_) {}

  return origEncodeUR(arg1, arg2);
}

/**
 *
 * @param str {string} For PSBT, or coordination setup (translates to `bytes`) it expects hex string. For ms cosigner it expects plain json string
 * @param len {number} length of each fragment
 * @return {string[]} txt fragments ready to be displayed in dynamic QR
 */
function encodeURv2(str, len) {
  // now, lets do some intelligent guessing what we've got here, psbt hex, or json with a multisig cosigner..?

  try {
    const cosigner = new MultisigCosigner(str);

    if (cosigner.isValid()) {
      let scriptExpressions = false;

      if (cosigner.isNativeSegwit()) {
        scriptExpressions = [ScriptExpressions.WITNESS_SCRIPT_HASH];
      } else if (cosigner.isWrappedSegwit()) {
        scriptExpressions = [ScriptExpressions.SCRIPT_HASH, ScriptExpressions.WITNESS_SCRIPT_HASH];
      } else if (cosigner.isLegacy()) {
        scriptExpressions = [ScriptExpressions.SCRIPT_HASH];
      } else {
        return ['unsupported multisig type'];
      }

      const cryptoKeyPathComponents = [];
      for (const component of cosigner.getPath().split('/')) {
        if (component === 'm') continue;
        const index = parseInt(component);
        const hardened = component.endsWith('h') || component.endsWith("'");
        cryptoKeyPathComponents.push(new PathComponent({ index, hardened }));
      }

      const cryptoAccount = new CryptoAccount(Buffer.from(cosigner.getFp(), 'hex'), [
        new CryptoOutput(
          scriptExpressions,
          new CryptoHDKey({
            isMaster: false,
            key: Buffer.from(cosigner.getKeyHex(), 'hex'),
            chainCode: Buffer.from(cosigner.getChainCodeHex(), 'hex'),
            origin: new CryptoKeypath(cryptoKeyPathComponents, Buffer.from(cosigner.getFp(), 'hex'), cosigner.getDepthNumber()),
            parentFingerprint: Buffer.from(cosigner.getParentFingerprintHex(), 'hex'),
          }),
        ),
      ]);
      const ur = cryptoAccount.toUREncoder(2000).nextPart();
      return [ur];
    }
  } catch (_) {}

  // not account. lets try psbt

  try {
    Psbt.fromHex(str); // will throw if not PSBT hex
    const data = Buffer.from(str, 'hex');
    const cryptoPSBT = new CryptoPSBT(data);
    const encoder = cryptoPSBT.toUREncoder(len);

    const ret = [];
    for (let c = 1; c <= encoder.fragmentsLength; c++) {
      const ur = encoder.nextPart();
      ret.push(ur);
    }

    return ret;
  } catch (_) {}

  // fail. fallback to bytes

  const bytes = new Bytes(Buffer.from(str, 'hex'));
  const encoder = bytes.toUREncoder(len);

  const ret = [];
  for (let c = 1; c <= encoder.fragmentsLength; c++) {
    const ur = encoder.nextPart();
    ret.push(ur);
  }

  return ret;
}

function extractSingleWorkload(arg) {
  return origExtractSingleWorkload(arg);
}

function decodeUR(arg) {
  try {
    return origDecodeUr(arg);
  } catch (_) {}

  const decoder = new URDecoder();

  for (const part of arg) {
    decoder.receivePart(part);
  }

  if (!decoder.isComplete()) {
    throw new Error("decodeUR func can't work with multimart BC-UR data. Prease use MalinURDecoder instead.");
  }

  if (!decoder.isSuccess()) {
    throw new Error(decoder.resultError());
  }

  const decoded = decoder.resultUR();

  if (decoded.type === 'crypto-psbt') {
    const cryptoPsbt = CryptoPSBT.fromCBOR(decoded.cbor);
    return cryptoPsbt.getPSBT().toString('hex');
  }

  if (decoded.type === 'bytes') {
    const b = Bytes.fromCBOR(decoded.cbor);
    return b.getData();
  }

  const cryptoAccount = CryptoAccount.fromCBOR(decoded.cbor);

  // now, crafting zpub out of data we have
  const hdKey = cryptoAccount.outputDescriptors[0].getCryptoKey();
  const derivationPath = 'm/' + hdKey.getOrigin().getPath();
  const script = cryptoAccount.outputDescriptors[0].getScriptExpressions()[0].getExpression();
  const isMultisig =
    script === ScriptExpressions.WITNESS_SCRIPT_HASH.getExpression() ||
    // fallback to paths (unreliable).
    // dont know how to add ms p2sh (legacy) or p2sh-p2wsh (wrapped segwit) atm
    derivationPath === MultisigHDWallet.PATH_LEGACY ||
    derivationPath === MultisigHDWallet.PATH_WRAPPED_SEGWIT ||
    derivationPath === MultisigHDWallet.PATH_NATIVE_SEGWIT;
  const version = Buffer.from(isMultisig ? '02aa7ed3' : '04b24746', 'hex');
  const parentFingerprint = hdKey.getParentFingerprint();
  const depth = hdKey.getOrigin().getDepth();
  const depthBuf = Buffer.alloc(1);
  depthBuf.writeUInt8(depth);
  const components = hdKey.getOrigin().getComponents();
  const lastComponents = components[components.length - 1];
  const index = lastComponents.isHardened() ? lastComponents.getIndex() + 0x80000000 : lastComponents.getIndex();
  const indexBuf = Buffer.alloc(4);
  indexBuf.writeUInt32BE(index);
  const chainCode = hdKey.getChainCode();
  const key = hdKey.getKey();
  const data = Buffer.concat([version, depthBuf, parentFingerprint, indexBuf, chainCode, key]);

  const zpub = b58.encode(data);

  const result = {};
  result.ExtPubKey = zpub;
  result.MasterFingerprint = cryptoAccount.getMasterFingerprint().toString('hex').toUpperCase();
  result.AccountKeyPath = derivationPath;

  const str = JSON.stringify(result);
  return Buffer.from(str, 'ascii').toString('hex'); // we are expected to return hex-encoded string
}

class MalinURDecoder extends URDecoder {
  toString() {
    const decoded = this.resultUR();

    if (decoded.type === 'crypto-psbt') {
      const cryptoPsbt = CryptoPSBT.fromCBOR(decoded.cbor);
      return cryptoPsbt.getPSBT().toString('base64');
    }

    if (decoded.type === 'bytes') {
      const bytes = Bytes.fromCBOR(decoded.cbor);
      return Buffer.from(bytes.getData(), 'hex').toString('ascii');
    }

    if (decoded.type === 'crypto-account') {
      const cryptoAccount = CryptoAccount.fromCBOR(decoded.cbor);

      const results = [];
      for (const outputDescriptor of cryptoAccount.outputDescriptors) {
        // now, crafting zpub out of data we have
        const hdKey = outputDescriptor.getCryptoKey();
        const derivationPath = 'm/' + hdKey.getOrigin().getPath();
        const script = cryptoAccount.outputDescriptors[0].getScriptExpressions()[0].getExpression();
        const isMultisig =
          script === ScriptExpressions.WITNESS_SCRIPT_HASH.getExpression() ||
          // fallback to paths (unreliable).
          // dont know how to add ms p2sh (legacy) or p2sh-p2wsh (wrapped segwit) atm
          derivationPath === MultisigHDWallet.PATH_LEGACY ||
          derivationPath === MultisigHDWallet.PATH_WRAPPED_SEGWIT ||
          derivationPath === MultisigHDWallet.PATH_NATIVE_SEGWIT;
        const version = Buffer.from(isMultisig ? '02aa7ed3' : '04b24746', 'hex');
        const parentFingerprint = hdKey.getParentFingerprint();
        const depth = hdKey.getOrigin().getDepth();
        const depthBuf = Buffer.alloc(1);
        depthBuf.writeUInt8(depth);
        const components = hdKey.getOrigin().getComponents();
        const lastComponents = components[components.length - 1];
        const index = lastComponents.isHardened() ? lastComponents.getIndex() + 0x80000000 : lastComponents.getIndex();
        const indexBuf = Buffer.alloc(4);
        indexBuf.writeUInt32BE(index);
        const chainCode = hdKey.getChainCode();
        const key = hdKey.getKey();
        const data = Buffer.concat([version, depthBuf, parentFingerprint, indexBuf, chainCode, key]);

        const zpub = b58.encode(data);

        const result = {};
        result.ExtPubKey = zpub;
        result.MasterFingerprint = cryptoAccount.getMasterFingerprint().toString('hex').toUpperCase();
        result.AccountKeyPath = derivationPath;

        if (derivationPath.startsWith("m/49'/0'/")) {
          // converting to ypub
          let data = b58.decode(result.ExtPubKey);
          data = data.slice(4);
          result.ExtPubKey = b58.encode(Buffer.concat([Buffer.from('049d7cb2', 'hex'), data]));
        }

        if (derivationPath.startsWith("m/44'/0'/")) {
          // converting to xpub
          let data = b58.decode(result.ExtPubKey);
          data = data.slice(4);
          result.ExtPubKey = b58.encode(Buffer.concat([Buffer.from('0488b21e', 'hex'), data]));
        }

        results.push(result);
      }

      return JSON.stringify(results);
    }

    if (decoded.type === 'crypto-output') {
      const output = CryptoOutput.fromCBOR(decoded.cbor);
      return output.toString();
    }

    throw new Error('unsupported data format');
  }
}

export { decodeUR, encodeUR, extractSingleWorkload, MalinURDecoder, isURv1Enabled, setUseURv1, clearUseURv1 };


================================================
FILE: ./malin_modules/bc-ur/dist/encodeUR.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeUR = void 0;
var miniCbor_1 = require("./miniCbor");
var bc_bech32_1 = require("bc-bech32");
var utils_1 = require("./utils");
var composeUR = function (payload, type) {
    if (type === void 0) { type = 'bytes'; }
    return "ur:" + type + "/" + payload;
};
var composeDigest = function (payload, digest) {
    return digest + "/" + payload;
};
var composeSequencing = function (payload, index, total) {
    return index + 1 + "of" + total + "/" + payload;
};
var composeHeadersToFragments = function (fragments, digest, type) {
    if (type === void 0) { type = 'bytes'; }
    if (fragments.length === 1) {
        return [composeUR(fragments[0])];
    }
    else {
        return fragments.map(function (f, index) {
            return utils_1.compose3(function (payload) { return composeUR(payload, type); }, function (payload) { return composeSequencing(payload, index, fragments.length); }, function (payload) { return composeDigest(payload, digest); })(f);
        });
    }
};
exports.encodeUR = function (payload, fragmentCapacity) {
    if (fragmentCapacity === void 0) { fragmentCapacity = 200; }
    var cborPayload = miniCbor_1.encodeSimpleCBOR(payload);
    var bc32Payload = bc_bech32_1.encodeBc32Data(cborPayload);
    var digest = utils_1.sha256Hash(Buffer.from(cborPayload, 'hex')).toString('hex');
    var bc32Digest = bc_bech32_1.encodeBc32Data(digest);
    var fragments = bc32Payload.match(new RegExp('.{1,' + fragmentCapacity + '}', 'g'));
    return composeHeadersToFragments(fragments, bc32Digest, 'bytes');
};
//# sourceMappingURL=encodeUR.js.map

================================================
FILE: ./malin_modules/bc-ur/dist/decodeUR.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSingleWorkload = exports.decodeUR = void 0;
var utils_1 = require("./utils");
var miniCbor_1 = require("./miniCbor");
var bc_bech32_1 = require("bc-bech32");
var checkAndGetSequence = function (sequence) {
    var pieces = sequence.toUpperCase().split('OF');
    if (pieces.length !== 2)
        throw new Error("invalid sequence: " + sequence);
    var index = pieces[0], total = pieces[1];
    return [+index, +total];
};
var checkDigest = function (digest, payload) {
    if (bc_bech32_1.decodeBc32Data(digest) !== utils_1.sha256Hash(Buffer.from(bc_bech32_1.decodeBc32Data(payload), 'hex')).toString('hex')) {
        throw new Error("invalid digest: \n digest:" + digest + " \n payload:" + payload);
    }
};
var checkURHeader = function (UR, type) {
    if (type === void 0) { type = 'bytes'; }
    if (UR.toUpperCase() !== ("ur:" + type).toUpperCase())
        throw new Error("invalid UR header: " + UR);
};
var dealWithSingleWorkload = function (workload, type) {
    if (type === void 0) { type = 'bytes'; }
    var pieces = workload.split('/');
    switch (pieces.length) {
        case 2: {
            //UR:Type/[Fragment]
            checkURHeader(pieces[0], type);
            return pieces[1];
        }
        case 3: {
            //UR:Type/[Digest]/[Fragment] when Sequencing is omitted, Digest MAY be omitted;
            //should check digest
            checkURHeader(pieces[0], type);
            var digest = pieces[1];
            var fragment = pieces[2];
            checkDigest(digest, fragment);
            return fragment;
        }
        case 4: {
            //UR:Type/[Sequencing]/[Digest]/[Fragment]
            //should check sequencing and digest
            checkURHeader(pieces[0], type);
            checkAndGetSequence(pieces[1]);
            var digest = pieces[2];
            var fragment = pieces[3];
            checkDigest(digest, fragment);
            return fragment;
        }
        default:
            throw new Error("invalid workload pieces length: expect 2 / 3 / 4 bug got " + pieces.length);
    }
};
var dealWithMultipleWorkloads = function (workloads, type) {
    if (type === void 0) { type = 'bytes'; }
    var length = workloads.length;
    var fragments = new Array(length).fill('');
    var digest = '';
    workloads.forEach(function (workload) {
        var pieces = workload.split('/');
        checkURHeader(pieces[0], type);
        var _a = checkAndGetSequence(pieces[1]), index = _a[0], total = _a[1];
        if (total !== length)
            throw new Error("invalid workload: " + workload + ", total " + total + " not equal workloads length " + length);
        if (digest && digest !== pieces[2])
            throw new Error("invalid workload: " + workload + ", checksum changed " + digest + ", " + pieces[2]);
        digest = pieces[2];
        if (fragments[index - 1])
            throw new Error("invalid workload: " + workload + ", index " + index + " has already been set");
        fragments[index - 1] = pieces[3];
    });
    var payload = fragments.join('');
    checkDigest(digest, payload);
    return payload;
};
var getBC32Payload = function (workloads, type) {
    if (type === void 0) { type = 'bytes'; }
    try {
        var length_1 = workloads.length;
        if (length_1 === 1) {
            return dealWithSingleWorkload(workloads[0], type);
        }
        else {
            return dealWithMultipleWorkloads(workloads, type);
        }
    }
    catch (e) {
        throw new Error("invalid workloads: " + workloads + "\n " + e);
    }
};
exports.decodeUR = function (workloads, type) {
    if (type === void 0) { type = 'bytes'; }
    var bc32Payload = getBC32Payload(workloads, type);
    var cborPayload = bc_bech32_1.decodeBc32Data(bc32Payload);
    return miniCbor_1.decodeSimpleCBOR(cborPayload);
};
exports.extractSingleWorkload = function (workload) {
    var pieces = workload.toUpperCase().split('/');
    switch (pieces.length) {
        case 2: //UR:Type/[Fragment]
        case 3: {
            //UR:Type/[Digest]/[Fragment] when Sequencing is omitted, Digest MAY be omitted;
            return [1, 1];
        }
        case 4: {
            //UR:Type/[Sequencing]/[Digest]/[Fragment]
            return checkAndGetSequence(pieces[1]);
        }
        default:
            throw new Error("invalid workload pieces length: expect 2 / 3 / 4 bug got " + pieces.length);
    }
};
//# sourceMappingURL=decodeUR.js.map

================================================
FILE: ./malin_modules/bc-ur/dist/miniCbor.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeSimpleCBOR = exports.encodeSimpleCBOR = exports.composeHeader = void 0;
/*
    this an simple cbor implementation which is just using
    on BCR-05
*/
exports.composeHeader = function (length) {
    var header;
    if (length > 0 && length <= 23) {
        header = Buffer.from([0x40 + length]);
    }
    if (length >= 24 && length <= 255) {
        var headerLength = Buffer.alloc(1);
        headerLength.writeUInt8(length);
        header = Buffer.concat([Buffer.from([0x58]), headerLength]);
    }
    if (length >= 256 && length <= 65535) {
        var headerLength = Buffer.alloc(2);
        headerLength.writeUInt16BE(length);
        header = Buffer.concat([Buffer.from([0x59]), headerLength]);
    }
    if (length >= 65536 && length <= Math.pow(2, 32) - 1) {
        var headerLength = Buffer.alloc(4);
        headerLength.writeUInt32BE(length);
        header = Buffer.concat([Buffer.from([0x60]), headerLength]);
    }
    return header;
};
exports.encodeSimpleCBOR = function (data) {
    var bufferData = Buffer.from(data, 'hex');
    if (bufferData.length <= 0 || bufferData.length >= Math.pow(2, 32)) {
        throw new Error('data is too large');
    }
    var header = exports.composeHeader(bufferData.length);
    var endcoded = Buffer.concat([header, bufferData]);
    return endcoded.toString('hex');
};
exports.decodeSimpleCBOR = function (data) {
    var dataBuffer = Buffer.from(data, 'hex');
    if (dataBuffer.length <= 0) {
        throw new Error('input data is not valid');
    }
    var header = dataBuffer[0];
    if (header < 0x58) {
        var dataLength = header - 0x40;
        return dataBuffer.slice(1, 1 + dataLength).toString('hex');
    }
    if (header == 0x58) {
        var dataLength = dataBuffer.slice(1, 2).readUInt8();
        return dataBuffer.slice(2, 2 + dataLength).toString('hex');
    }
    if (header == 0x59) {
        var dataLength = dataBuffer.slice(1, 3).readUInt16BE();
        return dataBuffer.slice(3, 3 + dataLength).toString('hex');
    }
    if (header == 0x60) {
        var dataLength = dataBuffer.slice(1, 5).readUInt32BE();
        return dataBuffer.slice(5, 5 + dataLength).toString('hex');
    }
};
//# sourceMappingURL=miniCbor.js.map

================================================
FILE: ./malin_modules/bc-ur/dist/index.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var encodeUR_1 = require("./encodeUR");
Object.defineProperty(exports, "encodeUR", { enumerable: true, get: function () { return encodeUR_1.encodeUR; } });
var decodeUR_1 = require("./decodeUR");
Object.defineProperty(exports, "decodeUR", { enumerable: true, get: function () { return decodeUR_1.decodeUR; } });
Object.defineProperty(exports, "extractSingleWorkload", { enumerable: true, get: function () { return decodeUR_1.extractSingleWorkload; } });
//# sourceMappingURL=index.js.map

================================================
FILE: ./malin_modules/bc-ur/dist/utils.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
"use strict";
import { sha256 as _sha256 } from '@noble/hashes/sha256';
Object.defineProperty(exports, "__esModule", { value: true });
exports.compose3 = exports.sha256Hash = void 0;
var bitcoinjs_lib_1 = require("bitcoinjs-lib");
const {uint8ArrayToHex} = require("../../uint8array-extras");
exports.sha256Hash = function (data) {
    return bitcoinjs_crypto_sha256(data);
};

function bitcoinjs_crypto_sha256(buffer/*: Buffer*/)/*: Buffer*/ {
    return Buffer.from(_sha256(Uint8Array.from(buffer)));
}


exports.compose3 = function (f, g, h) { return function (x) {
    return f(g(h(x)));
}; };
//# sourceMappingURL=utils.js.map

================================================
FILE: ./malin_modules/clipboard.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import Clipboard from '@react-native-clipboard/clipboard';

const STORAGE_KEY: string = 'ClipboardReadAllowed';

export const isReadClipboardAllowed = async (): Promise<boolean> => {
  try {
    const clipboardAccessAllowed = await AsyncStorage.getItem(STORAGE_KEY);
    if (clipboardAccessAllowed === null) {
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(true));
      return true;
    }
    return !!JSON.parse(clipboardAccessAllowed);
  } catch {
    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(true));
    return true;
  }
};

export const setReadClipboardAllowed = async (value: boolean): Promise<void> => {
  try {
    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(Boolean(value)));
  } catch (error) {
    console.error('Failed to set clipboard permission:', error);
    throw error;
  }
};

export const getClipboardContent = async (): Promise<string | undefined> => {
  try {
    const isAllowed = await isReadClipboardAllowed();
    if (!isAllowed) return undefined;

    const hasString = await Clipboard.hasString();
    return hasString ? await Clipboard.getString() : undefined;
  } catch (error) {
    console.error('Error accessing clipboard:', error);
    return undefined;
  }
};


================================================
FILE: ./malin_modules/fs.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Platform } from 'react-native';
import {
  pick,
  types,
  keepLocalCopy,
  errorCodes
} from '@react-native-documents/picker';
import RNFS from 'react-native-fs';
import {
  launchImageLibrary,
  ImagePickerResponse
} from 'react-native-image-picker';
import RNQRGenerator from 'rn-qr-generator';
import Share from 'react-native-share';

import presentAlert from '../components/Alert';
import loc from '../loc';
import { isDesktop } from './environment';
import { readFile } from './react-native-bw-file-access';
import {
  base64ToUint8Array,
  uint8ArrayToString
} from './uint8array-extras/index';

const _sanitizeFileName = (fileName: string) => {
  // Remove any path delimiters and non-alphanumeric characters except for -, _, and .
  return fileName.replace(/[^a-zA-Z0-9\-_.]/g, '');
};

export const isCancel = (err: any): boolean => {
  return err.code && err.code === errorCodes.OPERATION_CANCELED;
}

const _shareOpen = async (
  filePath: string,
  showShareDialog: boolean = false
) => {
  try {
    await Share.open({
      url: 'file://' + filePath,
      saveToFiles: isDesktop || !showShareDialog,
      // @ts-ignore: Website claims this propertie exists, but TS cant find it. Send anyways.
      useInternalStorage: Platform.OS === 'android',
      failOnCancel: false,
    })
  } catch (error: any) {
    console.log(error);
    // If user cancels sharing, we dont want to show an error. for some reason we get 'CANCELLED' string as error
    if (error.message !== 'CANCELLED') {
      presentAlert({ message: error.message });
    }
  } finally {
    await RNFS.unlink(filePath);
  }
};

/**
 * Writes a file to fs, and triggers an OS sharing dialog, so user can decide where to put this file (share to cloud
 * or perhaps messaging app). Provided filename should be just a file name, NOT a path
 */

export const writeFileAndExport = async function (
  fileName: string,
  contents: string,
  showShareDialog: boolean = true
) {
  const sanitizedFileName = _sanitizeFileName(fileName);
  try {
    if (Platform.OS === 'ios') {
      const filePath = `${RNFS.TemporaryDirectoryPath}/${sanitizedFileName}`;
      await RNFS.writeFile(filePath, contents);
      await _shareOpen(filePath, showShareDialog);
    } else if (Platform.OS === 'android') {
      const filePath = `${RNFS.DownloadDirectoryPath}/${sanitizedFileName}`;
      try {
        await RNFS.writeFile(filePath, contents);
        if (showShareDialog) {
          await _shareOpen(filePath);
        } else {
          presentAlert({
            message: loc.formatString(loc.send.file_saved_at_path, {
              filePath
            }),
          })
        }
      } catch (e: any) {
        console.error(e);
        presentAlert({ message: e.message });
      }
    }
  } catch (error: any) {
    console.error(error);
    presentAlert({ message: error.message });
  }
};

/**
 * Opens & reads *.psbt files, and returns base64 psbt. FALSE if something went wrong (wont throw).
 */
export const openSignedTransaction = async function (): Promise<
  string | false
  > {
  try {
    const [res] = await pick({
      type:
        Platform.OS === 'ios'
          ? ['com.malinwallet.psbt', 'com.malinwallet.psbt.txn', types.json]
          : [types.allFiles],
    })

    return await _readPsbtFileIntoBase64(res.uri);
  } catch (err) {
    if (!isCancel(err)) {
      presentAlert({ message: loc.send.details_no_signed_tx });
    }
  }

  return false;
}

const _readPsbtFileIntoBase64 = async function (uri: string): Promise<string> {
  const base64 = await RNFS.readFile(uri, 'base64');
  const stringData = uint8ArrayToString(base64ToUint8Array(base64)); // decode from base64
  if (stringData.startsWith('psbt')) {
    // file was binary, but outer code expects base64 psbt, so we return base64 we got from rn-fs;
    // most likely produced by Electrum-desktop
    return base64;
  } else {
    // file was a text file, having base64 psbt in there. so we basically have double base64encoded string
    // thats why we are returning string that was decoded once;
    // most likely produced by ColdCard
    return stringData;
  }
};

export const showImagePickerAndReadImage = async (): Promise<
  string | undefined
> => {
  try {
    const response: ImagePickerResponse = await launchImageLibrary({
      mediaType: 'photo',
      maxHeight: 800,
      maxWidth: 600,
      selectionLimit: 1,
    })

    if (response.didCancel) {
      return undefined;
    } else if (response.errorCode) {
      throw new Error(response.errorMessage);
    } else if (response.assets) {
      try {
        const uri = response.assets[0].uri;
        if (uri) {
          const result = await RNQRGenerator.detect({
            uri: decodeURI(uri.toString())
          });
          if (result?.values.length > 0) {
            return result?.values[0];
          }
        }
        throw new Error(loc.send.qr_error_no_qrcode);
      } catch (error) {
        console.error(error);
        presentAlert({ message: loc.send.qr_error_no_qrcode });
      }
    }

    return undefined;
  } catch (error: any) {
    console.error(error);
    throw error;
  }
};

export const showFilePickerAndReadFile = async function (): Promise<{
  data: string | false;
  uri: string | false;
}> {
  try {
    const [pickedFile] = await pick({
      type:
        Platform.OS === 'ios'
          ? [
              'io.malinwallet.psbt',
              'io.malinwallet.psbt.txn',
              'io.malinwallet.backup',
              types.plainText,
              types.json,
              types.images
            ]
          : [types.allFiles],
    })

    const [localCopy] = await keepLocalCopy({
      files: [
        {
          uri: pickedFile.uri,
          fileName: pickedFile.name ?? 'unnamed',
        },
      ],
      destination: 'cachesDirectory',
    });

    if (localCopy.status !== 'success') {
      // to make ts happy, should not need this check here
      presentAlert({
        message: 'Picking and caching a file failed: ' + localCopy.copyError
      });
      return { data: false, uri: false };
    }

    const fileCopyUri = decodeURI(localCopy.localUri);

    if (localCopy.localUri.toLowerCase().endsWith('.psbt')) {
      // this is either binary file from ElectrumDesktop OR string file with base64 string in there
      const file = await _readPsbtFileIntoBase64(fileCopyUri);
      return { data: file, uri: fileCopyUri };
    }

    if (
      localCopy.localUri.endsWith('.png') ||
      localCopy.localUri.endsWith('.jpg') ||
      localCopy.localUri.endsWith('.jpeg')
    ) {
      return await handleImageFile(fileCopyUri);
    }

    const file = await RNFS.readFile(fileCopyUri);
    return { data: file, uri: fileCopyUri };
  } catch (err: any) {
    if (!isCancel(err)) {
      presentAlert({ message: err.message });
    }
    return { data: false, uri: false };
  }
};

const handleImageFile = async (
  fileCopyUri: string
): Promise<{ data: string | false; uri: string | false }> => {
  try {
    const exists = await RNFS.exists(fileCopyUri);
    if (!exists) {
      presentAlert({ message: 'File does not exist' });
      return { data: false, uri: false };
    }
    // First attempt: use original URI
    let result = await RNQRGenerator.detect({ uri: decodeURI(fileCopyUri) });
    if (result?.values && result.values.length > 0) {
      return { data: result.values[0], uri: fileCopyUri };
    }
    // Second attempt: remove file:// prefix and try again
    const altUri = fileCopyUri.replace(/^file:\/\//, '');
    result = await RNQRGenerator.detect({ uri: decodeURI(altUri) });
    if (result?.values && result.values.length > 0) {
      return { data: result.values[0], uri: fileCopyUri };
    }
    presentAlert({ message: loc.send.qr_error_no_qrcode });
    return { data: false, uri: false };
  } catch (error: any) {
    console.error(error);
    presentAlert({ message: loc.send.qr_error_no_qrcode });
    return { data: false, uri: false };
  }
};

export const readFileOutsideSandbox = (filePath: string) => {
  if (Platform.OS === 'ios') {
    return readFile(filePath);
  } else if (Platform.OS === 'android') {
    return RNFS.readFile(filePath);
  } else {
    presentAlert({ message: 'Not implemented for this platform' });
    throw new Error('Not implemented for this platform');
  }
};

export const openSignedTransactionRaw: () => Promise<string> = async () => {
  try {
    const [res] = await pick({
      type:
        Platform.OS === 'ios'
          ? ['io.malinwallet.psbt', 'io.malinwallet.psbt.txn', types.json]
          : [types.allFiles],
    })
    const file = await RNFS.readFile(res.uri);
    if (file) {
      return file;
    } else {
      throw new Error('Could not read file');
    }
  } catch (err) {
    if (!isCancel(err)) {
      presentAlert({ message: loc.send.details_no_signed_tx });
    }

    return '';
  }
};

export const pickTransaction = async () => {
  const [res] = await pick({
    type:
      Platform.OS === 'ios'
        ? [
            'io.malinwallet.psbt',
            'io.malinwallet.psbt.txn',
            types.plainText,
            types.json
          ]
        : [types.allFiles],
  })

  return res;
}


================================================
FILE: ./malin_modules/start-and-decrypt.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Platform } from 'react-native';

import { MalinApp as MalinAppClass } from '../class/';
import prompt from '../helpers/prompt';
import { showKeychainWipeAlert } from '../hooks/useBiometrics';
import loc from '../loc';

const MalinApp = MalinAppClass.getInstance();
// If attempt reaches 10, a wipe keychain option will be provided to the user.
let unlockAttempt = 0;

type PasswordPromptCallback = () => Promise<string | undefined>;

export const startAndDecrypt = async (retry?: boolean, passwordPrompt?: PasswordPromptCallback): Promise<boolean> => {
  // If wallets are already loaded, no need to migrate, decrypt, or load from disk.
  if (MalinApp.getWallets().length > 0) {
    return true;
  }
  await MalinApp.migrateKeys();
  let password: undefined | string;
  if (await MalinApp.storageIsEncrypted()) {
    if (passwordPrompt) {
      password = await passwordPrompt();
    } else {
      do {
        password = await prompt((retry && loc._.bad_password) || loc._.enter_password, loc._.storage_is_encrypted, false);
      } while (!password);
    }
  }
  let success = false;
  let wasException = false;
  try {
    success = await MalinApp.loadFromDisk(password);
  } catch (error) {
    // in case of exception reading from keystore, lets retry instead of assuming there is no storage and
    // proceeding with no wallets
    console.warn('exception loading from disk:', error);
    wasException = true;
  }

  if (wasException) {
    // retrying, but only once
    try {
      await new Promise(resolve => setTimeout(resolve, 3000)); // sleep
      success = await MalinApp.loadFromDisk(password);
    } catch (error) {
      console.warn('second exception loading from disk:', error);
    }
  }

  if (success) {
    console.log('loaded from disk');
    return true;
  }

  if (password) {
    // we had password and yet could not load/decrypt
    unlockAttempt++;
    if (unlockAttempt < 10 || Platform.OS !== 'ios') {
      // Return false to indicate wrong password, let UI show error and retry
      return false;
    } else {
      unlockAttempt = 0;
      showKeychainWipeAlert();
      // We want to return false to let the UnlockWith screen that it is NOT ok to proceed.
      return false;
    }
  } else {
    unlockAttempt = 0;
    // Return true because there was no wallet data in keychain. Proceed.
    return true;
  }
};

export default MalinApp;


================================================
FILE: ./malin_modules/bip39.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bip39 from 'bip39';

const WORDLISTS: string[][] = [
  bip39.wordlists.english,
  bip39.wordlists.french,
  bip39.wordlists.spanish,
  bip39.wordlists.italian,
  bip39.wordlists.japanese,
  bip39.wordlists.korean,
  bip39.wordlists.chinese_simplified,
  bip39.wordlists.chinese_traditional,
  bip39.wordlists.czech,
  bip39.wordlists.portuguese,
];

export function validateMnemonic(mnemonic: string) {
  for (const wordlist of WORDLISTS) {
    const valid = bip39.validateMnemonic(mnemonic, wordlist);
    if (valid) return true;
  }
  return false;
}


================================================
FILE: ./malin_modules/environment.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { getDeviceType, isTablet as checkIsTablet } from 'react-native-device-info';

const isTablet: boolean = checkIsTablet();
const isDesktop: boolean = getDeviceType() === 'Desktop';
const isHandset: boolean = getDeviceType() === 'Handset';

export { isDesktop, isHandset, isTablet };


================================================
FILE: ./malin_modules/analytics.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import Bugsnag from '@bugsnag/react-native';
import { getUniqueId } from 'react-native-device-info';

import { MalinApp as MalinAppClass } from '../class';

const MalinApp = MalinAppClass.getInstance();

/**
 * in case Bugsnag was started, but user decided to opt out while using the app, we have this
 * flag `userHasOptedOut` and we forbid logging in `onError` handler
 * @type {boolean}
 */
let userHasOptedOut: boolean = false;

(async () => {
  // Don't try to start Bugsnag again as it's already initialized in native code
  // Just configure the existing instance if tracking is allowed
  const uniqueID = await getUniqueId();
  const doNotTrack = await MalinApp.isDoNotTrackEnabled();

  if (doNotTrack) {
    userHasOptedOut = true;
    return;
  }

  // Configure the existing Bugsnag instance instead of starting a new one
  Bugsnag.setUser(uniqueID);

  // Add additional configuration if needed
  Bugsnag.addOnError(function (event) {
    return !userHasOptedOut;
  });
})();

const A = async (event: string) => {};

A.setOptOut = (value: boolean) => {
  if (value) userHasOptedOut = true;
};

A.logError = (errorString: string) => {
  console.error(errorString);
  Bugsnag.notify(new Error(String(errorString)));
};

export default A;


================================================
FILE: ./malin_modules/sizeClass.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Dimensions, Platform, AppState, AppStateStatus } from 'react-native';
import { useState, useEffect } from 'react';
import { isDesktop } from './environment';

// Size class definitions following iOS conventions
export enum SizeClass {
  Compact, // Small size (iPhone width or height in landscape)
  Regular, // Standard size (iPad, or iPhone height in portrait)
  Large, // Additional size for larger screens (not in iOS, but useful for our app)
}

// Interface for the result of getSizeClass
export interface SizeClassInfo {
  // Size classes
  horizontalSizeClass: SizeClass;
  verticalSizeClass: SizeClass;

  // Overall size class (derived from horizontal and vertical)
  sizeClass: SizeClass;

  // Orientation
  orientation: 'portrait' | 'landscape';

  // Helper properties
  isCompact: boolean;
  isLarge: boolean;

  // Legacy support
  isLargeScreen: boolean;
}

/**
 * Get current size class information based on device dimensions
 */
export function getSizeClass(): SizeClassInfo {
  // Get device dimensions
  const { width, height } = Dimensions.get('window');
  const isLandscape = width > height;
  const orientation = isLandscape ? 'landscape' : 'portrait';

  // Determine horizontal size class (following iOS conventions)
  let horizontalSizeClass: SizeClass;

  if (Platform.OS === 'ios' && Platform.isPad) {
    // iPads always have Regular width
    horizontalSizeClass = SizeClass.Regular;
  } else if (isDesktop) {
    // Desktop systems get Large width
    horizontalSizeClass = SizeClass.Large;
  } else if (isLandscape && width >= 667) {
    // iPhone Plus models (and modern equivalent sizes) in landscape: Regular width
    // 667 points corresponds roughly to iPhone Plus models
    horizontalSizeClass = SizeClass.Regular;
  } else {
    // Regular iPhones: Compact width
    horizontalSizeClass = SizeClass.Compact;
  }

  // Determine vertical size class (following iOS conventions)
  let verticalSizeClass: SizeClass;

  if (Platform.OS === 'ios' && Platform.isPad) {
    // iPads always have Regular height
    verticalSizeClass = SizeClass.Regular;
  } else if (isDesktop) {
    // Desktop systems get Large height
    verticalSizeClass = SizeClass.Large;
  } else if (isLandscape) {
    // All iPhones in landscape: Compact height
    verticalSizeClass = SizeClass.Compact;
  } else {
    // iPhones in portrait: Regular height
    verticalSizeClass = SizeClass.Regular;
  }

  // Derive overall size class - simplified logic to avoid redundant comparisons
  let sizeClass: SizeClass;

  if (horizontalSizeClass === SizeClass.Compact) {
    // If width is compact, overall is compact
    sizeClass = SizeClass.Compact;
  } else {
    // Otherwise, width is Regular or Large, so overall is Large
    // (per requirements that any non-Compact width device is considered Large)
    sizeClass = SizeClass.Large;
  }

  // Determine isLargeScreen property (true for Regular and Large widths)
  const isLargeScreen = horizontalSizeClass !== SizeClass.Compact;

  return {
    horizontalSizeClass,
    verticalSizeClass,
    sizeClass,
    orientation,
    isCompact: sizeClass === SizeClass.Compact,
    isLarge: sizeClass === SizeClass.Large,
    isLargeScreen,
  };
}

/**
 * React hook to use size classes in components
 */
export function useSizeClass(): SizeClassInfo {
  const [sizeClassInfo, setSizeClassInfo] = useState<SizeClassInfo>(getSizeClass());

  useEffect(() => {
    // Update size class when dimensions change
    const updateSizeClass = () => {
      const newInfo = getSizeClass();
      setSizeClassInfo(newInfo);
      console.debug(
        `[SizeClass] Updated:`,
        `horizontal=${SizeClass[newInfo.horizontalSizeClass]}`,
        `vertical=${SizeClass[newInfo.verticalSizeClass]}`,
        `orientation=${newInfo.orientation}`,
        `isLargeScreen=${newInfo.isLargeScreen}`,
      );
    };

    const dimensionSubscription = Dimensions.addEventListener('change', updateSizeClass);

    // Also update when app becomes active
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      if (nextAppState === 'active') {
        updateSizeClass();
      }
    };

    const appStateSubscription = AppState.addEventListener('change', handleAppStateChange);

    // Clean up
    return () => {
      dimensionSubscription.remove();
      appStateSubscription.remove();
    };
  }, []);

  return sizeClassInfo;
}


================================================
FILE: ./malin_modules/uint8array-extras/index.d.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;

/**
Check if the given value is an instance of `Uint8Array`.

Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).

@example
```
import {isUint8Array} from 'uint8array-extras';

console.log(isUint8Array(new Uint8Array()));
//=> true

console.log(isUint8Array(Buffer.from('x')));
//=> true

console.log(isUint8Array(new ArrayBuffer(10)));
//=> false
```
*/
export function isUint8Array(value: unknown): value is Uint8Array;

/**
Throw a `TypeError` if the given value is not an instance of `Uint8Array`.

@example
```
import {assertUint8Array} from 'uint8array-extras';

try {
	assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError
} catch (error) {
	console.error(error.message);
}
```
*/
export function assertUint8Array(value: unknown): asserts value is Uint8Array;

/**
Convert a value to a `Uint8Array` without copying its data.

This can be useful for converting a `Buffer` to a pure `Uint8Array`. `Buffer` is already an `Uint8Array` subclass, but [`Buffer` alters some behavior](https://sindresorhus.com/blog/goodbye-nodejs-buffer), so it can be useful to cast it to a pure `Uint8Array` before returning it.

Tip: If you want a copy, just call `.slice()` on the return value.
*/
export function toUint8Array(value: TypedArray | ArrayBuffer | DataView): Uint8Array;

/**
Concatenate the given arrays into a new array.

If `arrays` is empty, it will return a zero-sized `Uint8Array`.

If `totalLength` is not specified, it is calculated from summing the lengths of the given arrays.

Replacement for [`Buffer.concat()`](https://nodejs.org/api/buffer.html#static-method-bufferconcatlist-totallength).

@example
```
import {concatUint8Arrays} from 'uint8array-extras';

const a = new Uint8Array([1, 2, 3]);
const b = new Uint8Array([4, 5, 6]);

console.log(concatUint8Arrays([a, b]));
//=> Uint8Array [1, 2, 3, 4, 5, 6]
```
*/
export function concatUint8Arrays(arrays: Uint8Array[], totalLength?: number): Uint8Array;

/**
Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.

Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).

@example
```
import {areUint8ArraysEqual} from 'uint8array-extras';

const a = new Uint8Array([1, 2, 3]);
const b = new Uint8Array([1, 2, 3]);
const c = new Uint8Array([4, 5, 6]);

console.log(areUint8ArraysEqual(a, b));
//=> true

console.log(areUint8ArraysEqual(a, c));
//=> false
```
*/
export function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array): boolean;

/**
Compare two arrays and indicate their relative order or equality. Useful for sorting.

Replacement for [`Buffer.compare()`](https://nodejs.org/api/buffer.html#static-method-buffercomparebuf1-buf2).

@example
```
import {compareUint8Arrays} from 'uint8array-extras';

const array1 = new Uint8Array([1, 2, 3]);
const array2 = new Uint8Array([4, 5, 6]);
const array3 = new Uint8Array([7, 8, 9]);

[array3, array1, array2].sort(compareUint8Arrays);
//=> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```
*/
export function compareUint8Arrays(a: Uint8Array, b: Uint8Array): 0 | 1 | -1;

/**
Convert a `Uint8Array` to a string.

@param encoding - The [encoding](https://developer.mozilla.org/en-US/docs/Web/API/Encoding_API/Encodings) to convert from. Default: `'utf8'`

Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end). For the `encoding` parameter, `latin1` should be used instead of `binary` and `utf-16le` instead of `utf16le`.

@example
```
import {uint8ArrayToString} from 'uint8array-extras';

const byteArray = new Uint8Array([72, 101, 108, 108, 111]);
console.log(uint8ArrayToString(byteArray));
//=> 'Hello'

const zh = new Uint8Array([167, 65, 166, 110]);
console.log(uint8ArrayToString(zh, 'big5'));
//=> ''

const ja = new Uint8Array([130, 177, 130, 241, 130, 201, 130, 191, 130, 205]);
console.log(uint8ArrayToString(ja, 'shift-jis'));
//=> ''
```
*/
// export function uint8ArrayToString(array: Uint8Array | ArrayBuffer, encoding?: string): string;

/**
Convert a string to a `Uint8Array` (using UTF-8 encoding).

Replacement for [`Buffer.from('Hello')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).

@example
```
import {stringToUint8Array} from 'uint8array-extras';

console.log(stringToUint8Array('Hello'));
//=> Uint8Array [72, 101, 108, 108, 111]
```
*/
export function stringToUint8Array(string: string): Uint8Array;

/**
Convert a `Uint8Array` to a Base64-encoded string.

Specify `{urlSafe: true}` to get a [Base64URL](https://base64.guru/standards/base64url)-encoded string.

Replacement for [`Buffer#toString('base64')`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).

@example
```
import {uint8ArrayToBase64} from 'uint8array-extras';

const byteArray = new Uint8Array([72, 101, 108, 108, 111]);

console.log(uint8ArrayToBase64(byteArray));
//=> 'SGVsbG8='
```
*/
export function uint8ArrayToBase64(array: Uint8Array, options?: { urlSafe: boolean }): string;

/**
Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.

Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).

@example
```
import {base64ToUint8Array} from 'uint8array-extras';

console.log(base64ToUint8Array('SGVsbG8='));
//=> Uint8Array [72, 101, 108, 108, 111]
```
*/
export function base64ToUint8Array(string: string): Uint8Array;

/**
Encode a string to Base64-encoded string.

Specify `{urlSafe: true}` to get a [Base64URL](https://base64.guru/standards/base64url)-encoded string.

Replacement for `Buffer.from('Hello').toString('base64')` and [`btoa()`](https://developer.mozilla.org/en-US/docs/Web/API/btoa).

@example
```
import {stringToBase64} from 'uint8array-extras';

console.log(stringToBase64('Hello'));
//=> 'SGVsbG8='
```
*/
export function stringToBase64(string: string, options?: { urlSafe: boolean }): string;

/**
Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.

Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).

@example
```
import {base64ToString} from 'uint8array-extras';

console.log(base64ToString('SGVsbG8='));
//=> 'Hello'
```
*/
export function base64ToString(base64String: string): string;

/**
Convert a `Uint8Array` to a Hex string.

Replacement for [`Buffer#toString('hex')`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).

@example
```
import {uint8ArrayToHex} from 'uint8array-extras';

const byteArray = new Uint8Array([72, 101, 108, 108, 111]);

console.log(uint8ArrayToHex(byteArray));
//=> '48656c6c6f'
```
*/
export function uint8ArrayToHex(array: Uint8Array): string;

/**
Convert a Hex string to a `Uint8Array`.

Replacement for [`Buffer.from('48656c6c6f', 'hex')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).

@example
```
import {hexToUint8Array} from 'uint8array-extras';

console.log(hexToUint8Array('48656c6c6f'));
//=> Uint8Array [72, 101, 108, 108, 111]
```
*/
export function hexToUint8Array(hexString: string): Uint8Array;

/**
Read `DataView#byteLength` number of bytes from the given view, up to 48-bit.

Replacement for [`Buffer#readUintBE`](https://nodejs.org/api/buffer.html#bufreadintbeoffset-bytelength)

@example
```
import {getUintBE} from 'uint8array-extras';

const byteArray = new Uint8Array([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(getUintBE(new DataView(byteArray.buffer)));
//=> 20015998341291
```
*/
export function getUintBE(view: DataView): number; // eslint-disable-line @typescript-eslint/naming-convention

/**
Find the index of the first occurrence of the given sequence of bytes (`value`) within the given `Uint8Array` (`array`).

Replacement for [`Buffer#indexOf`](https://nodejs.org/api/buffer.html#bufindexofvalue-byteoffset-encoding). `Uint8Array#indexOf` only takes a number which is different from Buffer's `indexOf` implementation.

@example
```
import {indexOf} from 'uint8array-extras';

const byteArray = new Uint8Array([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef]);

console.log(indexOf(byteArray, new Uint8Array([0x78, 0x90])));
//=> 3
```
*/
export function indexOf(array: Uint8Array, value: Uint8Array): number;

/**
Checks if the given sequence of bytes (`value`) is within the given `Uint8Array` (`array`).

Returns true if the value is included, otherwise false.

Replacement for [`Buffer#includes`](https://nodejs.org/api/buffer.html#bufincludesvalue-byteoffset-encoding). `Uint8Array#includes` only takes a number which is different from Buffer's `includes` implementation.

```
import {includes} from 'uint8array-extras';

const byteArray = new Uint8Array([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef]);

console.log(includes(byteArray, new Uint8Array([0x78, 0x90])));
//=> true
```
*/
export function includes(array: Uint8Array, value: Uint8Array): boolean;

/**
 * Convert a Uint8Array (or ArrayBuffer) of UTF-8 bytes into a JS string.
 * Only "utf8" is supported. For any other encoding youll need a polyfill.
 *
 * @param {Uint8Array|ArrayBuffer} input
 * @param {string} [encoding="utf8"]
 * @returns {string}
 */
export function uint8ArrayToString(array: Uint8Array, encoding?: string): string;

================================================
FILE: ./malin_modules/uint8array-extras/index.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * author: Sindre Sorhus
 * license: MIT
 * source: https://github.com/sindresorhus/uint8array-extras
 */
const objectToString = Object.prototype.toString;
const uint8ArrayStringified = '[object Uint8Array]';
const arrayBufferStringified = '[object ArrayBuffer]';

function isType(value, typeConstructor, typeStringified) {
  if (!value) {
    return false;
  }

  if (value.constructor === typeConstructor) {
    return true;
  }

  return objectToString.call(value) === typeStringified;
}

export function isUint8Array(value) {
  return isType(value, Uint8Array, uint8ArrayStringified);
}

function isArrayBuffer(value) {
  return isType(value, ArrayBuffer, arrayBufferStringified);
}

function isUint8ArrayOrArrayBuffer(value) {
  return isUint8Array(value) || isArrayBuffer(value);
}

export function assertUint8Array(value) {
  if (!isUint8Array(value)) {
    throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
  }
}

export function assertUint8ArrayOrArrayBuffer(value) {
  if (!isUint8ArrayOrArrayBuffer(value)) {
    throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value}\``);
  }
}

export function toUint8Array(value) {
  if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  }

  if (ArrayBuffer.isView(value)) {
    return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
  }

  throw new TypeError(`Unsupported value, got \`${typeof value}\`.`);
}

export function concatUint8Arrays(arrays, totalLength) {
  if (arrays.length === 0) {
    return new Uint8Array(0);
  }

  totalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);

  const returnValue = new Uint8Array(totalLength);

  let offset = 0;
  for (const array of arrays) {
    assertUint8Array(array);
    returnValue.set(array, offset);
    offset += array.length;
  }

  return returnValue;
}

export function areUint8ArraysEqual(a, b) {
  assertUint8Array(a);
  assertUint8Array(b);

  if (a === b) {
    return true;
  }

  if (a.length !== b.length) {
    return false;
  }

  // eslint-disable-next-line unicorn/no-for-loop
  for (let index = 0; index < a.length; index++) {
    if (a[index] !== b[index]) {
      return false;
    }
  }

  return true;
}

export function compareUint8Arrays(a, b) {
  assertUint8Array(a);
  assertUint8Array(b);

  const length = Math.min(a.length, b.length);

  for (let index = 0; index < length; index++) {
    const diff = a[index] - b[index];
    if (diff !== 0) {
      return Math.sign(diff);
    }
  }

  // At this point, all the compared elements are equal.
  // The shorter array should come first if the arrays are of different lengths.
  return Math.sign(a.length - b.length);
}

// const cachedDecoders = {
//   utf8: new globalThis.TextDecoder("utf8"),
// };

//
// !!!!!!! commented out because we dont have `TextDecoder` as dep anymore !!!!!!!!
//
// export function uint8ArrayToString(array, encoding = "utf8") {
//   assertUint8ArrayOrArrayBuffer(array);
//   cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
//   return cachedDecoders[encoding].decode(array);
// }
  
function assertString(value) {
  if (typeof value !== 'string') {
    throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
  }
}

const cachedEncoder = new globalThis.TextEncoder();

export function stringToUint8Array(string) {
  assertString(string);
  return cachedEncoder.encode(string);
}

function base64ToBase64Url(base64) {
  return base64.replaceAll('+', '-').replaceAll('/', '_').replace(/[=]+$/, '');
}

function base64UrlToBase64(base64url) {
  return base64url.replaceAll('-', '+').replaceAll('_', '/');
}

// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/
const MAX_BLOCK_SIZE = 65_535;

export function uint8ArrayToBase64(array, { urlSafe = false } = {}) {
  assertUint8Array(array);

  let base64;

  if (array.length < MAX_BLOCK_SIZE) {
    // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
    base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));
  } else {
    base64 = '';
    for (const value of array) {
      base64 += String.fromCodePoint(value);
    }

    base64 = globalThis.btoa(base64);
  }

  return urlSafe ? base64ToBase64Url(base64) : base64;
}

export function base64ToUint8Array(base64String) {
  assertString(base64String);
  return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), x => x.codePointAt(0));
}

export function stringToBase64(string, { urlSafe = false } = {}) {
  assertString(string);
  return uint8ArrayToBase64(stringToUint8Array(string), { urlSafe });
}

// export function base64ToString(base64String) {
//   assertString(base64String);
//   return uint8ArrayToString(base64ToUint8Array(base64String));
// }

const byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, '0'));

export function uint8ArrayToHex(array) {
  assertUint8Array(array);

  // Concatenating a string is faster than using an array.
  let hexString = '';

  // eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.
  for (let index = 0; index < array.length; index++) {
    hexString += byteToHexLookupTable[array[index]];
  }

  return hexString;
}

const hexToDecimalLookupTable = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
};

export function hexToUint8Array(hexString) {
  assertString(hexString);

  if (hexString.length % 2 !== 0) {
    throw new Error('Invalid Hex string length.');
  }

  const resultLength = hexString.length / 2;
  const bytes = new Uint8Array(resultLength);

  for (let index = 0; index < resultLength; index++) {
    const highNibble = hexToDecimalLookupTable[hexString[index * 2]];
    const lowNibble = hexToDecimalLookupTable[hexString[index * 2 + 1]];

    if (highNibble === undefined || lowNibble === undefined) {
      throw new Error(`Invalid Hex character encountered at position ${index * 2}`);
    }

    bytes[index] = (highNibble << 4) | lowNibble; // eslint-disable-line no-bitwise
  }

  return bytes;
}

/**
@param {DataView} view
@returns {number}
*/
export function getUintBE(view) {
  const { byteLength } = view;

  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }

  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }

  if (byteLength === 4) {
    return view.getUint32(0);
  }

  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }

  if (byteLength === 2) {
    return view.getUint16(0);
  }

  if (byteLength === 1) {
    return view.getUint8(0);
  }
}

/**
@param {Uint8Array} array
@param {Uint8Array} value
@returns {number}
*/
export function indexOf(array, value) {
  const arrayLength = array.length;
  const valueLength = value.length;

  if (valueLength === 0) {
    return -1;
  }

  if (valueLength > arrayLength) {
    return -1;
  }

  const validOffsetLength = arrayLength - valueLength;

  for (let index = 0; index <= validOffsetLength; index++) {
    let isMatch = true;
    for (let index2 = 0; index2 < valueLength; index2++) {
      if (array[index + index2] !== value[index2]) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      return index;
    }
  }

  return -1;
}

/**
@param {Uint8Array} array
@param {Uint8Array} value
@returns {boolean}
*/
export function includes(array, value) {
  return indexOf(array, value) !== -1;
}

// we can use this implementation when we will have TextDecoder in RN
// const cachedDecoders = {
//   utf8: new globalThis.TextDecoder("utf8"),
// };
// export function uint8ArrayToString(array, encoding = "utf8") {
//   assertUint8ArrayOrArrayBuffer(array);
//   cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
//   return cachedDecoders[encoding].decode(array);
// }
// meanwhile:

/**
 * Convert a Uint8Array (or ArrayBuffer) of UTF-8 bytes into a JS string.
 * Only "utf8" is supported. For any other encoding youll need a polyfill.
 *
 * @param {Uint8Array|ArrayBuffer} input
 * @param {string} [encoding="utf8"]
 * @returns {string}
 */
export function uint8ArrayToString(input, encoding = 'utf8') {
  assertUint8ArrayOrArrayBuffer(input);

  // Reject anything other than UTF-8
  if (!/utf-?8/i.test(encoding)) {
    throw new Error('Encoding "' + encoding + '" isnt supported without a TextDecoder polyfill');
  }

  // Normalise to Uint8Array
  const bytes = input instanceof Uint8Array ? input : new Uint8Array(input);
  return decodeUtf8(bytes);
}

/**
 * Minimal UTF-8 decoder
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function decodeUtf8(bytes) {
  let i = 0;
  const l = bytes.length;
  const codeUnits = [];
  let result = '';

  while (i < l) {
    const byte1 = bytes[i++];

    // 1-byte (ASCII)
    if (byte1 < 0x80) {
      codeUnits.push(byte1);
    }
    // 2-byte
    else if (byte1 < 0xe0) {
      const byte2 = bytes[i++] & 0x3f;
      codeUnits.push(((byte1 & 0x1f) << 6) | byte2);
    }
    // 3-byte
    else if (byte1 < 0xf0) {
      const byte2 = bytes[i++] & 0x3f;
      const byte3 = bytes[i++] & 0x3f;
      codeUnits.push(((byte1 & 0x0f) << 12) | (byte2 << 6) | byte3);
    }
    // 4-byte ( surrogate pair)
    else {
      const byte2 = bytes[i++] & 0x3f;
      const byte3 = bytes[i++] & 0x3f;
      const byte4 = bytes[i++] & 0x3f;
      let cp = ((byte1 & 0x07) << 18) | (byte2 << 12) | (byte3 << 6) | byte4;
      cp -= 0x10000;
      codeUnits.push(0xd800 + (cp >> 10), 0xdc00 + (cp & 0x3ff));
    }

    // Flush periodically to avoid huge apply() calls
    if (codeUnits.length > 0x8000) {
      result += String.fromCharCode.apply(null, codeUnits);
      codeUnits.length = 0;
    }
  }

  return result + String.fromCharCode.apply(null, codeUnits);
}


================================================
FILE: ./malin_modules/MalinElectrum.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BigNumber from "bignumber.js";
import * as bitcoin from "bitcoinjs-lib";
import DefaultPreference from "react-native-default-preference";
import RNFS from "react-native-fs";
import Realm from "realm";
import { sha256 as _sha256 } from "@noble/hashes/sha256";

import {
  LegacyWallet,
  SegwitBech32Wallet,
  SegwitP2SHWallet,
  TaprootWallet,
} from "../class";
import presentAlert from "../components/Alert";
import loc from "../loc";
import { GROUP_IO_MALINWALLET } from "./currency";
import { ElectrumServerItem } from "../screen/settings/ElectrumSettings";
import { triggerWarningHapticFeedback } from "./hapticFeedback";
import { AlertButton } from "react-native";
import {
  uint8ArrayToHex,
  stringToUint8Array,
  hexToUint8Array,
} from "./uint8array-extras/index";

const ElectrumClient = require("electrum-client");
const net = require("net");
const tls = require("tls");

type Utxo = {
  height: number;
  value: number;
  address: string;
  txid: string;
  vout: number;
  wif?: string;
};

type ElectrumTransaction = {
  txid: string;
  hash: string;
  version: number;
  size: number;
  vsize: number;
  weight: number;
  locktime: number;
  vin: {
    txid: string;
    vout: number;
    scriptSig: { asm: string; hex: string };
    txinwitness: string[];
    sequence: number;
    addresses?: string[];
    value?: number;
  }[];
  vout: {
    value: number;
    n: number;
    scriptPubKey: {
      asm: string;
      hex: string;
      reqSigs: number;
      type: string;
      addresses: string[];
    };
  }[];
  blockhash: string;
  confirmations: number;
  time: number;
  blocktime: number;
};

type ElectrumTransactionWithHex = ElectrumTransaction & {
  hex: string;
};

type MempoolTransaction = {
  height: 0;
  tx_hash: string;
  fee: number;
};

type Peer = {
  host: string;
  ssl?: number;
  tcp?: number;
};

export const ELECTRUM_HOST = "electrum_host";
export const ELECTRUM_TCP_PORT = "electrum_tcp_port";
export const ELECTRUM_SSL_PORT = "electrum_ssl_port";
export const ELECTRUM_SERVER_HISTORY = "electrum_server_history";
const ELECTRUM_CONNECTION_DISABLED = "electrum_disabled";
const storageKey = "ELECTRUM_PEERS";
const defaultPeer = { host: "electrum1.malinwallet.io", ssl: 443 }
export const hardcodedPeers: Peer[] = [
  { host: "mainnet.foundationdevices.com", ssl: 50002 },
  { host: "bitcoin.lu.ke", ssl: 50002 },
  // { host: 'electrum.jochen-hoenicke.de', ssl: '50006' },
  { host: "electrum1.malinwallet.io", ssl: 443 },
  { host: "electrum.acinq.co", ssl: 50002 },
  { host: "electrum.bitaroo.net", ssl: 50002 }
]

export const suggestedServers: Peer[] = hardcodedPeers.map((peer) => ({
  ...peer
}))

let mainClient: typeof ElectrumClient | undefined
let mainConnected: boolean = false
let wasConnectedAtLeastOnce: boolean = false
let serverName: string | false = false
let disableBatching: boolean = false
let connectionAttempt: number = 0
let currentPeerIndex = Math.floor(Math.random() * hardcodedPeers.length)
let latestBlock:
  | { height: number; time: number }
  | { height: undefined; time: undefined } = {
  height: undefined,
  time: undefined,
  };
const txhashHeightCache: Record<string, number> = {}
let _realm: Realm | undefined

function bitcoinjs_crypto_sha256 (buffer: Uint8Array): Uint8Array {
  return _sha256(buffer)
}

async function _getRealm () {
  if (_realm) return _realm

  const cacheFolderPath = RNFS.CachesDirectoryPath // Path to cache folder
  const password = uint8ArrayToHex(
    bitcoinjs_crypto_sha256(stringToUint8Array("fyegjitkyf[eqjnc.lf")),
  )
  const buf = hexToUint8Array(password + password)
  const encryptionKey = Int8Array.from(buf)
  const path = `${cacheFolderPath}/electrumcache.realm` // Use cache folder path

  const schema = [
    {
      name: "Cache",
      primaryKey: "cache_key",
      properties: {
        cache_key: { type: "string", indexed: true },
        cache_value: "string", // stringified json
      }
    }
  ];

  // @ts-ignore schema doesn't match Realm's schema type
  _realm = await Realm.open({
    schema,
    path,
    encryptionKey,
    excludeFromIcloudBackup: true
  });

  return _realm
}

export const getPreferredServer = async (): Promise<
  ElectrumServerItem | undefined
> => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET)
    const host = (await DefaultPreference.get(ELECTRUM_HOST)) as string
    const tcpPort = await DefaultPreference.get(ELECTRUM_TCP_PORT)
    const sslPort = await DefaultPreference.get(ELECTRUM_SSL_PORT)

    console.log("Getting preferred server:", { host, tcpPort, sslPort })

    if (!host) {
      console.warn("Preferred server host is undefined");
      return
    }

    return {
      host,
      tcp: tcpPort ? Number(tcpPort) : undefined,
      ssl: sslPort ? Number(sslPort) : undefined
    }
  } catch (error) {
    console.error("Error in getPreferredServer:", error)
    return undefined
  }
}

export const removePreferredServer = async () => {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET)
    console.log("Removing preferred server");
    await DefaultPreference.clear(ELECTRUM_HOST)
    await DefaultPreference.clear(ELECTRUM_TCP_PORT)
    await DefaultPreference.clear(ELECTRUM_SSL_PORT)
  } catch (error) {
    console.error("Error in removePreferredServer:", error)
  }
}

export async function isDisabled (): Promise<boolean> {
  let result
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET)
    const savedValue = await DefaultPreference.get(
      ELECTRUM_CONNECTION_DISABLED,
    )
    console.log("Getting Electrum connection disabled state:", savedValue)
    if (savedValue === null) {
      result = false
    } else {
      result = savedValue
    }
  } catch (error) {
    console.error("Error getting Electrum connection disabled state:", error)
    result = false
  }
  return !!result
}

export async function setDisabled (disabled = true) {
  await DefaultPreference.setName(GROUP_IO_MALINWALLET)
  console.log("Setting Electrum connection disabled state to:", disabled)
  return DefaultPreference.set(
    ELECTRUM_CONNECTION_DISABLED,
    disabled ? "1" : "",
  );
}

function getCurrentPeer () {
  return hardcodedPeers[currentPeerIndex]
}

/**
 * Returns NEXT hardcoded electrum server (increments index after use)
 */
function getNextPeer () {
  const peer = getCurrentPeer()
  currentPeerIndex++;
  if (currentPeerIndex + 1 >= hardcodedPeers.length) currentPeerIndex = 0
  return peer
}

async function getSavedPeer (): Promise<Peer | null> {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET)
    const host = (await DefaultPreference.get(ELECTRUM_HOST)) as string
    const tcpPort = await DefaultPreference.get(ELECTRUM_TCP_PORT)
    const sslPort = await DefaultPreference.get(ELECTRUM_SSL_PORT)

    console.log("Getting saved peer:", { host, tcpPort, sslPort })

    if (!host) {
      return null
    }

    if (sslPort) {
      return { host, ssl: Number(sslPort) }
    }

    if (tcpPort) {
      return { host, tcp: Number(tcpPort) }
    }

    return null
  } catch (error) {
    console.error("Error in getSavedPeer:", error)
    return null
  }
}

export async function connectMain (): Promise<void> {
  if (await isDisabled()) {
    console.log(
      "Electrum connection disabled by user. Skipping connectMain call",
    );
    return;
  }
  let usingPeer = getNextPeer()
  const savedPeer = await getSavedPeer()
  if (savedPeer && savedPeer.host && (savedPeer.tcp || savedPeer.ssl)) {
    usingPeer = savedPeer
  }

  console.log("Using peer:", JSON.stringify(usingPeer))

  try {
    console.log("begin connection:", JSON.stringify(usingPeer))
    mainClient = new ElectrumClient(
      net,
      tls,
      usingPeer.ssl || usingPeer.tcp,
      usingPeer.host,
      usingPeer.ssl ? "tls" : "tcp",
    );

    mainClient.onError = function (e: { message: string }) {
      console.log("electrum mainClient.onError():", e.message)
      if (mainConnected) {
        // most likely got a timeout from electrum ping. lets reconnect
        // but only if we were previously connected (mainConnected), otherwise theres other
        // code which does connection retries
        mainClient?.close()
        mainClient = undefined
        mainConnected = false
        // dropping `mainConnected` flag ensures there wont be reconnection race condition if several
        // errors triggered
        console.log("reconnecting after socket error");
        setTimeout(connectMain, usingPeer.host.endsWith(".onion") ? 4000 : 500)
      }
    }
    const ver = await mainClient.initElectrum({
      client: "malinwallet",
      version: "1.4",
    })
    if (ver && ver[0]) {
      console.log("connected to ", ver)
      serverName = ver[0]
      mainConnected = true
      wasConnectedAtLeastOnce = true
      if (
        ver[0].startsWith("ElectrumPersonalServer") ||
        ver[0].startsWith("electrs") ||
        ver[0].startsWith("Fulcrum")
      ) {
        disableBatching = true

        // exeptions for versions:
        const [electrumImplementation, electrumVersion] = ver[0].split(" ");
        switch (electrumImplementation) {
          case "electrs":
            if (semVerToInt(electrumVersion) >= semVerToInt("0.9.0")) {
              disableBatching = false
            }
            break
          case "electrs-esplora":
            // its a different one, and it does NOT support batching
            // nop
            break
          case "Fulcrum":
            if (semVerToInt(electrumVersion) >= semVerToInt("1.9.0")) {
              disableBatching = false
            }
            break
        }
      }
      const header = await mainClient.blockchainHeaders_subscribe()
      if (header && header.height) {
        latestBlock = {
          height: header.height,
          time: Math.floor(+new Date() / 1000)
        }
      }
      // AsyncStorage.setItem(storageKey, JSON.stringify(peers));  TODO: refactor
    }
  } catch (e) {
    mainConnected = false
    console.log("bad connection:", JSON.stringify(usingPeer), e)
    mainClient?.close()
    mainClient = undefined
  }

  if (!mainConnected) {
    console.log("retry");
    connectionAttempt = connectionAttempt + 1
    mainClient?.close()
    mainClient = undefined
    if (connectionAttempt >= 5) {
      presentNetworkErrorAlert(usingPeer)
    } else {
      console.log("reconnection attempt #", connectionAttempt)
      await new Promise((resolve) => setTimeout(resolve, 500)) // sleep
      return connectMain()
    }
  }
}

export async function presentResetToDefaultsAlert (): Promise<boolean> {
  const hasPreferredServer = await getPreferredServer()
  const serverHistoryStr = await DefaultPreference.get(ELECTRUM_SERVER_HISTORY)
  const serverHistory =
    typeof serverHistoryStr === "string" ? JSON.parse(serverHistoryStr) : []
  return new Promise((resolve) => {
    triggerWarningHapticFeedback()

    const buttons: AlertButton[] = []

    if (
      hasPreferredServer?.host &&
      (hasPreferredServer.tcp || hasPreferredServer.ssl)
    ) {
      buttons.push({
        text: loc.settings.electrum_reset,
        onPress: async () => {
          try {
            await DefaultPreference.setName(GROUP_IO_MALINWALLET)
            await DefaultPreference.clear(ELECTRUM_HOST)
            await DefaultPreference.clear(ELECTRUM_SSL_PORT)
            await DefaultPreference.clear(ELECTRUM_TCP_PORT)
          } catch (e) {
            console.log(e) // Must be running on Android
          }
          resolve(true)
        },
        style: "default",
      })
    }

    if (serverHistory.length > 0) {
      buttons.push({
        text: loc.settings.electrum_reset_to_default_and_clear_history,
        onPress: async () => {
          try {
            await DefaultPreference.setName(GROUP_IO_MALINWALLET)
            await DefaultPreference.clear(ELECTRUM_SERVER_HISTORY)
            await DefaultPreference.clear(ELECTRUM_HOST)
            await DefaultPreference.clear(ELECTRUM_SSL_PORT)
            await DefaultPreference.clear(ELECTRUM_TCP_PORT)
          } catch (e) {
            console.log(e) // Must be running on Android
          }
          resolve(true)
        },
        style: "destructive",
      })
    }

    buttons.push({
      text: loc._.cancel,
      onPress: () => resolve(false),
      style: "cancel",
    })

    presentAlert({
      title: loc.settings.electrum_reset,
      message: loc.settings.electrum_reset_to_default,
      buttons,
      options: { cancelable: true }
    });
  })
}

const presentNetworkErrorAlert = async (usingPeer?: Peer) => {
  if (await isDisabled()) {
    console.log(
      "Electrum connection disabled by user. Perhaps we are attempting to show this network error alert after the user disabled connections.",
    )
    return
  }

  presentAlert({
    allowRepeat: false,
    title: loc.errors.network,
    message: loc.formatString(
      usingPeer
        ? loc.settings.electrum_unable_to_connect
        : loc.settings.electrum_error_connect,
      usingPeer
        ? { server: `${usingPeer.host}:${usingPeer.ssl ?? usingPeer.tcp}` }
        : {}
    ),
    buttons: [
      {
        text: loc.wallets.list_tryagain,
        onPress: () => {
          connectionAttempt = 0
          mainClient?.close()
          mainClient = undefined
          setTimeout(connectMain, 500)
        },
        style: "default",
      },
      {
        text: loc.settings.electrum_reset,
        onPress: () => {
          presentResetToDefaultsAlert().then((result) => {
            if (result) {
              connectionAttempt = 0
              mainClient?.close()
              mainClient = undefined
              setTimeout(connectMain, 500)
            }
          })
        },
        style: "destructive",
      },
      {
        text: loc._.cancel,
        onPress: () => {
          connectionAttempt = 0
          mainClient?.close()
          mainClient = undefined
        },
        style: "cancel",
      }
    ],
    options: { cancelable: false }
  });
};

/**
 * Returns random electrum server out of list of servers
 * previous electrum server told us. Nearly half of them is
 * usually offline.
 * Not used for now.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function getRandomDynamicPeer (): Promise<Peer> {
  try {
    let peers = JSON.parse((await DefaultPreference.get(storageKey)) as string)
    peers = peers.sort(() => Math.random() - 0.5) // shuffle
    for (const peer of peers) {
      const ret: Peer = { host: peer[0], ssl: peer[1] }
      ret.host = peer[1]

      if (peer[1] === "s") {
        ret.ssl = peer[2]
      } else {
        ret.tcp = peer[2]
      }

      for (const item of peer[2]) {
        if (item.startsWith("t")) {
          ret.tcp = item.replace("t", "");
        }
      }
      if (ret.host && ret.tcp) return ret
    }

    return defaultPeer // failed to find random client, using default
  } catch (_) {
    return defaultPeer // smth went wrong, using default
  }
}

export const getBalanceByAddress = async function (
  address: string,
): Promise<{ confirmed: number; unconfirmed: number }> {
  try {
    if (!mainClient) throw new Error("Electrum client is not connected");
    const script = bitcoin.address.toOutputScript(address)
    const hash = bitcoinjs_crypto_sha256(script)
    const reversedHash = new Uint8Array(hash).reverse()
    const balance = await mainClient.blockchainScripthash_getBalance(
      uint8ArrayToHex(reversedHash),
    )
    balance.addr = address
    return balance
  } catch (error) {
    console.error("Error in getBalanceByAddress:", error)
    throw error
  }
}

export const getConfig = async function () {
  if (!mainClient) throw new Error("Electrum client is not connected");
  return {
    host: mainClient.host,
    port: mainClient.port,
    serverName,
    connected: mainClient.timeLastCall !== 0 && mainClient.status
  }
};

export const getSecondsSinceLastRequest = function () {
  return mainClient && mainClient.timeLastCall
    ? (+new Date() - mainClient.timeLastCall) / 1000
    : -1
}

export const getTransactionsByAddress = async function (
  address: string,
): Promise<ElectrumHistory[]> {
  if (!mainClient) throw new Error("Electrum client is not connected");
  const script = bitcoin.address.toOutputScript(address)
  const hash = bitcoinjs_crypto_sha256(script)
  const reversedHash = new Uint8Array(hash).reverse()
  const history = await mainClient.blockchainScripthash_getHistory(
    uint8ArrayToHex(reversedHash),
  )
  for (const h of history || []) {
    if (h.tx_hash) txhashHeightCache[h.tx_hash] = h.height // cache tx height
  }

  return history
}

export const getMempoolTransactionsByAddress = async function (
  address: string,
): Promise<MempoolTransaction[]> {
  if (!mainClient) throw new Error("Electrum client is not connected");
  const script = bitcoin.address.toOutputScript(address)
  const hash = bitcoinjs_crypto_sha256(script)
  const reversedHash = new Uint8Array(hash).reverse()
  return mainClient.blockchainScripthash_getMempool(
    uint8ArrayToHex(reversedHash),
  )
};

export const ping = async function () {
  try {
    await mainClient.server_ping()
    return true
  } catch (_) {}

  mainConnected = false
  return false
}

// exported only to be used in unit tests
export function txhexToElectrumTransaction (
  txhex: string,
): ElectrumTransactionWithHex {
  const tx = bitcoin.Transaction.fromHex(txhex)

  const ret: ElectrumTransactionWithHex = {
    txid: tx.getId(),
    hash: tx.getId(),
    version: tx.version,
    size: Math.ceil(txhex.length / 2),
    vsize: tx.virtualSize(),
    weight: tx.weight(),
    locktime: tx.locktime,
    vin: [],
    vout: [],
    hex: txhex,
    blockhash: "",
    confirmations: 0,
    time: 0,
    blocktime: 0
  }

  if (txhashHeightCache[ret.txid]) {
    // got blockheight where this tx was confirmed
    ret.confirmations =
      estimateCurrentBlockheight() - txhashHeightCache[ret.txid]
    if (ret.confirmations < 0) {
      // ugly fix for when estimator lags behind
      ret.confirmations = 1
    }
    ret.time = calculateBlockTime(txhashHeightCache[ret.txid])
    ret.blocktime = calculateBlockTime(txhashHeightCache[ret.txid])
  }

  for (const inn of tx.ins) {
    const txinwitness = []
    if (inn.witness[0]) txinwitness.push(uint8ArrayToHex(inn.witness[0]))
    if (inn.witness[1]) txinwitness.push(uint8ArrayToHex(inn.witness[1]))

    ret.vin.push({
      txid: uint8ArrayToHex(new Uint8Array(inn.hash).reverse()),
      vout: inn.index,
      scriptSig: { hex: uint8ArrayToHex(inn.script), asm: "" },
      txinwitness,
      sequence: inn.sequence
    });
  }

  let n = 0
  for (const out of tx.outs) {
    const value = new BigNumber(out.value).dividedBy(100000000).toNumber()
    let address: false | string = false
    let type: false | string = false

    if (SegwitBech32Wallet.scriptPubKeyToAddress(uint8ArrayToHex(out.script))) {
      address = SegwitBech32Wallet.scriptPubKeyToAddress(
        uint8ArrayToHex(out.script),
      )
      type = "witness_v0_keyhash";
    } else if (
      SegwitP2SHWallet.scriptPubKeyToAddress(uint8ArrayToHex(out.script))
    ) {
      address = SegwitP2SHWallet.scriptPubKeyToAddress(
        uint8ArrayToHex(out.script),
      )
      type = "???"; // TODO
    } else if (
      LegacyWallet.scriptPubKeyToAddress(uint8ArrayToHex(out.script))
    ) {
      address = LegacyWallet.scriptPubKeyToAddress(uint8ArrayToHex(out.script))
      type = "???"; // TODO
    } else {
      address = TaprootWallet.scriptPubKeyToAddress(
        uint8ArrayToHex(out.script),
      )
      type = "witness_v1_taproot";
    }

    if (!address) {
      throw new Error(
        "Internal error: unable to decode address from output script",
      );
    }

    ret.vout.push({
      value,
      n,
      scriptPubKey: {
        asm: "",
        hex: uint8ArrayToHex(out.script),
        reqSigs: 1, // todo
        type,
        addresses: [address]
      }
    })
    n++;
  }
  return ret
}

export const getTransactionsFullByAddress = async (
  address: string,
): Promise<ElectrumTransaction[]> => {
  const txs = await getTransactionsByAddress(address)
  const ret: ElectrumTransaction[] = []
  for (const tx of txs) {
    let full
    try {
      full = await mainClient.blockchainTransaction_get(tx.tx_hash, true)
    } catch (error: any) {
      if (
        String(error?.message ?? error).startsWith(
          "verbose transactions are currently unsupported",
        )
      ) {
        // apparently, stupid esplora instead of returning txhex when it cant return verbose tx started
        // throwing a proper exception. lets fetch txhex manually and decode on our end
        const txhex = await mainClient.blockchainTransaction_get(
          tx.tx_hash,
          false,
        )
        full = txhexToElectrumTransaction(txhex)
      } else {
        // nope, its something else
        throw new Error(String(error?.message ?? error))
      }
    }
    full.address = address
    for (const input of full.vin) {
      // now we need to fetch previous TX where this VIN became an output, so we can see its amount
      let prevTxForVin
      try {
        prevTxForVin = await mainClient.blockchainTransaction_get(
          input.txid,
          true,
        )
      } catch (error: any) {
        if (
          String(error?.message ?? error).startsWith(
            "verbose transactions are currently unsupported",
          )
        ) {
          // apparently, stupid esplora instead of returning txhex when it cant return verbose tx started
          // throwing a proper exception. lets fetch txhex manually and decode on our end
          const txhex = await mainClient.blockchainTransaction_get(
            input.txid,
            false,
          )
          prevTxForVin = txhexToElectrumTransaction(txhex)
        } else {
          // nope, its something else
          throw new Error(String(error?.message ?? error))
        }
      }
      if (prevTxForVin && prevTxForVin.vout && prevTxForVin.vout[input.vout]) {
        input.value = prevTxForVin.vout[input.vout].value
        // also, we extract destination address from prev output:
        if (
          prevTxForVin.vout[input.vout].scriptPubKey &&
          prevTxForVin.vout[input.vout].scriptPubKey.addresses
        ) {
          input.addresses =
            prevTxForVin.vout[input.vout].scriptPubKey.addresses
        }
        // in bitcoin core 22.0.0+ they removed `.addresses` and replaced it with plain `.address`:
        if (prevTxForVin.vout[input.vout]?.scriptPubKey?.address) {
          input.addresses = [
            prevTxForVin.vout[input.vout].scriptPubKey.address,
          ]
        }
      }
    }

    for (const output of full.vout) {
      if (output?.scriptPubKey && output.scriptPubKey.addresses) {
        output.addresses = output.scriptPubKey.addresses
      }
      // in bitcoin core 22.0.0+ they removed `.addresses` and replaced it with plain `.address`:
      if (output?.scriptPubKey?.address) {
        output.addresses = [output.scriptPubKey.address]
      }
    }
    full.inputs = full.vin
    full.outputs = full.vout
    delete full.vin
    delete full.vout
    delete full.hex // compact
    delete full.hash // compact
    ret.push(full)
  }

  return ret
}

type MultiGetBalanceResponse = {
  balance: number;
  unconfirmed_balance: number;
  addresses: Record<string, { confirmed: number; unconfirmed: number }>;
};

export const multiGetBalanceByAddress = async (
  addresses: string[],
  batchsize: number = 200,
): Promise<MultiGetBalanceResponse> => {
  if (!mainClient) throw new Error("Electrum client is not connected");
  const ret = {
    balance: 0,
    unconfirmed_balance: 0,
    addresses: {} as Record<string, { confirmed: number; unconfirmed: number }>
  }

  const chunks = splitIntoChunks(addresses, batchsize)
  for (const chunk of chunks) {
    const scripthashes = []
    const scripthash2addr: Record<string, string> = {}
    for (const addr of chunk) {
      const script = bitcoin.address.toOutputScript(addr)
      const hash = bitcoinjs_crypto_sha256(script)
      const reversedHash = uint8ArrayToHex(new Uint8Array(hash).reverse())
      scripthashes.push(reversedHash)
      scripthash2addr[reversedHash] = addr
    }

    let balances = []

    if (disableBatching) {
      const promises = []
      const index2scripthash: Record<number, string> = {}
      for (
        let promiseIndex = 0;
        promiseIndex < scripthashes.length;
        promiseIndex++
      ) {
        promises.push(
          mainClient.blockchainScripthash_getBalance(
            scripthashes[promiseIndex],
          )
        )
        index2scripthash[promiseIndex] = scripthashes[promiseIndex]
      }
      const promiseResults = await Promise.all(promises)
      for (
        let resultIndex = 0;
        resultIndex < promiseResults.length;
        resultIndex++
      ) {
        balances.push({
          result: promiseResults[resultIndex],
          param: index2scripthash[resultIndex],
        })
      }
    } else {
      balances =
        await mainClient.blockchainScripthash_getBalanceBatch(scripthashes)
    }

    for (const bal of balances) {
      if (bal.error) console.warn("multiGetBalanceByAddress():", bal.error)
      ret.balance += +bal.result.confirmed
      ret.unconfirmed_balance += +bal.result.unconfirmed
      ret.addresses[scripthash2addr[bal.param]] = bal.result
    }
  }

  return ret
}

export const multiGetUtxoByAddress = async function (
  addresses: string[],
  batchsize: number = 100,
): Promise<Record<string, Utxo[]>> {
  if (!mainClient) throw new Error("Electrum client is not connected");
  const ret: Record<string, any> = {}

  const chunks = splitIntoChunks(addresses, batchsize)
  for (const chunk of chunks) {
    const scripthashes = []
    const scripthash2addr: Record<string, string> = {}
    for (const addr of chunk) {
      const script = bitcoin.address.toOutputScript(addr)
      const hash = bitcoinjs_crypto_sha256(script)
      const reversedHash = uint8ArrayToHex(new Uint8Array(hash).reverse())
      scripthashes.push(reversedHash)
      scripthash2addr[reversedHash] = addr
    }

    let results = []

    if (disableBatching) {
      // ElectrumPersonalServer doesnt support `blockchain.scripthash.listunspent`
      // electrs OTOH supports it, but we dont know it we are currently connected to it or to EPS
      // so it is pretty safe to do nothing, as caller can derive UTXO from stored transactions
    } else {
      results =
        await mainClient.blockchainScripthash_listunspentBatch(scripthashes)
    }

    for (const utxos of results) {
      ret[scripthash2addr[utxos.param]] = utxos.result
      for (const utxo of ret[scripthash2addr[utxos.param]]) {
        utxo.address = scripthash2addr[utxos.param]
        utxo.txid = utxo.tx_hash
        utxo.vout = utxo.tx_pos
        delete utxo.tx_pos
        delete utxo.tx_hash
      }
    }
  }

  return ret
}

export type ElectrumHistory = {
  tx_hash: string;
  height: number;
  address: string;
};

export const multiGetHistoryByAddress = async function (
  addresses: string[],
  batchsize: number = 100
): Promise<Record<string, ElectrumHistory[]>> {
  if (!mainClient) throw new Error("Electrum client is not connected");
  const ret: Record<string, ElectrumHistory[]> = {}

  const chunks = splitIntoChunks(addresses, batchsize)
  for (const chunk of chunks) {
    const scripthashes = []
    const scripthash2addr: Record<string, string> = {}
    for (const addr of chunk) {
      const script = bitcoin.address.toOutputScript(addr)
      const hash = bitcoinjs_crypto_sha256(script)
      const reversedHash = uint8ArrayToHex(new Uint8Array(hash).reverse())
      scripthashes.push(reversedHash)
      scripthash2addr[reversedHash] = addr
    }

    let results = []

    if (disableBatching) {
      const promises = []
      const index2scripthash: Record<number, string> = {}
      for (
        let promiseIndex = 0;
        promiseIndex < scripthashes.length;
        promiseIndex++
      ) {
        index2scripthash[promiseIndex] = scripthashes[promiseIndex]
        promises.push(
          mainClient.blockchainScripthash_getHistory(
            scripthashes[promiseIndex],
          )
        )
      }
      const histories = await Promise.all(promises)
      for (
        let historyIndex = 0;
        historyIndex < histories.length;
        historyIndex++
      ) {
        results.push({
          result: histories[historyIndex],
          param: index2scripthash[historyIndex],
        })
      }
    } else {
      results =
        await mainClient.blockchainScripthash_getHistoryBatch(scripthashes)
    }

    for (const history of results) {
      if (history.error) {
        console.warn('multiGetHistoryByAddress():', history.error)
      }
      ret[scripthash2addr[history.param]] = history.result || []
      for (const result of history.result || []) {
        if (result.tx_hash) txhashHeightCache[result.tx_hash] = result.height // cache tx height
      }

      for (const hist of ret[scripthash2addr[history.param]]) {
        hist.address = scripthash2addr[history.param]
      }
    }
  }

  return ret
}

// if verbose === true ? Record<string, ElectrumTransaction> : Record<string, string>
type MultiGetTransactionByTxidResult<T extends boolean> = T extends true
  ? Record<string, ElectrumTransaction>
  : Record<string, string>;

// TODO: this function returns different results based on the value of `verboseParam`, consider splitting it into two
export async function multiGetTransactionByTxid<T extends boolean> (
  txids: string[],
  verbose: T,
  batchsize: number = 45
): Promise<MultiGetTransactionByTxidResult<T>> {
  txids = txids.filter((txid) => !!txid) // failsafe: removing 'undefined' or other falsy stuff from txids array
  // this value is fine-tuned so althrough wallets in test suite will occasionally
  // throw 'response too large (over 1,000,000 bytes', test suite will pass
  if (!mainClient) throw new Error("Electrum client is not connected");
  const ret: MultiGetTransactionByTxidResult<T> = {}
  txids = [...new Set(txids)] // deduplicate just for any case

  // lets try cache first:
  const realm = await _getRealm()
  const cacheKeySuffix = verbose ? "_verbose" : "_non_verbose";
  const keysCacheMiss = []
  for (const txid of txids) {
    const jsonString = realm.objectForPrimaryKey(
      "Cache",
      txid + cacheKeySuffix,
    ) // search for a realm object with a primary key
    if (jsonString && jsonString.cache_value) {
      try {
        ret[txid] = JSON.parse(jsonString.cache_value as string)
      } catch (error) {
        console.log(error, "cache failed to parse", jsonString.cache_value)
      }
    }

    if (!ret[txid]) keysCacheMiss.push(txid)
  }

  if (keysCacheMiss.length === 0) {
    return ret
  }

  txids = keysCacheMiss
  // end cache

  const chunks = splitIntoChunks(txids, batchsize)
  for (const chunk of chunks) {
    let results = []

    if (disableBatching) {
      try {
        // in case of ElectrumPersonalServer it might not track some transactions (like source transactions for our transactions)
        // so we wrap it in try-catch. note, when `Promise.all` fails we will get _zero_ results, but we have a fallback for that
        const promises = []
        const index2txid: Record<number, string> = {}
        for (
          let promiseIndex = 0;
          promiseIndex < chunk.length;
          promiseIndex++
        ) {
          const txid = chunk[promiseIndex]
          index2txid[promiseIndex] = txid
          promises.push(mainClient.blockchainTransaction_get(txid, verbose))
        }

        const transactionResults = await Promise.all(promises)
        for (
          let resultIndex = 0;
          resultIndex < transactionResults.length;
          resultIndex++
        ) {
          let tx = transactionResults[resultIndex]
          if (typeof tx === "string" && verbose) {
            // apparently electrum server (EPS?) didnt recognize VERBOSE parameter, and  sent us plain txhex instead of decoded tx.
            // lets decode it manually on our end then:
            tx = txhexToElectrumTransaction(tx)
          }
          const txid = index2txid[resultIndex]
          results.push({ result: tx, param: txid })
        }
      } catch (error: any) {
        if (
          String(error?.message ?? error).startsWith(
            "verbose transactions are currently unsupported",
          )
        ) {
          // electrs-esplora. cant use verbose, so fetching txs one by one and decoding locally
          for (const txid of chunk) {
            try {
              let tx = await mainClient.blockchainTransaction_get(txid, false)
              tx = txhexToElectrumTransaction(tx)
              results.push({ result: tx, param: txid })
            } catch (err) {
              console.log(err)
            }
          }
        } else {
          // fallback. pretty sure we are connected to EPS.  we try getting transactions one-by-one. this way we wont
          // fail and only non-tracked by EPS transactions will be omitted
          for (const txid of chunk) {
            try {
              let tx = await mainClient.blockchainTransaction_get(
                txid,
                verbose,
              )
              if (typeof tx === "string" && verbose) {
                // apparently electrum server (EPS?) didnt recognize VERBOSE parameter, and  sent us plain txhex instead of decoded tx.
                // lets decode it manually on our end then:
                tx = txhexToElectrumTransaction(tx)
              }
              results.push({ result: tx, param: txid })
            } catch (err) {
              console.log(err)
            }
          }
        }
      }
    } else {
      results = await mainClient.blockchainTransaction_getBatch(chunk, verbose)
    }

    for (const txdata of results) {
      if (txdata.error && txdata.error.code === -32600) {
        // response too large
        // lets do single call, that should go through okay:
        txdata.result = await mainClient.blockchainTransaction_get(
          txdata.param,
          false,
        )
        // since we used VERBOSE=false, server sent us plain txhex which we must decode on our end:
        txdata.result = txhexToElectrumTransaction(txdata.result)
      }
      ret[txdata.param] = txdata.result
      // @ts-ignore: hex property
      if (ret[txdata.param]) delete ret[txdata.param].hex // compact
    }
  }

  // in bitcoin core 22.0.0+ they removed `.addresses` and replaced it with plain `.address`:
  for (const txid of Object.keys(ret)) {
    const tx = ret[txid]
    if (typeof tx === "string") continue
    for (const vout of tx?.vout ?? []) {
      // @ts-ignore: address is not in type definition
      if (vout?.scriptPubKey?.address) {
        vout.scriptPubKey.addresses = [vout.scriptPubKey.address]
      }
    }
  }

  // saving cache:
  try {
    realm.write(() => {
      for (const txid of Object.keys(ret)) {
        const tx = ret[txid]
        // dont cache immature txs, but only for 'verbose', since its fully decoded tx jsons. non-verbose are just plain
        // strings txhex
        if (
          verbose &&
          typeof tx !== "string" &&
          (!tx?.confirmations || tx.confirmations < 7)
        ) {
          continue
        }

        realm.create(
          "Cache",
          {
            cache_key: txid + cacheKeySuffix,
            cache_value: JSON.stringify(ret[txid])
          },
          Realm.UpdateMode.Modified
        )
      }
    })
  } catch (writeError) {
    console.error("Failed to write transaction cache:", writeError)
  }

  return ret
}

/**
 * Simple waiter till `mainConnected` becomes true (which means
 * it Electrum was connected in other function), or timeout 30 sec.
 */
export const waitTillConnected = async function (): Promise<boolean> {
  let waitTillConnectedInterval: NodeJS.Timeout | undefined
  let retriesCounter = 0
  if (await isDisabled()) {
    console.warn(
      "Electrum connections disabled by user. waitTillConnected skipping...",
    );
    return false
  }
  return new Promise(function (resolve, reject) {
    waitTillConnectedInterval = setInterval(() => {
      if (mainConnected) {
        clearInterval(waitTillConnectedInterval)
        return resolve(true)
      }

      if (wasConnectedAtLeastOnce && retriesCounter++ >= 150) {
        // `wasConnectedAtLeastOnce` needed otherwise theres gona be a race condition with the code that connects
        // electrum during app startup
        clearInterval(waitTillConnectedInterval)
        presentNetworkErrorAlert()
        reject(new Error("Waiting for Electrum connection timeout"))
      }
    }, 100)
  });
};

// Returns the value at a given percentile in a sorted numeric array.
// "Linear interpolation between closest ranks" method
function percentile (arr: number[], p: number) {
  if (arr.length === 0) return 0
  if (typeof p !== "number") throw new TypeError("p must be a number");
  if (p <= 0) return arr[0]
  if (p >= 1) return arr[arr.length - 1]

  const index = (arr.length - 1) * p
  const lower = Math.floor(index)
  const upper = lower + 1
  const weight = index % 1

  if (upper >= arr.length) return arr[lower]
  return arr[lower] * (1 - weight) + arr[upper] * weight
}

/**
 * The histogram is an array of [fee, vsize] pairs, where vsizen is the cumulative virtual size of mempool transactions
 * with a fee rate in the interval [feen-1, feen], and feen-1 > feen.
 */
export const calcEstimateFeeFromFeeHistorgam = function (
  numberOfBlocks: number,
  feeHistorgram: number[][],
) {
  // first, transforming histogram:
  let totalVsize = 0
  const histogramToUse = []
  for (const h of feeHistorgram) {
    let [fee, vsize] = h
    let timeToStop = false

    if (totalVsize + vsize >= 1000000 * numberOfBlocks) {
      vsize = 1000000 * numberOfBlocks - totalVsize // only the difference between current summarized sige to tip of the block
      timeToStop = true
    }

    histogramToUse.push({ fee, vsize })
    totalVsize += vsize
    if (timeToStop) break
  }

  // now we have histogram of precisely size for numberOfBlocks.
  // lets spread it into flat array so its easier to calculate percentile:
  let histogramFlat: number[] = []
  for (const hh of histogramToUse) {
    histogramFlat = histogramFlat.concat(
      Array(Math.round(hh.vsize / 25000)).fill(hh.fee),
    )
    // division is needed so resulting flat array is not too huge
  }

  histogramFlat = histogramFlat.sort(function (a, b) {
    return a - b
  });

  return Math.round(percentile(histogramFlat, 0.5) || 1)
}

export const estimateFees = async function (): Promise<{
  fast: number;
  medium: number;
  slow: number;
}> {
  let histogram
  let timeoutId
  try {
    histogram = await Promise.race([
      mainClient.mempool_getFeeHistogram(),
      new Promise((resolve) => (timeoutId = setTimeout(resolve, 15000)))
    ]);
  } finally {
    clearTimeout(timeoutId)
  }

  // fetching what electrum (which uses bitcoin core) thinks about fees:
  const _fast = await estimateFee(1)
  const _medium = await estimateFee(18)
  const _slow = await estimateFee(144)

  /**
   * sanity check, see
   * @see https://github.com/cculianu/Fulcrum/issues/197
   * (fallback to bitcoin core estimates)
   */
  if (!histogram || histogram?.[0]?.[0] > 1000) {
    return { fast: _fast, medium: _medium, slow: _slow }
  }

  // calculating fast fees from mempool:
  const fast = Math.max(2, calcEstimateFeeFromFeeHistorgam(1, histogram))
  // recalculating medium and slow fees using bitcoincore estimations only like relative weights:
  // (minimum 1 sat, just for any case)
  const medium = Math.max(1, Math.round((fast * _medium) / _fast))
  const slow = Math.max(1, Math.round((fast * _slow) / _fast))
  return { fast, medium, slow }
}

/**
 * Returns the estimated transaction fee to be confirmed within a certain number of blocks
 *
 * @param numberOfBlocks {number} The number of blocks to target for confirmation
 * @returns {Promise<number>} Satoshis per byte
 */
export const estimateFee = async function (
  numberOfBlocks: number,
): Promise<number> {
  if (!mainClient) throw new Error("Electrum client is not connected");
  numberOfBlocks = numberOfBlocks || 1
  const coinUnitsPerKilobyte =
    await mainClient.blockchainEstimatefee(numberOfBlocks)
  if (coinUnitsPerKilobyte === -1) return 1
  return Math.round(
    new BigNumber(coinUnitsPerKilobyte)
      .dividedBy(1024)
      .multipliedBy(100000000)
      .toNumber(),
  )
};

export const serverFeatures = async function () {
  if (!mainClient) throw new Error("Electrum client is not connected");
  return mainClient.server_features()
}

export const broadcast = async function (hex: string) {
  if (!mainClient) throw new Error("Electrum client is not connected");
  try {
    const res = await mainClient.blockchainTransaction_broadcast(hex)
    return res
  } catch (error) {
    return error
  }
}

export const broadcastV2 = async function (hex: string): Promise<string> {
  if (!mainClient) throw new Error("Electrum client is not connected");
  return mainClient.blockchainTransaction_broadcast(hex)
}

export const estimateCurrentBlockheight = function (): number {
  if (latestBlock.height) {
    const timeDiff = Math.floor(+new Date() / 1000) - latestBlock.time
    const extraBlocks = Math.floor(timeDiff / (9.93 * 60))
    return latestBlock.height + extraBlocks
  }

  const baseTs = 1587570465609 // uS
  const baseHeight = 627179
  return Math.floor(baseHeight + (+new Date() - baseTs) / 1000 / 60 / 9.93)
}

export const calculateBlockTime = function (height: number): number {
  if (latestBlock.height) {
    return Math.floor(
      latestBlock.time + (height - latestBlock.height) * 9.93 * 60,
    )
  }

  const baseTs = 1585837504 // sec
  const baseHeight = 624083
  return Math.floor(baseTs + (height - baseHeight) * 9.93 * 60)
}

/**
 * @returns {Promise<boolean>} Whether provided host:port is a valid electrum server
 */
export const testConnection = async function (
  host: string,
  tcpPort?: number,
  sslPort?: number,
): Promise<boolean> {
  const client = new ElectrumClient(
    net,
    tls,
    sslPort || tcpPort,
    host,
    sslPort ? "tls" : "tcp",
  );

  client.onError = () => {} // mute
  let timeoutId: NodeJS.Timeout | undefined
  try {
    const rez = await Promise.race([
      new Promise((resolve) => {
        timeoutId = setTimeout(() => resolve("timeout"), 5000)
      }),
      client.connect()
    ]);
    if (rez === "timeout") return false

    await client.server_version("2.7.11", "1.4");
    await client.server_ping()
    return true
  } catch (_) {
  } finally {
    if (timeoutId) clearTimeout(timeoutId)
    client.close()
  }

  return false
}

export const forceDisconnect = (): void => {
  mainClient?.close()
}

export const setBatchingDisabled = () => {
  disableBatching = true
}

export const setBatchingEnabled = () => {
  disableBatching = false
}

const splitIntoChunks = function (arr: any[], chunkSize: number) {
  const groups = []
  let i
  for (i = 0; i < arr.length; i += chunkSize) {
    groups.push(arr.slice(i, i + chunkSize))
  }
  return groups
}

const semVerToInt = function (semver: string): number {
  if (!semver) return 0
  if (semver.split(".").length !== 3) return 0

  const ret =
    Number(semver.split(".")[0]) * 1000000 +
    Number(semver.split(".")[1]) * 1000 +
    Number(semver.split(".")[2]) * 1

  if (isNaN(ret)) return 0

  return ret
}



================================================
FILE: ./malin_modules/checksumWords.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bip39 from 'bip39';
import { sha256 } from '@noble/hashes/sha256';

// partial (11 or 23 word) seed phrase
export function generateChecksumWords(stringSeedPhrase: string) {
  const seedPhrase = stringSeedPhrase.toLowerCase().trim().split(' ');

  if ((seedPhrase.length + 1) % 3 > 0) {
    return false; // Partial mnemonic size must be multiple of three words, less one.
  }

  const wordList = bip39.wordlists[bip39.getDefaultWordlist()];

  const concatLenBits = seedPhrase.length * 11;
  const concatBits = new Array(concatLenBits);
  let wordindex = 0;
  for (let i = 0; i < seedPhrase.length; i++) {
    const word = seedPhrase[i];
    const ndx = wordList.indexOf(word.toLowerCase());
    if (ndx === -1) return false;
    // Set the next 11 bits to the value of the index.
    for (let ii = 0; ii < 11; ++ii) {
      concatBits[wordindex * 11 + ii] = (ndx & (1 << (10 - ii))) !== 0; // eslint-disable-line no-bitwise
    }
    ++wordindex;
  }

  const checksumLengthBits = (concatLenBits + 11) / 33;
  const entropyLengthBits = concatLenBits + 11 - checksumLengthBits;
  const varyingLengthBits = entropyLengthBits - concatLenBits;
  const numPermutations = 2 ** varyingLengthBits;

  const bitPermutations = new Array(numPermutations);

  for (let i = 0; i < numPermutations; i++) {
    if (bitPermutations[i] === undefined || bitPermutations[i] === null) bitPermutations[i] = new Array(varyingLengthBits);
    for (let j = 0; j < varyingLengthBits; j++) {
      bitPermutations[i][j] = ((i >> j) & 1) === 1; // eslint-disable-line no-bitwise
    }
  }

  const possibleWords = [];
  for (let i = 0; i < bitPermutations.length; i++) {
    const bitPermutation = bitPermutations[i];
    const entropyBits = new Array(concatLenBits + varyingLengthBits);
    entropyBits.splice(0, 0, ...concatBits);
    entropyBits.splice(concatBits.length, 0, ...bitPermutation.slice(0, varyingLengthBits));

    const entropy = new Array(entropyLengthBits / 8);
    for (let ii = 0; ii < entropy.length; ++ii) {
      for (let jj = 0; jj < 8; ++jj) {
        if (entropyBits[ii * 8 + jj]) {
          entropy[ii] |= 1 << (7 - jj); // eslint-disable-line no-bitwise
        }
      }
    }

    const hash = sha256(new Uint8Array(entropy));

    const hashBits = new Array(hash.length * 8);
    for (let iq = 0; iq < hash.length; ++iq) for (let jq = 0; jq < 8; ++jq) hashBits[iq * 8 + jq] = (hash[iq] & (1 << (7 - jq))) !== 0; // eslint-disable-line no-bitwise

    const wordBits = new Array(11);
    wordBits.splice(0, 0, ...bitPermutation.slice(0, varyingLengthBits));
    wordBits.splice(varyingLengthBits, 0, ...hashBits.slice(0, checksumLengthBits));

    let index = 0;
    for (let j = 0; j < 11; ++j) {
      index <<= 1; // eslint-disable-line no-bitwise
      if (wordBits[j]) {
        index |= 0x1; // eslint-disable-line no-bitwise
      }
    }

    possibleWords.push(wordList[index]);
  }

  return possibleWords;
}


================================================
FILE: ./malin_modules/react-native-bw-file-access/ios/BwFileAccess.h
================================================

// BwFileAccess.h

#import <React/RCTBridgeModule.h>

@interface BwFileAccess : NSObject <RCTBridgeModule>

@end


================================================
FILE: ./malin_modules/react-native-bw-file-access/index.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// main index.js

import { NativeModules } from 'react-native';

const { BwFileAccess } = NativeModules;

export function readFile(filePath: string): Promise<string> {
  return BwFileAccess.readFileContent(filePath);
}

export default BwFileAccess;


================================================
FILE: ./malin_modules/currency.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import BigNumber from 'bignumber.js';
import DefaultPreference from 'react-native-default-preference';
import * as RNLocalize from 'react-native-localize';

import { FiatUnit, FiatUnitType, getFiatRate } from '../models/fiatUnit';

const PREFERRED_CURRENCY_STORAGE_KEY = 'preferredCurrency';
const PREFERRED_CURRENCY_LOCALE_STORAGE_KEY = 'preferredCurrencyLocale';
const EXCHANGE_RATES_STORAGE_KEY = 'exchangeRates';
const LAST_UPDATED = 'LAST_UPDATED';
export const GROUP_IO_MALINWALLET = 'group.com.malinwallet.app';
const BTC_PREFIX = 'BTC_';

export interface CurrencyRate {
  LastUpdated: Date | null;
  Rate: number | string | null;
}

interface ExchangeRates {
  [key: string]: number | boolean | undefined;
  LAST_UPDATED_ERROR: boolean;
}

let preferredFiatCurrency: FiatUnitType = FiatUnit.USD;
let exchangeRates: ExchangeRates = { LAST_UPDATED_ERROR: false };
let lastTimeUpdateExchangeRateWasCalled: number = 0;
let skipUpdateExchangeRate: boolean = false;

let currencyFormatter: Intl.NumberFormat | null = null;

function getCurrencyFormatter(): Intl.NumberFormat {
  if (
    !currencyFormatter ||
    currencyFormatter.resolvedOptions().locale !== preferredFiatCurrency.locale ||
    currencyFormatter.resolvedOptions().currency !== preferredFiatCurrency.endPointKey
  ) {
    currencyFormatter = new Intl.NumberFormat(preferredFiatCurrency.locale, {
      style: 'currency',
      currency: preferredFiatCurrency.endPointKey,
      minimumFractionDigits: 2,
      maximumFractionDigits: 8,
    });
    console.debug('Created new currency formatter for: ', preferredFiatCurrency);
  }
  return currencyFormatter;
}

async function setPreferredCurrency(item: FiatUnitType): Promise<void> {
  await DefaultPreference.setName(GROUP_IO_MALINWALLET);
  try {
    await DefaultPreference.set(PREFERRED_CURRENCY_STORAGE_KEY, item.endPointKey);
    await DefaultPreference.set(PREFERRED_CURRENCY_LOCALE_STORAGE_KEY, item.locale.replace('-', '_'));
    preferredFiatCurrency = FiatUnit[item.endPointKey];
    currencyFormatter = null; // Remove cached formatter
    console.debug('Preferred currency set to:', item);
    console.debug('Preferred currency locale set to:', item.locale.replace('-', '_'));
    console.debug('Cleared all cached currency formatters');
  } catch (error) {
    console.error('Failed to set preferred currency:', error);
    throw error;
  }
  currencyFormatter = null;
}

async function updateExchangeRate(): Promise<void> {
  if (skipUpdateExchangeRate) return;
  if (Date.now() - lastTimeUpdateExchangeRateWasCalled <= 10000) {
    // simple debounce so there's no race conditions
    return;
  }
  lastTimeUpdateExchangeRateWasCalled = Date.now();

  const lastUpdated = exchangeRates[LAST_UPDATED] as number | undefined;
  if (lastUpdated && Date.now() - lastUpdated <= 30 * 60 * 1000) {
    // not updating too often
    return;
  }
  console.log('updating exchange rate...');

  try {
    const rate = await getFiatRate(preferredFiatCurrency.endPointKey);
    exchangeRates[LAST_UPDATED] = Date.now();
    exchangeRates[BTC_PREFIX + preferredFiatCurrency.endPointKey] = rate;
    exchangeRates.LAST_UPDATED_ERROR = false;

    try {
      const exchangeRatesString = JSON.stringify(exchangeRates);
      await DefaultPreference.setName(GROUP_IO_MALINWALLET);
      await DefaultPreference.set(EXCHANGE_RATES_STORAGE_KEY, exchangeRatesString);
    } catch (error) {
      await DefaultPreference.clear(EXCHANGE_RATES_STORAGE_KEY);
      exchangeRates = { LAST_UPDATED_ERROR: false };
    }
  } catch (error) {
    try {
      await DefaultPreference.setName(GROUP_IO_MALINWALLET);
      const ratesValue = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
      let ratesString: string | null = null;

      if (typeof ratesValue === 'string') {
        ratesString = ratesValue;
      }

      let rate;
      if (ratesString) {
        try {
          rate = JSON.parse(ratesString);
        } catch (parseError) {
          await DefaultPreference.clear(EXCHANGE_RATES_STORAGE_KEY);
          rate = {};
        }
      } else {
        rate = {};
      }
      rate.LAST_UPDATED_ERROR = true;
      exchangeRates.LAST_UPDATED_ERROR = true;
      await DefaultPreference.set(EXCHANGE_RATES_STORAGE_KEY, JSON.stringify(rate));
    } catch (storageError) {
      exchangeRates = { LAST_UPDATED_ERROR: true };
      throw storageError;
    }
  }
}

async function getPreferredCurrency(): Promise<FiatUnitType> {
  await DefaultPreference.setName(GROUP_IO_MALINWALLET);
  const preferredCurrencyValue = await DefaultPreference.get(PREFERRED_CURRENCY_STORAGE_KEY);
  let preferredCurrency: string | null = null;

  if (typeof preferredCurrencyValue === 'string') {
    preferredCurrency = preferredCurrencyValue;
  }

  if (preferredCurrency) {
    try {
      if (!FiatUnit[preferredCurrency]) {
        throw new Error('Invalid Fiat Unit');
      }
      preferredFiatCurrency = FiatUnit[preferredCurrency];
    } catch (error) {
      await DefaultPreference.clear(PREFERRED_CURRENCY_STORAGE_KEY);
    }
  }

  if (!preferredFiatCurrency) {
    const deviceCurrencies = RNLocalize.getCurrencies();
    if (deviceCurrencies[0] && FiatUnit[deviceCurrencies[0]]) {
      preferredFiatCurrency = FiatUnit[deviceCurrencies[0]];
    } else {
      preferredFiatCurrency = FiatUnit.USD;
    }
  }

  await DefaultPreference.set(PREFERRED_CURRENCY_LOCALE_STORAGE_KEY, preferredFiatCurrency.locale.replace('-', '_'));
  return preferredFiatCurrency;
}

async function _restoreSavedExchangeRatesFromStorage(): Promise<void> {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const ratesValue = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    let ratesString: string | null = null;

    if (typeof ratesValue === 'string') {
      ratesString = ratesValue;
    }

    if (ratesString) {
      try {
        const parsedRates = JSON.parse(ratesString);
        // Atomic update to prevent race conditions
        exchangeRates = parsedRates;
      } catch (error) {
        await DefaultPreference.clear(EXCHANGE_RATES_STORAGE_KEY);
        exchangeRates = { LAST_UPDATED_ERROR: false };
        // Add delay before update to prevent rapid consecutive calls
        await new Promise(resolve => setTimeout(resolve, 1000));
        await updateExchangeRate();
      }
    } else {
      exchangeRates = { LAST_UPDATED_ERROR: false };
    }
  } catch (error) {
    exchangeRates = { LAST_UPDATED_ERROR: false };
    await updateExchangeRate();
  }
}

async function _restoreSavedPreferredFiatCurrencyFromStorage(): Promise<void> {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const storedCurrencyValue = await DefaultPreference.get(PREFERRED_CURRENCY_STORAGE_KEY);
    let storedCurrency: string | null = null;

    if (typeof storedCurrencyValue === 'string') {
      storedCurrency = storedCurrencyValue;
    }

    if (!storedCurrency) throw new Error('No Preferred Fiat selected');

    try {
      if (!FiatUnit[storedCurrency]) {
        throw new Error('Invalid Fiat Unit');
      }
      preferredFiatCurrency = FiatUnit[storedCurrency];
    } catch (error) {
      await DefaultPreference.clear(PREFERRED_CURRENCY_STORAGE_KEY);

      const deviceCurrencies = RNLocalize.getCurrencies();
      if (deviceCurrencies[0] && FiatUnit[deviceCurrencies[0]]) {
        preferredFiatCurrency = FiatUnit[deviceCurrencies[0]];
      } else {
        preferredFiatCurrency = FiatUnit.USD;
      }
    }
  } catch (error) {
    const deviceCurrencies = RNLocalize.getCurrencies();
    if (deviceCurrencies[0] && FiatUnit[deviceCurrencies[0]]) {
      preferredFiatCurrency = FiatUnit[deviceCurrencies[0]];
    } else {
      preferredFiatCurrency = FiatUnit.USD;
    }
  }
}

async function isRateOutdated(): Promise<boolean> {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const rateValue = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    let rateString: string | null = null;

    if (typeof rateValue === 'string') {
      rateString = rateValue;
    }

    let rate;
    if (rateString) {
      try {
        rate = JSON.parse(rateString);
      } catch (parseError) {
        await DefaultPreference.clear(EXCHANGE_RATES_STORAGE_KEY);
        rate = {};
        await updateExchangeRate();
      }
    } else {
      rate = {};
    }
    return rate.LAST_UPDATED_ERROR || Date.now() - (rate[LAST_UPDATED] || 0) >= 31 * 60 * 1000;
  } catch {
    return true;
  }
}

async function restoreSavedPreferredFiatCurrencyAndExchangeFromStorage(): Promise<void> {
  await _restoreSavedExchangeRatesFromStorage();
  await _restoreSavedPreferredFiatCurrencyFromStorage();
}

async function initCurrencyDaemon(clearLastUpdatedTime: boolean = false): Promise<void> {
  await _restoreSavedExchangeRatesFromStorage();
  await _restoreSavedPreferredFiatCurrencyFromStorage();

  if (clearLastUpdatedTime) {
    exchangeRates[LAST_UPDATED] = 0;
    lastTimeUpdateExchangeRateWasCalled = 0;
  }

  await updateExchangeRate();
}

function satoshiToLocalCurrency(satoshi: number, format: boolean = true): string {
  const exchangeRateKey = BTC_PREFIX + preferredFiatCurrency.endPointKey;
  const exchangeRate = exchangeRates[exchangeRateKey];

  if (typeof exchangeRate !== 'number') {
    updateExchangeRate();
    return '...';
  }

  const btcAmount = new BigNumber(satoshi).dividedBy(100000000);
  const convertedAmount = btcAmount.multipliedBy(exchangeRate);
  let formattedAmount: string;

  if (convertedAmount.isGreaterThanOrEqualTo(0.005) || convertedAmount.isLessThanOrEqualTo(-0.005)) {
    formattedAmount = convertedAmount.toFixed(2);
  } else {
    formattedAmount = convertedAmount.toPrecision(2);
  }

  if (format === false) return formattedAmount;

  try {
    return getCurrencyFormatter().format(Number(formattedAmount));
  } catch (error) {
    console.error(error);
    return formattedAmount;
  }
}

function BTCToLocalCurrency(bitcoin: BigNumber.Value): string {
  const sat = new BigNumber(bitcoin).multipliedBy(100000000).toNumber();
  return satoshiToLocalCurrency(sat);
}

async function mostRecentFetchedRate(): Promise<CurrencyRate> {
  try {
    await DefaultPreference.setName(GROUP_IO_MALINWALLET);
    const currencyInfoValue = await DefaultPreference.get(EXCHANGE_RATES_STORAGE_KEY);
    let currencyInformationString: string | null = null;

    if (typeof currencyInfoValue === 'string') {
      currencyInformationString = currencyInfoValue;
    }

    let currencyInformation;
    if (currencyInformationString) {
      try {
        currencyInformation = JSON.parse(currencyInformationString);
      } catch (parseError) {
        await DefaultPreference.clear(EXCHANGE_RATES_STORAGE_KEY);
        currencyInformation = {};
        await updateExchangeRate();
      }
    } else {
      currencyInformation = {};
    }

    const rate = currencyInformation[BTC_PREFIX + preferredFiatCurrency.endPointKey];
    return {
      LastUpdated: currencyInformation[LAST_UPDATED] ? new Date(currencyInformation[LAST_UPDATED]) : null,
      Rate: rate ? getCurrencyFormatter().format(rate) : '...',
    };
  } catch {
    return {
      LastUpdated: null,
      Rate: null,
    };
  }
}

function satoshiToBTC(satoshi: number): string {
  return new BigNumber(satoshi).dividedBy(100000000).toString(10);
}

function btcToSatoshi(btc: BigNumber.Value): number {
  return new BigNumber(btc).multipliedBy(100000000).toNumber();
}

function fiatToBTC(fiatFloat: number): string {
  const exchangeRateKey = BTC_PREFIX + preferredFiatCurrency.endPointKey;
  const exchangeRate = exchangeRates[exchangeRateKey];

  if (typeof exchangeRate !== 'number') {
    throw new Error('Exchange rate not available');
  }

  const btcAmount = new BigNumber(fiatFloat).dividedBy(exchangeRate);
  return btcAmount.toFixed(8);
}

function getCurrencySymbol(): string {
  return preferredFiatCurrency.symbol;
}

function formatBTC(btc: BigNumber.Value): string {
  return new BigNumber(btc).toFormat(8);
}

function _setPreferredFiatCurrency(currency: FiatUnitType): void {
  preferredFiatCurrency = currency;
}

function _setExchangeRate(pair: string, rate: number): void {
  exchangeRates[pair] = rate;
}

function _setSkipUpdateExchangeRate(): void {
  skipUpdateExchangeRate = true;
}

export {
  _setExchangeRate,
  _setPreferredFiatCurrency,
  _setSkipUpdateExchangeRate,
  BTCToLocalCurrency,
  btcToSatoshi,
  EXCHANGE_RATES_STORAGE_KEY,
  fiatToBTC,
  getCurrencySymbol,
  getPreferredCurrency,
  initCurrencyDaemon,
  isRateOutdated,
  LAST_UPDATED,
  mostRecentFetchedRate,
  PREFERRED_CURRENCY_STORAGE_KEY,
  restoreSavedPreferredFiatCurrencyAndExchangeFromStorage,
  satoshiToBTC,
  satoshiToLocalCurrency,
  setPreferredCurrency,
  updateExchangeRate,
  formatBTC,
};


================================================
FILE: ./malin_modules/debounce.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
// https://levelup.gitconnected.com/debounce-in-javascript-improve-your-applications-performance-5b01855e086
// malin_modules/debounce.ts
type DebouncedFunction<T extends (...args: any[]) => void> = {
  (this: ThisParameterType<T>, ...args: Parameters<T>): void;
  cancel(): void;
};

const debounce = <T extends (...args: any[]) => void>(func: T, wait: number): DebouncedFunction<T> => {
  let timeout: NodeJS.Timeout | null;
  const debouncedFunction = function (this: ThisParameterType<T>, ...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func.apply(this, args);
    };
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };

  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = null;
  };

  return debouncedFunction as DebouncedFunction<T>;
};

export default debounce;


================================================
FILE: ./malin_modules/encryption.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AES from 'crypto-js/aes';
import Utf8 from 'crypto-js/enc-utf8';
import Hex from 'crypto-js/enc-hex';
import PBKDF2 from 'crypto-js/pbkdf2';
import WordArray from 'crypto-js/lib-typedarrays';

const PBKDF2_ITERATIONS = 250000;
const KEY_SIZE = 256 / 32;

export function encrypt(data: string, password: string): string {
  if (data.length < 10) throw new Error('data length cant be < 10');

  const salt = WordArray.random(16);
  const iv = WordArray.random(16);
  const key = PBKDF2(password, salt, {
    keySize: KEY_SIZE,
    iterations: PBKDF2_ITERATIONS,
  });

  const encrypted = AES.encrypt(data, key, {
    iv,
  });

  const transitmessage = salt.toString(Hex) + ':' + iv.toString(Hex) + ':' + encrypted.ciphertext.toString(Hex);
  return transitmessage;
}

export function decrypt(data: string, password: string): string | false {
  const parts = data.split(':');
  if (parts.length !== 3) {
    // backward compatibility
    const bytes = AES.decrypt(data, password);
    let str: string | false = false;
    try {
      str = bytes.toString(Utf8);
    } catch (e) {}
    if (str && str.length < 10) return false;
    return str;
  }

  const salt = Hex.parse(parts[0]);
  const iv = Hex.parse(parts[1]);
  const ciphertext = Hex.parse(parts[2]);

  const key = PBKDF2(password, salt, {
    keySize: KEY_SIZE,
    iterations: PBKDF2_ITERATIONS,
  });

  const decrypted = AES.decrypt({ ciphertext: ciphertext } as any, key, {
    iv,
  });

  let str: string | false = false;
  try {
    str = decrypted.toString(Utf8);
  } catch (e) {
    return false;
  }

  if (str && str.length < 10) return false;

  return str;
}


================================================
FILE: ./malin_modules/constants.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * Let's keep config vars, constants and definitions here
 */

export const groundControlUri: string =
  'https://groundcontrol-malinwallet.herokuapp.com';


================================================
FILE: ./malin_modules/notifications.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import AsyncStorage from '@react-native-async-storage/async-storage';
import PushNotificationIOS from '@react-native-community/push-notification-ios';
import { AppState, AppStateStatus, Platform } from 'react-native';
import { getApplicationName, getSystemName, getSystemVersion, getVersion, hasGmsSync, hasHmsSync } from 'react-native-device-info';
import { checkNotifications, requestNotifications, RESULTS } from 'react-native-permissions';
import PushNotification, { ReceivedNotification } from 'react-native-push-notification';
import loc from '../loc';
import { groundControlUri } from './constants';
import { fetch } from '../util/fetch';

const PUSH_TOKEN = 'PUSH_TOKEN';
const GROUNDCONTROL_BASE_URI = 'GROUNDCONTROL_BASE_URI';
const NOTIFICATIONS_STORAGE = 'NOTIFICATIONS_STORAGE';
export const NOTIFICATIONS_NO_AND_DONT_ASK_FLAG = 'NOTIFICATIONS_NO_AND_DONT_ASK_FLAG';
let alreadyConfigured = false;
let baseURI = groundControlUri;

type TPushToken = {
  token: string;
  os: string; // its actually ('ios' | 'android'), but types for the lib are a bit more generic...
};

// thats unwrapped `ReceivedNotification`, withall `data` fields inline
type TPayload = {
  // inherited from `ReceivedNotification`:
  subText?: string;
  message?: string | object;
  foreground: boolean;
  userInteraction: boolean;
  // hopefully stuffed in `data` and uwrapped when received:
  address: string;
  txid: string;
  type: number;
  hash: string;
};

function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

const checkAndroidNotificationPermission = async () => {
  try {
    const { status } = await checkNotifications();
    console.debug('Notification permission check:', status);
    return status === RESULTS.GRANTED;
  } catch (err) {
    console.error('Failed to check notification permission:', err);
    return false;
  }
};

export const checkNotificationPermissionStatus = async () => {
  try {
    const { status } = await checkNotifications();
    return status;
  } catch (error) {
    console.error('Failed to check notification permissions:', error);
    return 'unavailable'; // Return 'unavailable' if the status cannot be retrieved
  }
};

// Listener to monitor notification permission status changes while app is running
let currentPermissionStatus = 'unavailable';
const handleAppStateChange = async (nextAppState: AppStateStatus) => {
  if (nextAppState === 'active') {
    const isDisabledByUser = (await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG)) === 'true';
    if (!isDisabledByUser) {
      const newPermissionStatus = await checkNotificationPermissionStatus();
      if (newPermissionStatus !== currentPermissionStatus) {
        currentPermissionStatus = newPermissionStatus;
        if (newPermissionStatus === 'granted') {
          await initializeNotifications();
        }
      }
    }
  }
};

AppState.addEventListener('change', handleAppStateChange);

export const cleanUserOptOutFlag = async () => {
  return AsyncStorage.removeItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG);
};

/**
 * Should be called when user is most interested in receiving push notifications.
 * If we dont have a token it will show alert asking whether
 * user wants to receive notifications, and if yes - will configure push notifications.
 * FYI, on Android permissions are acquired when app is installed, so basically we dont need to ask,
 * we can just call `configure`. On iOS its different, and calling `configure` triggers system's dialog box.
 *
 * @returns {Promise<boolean>} TRUE if permissions were obtained, FALSE otherwise
 */
/**
 * Attempts to obtain permissions and configure notifications.
 * Shows a rationale on Android if permissions are needed.
 *
 * @returns {Promise<boolean>}
 */
export const tryToObtainPermissions = async () => {
  console.debug('tryToObtainPermissions: Starting user-triggered permission request');

  if (!isNotificationsCapable) {
    console.debug('tryToObtainPermissions: Device not capable');
    return false;
  }

  try {
    const rationale = {
      title: loc.settings.notifications,
      message: loc.notifications.would_you_like_to_receive_notifications,
      buttonPositive: loc._.ok,
      buttonNegative: loc.notifications.no_and_dont_ask,
    };

    const { status } = await requestNotifications(
      ['alert', 'sound', 'badge'],
      Platform.OS === 'android' && Platform.Version < 33 ? rationale : undefined,
    );
    if (status !== RESULTS.GRANTED) {
      console.debug('tryToObtainPermissions: Permission denied');
      return false;
    }
    return configureNotifications();
  } catch (error) {
    console.error('Error requesting notification permissions:', error);
    return false;
  }
};
/**
 * Submits onchain bitcoin addresses and ln invoice preimage hashes to GroundControl server, so later we could
 * be notified if they were paid
 *
 * @param addresses {string[]}
 * @param hashes {string[]}
 * @param txids {string[]}
 * @returns {Promise<object>} Response object from API rest call
 */
export const majorTomToGroundControl = async (addresses: string[], hashes: string[], txids: string[]) => {
  console.debug('majorTomToGroundControl: Starting notification registration', {
    addressCount: addresses?.length,
    hashCount: hashes?.length,
    txidCount: txids?.length,
  });

  try {
    const noAndDontAskFlag = await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG);
    if (noAndDontAskFlag === 'true') {
      console.warn('User has opted out of notifications.');
      return;
    }

    if (!Array.isArray(addresses) || !Array.isArray(hashes) || !Array.isArray(txids)) {
      throw new Error('No addresses, hashes, or txids provided');
    }

    const pushToken = await getPushToken();
    console.debug('majorTomToGroundControl: Retrieved push token:', !!pushToken);
    if (!pushToken || !pushToken.token || !pushToken.os) {
      return;
    }

    const requestBody = JSON.stringify({
      addresses,
      hashes,
      txids,
      token: pushToken.token,
      os: pushToken.os,
    });

    let response;
    try {
      console.debug('majorTomToGroundControl: Sending request to:', `${baseURI}/majorTomToGroundControl`);
      response = await fetch(`${baseURI}/majorTomToGroundControl`, {
        method: 'POST',
        headers: _getHeaders(),
        body: requestBody,
      });
    } catch (networkError) {
      console.error('Network request failed:', networkError);
      throw networkError;
    }

    if (!response.ok) {
      throw new Error(`Ground Control request failed with status ${response.status}: ${response.statusText}`);
    }

    const responseText = await response.text();
    if (responseText) {
      try {
        return JSON.parse(responseText);
      } catch (jsonError) {
        console.error('Error parsing response JSON:', jsonError);
        throw jsonError;
      }
    } else {
      return {}; // Return an empty object if there is no response body
    }
  } catch (error) {
    console.error('Error in majorTomToGroundControl:', error);
    throw error;
  }
};

/**
 * Returns a permissions object:
 * alert: boolean
 * badge: boolean
 * sound: boolean
 *
 * @returns {Promise<Object>}
 */
export const checkPermissions = async () => {
  try {
    return new Promise(function (resolve) {
      PushNotification.checkPermissions((result: any) => {
        resolve(result);
      });
    });
  } catch (error) {
    console.error('Error checking permissions:', error);
    throw error;
  }
};

/**
 * Posts to groundcontrol info whether we want to opt in or out of specific notifications level
 *
 * @param levelAll {Boolean}
 * @returns {Promise<*>}
 */
export const setLevels = async (levelAll: boolean) => {
  const pushToken = await getPushToken();
  if (!pushToken || !pushToken.token || !pushToken.os) return;

  try {
    const response = await fetch(`${baseURI}/setTokenConfiguration`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        level_all: !!levelAll,
        token: pushToken.token,
        os: pushToken.os,
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to set token configuration: ' + response.statusText);
    }

    if (!levelAll) {
      console.debug('Disabling notifications as user opted out...');
      PushNotification.removeAllDeliveredNotifications();
      PushNotification.setApplicationIconBadgeNumber(0);
      PushNotification.cancelAllLocalNotifications();
      await AsyncStorage.setItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG, 'true');
      console.debug('Notifications disabled successfully');
    } else {
      await AsyncStorage.removeItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG); // Clear flag when enabling
    }
  } catch (error) {
    console.error('Error setting notification levels:', error);
  }
};

export const addNotification = async (notification: TPayload) => {
  let notifications = [];
  try {
    const stringified = await AsyncStorage.getItem(NOTIFICATIONS_STORAGE);
    notifications = JSON.parse(String(stringified));
    if (!Array.isArray(notifications)) notifications = [];
  } catch (e) {
    console.error(e);
    // Start fresh with just the new notification
    notifications = [];
  }

  notifications.push(notification);
  await AsyncStorage.setItem(NOTIFICATIONS_STORAGE, JSON.stringify(notifications));
};

const postTokenConfig = async () => {
  console.debug('postTokenConfig: Starting token configuration');
  const pushToken = await getPushToken();
  console.debug('postTokenConfig: Retrieved push token:', !!pushToken);

  if (!pushToken || !pushToken.token || !pushToken.os) {
    console.debug('postTokenConfig: Invalid token or missing OS info');
    return;
  }

  try {
    const lang = (await AsyncStorage.getItem('lang')) || 'en';
    const appVersion = getSystemName() + ' ' + getSystemVersion() + ';' + getApplicationName() + ' ' + getVersion();
    console.debug('postTokenConfig: Posting configuration', { lang, appVersion });

    await fetch(`${baseURI}/setTokenConfiguration`, {
      method: 'POST',
      headers: _getHeaders(),
      body: JSON.stringify({
        token: pushToken.token,
        os: pushToken.os,
        lang,
        app_version: appVersion,
      }),
    });
  } catch (e) {
    console.error(e);
    await AsyncStorage.setItem('lang', 'en');
    throw e;
  }
};

const _setPushToken = async (token: TPushToken) => {
  try {
    return await AsyncStorage.setItem(PUSH_TOKEN, JSON.stringify(token));
  } catch (error) {
    console.error('Error setting push token:', error);
    throw error;
  }
};

/**
 * Configures notifications. For Android, it will show a native rationale prompt if necessary.
 *
 * @returns {Promise<boolean>}
 */
export const configureNotifications = async (onProcessNotifications?: () => void) => {
  if (alreadyConfigured) {
    console.debug('configureNotifications: Already configured, skipping');
    return true;
  }

  return new Promise(resolve => {
    const handleRegistration = async (token: TPushToken) => {
      if (__DEV__) {
        console.debug('configureNotifications: Token received:', token);
      }
      alreadyConfigured = true;
      await _setPushToken(token);
      resolve(true);
    };

    // const handleNotification = async (notification: TPushNotification & { data: any }) => {
    const handleNotification = async (notification: Omit<ReceivedNotification, 'userInfo'>) => {
      // Deep clone to avoid modifying the original object
      // @ts-ignore some missing properties hopefully will be unwrapped from `.data`
      const payload: TPayload = deepClone({
        ...notification,
        ...notification.data,
      });

      if (notification.data?.data) {
        const validData = Object.fromEntries(Object.entries(notification.data.data).filter(([_, value]) => value != null));
        Object.assign(payload, validData);
      }

      // @ts-ignore stfu ts, its cleanup
      payload.data = undefined;

      if (!payload.subText && !payload.message) {
        console.warn('Notification missing required fields:', payload);
        return;
      }

      await addNotification(payload);
      notification.finish(PushNotificationIOS.FetchResult.NoData);

      if (payload.foreground && onProcessNotifications) {
        await onProcessNotifications();
      }
    };

    const configure = async () => {
      try {
        const { status } = await checkNotifications();
        if (status !== RESULTS.GRANTED) {
          console.debug('configureNotifications: Permissions not granted');
          return resolve(false);
        }

        const existingToken = await getPushToken();
        if (existingToken) {
          alreadyConfigured = true;
          console.debug('Notifications already configured with existing token');
          return resolve(true);
        }

        PushNotification.configure({
          onRegister: handleRegistration,
          onNotification: handleNotification,
          onRegistrationError: (error: any) => {
            console.error('Registration error:', error);
            resolve(false);
          },
          permissions: { alert: true, badge: true, sound: true },
          popInitialNotification: true,
        });
      } catch (error) {
        console.error('Error in configure:', error);
        resolve(false);
      }
    };

    configure();
  });
};

/**
 * Validates whether the provided GroundControl URI is valid by pinging it.
 *
 * @param uri {string}
 * @returns {Promise<boolean>} TRUE if valid, FALSE otherwise
 */
export const isGroundControlUriValid = async (uri: string) => {
  try {
    const response = await fetch(`${uri}/ping`, { headers: _getHeaders() });
    const json = await response.json();
    return !!json.description;
  } catch (_) {
    return false;
  }
};

export const isNotificationsCapable = hasGmsSync() || hasHmsSync() || Platform.OS !== 'android';

export const getPushToken = async (): Promise<TPushToken> => {
  try {
    const token = await AsyncStorage.getItem(PUSH_TOKEN);
    return JSON.parse(String(token)) as TPushToken;
  } catch (e) {
    console.error(e);
    AsyncStorage.removeItem(PUSH_TOKEN);
    throw e;
  }
};

/**
 * Queries groundcontrol for token configuration, which contains subscriptions to notification levels
 *
 * @returns {Promise<{}|*>}
 */
const getLevels = async () => {
  const pushToken = await getPushToken();
  if (!pushToken || !pushToken.token || !pushToken.os) return;

  try {
    const response = await fetch(`${baseURI}/getTokenConfiguration`, {
      method: 'POST',
      headers: _getHeaders(),
      body: JSON.stringify({
        token: pushToken.token,
        os: pushToken.os,
      }),
    });

    if (!response) return {};
    return await response.json();
  } catch (_) {
    return {};
  }
};

/**
 * The opposite of `majorTomToGroundControl` call.
 *
 * @param addresses {string[]}
 * @param hashes {string[]}
 * @param txids {string[]}
 * @returns {Promise<object>} Response object from API rest call
 */
export const unsubscribe = async (addresses: string[], hashes: string[], txids: string[]) => {
  if (!Array.isArray(addresses) || !Array.isArray(hashes) || !Array.isArray(txids)) {
    throw new Error('No addresses, hashes, or txids provided');
  }

  const token = await getPushToken();
  if (!token?.token || !token?.os) {
    console.error('No push token or OS found');
    return;
  }

  const body = JSON.stringify({
    addresses,
    hashes,
    txids,
    token: token.token,
    os: token.os,
  });

  try {
    const response = await fetch(`${baseURI}/unsubscribe`, {
      method: 'POST',
      headers: _getHeaders(),
      body,
    });

    if (!response.ok) {
      console.error('Failed to unsubscribe:', response.statusText);
      return;
    }

    return response;
  } catch (error) {
    console.error('Error during unsubscribe:', error);
    throw error;
  }
};

const _getHeaders = () => {
  return {
    'Access-Control-Allow-Origin': '*',
    'Content-Type': 'application/json',
  };
};

export const clearStoredNotifications = async () => {
  try {
    await AsyncStorage.setItem(NOTIFICATIONS_STORAGE, JSON.stringify([]));
  } catch (_) {}
};

export const getDeliveredNotifications: () => Promise<Record<string, any>[]> = () => {
  try {
    return new Promise(resolve => {
      PushNotification.getDeliveredNotifications((notifications: Record<string, any>[]) => resolve(notifications));
    });
  } catch (error) {
    console.error('Error getting delivered notifications:', error);
    throw error;
  }
};

export const removeDeliveredNotifications = (identifiers = []) => {
  PushNotification.removeDeliveredNotifications(identifiers);
};

export const setApplicationIconBadgeNumber = (badges: number) => {
  PushNotification.setApplicationIconBadgeNumber(badges);
};

export const removeAllDeliveredNotifications = () => {
  PushNotification.removeAllDeliveredNotifications();
};

export const getDefaultUri = () => {
  return groundControlUri;
};

export const saveUri = async (uri: string) => {
  try {
    baseURI = uri || groundControlUri;
    await AsyncStorage.setItem(GROUNDCONTROL_BASE_URI, baseURI);
  } catch (error) {
    console.error('Error saving URI:', error);
    throw error;
  }
};

export const getSavedUri = async () => {
  try {
    const baseUriStored = await AsyncStorage.getItem(GROUNDCONTROL_BASE_URI);
    if (baseUriStored) {
      baseURI = baseUriStored;
    }
    return baseUriStored;
  } catch (e) {
    console.error(e);
    try {
      await AsyncStorage.setItem(GROUNDCONTROL_BASE_URI, groundControlUri);
    } catch (storageError) {
      console.error('Failed to reset URI:', storageError);
    }
    throw e;
  }
};

export const isNotificationsEnabled = async () => {
  try {
    const levels = await getLevels();
    const token = await getPushToken();
    const isDisabledByUser = (await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG)) === 'true';

    // Return true only if we have all requirements and user hasn't opted out
    return !isDisabledByUser && !!token && !!levels.level_all;
  } catch (error) {
    console.log('Error checking notification levels:', error);
    if (error instanceof SyntaxError) {
      throw error;
    }
    return false;
  }
};

export const getStoredNotifications = async (): Promise<TPayload[]> => {
  let notifications = [];
  try {
    notifications = JSON.parse(String(await AsyncStorage.getItem(NOTIFICATIONS_STORAGE)));
    if (!Array.isArray(notifications)) notifications = [];
  } catch (e) {
    if (e instanceof SyntaxError) {
      console.error('Invalid notifications format:', e);
      notifications = [];
      await AsyncStorage.setItem(NOTIFICATIONS_STORAGE, '[]');
    } else {
      console.error('Error accessing notifications:', e);
      throw e;
    }
  }

  return notifications;
};

// on app launch (load module):
export const initializeNotifications = async (onProcessNotifications?: () => void) => {
  console.debug('initializeNotifications: Starting initialization');
  try {
    const noAndDontAskFlag = await AsyncStorage.getItem(NOTIFICATIONS_NO_AND_DONT_ASK_FLAG);
    console.debug('initializeNotifications: No ask flag status:', noAndDontAskFlag);

    if (noAndDontAskFlag === 'true') {
      console.warn('User has opted out of notifications.');
      return;
    }

    const baseUriStored = await AsyncStorage.getItem(GROUNDCONTROL_BASE_URI);
    baseURI = baseUriStored || groundControlUri;
    console.debug('Base URI set to:', baseURI);

    setApplicationIconBadgeNumber(0);

    // Only check permissions, never request
    currentPermissionStatus = await checkNotificationPermissionStatus();
    console.debug('initializeNotifications: Permission status:', currentPermissionStatus);

    // Handle Android 13+ permissions differently
    const canProceed =
      Platform.OS === 'android'
        ? isNotificationsCapable && (await checkAndroidNotificationPermission())
        : currentPermissionStatus === 'granted';

    if (canProceed) {
      console.debug('initializeNotifications: Can proceed with notification setup');
      const token = await getPushToken();

      if (token) {
        console.debug('initializeNotifications: Existing token found, configuring');
        await configureNotifications(onProcessNotifications);
        await postTokenConfig();
      } else {
        console.debug('initializeNotifications: No token found, will request permissions');
        await tryToObtainPermissions();
      }
    } else {
      console.debug('Notifications require user action to enable');
    }
  } catch (error) {
    console.error('Failed to initialize notifications:', error);
    baseURI = groundControlUri;
    await AsyncStorage.setItem(GROUNDCONTROL_BASE_URI, groundControlUri).catch(err => console.error('Failed to reset URI:', err));
  }
};


================================================
FILE: ./malin_modules/base43.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import base from 'base-x';
import { uint8ArrayToHex } from './uint8array-extras/index';

const Base43 = {
  encode: function () {
    throw new Error('not implemented');
  },

  decode: function (input: string): string {
    const x = base('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$*+-./:');
    const uint8 = x.decode(input);
    return uint8ArrayToHex(uint8);
  },
};

export default Base43;


================================================
FILE: ./malin_modules/noble_ecc.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
/**
 * adapted from https://github.com/BitGo/BitGoJS/blob/bitcoinjs_lib_6_sync/modules/utxo-lib/src/noble_ecc.ts
 * license: Apache License
 *
 * @see https://github.com/bitcoinjs/tiny-secp256k1/issues/84#issuecomment-1185682315
 * @see https://github.com/bitcoinjs/bitcoinjs-lib/issues/1781
 */
import * as necc from '@noble/secp256k1';
import { TinySecp256k1Interface as TinySecp256k1InterfaceBIP32 } from 'bip32';
import { XOnlyPointAddTweakResult } from 'bitcoinjs-lib/src/types';
import { hmac } from '@noble/hashes/hmac';
import { sha256 } from '@noble/hashes/sha2';
import { TinySecp256k1Interface } from 'ecpair';

export interface TinySecp256k1InterfaceExtended {
  pointMultiply(p: Uint8Array, tweak: Uint8Array, compressed?: boolean): Uint8Array | null;

  pointAdd(pA: Uint8Array, pB: Uint8Array, compressed?: boolean): Uint8Array | null;

  isXOnlyPoint(p: Uint8Array): boolean;

  xOnlyPointAddTweak(p: Uint8Array, tweak: Uint8Array): XOnlyPointAddTweakResult | null;

  privateNegate(d: Uint8Array): Uint8Array;

  signDER(h: Uint8Array, d: Uint8Array, e?: Uint8Array): Uint8Array;
}

necc.utils.sha256Sync = (...messages: Uint8Array[]): Uint8Array => {
  const combinedMessages = messages.reduce((acc, msg) => {
    const newArray = new Uint8Array(acc.length + msg.length);
    newArray.set(acc);
    newArray.set(msg, acc.length);
    return newArray;
  }, new Uint8Array(0));
  return sha256(combinedMessages);
};

necc.utils.hmacSha256Sync = (key: Uint8Array, ...messages: Uint8Array[]): Uint8Array => {
  const combinedMessages = messages.reduce((acc, msg) => {
    const newArray = new Uint8Array(acc.length + msg.length);
    newArray.set(acc);
    newArray.set(msg, acc.length);
    return newArray;
  }, new Uint8Array(0));
  return hmac(sha256, key, combinedMessages);
};

/* const normal = necc.utils._normalizePrivateKey;
type Hex = string | Uint8Array;
type PrivKey = Hex | bigint | number;

necc.utils.privateAdd = (privateKey: PrivKey, tweak: Hex) => {
  console.log({ privateKey, tweak });
  const p = normal(privateKey);
  const t = normal(tweak);
  return necc.utils.privateAdd(necc.utils.mod(p + t, necc.CURVE.n));
}; */

const defaultTrue = (param?: boolean): boolean => param !== false;

function throwToNull<Type>(fn: () => Type): Type | null {
  try {
    return fn();
  } catch (e) {
    // console.log(e);
    return null;
  }
}

function isPoint(p: Uint8Array, xOnly: boolean): boolean {
  if ((p.length === 32) !== xOnly) return false;
  try {
    return !!necc.Point.fromHex(p);
  } catch (e) {
    return false;
  }
}

const ecc: TinySecp256k1InterfaceExtended & TinySecp256k1Interface & TinySecp256k1InterfaceBIP32 = {
  isPoint: (p: Uint8Array): boolean => isPoint(p, false),
  isPrivate: (d: Uint8Array): boolean => {
    /* if (
      [
        '0000000000000000000000000000000000000000000000000000000000000000',
        'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141',
        'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142',
      ].includes(d.toString('hex'))
    ) {
      return false;
    } */
    return necc.utils.isValidPrivateKey(d);
  },
  isXOnlyPoint: (p: Uint8Array): boolean => isPoint(p, true),

  xOnlyPointAddTweak: (p: Uint8Array, tweak: Uint8Array): { parity: 0 | 1; xOnlyPubkey: Uint8Array } | null =>
    throwToNull(() => {
      const P = necc.utils.pointAddScalar(p, tweak, true);
      const parity = P[0] % 2 === 1 ? 1 : 0;
      return { parity, xOnlyPubkey: P.slice(1) };
    }),

  pointFromScalar: (sk: Uint8Array, compressed?: boolean): Uint8Array | null =>
    throwToNull(() => necc.getPublicKey(sk, defaultTrue(compressed))),

  pointCompress: (p: Uint8Array, compressed?: boolean): Uint8Array => {
    return necc.Point.fromHex(p).toRawBytes(defaultTrue(compressed));
  },

  pointMultiply: (a: Uint8Array, tweak: Uint8Array, compressed?: boolean): Uint8Array | null =>
    throwToNull(() => necc.utils.pointMultiply(a, tweak, defaultTrue(compressed))),

  pointAdd: (a: Uint8Array, b: Uint8Array, compressed?: boolean): Uint8Array | null =>
    throwToNull(() => {
      const A = necc.Point.fromHex(a);
      const B = necc.Point.fromHex(b);
      return A.add(B).toRawBytes(defaultTrue(compressed));
    }),

  pointAddScalar: (p: Uint8Array, tweak: Uint8Array, compressed?: boolean): Uint8Array | null =>
    throwToNull(() => necc.utils.pointAddScalar(p, tweak, defaultTrue(compressed))),

  privateAdd: (d: Uint8Array, tweak: Uint8Array): Uint8Array | null =>
    throwToNull(() => {
      // console.log({ d, tweak });
      if (d.join('') === '00000000000000000000000000000001' && tweak.join('') === '00000000000000000000000000000000') {
        return new Uint8Array(d); // make test_ecc happy
      }

      const ret = necc.utils.privateAdd(d, tweak);
      // console.log(ret);
      if (ret.join('') === '00000000000000000000000000000000') {
        return null;
      }
      return ret;
    }),

  privateNegate: (d: Uint8Array): Uint8Array => necc.utils.privateNegate(d),

  sign: (h: Uint8Array, d: Uint8Array, e?: Uint8Array): Uint8Array => {
    return necc.signSync(h, d, { der: false, extraEntropy: e });
  },

  signDER: (h: Uint8Array, d: Uint8Array, e?: Uint8Array): Uint8Array => {
    return necc.signSync(h, d, { der: true, extraEntropy: e });
  },

  signSchnorr: (h: Uint8Array, d: Uint8Array, e: Uint8Array = new Uint8Array(32).fill(0x00)): Uint8Array => {
    return necc.schnorr.signSync(h, d, e);
  },

  verify: (h: Uint8Array, Q: Uint8Array, signature: Uint8Array, strict?: boolean): boolean => {
    return necc.verify(signature, h, Q, { strict });
  },

  verifySchnorr: (h: Uint8Array, Q: Uint8Array, signature: Uint8Array): boolean => {
    return necc.schnorr.verifySync(signature, h, Q);
  },
};

export default ecc;

// module.exports.ecc = ecc;


================================================
FILE: ./malin_modules/hapticFeedback.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import DeviceInfo, { PowerState } from 'react-native-device-info';
import ReactNativeHapticFeedback from 'react-native-haptic-feedback';
import { isDesktop } from './environment';

// Define a const enum for HapticFeedbackTypes
export const enum HapticFeedbackTypes {
  ImpactLight = 'impactLight',
  ImpactMedium = 'impactMedium',
  ImpactHeavy = 'impactHeavy',
  Selection = 'selection',
  NotificationSuccess = 'notificationSuccess',
  NotificationWarning = 'notificationWarning',
  NotificationError = 'notificationError',
}

const triggerHapticFeedback = (type: HapticFeedbackTypes) => {
  if (isDesktop) return;
  DeviceInfo.getPowerState().then((state: Partial<PowerState>) => {
    if (!state.lowPowerMode) {
      ReactNativeHapticFeedback.trigger(type, { ignoreAndroidSystemSettings: false, enableVibrateFallback: true });
    } else {
      console.log('Haptic feedback not triggered due to low power mode.');
    }
  });
};

export const triggerSuccessHapticFeedback = () => {
  triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
};

export const triggerWarningHapticFeedback = () => {
  triggerHapticFeedback(HapticFeedbackTypes.NotificationWarning);
};

export const triggerErrorHapticFeedback = () => {
  triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
};

export const triggerSelectionHapticFeedback = () => {
  triggerHapticFeedback(HapticFeedbackTypes.Selection);
};

export default triggerHapticFeedback;


================================================
FILE: ./malin_modules/SettingsModule.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { NativeModules, Platform } from 'react-native';

interface SettingsModuleInterface {
  /**
   * Initialize device UID if not exists
   * Returns the device UID or "Disabled" if Do Not Track is enabled
   */
  initializeDeviceUID(): Promise<string>;

  /**
   * Get the device UID
   * Returns the device UID or "Disabled" if Do Not Track is enabled
   */
  getDeviceUID(): Promise<string | null>;

  /**
   * Get the device UID copy (for Settings display)
   */
  getDeviceUIDCopy(): Promise<string>;

  /**
   * Set the clearFilesOnLaunch preference
   */
  setClearFilesOnLaunch(value: boolean): Promise<boolean>;

  /**
   * Get the clearFilesOnLaunch preference
   */
  getClearFilesOnLaunch(): Promise<boolean>;

  /**
   * Set Do Not Track setting
   */
  setDoNotTrack(enabled: boolean): Promise<boolean>;

  /**
   * Get Do Not Track setting
   */
  getDoNotTrack(): Promise<boolean>;

  /**
   * Open the settings activity (Android only)
   * This opens the app's settings screen
   */
  openSettings(): Promise<boolean>;
}

// Only available on Android
const SettingsModule: SettingsModuleInterface | null = Platform.OS === 'android' ? NativeModules.SettingsModule : null;

export default SettingsModule;


================================================
FILE: ./babel.config.js
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    [
      'module-resolver',
      {
        alias: {
          '@': './src',
          '@screens': './src/screens',
          '@components': './src/components',
          '@services': './src/services',
          '@utils': './src/utils',
          '@types': './src/types',
        },
      },
    ],
    'react-native-reanimated/plugin',
  ],
};

================================================
FILE: ./utils/isValidBech32Address.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';

export function isValidBech32Address(address: string): boolean {
  try {
    bitcoin.address.fromBech32(address);    
    return true;
  } catch (e) {
    return false;
  }
}

================================================
FILE: ./utils/combinePSBTs.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import * as bitcoin from 'bitcoinjs-lib';

/**
 * Combines two PSBTs and returns the combined PSBT.
 * @param {string} psbtBase64 - The base64 string of the first PSBT.
 * @param {string} newPSBTBase64 - The base64 string of the new PSBT to combine.
 * @returns {bitcoin.Psbt} - The combined PSBT.
 */
interface CombinePSBTsParams {
  psbtBase64: string;
  newPSBTBase64: string;
}

export const combinePSBTs = ({ psbtBase64, newPSBTBase64 }: CombinePSBTsParams): bitcoin.Psbt => {
  if (psbtBase64 === newPSBTBase64) {
    return bitcoin.Psbt.fromBase64(psbtBase64);
  }
  try {
    const psbt = bitcoin.Psbt.fromBase64(psbtBase64);
    const newPsbt = bitcoin.Psbt.fromBase64(newPSBTBase64);
    psbt.combine(newPsbt);
    return psbt;
  } catch (err) {
    console.error('Error combining PSBTs:', err);
    throw err;
  }
};


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/ThemeHelper.kt
================================================

package com.malinwallet.app

import android.content.Context
import android.content.res.Configuration
import androidx.appcompat.app.AppCompatDelegate

object ThemeHelper {
    private const val SHARED_PREF_NAME = "group.com.malinwallet.app"
    private const val KEY_FORCE_DARK_MODE = "force_dark_mode"

    /**
     * Check if dark mode is currently active
     * @param context Application context
     * @return true if dark mode is active, false otherwise
     */
    fun isDarkModeActive(context: Context): Boolean {
        val preferences = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
        val forceDarkMode = preferences.getBoolean(KEY_FORCE_DARK_MODE, false)

        return if (forceDarkMode) {
            true
        } else {
            val currentNightMode = context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
            currentNightMode == Configuration.UI_MODE_NIGHT_YES
        }
    }

    /**
     * Set the force dark mode option
     * @param context Application context
     * @param forceDarkMode Whether to force dark mode
     */
    fun setForceDarkMode(context: Context, forceDarkMode: Boolean) {
        context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            .edit()
            .putBoolean(KEY_FORCE_DARK_MODE, forceDarkMode)
            .apply()
            
        // Apply theme setting immediately
        AppCompatDelegate.setDefaultNightMode(
            if (forceDarkMode) AppCompatDelegate.MODE_NIGHT_YES 
            else AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM
        )
        
        // Update widgets with new theme
        updateAllWidgets(context)
    }
    
    /**
     * Get whether force dark mode is enabled
     * @param context Application context
     * @return true if force dark mode is enabled, false otherwise
     */
    fun isForceDarkModeEnabled(context: Context): Boolean {
        return context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            .getBoolean(KEY_FORCE_DARK_MODE, false)
    }
    
    /**
     * Update all widgets to reflect current theme
     * @param context Application context
     */
    fun updateAllWidgets(context: Context) {
        // Update Bitcoin Price Widgets
        val bitcoinPriceWidgetIds = AppWidgetUtils.getBitcoinPriceWidgetIds(context)
        if (bitcoinPriceWidgetIds.isNotEmpty()) {
            BitcoinPriceWidget.updateNetworkStatus(context, bitcoinPriceWidgetIds)
        }
        
        // Update Market Widgets
        val marketWidgetIds = MarketWidget.getAllWidgetIds(context)
        if (marketWidgetIds.isNotEmpty()) {
            MarketWidget.refreshAllWidgetsImmediately(context)
        }
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MarketWidget.kt
================================================

package com.malinwallet.app

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.util.Log
import android.view.View
import android.widget.RemoteViews
import androidx.work.WorkManager
import kotlinx.coroutines.delay
import org.json.JSONObject
import java.util.concurrent.TimeUnit
import com.malinwallet.app.ElectrumClient.ElectrumServer

class MarketWidget : AppWidgetProvider() {

    companion object {
        private const val TAG = "MarketWidget"
        private const val SHARED_PREF_NAME = "group.com.malinwallet.app"
        private const val DEFAULT_CURRENCY = "USD"
        private const val KEY_LAST_ONLINE_STATUS = "market_widget_last_online_status"

        private val hardcodedPeers = listOf(
            ElectrumServer("mainnet.foundationdevices.com", 50002, true),
            ElectrumServer("electrum1.malinwallet.io", 443, true),
            ElectrumServer("electrum.acinq.co", 50002, true),
            ElectrumServer("electrum.bitaroo.net", 50002, true)
        )

        private suspend fun connectToElectrumServer(): Boolean {
            for (peer in hardcodedPeers) {
                repeat(3) { attempt ->
                    Log.d(TAG, "Attempting to connect to Electrum server: ${peer.host}:${peer.port}, Attempt: ${attempt + 1}")
                    val success = ElectrumClient().connect(peer, validateCertificates = true)
                    if (success) {
                        Log.i(TAG, "Successfully connected to Electrum server: ${peer.host}:${peer.port}")
                        return true
                    } else {
                        Log.w(TAG, "Failed to connect to Electrum server: ${peer.host}:${peer.port}, Attempt: ${attempt + 1}")
                    }
                }
            }
            Log.e(TAG, "Failed to connect to any Electrum server from the hardcoded list after 3 attempts each. Waiting 10 minutes before retrying.")
            delay(10 * 60 * 1000) // Wait for 10 minutes
            return false
        }

        fun updateWidget(context: Context, appWidgetId: Int) {
            val appWidgetManager = AppWidgetManager.getInstance(context)
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
        
        fun updateAllWidgets(context: Context) {
            val widgetIds = getAllWidgetIds(context)
            if (widgetIds.isNotEmpty()) {
                MarketWidgetUpdateWorker.scheduleMarketUpdate(context)
            }
        }
        
        fun refreshAllWidgetsImmediately(context: Context) {
            val widgetIds = getAllWidgetIds(context)
            if (widgetIds.isNotEmpty()) {
                val appWidgetManager = AppWidgetManager.getInstance(context)
                for (widgetId in widgetIds) {
                    updateAppWidget(context, appWidgetManager, widgetId)
                }
                
                MarketWidgetUpdateWorker.scheduleMarketUpdate(context, forceUpdate = true)
                
                Log.d(TAG, "Scheduled immediate market widget update")
            }
        }
        
        fun getAllWidgetIds(context: Context): IntArray {
            val appWidgetManager = AppWidgetManager.getInstance(context)
            val thisWidget = ComponentName(context, MarketWidget::class.java)
            return appWidgetManager.getAppWidgetIds(thisWidget)
        }

        private fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) {
            Log.d(TAG, "Updating widget: $appWidgetId")
            
            // Check network connectivity
            val isNetworkAvailable = NetworkUtils.isNetworkAvailable(context)
            
            // Store connectivity status
            storeConnectivityStatus(context, isNetworkAvailable)
            
            // Get market data from shared preferences
            val marketData = getStoredMarketData(context)
            Log.d(TAG, "Retrieved market data for widget: $marketData")
            
            // Create RemoteViews to update the widget
            val views = RemoteViews(context.packageName, R.layout.widget_market)
            
            views.setViewVisibility(R.id.network_status, if (isNetworkAvailable) View.GONE else View.VISIBLE)
            
            // Add click intent to open the app
            val intent = Intent(context, MainActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or 
                        Intent.FLAG_ACTIVITY_CLEAR_TOP or 
                        Intent.FLAG_ACTIVITY_SINGLE_TOP
                action = Intent.ACTION_MAIN
                addCategory(Intent.CATEGORY_LAUNCHER)
            }
            
            val pendingIntent = PendingIntent.getActivity(
                context,
                0,
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            views.setOnClickPendingIntent(R.id.widget_market, pendingIntent)
            
            // Set the text for each view
            val formattedNextBlock = marketData.formattedNextBlock
            Log.d(TAG, "Setting next block value to: '$formattedNextBlock'")
            
            val displayText = when (formattedNextBlock) {
                "..." -> context.getString(R.string.loading_placeholder, "...")
                "!" -> context.getString(R.string.error_placeholder, "!")
                else -> formattedNextBlock
            }
            views.setTextViewText(R.id.next_block_value, displayText)
            
            // Get the user preferred currency
            val currency = getPreferredCurrency(context)
            views.setTextViewText(R.id.sats_label, context.getString(R.string.market_sats_label, currency))
            views.setTextViewText(R.id.sats_value, marketData.sats)
            views.setTextViewText(R.id.price_value, marketData.price)
            
            // Update the widget
            appWidgetManager.updateAppWidget(appWidgetId, views)
            
            // Schedule update if network available, otherwise retry in 30 seconds
            if (isNetworkAvailable) {
                MarketWidgetUpdateWorker.scheduleMarketUpdate(context)
            } else {
                MarketWidgetUpdateWorker.scheduleRetryOnNetworkAvailable(context)
            }
        }
        

        
        private fun storeConnectivityStatus(context: Context, isOnline: Boolean) {
            val sharedPrefs = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            sharedPrefs.edit().putBoolean(KEY_LAST_ONLINE_STATUS, isOnline).apply()
        }
        
        private fun getStoredMarketData(context: Context): MarketData {
            val sharedPrefs = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            val marketDataJson = sharedPrefs.getString(MarketData.PREF_KEY, null)
            
            Log.d(TAG, "Reading market data from preferences: $marketDataJson")
            
            return if (marketDataJson != null) {
                try {
                    val json = JSONObject(marketDataJson)
                    val nextBlock = json.optString("nextBlock", "...")
                    Log.d(TAG, "Retrieved nextBlock from storage: $nextBlock")
                    
                    MarketData(
                        nextBlock = nextBlock,
                        sats = json.optString("sats", "..."),
                        price = json.optString("price", "..."),
                        rate = json.optDouble("rate", 0.0),
                        dateString = json.optString("dateString", "")
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing stored market data", e)
                    MarketData()
                }
            } else {
                Log.d(TAG, "No market data found in preferences")
                MarketData()
            }
        }
        
        private fun getPreferredCurrency(context: Context): String {
            val sharedPrefs = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            val preferredCurrency = sharedPrefs.getString("preferredCurrency", null)
            return preferredCurrency ?: DEFAULT_CURRENCY // Default to USD if no currency is saved
        }
    }

    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)
        Log.d(TAG, "MarketWidget onUpdate called. Widget IDs: ${appWidgetIds.joinToString()}")
        
        for (appWidgetId in appWidgetIds) {
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
        
        MarketWidgetUpdateWorker.scheduleMarketUpdate(context)
    }

    override fun onEnabled(context: Context) {
        super.onEnabled(context)
        Log.d(TAG, "MarketWidget enabled - First widget added")
        val widgetIds = getAllWidgetIds(context)
        if (widgetIds.isNotEmpty()) {
            MarketWidgetUpdateWorker.scheduleMarketUpdate(context, forceUpdate = true)
        }
    }

    override fun onDisabled(context: Context) {
        super.onDisabled(context)
        Log.d(TAG, "MarketWidget disabled - Last widget removed")
        // Cancel all scheduled work when last widget is removed
        val workManager = WorkManager.getInstance(context)
        workManager.cancelUniqueWork(MarketWidgetUpdateWorker.WORK_NAME)
        workManager.cancelUniqueWork(MarketWidgetUpdateWorker.NETWORK_RETRY_WORK_NAME)
        
        // Clear cached data
        clearMarketData(context)
    }
    
    private fun clearMarketData(context: Context) {
        context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            .edit()
            .remove(MarketData.PREF_KEY)
            .remove(KEY_LAST_ONLINE_STATUS)
            .apply()
        Log.d(TAG, "Market widget data cleared")
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/SettingsActivity.kt
================================================

package com.malinwallet.app

import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.preference.PreferenceFragmentCompat

/**
 * Settings Activity accessible from Android System Settings
 */
class SettingsActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.settings_activity)
        
        Log.d("SettingsActivity", "Settings activity created")
        
        // Enable back button in action bar
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        
        if (savedInstanceState == null) {
            supportFragmentManager
                .beginTransaction()
                .replace(R.id.settings_container, SettingsFragment())
                .commit()
        }
    }

    override fun onSupportNavigateUp(): Boolean {
        finish()
        return true
    }

    class SettingsFragment : PreferenceFragmentCompat() {
        override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
            // Set the SharedPreferences name to match the app's preferences
            preferenceManager.sharedPreferencesName = "group.com.malinwallet.app"
            
            // Load preferences from XML
            setPreferencesFromResource(R.xml.settings_preferences, rootKey)
            
            Log.d("SettingsFragment", "Preferences loaded from XML")
            
            // Set up click listener for deviceUIDCopy to copy to clipboard
            val deviceUIDPref = findPreference<androidx.preference.Preference>("deviceUIDCopy")
            deviceUIDPref?.let { pref ->
                // Get the device UID from SharedPreferences
                val sharedPref = preferenceManager.sharedPreferences
                val deviceUID = sharedPref?.getString("deviceUIDCopy", "") ?: ""
                
                // Set the summary to show the UUID
                pref.summary = deviceUID
                
                // Check if report issue is disabled
                val isDisabled = deviceUID == "Disabled"
                
                // Make it non-selectable if disabled
                pref.isSelectable = !isDisabled
                
                // Set click listener to copy to clipboard (only if not disabled)
                if (!isDisabled) {
                    pref.setOnPreferenceClickListener {
                        if (deviceUID.isNotEmpty()) {
                            val clipboard = requireContext().getSystemService(android.content.Context.CLIPBOARD_SERVICE) 
                                as android.content.ClipboardManager
                            val clip = android.content.ClipData.newPlainText("Device UID", deviceUID)
                            clipboard.setPrimaryClip(clip)
                            
                            // Show a toast message
                            android.widget.Toast.makeText(
                                requireContext(),
                                R.string.copied_to_clipboard,
                                android.widget.Toast.LENGTH_SHORT
                            ).show()
                            
                            Log.d("SettingsFragment", "Device UID copied to clipboard: $deviceUID")
                        }
                        true
                    }
                }
            }
        }
    }
}



================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/SettingsPackage.kt
================================================

package com.malinwallet.app

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class SettingsPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(SettingsModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MarketData.kt
================================================

package com.malinwallet.app

import android.util.Log
import java.text.NumberFormat
import java.util.Locale
import java.util.Date

data class MarketData(
    var nextBlock: String = "...",
    var sats: String = "...",
    var price: String = "...",
    var rate: Double = 0.0,
    var dateString: String = ""
) {
    val formattedNextBlock: String
        get() {
            Log.d("MarketData", "Getting formatted next block from value: '$nextBlock'")
            return when (nextBlock) {
                "..." -> {
                    Log.d("MarketData", "Next block is a loading placeholder")
                    "..."
                }
                "!" -> {
                    Log.d("MarketData", "Next block is an error placeholder")
                    "!"
                }
                else -> {
                    try {
                        val nextBlockInt = nextBlock.toInt()
                        val numberFormatter = NumberFormat.getNumberInstance()
                        val formattedValue = "${numberFormatter.format(nextBlockInt)} sat/vb"
                        Log.d("MarketData", "Formatted next block: $formattedValue from $nextBlock")
                        formattedValue
                    } catch (e: Exception) {
                        Log.e("MarketData", "Error formatting next block value: '$nextBlock'", e)
                        "$nextBlock sat/vb"
                    }
                }
            }
        }
    
    val formattedDate: String?
        get() {
            if (dateString.isEmpty()) return null
            
            try {
                // Simple implementation - proper implementation would parse ISO8601
                return Date().toString()
            } catch (e: Exception) {
                return null
            }
        }
        
    companion object {
        const val PREF_KEY = "market_data"
    }
    
    override fun toString(): String {
        return "MarketData(nextBlock=$nextBlock, sats=$sats, price=$price, rate=$rate, formattedNextBlock=$formattedNextBlock)"
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/ThemeChangeReceiver.kt
================================================

package com.malinwallet.app

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.res.Configuration
import android.util.Log

/**
 * BroadcastReceiver to handle system theme changes (light/dark mode)
 */
class ThemeChangeReceiver : BroadcastReceiver() {
    companion object {
        private const val TAG = "ThemeChangeReceiver"
    }
    
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_CONFIGURATION_CHANGED) {
            val currentNightMode = context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
            
            if (!ThemeHelper.isForceDarkModeEnabled(context)) {
                Log.d(TAG, "Configuration changed, updating widgets for theme change")
                AppWidgetUtils.updateWidgetsForThemeChange(context)
            }
        }
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/AppWidgetUtils.kt
================================================

package com.malinwallet.app

import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi

object AppWidgetUtils {
    private const val TAG = "AppWidgetUtils"
    
    /**
     * Get all Bitcoin Price Widget IDs
     */
    fun getBitcoinPriceWidgetIds(context: Context): IntArray {
        val appWidgetManager = AppWidgetManager.getInstance(context)
        val component = ComponentName(context, BitcoinPriceWidget::class.java)
        return appWidgetManager.getAppWidgetIds(component)
    }
    
    /**
     * Trigger update for all widgets when theme changes
     */
    fun updateWidgetsForThemeChange(context: Context) {
        Log.d(TAG, "Updating widgets for theme change")
        
        // Update Bitcoin Price widgets - force a complete refresh
        val bitcoinWidgetIds = getBitcoinPriceWidgetIds(context)
        if (bitcoinWidgetIds.isNotEmpty()) {
            Log.d(TAG, "Refreshing ${bitcoinWidgetIds.size} Bitcoin Price widgets")
            for (widgetId in bitcoinWidgetIds) {
                BitcoinPriceWidget.refreshWidget(context, widgetId)
            }
        }
        
        // Update Market widgets
        val marketWidgetIds = MarketWidget.getAllWidgetIds(context)
        if (marketWidgetIds.isNotEmpty()) {
            Log.d(TAG, "Refreshing ${marketWidgetIds.size} Market widgets")
            MarketWidget.refreshAllWidgetsImmediately(context)
        }
    }
    
    /**
     * Check if app widgets are supported and available on this device
     */
    fun isWidgetAvailable(context: Context): Boolean {
        val appWidgetManager = AppWidgetManager.getInstance(context)
        return appWidgetManager != null
    }
    
    /**
     * Request to pin a widget to the home screen (Android 8.0+)
     */
    @RequiresApi(Build.VERSION_CODES.O)
    fun requestPinBitcoinWidget(context: Context): Boolean {
        val appWidgetManager = AppWidgetManager.getInstance(context)
        if (!appWidgetManager.isRequestPinAppWidgetSupported) {
            Log.w(TAG, "Pin widget not supported on this device")
            return false
        }
        
        val myProvider = ComponentName(context, BitcoinPriceWidget::class.java)
        return try {
            appWidgetManager.requestPinAppWidget(myProvider, null, null)
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to request pin widget", e)
            false
        }
    }
    
    /**
     * Request to pin a market widget to the home screen (Android 8.0+)
     */
    @RequiresApi(Build.VERSION_CODES.O)
    fun requestPinMarketWidget(context: Context): Boolean {
        val appWidgetManager = AppWidgetManager.getInstance(context)
        if (!appWidgetManager.isRequestPinAppWidgetSupported) {
            Log.w(TAG, "Pin widget not supported on this device")
            return false
        }
        
        val myProvider = ComponentName(context, MarketWidget::class.java)
        return try {
            appWidgetManager.requestPinAppWidget(myProvider, null, null)
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to request pin widget", e)
            false
        }
    }
    
    /**
     * Refresh all widgets by triggering updates
     */
    fun refreshAllWidgets(context: Context) {
        Log.d(TAG, "Refreshing all widgets")
        
        // Refresh Bitcoin Price widgets
        val bitcoinWidgetIds = getBitcoinPriceWidgetIds(context)
        if (bitcoinWidgetIds.isNotEmpty()) {
            for (widgetId in bitcoinWidgetIds) {
                BitcoinPriceWidget.refreshWidget(context, widgetId)
            }
        }
        
        // Refresh Market widgets
        val marketWidgetIds = MarketWidget.getAllWidgetIds(context)
        if (marketWidgetIds.isNotEmpty()) {
            MarketWidget.refreshAllWidgetsImmediately(context)
        }
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MainActivity.kt
================================================

package com.malinwallet.app

import android.content.Context
import android.content.pm.ActivityInfo
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.appcompat.app.AlertDialog
import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint
import com.facebook.react.defaults.DefaultReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.swmansion.rnscreens.fragment.restoration.RNScreensFragmentFactory

class MainActivity : ReactActivity() {

    /**
     * Returns the name of the main component registered from JavaScript.
     * This is used to schedule rendering of the component.
     */
    override fun getMainComponentName(): String {
        return "MalinWallet"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        // react-native-screens override
        supportFragmentManager.fragmentFactory = RNScreensFragmentFactory()
        super.onCreate(null)
        if (resources.getBoolean(R.bool.portrait_only)) {
            requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
        }
    }

    override fun onResume() {
        super.onResume()
        Log.d("MainActivity", "MainActivity resumed. Confirming single instance is active.")
        
        // Check if we should show cache cleared alert
        checkAndShowCacheClearedAlert()
    }
    
    private fun checkAndShowCacheClearedAlert() {
        val sharedPref = getSharedPreferences("group.com.malinwallet.app", Context.MODE_PRIVATE)
        val shouldShowAlert = sharedPref.getBoolean("shouldShowCacheClearedAlert", false)
        
        if (shouldShowAlert) {
            // Reset the flag
            sharedPref.edit()
                .putBoolean("shouldShowCacheClearedAlert", false)
                .apply()
            
            // Show alert after a short delay to ensure UI is ready
            Handler(Looper.getMainLooper()).postDelayed({
                AlertDialog.Builder(this)
                    .setTitle(R.string.cache_cleared_title)
                    .setMessage(R.string.cache_cleared_message)
                    .setPositiveButton(android.R.string.ok, null)
                    .show()
            }, 500)
        }
    }

    /**
     * Returns the instance of the [ReactActivityDelegate]. Here we use a util class [DefaultReactActivityDelegate]
     * which allows you to easily enable Fabric and Concurrent React (aka React 18) with two boolean flags.
     */

    override fun createReactActivityDelegate(): ReactActivityDelegate =
        DefaultReactActivityDelegate(this, mainComponentName, fabricEnabled)
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MarketWidgetUpdateWorker.kt
================================================

package com.malinwallet.app

import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.util.Log
import androidx.work.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.util.concurrent.TimeUnit

class MarketWidgetUpdateWorker(context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {

    companion object {
        const val TAG = "MarketWidgetUpdateWorker"
        const val WORK_NAME = "market_widget_update_work"
        const val NETWORK_RETRY_WORK_NAME = "market_network_retry_work"
        private const val SHARED_PREF_NAME = "group.com.malinwallet.app"
        private const val DEFAULT_CURRENCY = "USD"
        private const val KEY_LAST_UPDATE_TIME = "market_widget_last_update_time"
        private const val MIN_UPDATE_INTERVAL_MS = 15L * 60 * 1000
        private const val RATE_LIMIT_COOLDOWN_MS = 30L * 60 * 1000
        private const val NETWORK_RETRY_DELAY_SECONDS = 30L

        fun scheduleMarketUpdate(context: Context, forceUpdate: Boolean = false) {
            val sharedPrefs = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            val lastUpdateTime = sharedPrefs.getLong(KEY_LAST_UPDATE_TIME, 0)
            val currentTime = System.currentTimeMillis()
            
            if (!forceUpdate && currentTime - lastUpdateTime < MIN_UPDATE_INTERVAL_MS) {
                Log.d(TAG, "Skipping update - too soon since last update")
                return
            }
                
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
                
            val initialDelay = if (forceUpdate) 0 else calculateInitialDelay(context)
            
            val updateRequest = OneTimeWorkRequestBuilder<MarketWidgetUpdateWorker>()
                .setConstraints(constraints)
                .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30, TimeUnit.MINUTES)
                .build()
                
            WorkManager.getInstance(context).enqueueUniqueWork(
                WORK_NAME,
                ExistingWorkPolicy.REPLACE,
                updateRequest
            )
            
            Log.d(TAG, "Scheduled market widget update work with delay: ${initialDelay}ms")
        }
        
        /**
         * Calculate delay for rate limiting
         */
        private fun calculateInitialDelay(context: Context): Long {
            val sharedPrefs = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            val rateLimitedTime = sharedPrefs.getLong("market_widget_rate_limited_time", 0)
            val currentTime = System.currentTimeMillis()
            
            return if (rateLimitedTime > 0 && currentTime - rateLimitedTime < RATE_LIMIT_COOLDOWN_MS) {
                val remainingCooldown = RATE_LIMIT_COOLDOWN_MS - (currentTime - rateLimitedTime)
                Log.d(TAG, "Rate limit cooldown active, delaying for ${remainingCooldown}ms")
                remainingCooldown
            } else {
                0
            }
        }

        fun scheduleRetryOnNetworkAvailable(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
                
            val updateRequest = OneTimeWorkRequestBuilder<MarketWidgetUpdateWorker>()
                .setConstraints(constraints)
                .setInitialDelay(NETWORK_RETRY_DELAY_SECONDS, TimeUnit.SECONDS)
                .build()
                
            WorkManager.getInstance(context).enqueueUniqueWork(
                NETWORK_RETRY_WORK_NAME,
                ExistingWorkPolicy.REPLACE,
                updateRequest
            )
            
            Log.d(TAG, "Scheduled network retry in $NETWORK_RETRY_DELAY_SECONDS seconds")
        }
    }

    override suspend fun doWork(): Result {
        Log.d(TAG, "MarketWidgetUpdateWorker running. Confirming interaction with MainActivity.")
        return updateMarketWidgets()
    }

    private suspend fun updateMarketWidgets(): Result {
        Log.d(TAG, "Starting market widget update work")
        val widgetIds = MarketWidget.getAllWidgetIds(applicationContext)
        
        val currency = getPreferredCurrency(applicationContext)
        
        try {
            markUpdateTime()
            
            // Fetch market data
            Log.i(TAG, "About to call MarketAPI.fetchMarketData")
            val marketData = withContext(Dispatchers.IO) {
                MarketAPI.fetchMarketData(applicationContext, currency)
            }
            Log.i(TAG, "Received market data from API: $marketData with nextBlock=${marketData.nextBlock}")
            
            storeMarketData(marketData)
            Log.i(TAG, "Stored market data including nextBlock=${marketData.nextBlock}")
            
            for (widgetId in widgetIds) {
                MarketWidget.updateWidget(applicationContext, widgetId)
            }
            
            if (marketData.rate > 0) {
                clearRateLimitFlag()
                scheduleNextMarketUpdate(TimeUnit.MINUTES.toMillis(30))
                return Result.success()
            } else {
                Log.w(TAG, "Market data fetch returned invalid rate (${marketData.rate}), but fee may be available")
                scheduleNextMarketUpdate(TimeUnit.MINUTES.toMillis(15))
                return Result.retry()
            }
        } catch (e: RateLimitException) {
            Log.e(TAG, "Rate limit encountered", e)
            setRateLimitFlag()
            scheduleNextMarketUpdate(RATE_LIMIT_COOLDOWN_MS)
            return Result.failure()
        } catch (e: Exception) {
            Log.e(TAG, "Error updating market widget", e)
            scheduleNextMarketUpdate(TimeUnit.MINUTES.toMillis(15))
            return Result.retry()
        }
    }

    /**
     * Store market data in shared preferences
     */
    private fun storeMarketData(marketData: MarketData) {
        try {
            val json = JSONObject().apply {
                put("nextBlock", marketData.nextBlock)
                put("sats", marketData.sats)
                put("price", marketData.price)
                put("rate", marketData.rate)
                put("dateString", marketData.dateString)
            }
            
            val jsonString = json.toString()
            Log.d(TAG, "Storing market data JSON: $jsonString")
            
            applicationContext.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
                .edit()
                .putString(MarketData.PREF_KEY, jsonString)
                .apply()
                
            Log.d(TAG, "Stored market data: $marketData")
        } catch (e: Exception) {
            Log.e(TAG, "Error storing market data", e)
        }
    }
    
    private fun scheduleNextMarketUpdate(delayMs: Long) {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
            
        val updateRequest = OneTimeWorkRequestBuilder<MarketWidgetUpdateWorker>()
            .setConstraints(constraints)
            .setInitialDelay(delayMs, TimeUnit.MILLISECONDS)
            .build()
            
        WorkManager.getInstance(applicationContext).enqueueUniqueWork(
            WORK_NAME,
            ExistingWorkPolicy.REPLACE,
            updateRequest
        )
        
        Log.d(TAG, "Scheduled next market update with delay: ${delayMs}ms")
    }
    
    /**
     * Get user's preferred currency
     */
    private fun getPreferredCurrency(context: Context): String {
        val sharedPrefs = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
        return sharedPrefs.getString("preferredCurrency", DEFAULT_CURRENCY) ?: DEFAULT_CURRENCY
    }
    
    /**
     * Mark last update time
     */
    private fun markUpdateTime() {
        applicationContext.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            .edit()
            .putLong(KEY_LAST_UPDATE_TIME, System.currentTimeMillis())
            .apply()
    }
    
    /**
     * Set rate limit flag when API rate limit encountered
     */
    private fun setRateLimitFlag() {
        applicationContext.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            .edit()
            .putLong("market_widget_rate_limited_time", System.currentTimeMillis())
            .apply()
    }
    
    /**
     * Clear rate limit flag
     */
    private fun clearRateLimitFlag() {
        applicationContext.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            .edit()
            .remove("market_widget_rate_limited_time")
            .apply()
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/WidgetUpdateWorker.kt
================================================

package com.malinwallet.app

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.util.Log
import android.view.View
import android.widget.RemoteViews
import androidx.work.*
import java.text.DecimalFormatSymbols
import java.text.NumberFormat
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject

class WidgetUpdateWorker(context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {

    companion object {
        const val TAG = "WidgetUpdateWorker"
        const val WORK_NAME = "bitcoin_price_widget_update_work"
        const val NETWORK_RETRY_WORK_NAME = "bitcoin_price_network_retry_work"
        const val REPEAT_INTERVAL_MINUTES = 15L
        private const val SHARED_PREF_NAME = "group.com.malinwallet.app"
        private const val DEFAULT_CURRENCY = "USD"
        private const val NETWORK_RETRY_DELAY_SECONDS = 30L

        fun scheduleWork(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .setRequiresBatteryNotLow(false)
                .build()
                
            val workRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
                REPEAT_INTERVAL_MINUTES, TimeUnit.MINUTES
            )
                .setConstraints(constraints)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, WorkRequest.MIN_BACKOFF_MILLIS, TimeUnit.MILLISECONDS)
                .addTag(TAG)
                .build()
                
            WorkManager.getInstance(context).enqueueUniquePeriodicWork(
                WORK_NAME,
                ExistingPeriodicWorkPolicy.KEEP,
                workRequest
            )
        }
        
        fun scheduleImmediateUpdate(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
                
            val updateRequest = OneTimeWorkRequestBuilder<WidgetUpdateWorker>()
                .setConstraints(constraints)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, WorkRequest.MIN_BACKOFF_MILLIS, TimeUnit.MILLISECONDS)
                .addTag(TAG)
                .build()
                
            WorkManager.getInstance(context).enqueue(updateRequest)
        }

        fun scheduleRetryOnNetworkAvailable(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
                
            val updateRequest = OneTimeWorkRequestBuilder<WidgetUpdateWorker>()
                .setConstraints(constraints)
                .setInitialDelay(NETWORK_RETRY_DELAY_SECONDS, TimeUnit.SECONDS)
                .build()
                
            WorkManager.getInstance(context).enqueueUniqueWork(
                NETWORK_RETRY_WORK_NAME,
                ExistingWorkPolicy.REPLACE,
                updateRequest
            )
        }
    }

    private lateinit var sharedPref: SharedPreferences

    override suspend fun doWork(): Result {
        sharedPref = applicationContext.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
        
        if (!NetworkUtils.isNetworkAvailable(applicationContext)) {
            val component = ComponentName(applicationContext, BitcoinPriceWidget::class.java)
            val widgetIds = AppWidgetManager.getInstance(applicationContext).getAppWidgetIds(component)
            BitcoinPriceWidget.updateNetworkStatus(applicationContext, widgetIds)
            scheduleRetryOnNetworkAvailable(applicationContext)
            return Result.retry()
        }

        return updatePriceWidgets()
    }

    private suspend fun updatePriceWidgets(): Result {
        val appWidgetManager = AppWidgetManager.getInstance(applicationContext)
        val thisWidget = ComponentName(applicationContext, BitcoinPriceWidget::class.java)
        val appWidgetIds = appWidgetManager.getAppWidgetIds(thisWidget)
        val views = RemoteViews(applicationContext.packageName, R.layout.widget_layout)

        val intent = Intent(applicationContext, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP
            action = "android.intent.action.MAIN"
            addCategory("android.intent.category.LAUNCHER")
        }
        val pendingIntent = PendingIntent.getActivity(
            applicationContext,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        views.setOnClickPendingIntent(R.id.widget_layout, pendingIntent)

        views.setViewVisibility(R.id.loading_indicator, View.VISIBLE)
        views.setViewVisibility(R.id.price_value, View.GONE)
        views.setViewVisibility(R.id.last_updated_label, View.GONE)
        views.setViewVisibility(R.id.last_updated_time, View.GONE)
        views.setViewVisibility(R.id.price_arrow_container, View.GONE)

        appWidgetManager.updateAppWidget(appWidgetIds, views)

        val preferredCurrency = sharedPref.getString("preferredCurrency", null) ?: "USD"
        val preferredCurrencyLocale = sharedPref.getString("preferredCurrencyLocale", null) ?: "en-US"
        val previousPrice = sharedPref.getString("previous_price", null)

        val currentTime = SimpleDateFormat("hh:mm a", Locale.getDefault()).format(Date())

        val fetchedPrice = fetchPrice(preferredCurrency)

        // Check network connectivity
        val isNetworkAvailable = NetworkUtils.isNetworkAvailable(applicationContext)
        views.setViewVisibility(R.id.network_status, if (isNetworkAvailable) View.GONE else View.VISIBLE)

        handlePriceResult(
            appWidgetManager, appWidgetIds, views, sharedPref,
            fetchedPrice, previousPrice, currentTime, preferredCurrency, preferredCurrencyLocale
        )

        return Result.success()
    }

    private suspend fun fetchPrice(currency: String?): String? {
        return withContext(Dispatchers.IO) {
            MarketAPI.fetchPrice(applicationContext, currency ?: "USD")
        }
    }

    private fun handlePriceResult(
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray,
        views: RemoteViews,
        sharedPref: SharedPreferences,
        fetchedPrice: String?,
        previousPrice: String?,
        currentTime: String,
        preferredCurrency: String?,
        preferredCurrencyLocale: String?
    ) {
        val isPriceFetched = fetchedPrice != null
        val isPriceCached = previousPrice != null

        if (!isPriceFetched) {
            Log.e(TAG, "Error fetching price.")
            if (!isPriceCached) {
                showLoadingError(views)
            } else {
                displayCachedPrice(views, previousPrice, currentTime, preferredCurrency, preferredCurrencyLocale)
            }
        } else {
            if (fetchedPrice != null) {
                displayFetchedPrice(
                    views, fetchedPrice, previousPrice, currentTime, preferredCurrency, preferredCurrencyLocale
                )
            }
            if (fetchedPrice != null) {
                savePrice(sharedPref, fetchedPrice)
            }
        }

        appWidgetManager.updateAppWidget(appWidgetIds, views)
    }

    private fun showLoadingError(views: RemoteViews) {
        views.apply {
            setViewVisibility(R.id.loading_indicator, View.GONE)
            setViewVisibility(R.id.price_value, View.GONE)
            setViewVisibility(R.id.last_updated_label, View.GONE)
            setViewVisibility(R.id.last_updated_time, View.GONE)
            setViewVisibility(R.id.price_arrow_container, View.GONE)
        }
    }

    private fun displayCachedPrice(
        views: RemoteViews,
        previousPrice: String?,
        currentTime: String,
        preferredCurrency: String?,
        preferredCurrencyLocale: String?
    ) {
        val currencyFormat = getCurrencyFormat(preferredCurrency, preferredCurrencyLocale)

        views.apply {
            setViewVisibility(R.id.loading_indicator, View.GONE)
            setTextViewText(R.id.price_value, currencyFormat.format(previousPrice?.toDouble()?.toInt()))
            setTextViewText(R.id.last_updated_time, currentTime)
            setViewVisibility(R.id.price_value, View.VISIBLE)
            setViewVisibility(R.id.last_updated_label, View.VISIBLE)
            setViewVisibility(R.id.last_updated_time, View.VISIBLE)
            setViewVisibility(R.id.price_arrow_container, View.GONE)
        }
    }

    private fun displayFetchedPrice(
        views: RemoteViews,
        fetchedPrice: String,
        previousPrice: String?,
        currentTime: String,
        preferredCurrency: String?,
        preferredCurrencyLocale: String?
    ) {
        val currentPrice = fetchedPrice.toDouble().toInt()
        val currencyFormat = getCurrencyFormat(preferredCurrency, preferredCurrencyLocale)

        views.apply {
            setViewVisibility(R.id.loading_indicator, View.GONE)
            setTextViewText(R.id.price_value, currencyFormat.format(currentPrice))
            setTextViewText(R.id.last_updated_time, currentTime)
            setViewVisibility(R.id.price_value, View.VISIBLE)
            setViewVisibility(R.id.last_updated_label, View.VISIBLE)
            setViewVisibility(R.id.last_updated_time, View.VISIBLE)

            if (previousPrice != null) {
                setViewVisibility(R.id.price_arrow_container, View.VISIBLE)
                setTextViewText(R.id.previous_price, currencyFormat.format(previousPrice.toDouble().toInt()))
                setImageViewResource(
                    R.id.price_arrow,
                    if (currentPrice > previousPrice.toDouble().toInt()) android.R.drawable.arrow_up_float else android.R.drawable.arrow_down_float
                )
            } else {
                setViewVisibility(R.id.price_arrow_container, View.GONE)
            }
        }
    }

    private fun getCurrencyFormat(currencyCode: String?, localeString: String?): NumberFormat {
        val localeParts = localeString?.split("-") ?: listOf("en", "US")
        val locale = if (localeParts.size == 2) {
            Locale(localeParts[0], localeParts[1])
        } else {
            Locale.getDefault()
        }
        val currencyFormat = NumberFormat.getCurrencyInstance(locale)
        val currency = try {
            Currency.getInstance(currencyCode ?: "USD")
        } catch (e: IllegalArgumentException) {
            Currency.getInstance("USD")
        }
        currencyFormat.currency = currency
        currencyFormat.maximumFractionDigits = 0

        val decimalFormatSymbols = (currencyFormat as java.text.DecimalFormat).decimalFormatSymbols
        decimalFormatSymbols.currencySymbol = currency.symbol
        currencyFormat.decimalFormatSymbols = decimalFormatSymbols

        return currencyFormat
    }

    private fun savePrice(sharedPref: SharedPreferences, price: String) {
        sharedPref.edit().putString("previous_price", price).apply()
    }
}

================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/RateLimitException.kt
================================================

package com.malinwallet.app

/**
 * Exception thrown when an API rate limit is encountered
 */
class RateLimitException(message: String) : Exception(message)


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/components/segmentedcontrol/CustomSegmentedControlPackage.kt
================================================

package com.malinwallet.app.components.segmentedcontrol

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class CustomSegmentedControlPackage : ReactPackage {

    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return emptyList()
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return listOf(CustomSegmentedControlManager())
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/components/segmentedcontrol/CustomSegmentedControl.kt
================================================

package com.malinwallet.app.components.segmentedcontrol

import android.content.Context
import android.content.res.ColorStateList
import android.graphics.Color
import android.util.AttributeSet
import android.widget.LinearLayout
import androidx.core.content.ContextCompat
import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.ReactContext
import com.facebook.react.bridge.WritableMap
import com.facebook.react.uimanager.events.Event
import com.facebook.react.uimanager.UIManagerHelper
import com.google.android.material.button.MaterialButton
import com.google.android.material.button.MaterialButtonToggleGroup
import com.malinwallet.app.R

class CustomSegmentedControl @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : LinearLayout(context, attrs, defStyleAttr) {

    private val toggleGroup: MaterialButtonToggleGroup
    private var currentSelectedIndex: Int = 0
    private var onChangeEvent: ((WritableMap) -> Unit)? = null

    var values: Array<String> = emptyArray()
        set(value) {
            field = value
            updateSegments()
        }

    var selectedIndex: Int = 0
        set(value) {
            field = value
            currentSelectedIndex = value
            updateSelectedSegment()
        }

    init {
        orientation = HORIZONTAL
        toggleGroup = MaterialButtonToggleGroup(context).apply {
            isSingleSelection = true
            isSelectionRequired = true
        }
        addView(toggleGroup, LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        ))

        toggleGroup.addOnButtonCheckedListener { _, checkedId, isChecked ->
            if (isChecked) {
                val newIndex = findIndexById(checkedId)
                if (newIndex != -1 && newIndex != currentSelectedIndex) {
                    currentSelectedIndex = newIndex
                    emitChangeEvent(newIndex)
                }
            }
        }
    }

    private fun updateSegments() {
        toggleGroup.removeAllViews()
        
        values.forEachIndexed { index, title ->
            val button = MaterialButton(
                context,
                null,
                com.google.android.material.R.attr.materialButtonOutlinedStyle
            ).apply {
                text = title
                id = generateViewId()
                layoutParams = LinearLayout.LayoutParams(
                    0,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    1f
                )
                isCheckable = true
                
                strokeWidth = 2
                
                val cornerRadius = resources.getDimensionPixelSize(
                    com.google.android.material.R.dimen.mtrl_btn_corner_radius
                )
                
                when {
                    values.size == 1 -> {
                        this.cornerRadius = cornerRadius
                    }
                    index == 0 -> {
                        this.cornerRadius = cornerRadius
                    }
                    index == values.size - 1 -> {
                        this.cornerRadius = cornerRadius
                    }
                    else -> {
                        this.cornerRadius = 0
                    }
                }
            }
            
            toggleGroup.addView(button)
        }
        
        updateButtonColors()
        updateSelectedSegment()
    }

    private fun updateButtonColors() {
        for (i in 0 until toggleGroup.childCount) {
            val button = toggleGroup.getChildAt(i) as? MaterialButton ?: continue
            
            val selectedBgColor = ContextCompat.getColor(context, R.color.button_background_color)
            val unselectedBgColor = ContextCompat.getColor(context, R.color.button_disabled_background_color)
            val selectedTextColor = ContextCompat.getColor(context, R.color.button_text_color)
            val unselectedTextColor = ContextCompat.getColor(context, R.color.button_disabled_text_color)
            val borderColor = ContextCompat.getColor(context, R.color.form_border_color)
            val rippleColor = ContextCompat.getColor(context, R.color.ripple_color)
            val rippleColorSelected = ContextCompat.getColor(context, R.color.ripple_color_selected)
            
            val bgColorStateList = ColorStateList(
                arrayOf(
                    intArrayOf(android.R.attr.state_checked),
                    intArrayOf(-android.R.attr.state_checked)  
                ),
                intArrayOf(selectedBgColor, unselectedBgColor)
            )
            
            val textColorStateList = ColorStateList(
                arrayOf(
                    intArrayOf(android.R.attr.state_checked),  
                    intArrayOf(-android.R.attr.state_checked)  
                ),
                intArrayOf(selectedTextColor, unselectedTextColor)
            )
            
            val strokeColorStateList = ColorStateList(
                arrayOf(
                    intArrayOf(android.R.attr.state_checked),  
                    intArrayOf(-android.R.attr.state_checked)  
                ),
                intArrayOf(borderColor, borderColor)
            )
            
            val rippleColorStateList = ColorStateList(
                arrayOf(
                    intArrayOf(android.R.attr.state_checked),  
                    intArrayOf(-android.R.attr.state_checked)  
                ),
                intArrayOf(rippleColorSelected, rippleColor)
            )
            
            button.backgroundTintList = bgColorStateList
            button.setTextColor(textColorStateList)
            button.strokeColor = strokeColorStateList
            button.rippleColor = rippleColorStateList
        }
    }

    private fun updateSelectedSegment() {
        if (values.isNotEmpty() && currentSelectedIndex in 0 until values.size) {
            val buttonId = getButtonIdAtIndex(currentSelectedIndex)
            if (buttonId != -1) {
                toggleGroup.check(buttonId)
            }
        }
    }

    private fun findIndexById(id: Int): Int {
        for (i in 0 until toggleGroup.childCount) {
            if (toggleGroup.getChildAt(i).id == id) {
                return i
            }
        }
        return -1
    }

    private fun getButtonIdAtIndex(index: Int): Int {
        return if (index in 0 until toggleGroup.childCount) {
            toggleGroup.getChildAt(index).id
        } else {
            -1
        }
    }

    private fun emitChangeEvent(selectedIndex: Int) {
        val reactContext = context as? ReactContext ?: return
        val surfaceId = UIManagerHelper.getSurfaceId(reactContext)
        val eventDispatcher = UIManagerHelper.getEventDispatcherForReactTag(reactContext, id)
        
        val event = Arguments.createMap().apply {
            putInt("selectedIndex", selectedIndex)
        }
        
        eventDispatcher?.dispatchEvent(ChangeEvent(surfaceId, id, event))
    }

    private inner class ChangeEvent(
        surfaceId: Int,
        viewId: Int,
        private val eventData: WritableMap
    ) : Event<ChangeEvent>(surfaceId, viewId) {
        
        override fun getEventName(): String = "onChangeEvent"
        
        override fun getEventData(): WritableMap = eventData
    }

    fun setOnChangeEvent(callback: ((WritableMap) -> Unit)?) {
        onChangeEvent = callback
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/components/segmentedcontrol/CustomSegmentedControlManager.kt
================================================

package com.malinwallet.app.components.segmentedcontrol

import com.facebook.react.bridge.ReadableArray
import com.facebook.react.common.MapBuilder
import com.facebook.react.uimanager.SimpleViewManager
import com.facebook.react.uimanager.ThemedReactContext
import com.facebook.react.uimanager.annotations.ReactProp

class CustomSegmentedControlManager : SimpleViewManager<CustomSegmentedControl>() {

    companion object {
        const val REACT_CLASS = "CustomSegmentedControl"
        private const val ON_CHANGE_EVENT = "onChangeEvent"
    }

    override fun getName(): String = REACT_CLASS

    override fun createViewInstance(reactContext: ThemedReactContext): CustomSegmentedControl {
        return CustomSegmentedControl(reactContext)
    }

    @ReactProp(name = "values")
    fun setValues(view: CustomSegmentedControl, values: ReadableArray?) {
        val valuesArray = values?.let { array ->
            Array(array.size()) { index ->
                array.getString(index) ?: ""
            }
        } ?: emptyArray()
        
        view.values = valuesArray
    }

    @ReactProp(name = "selectedIndex", defaultInt = 0)
    fun setSelectedIndex(view: CustomSegmentedControl, selectedIndex: Int) {
        view.selectedIndex = selectedIndex
    }

    override fun getExportedCustomDirectEventTypeConstants(): Map<String, Any>? {
        return MapBuilder.builder<String, Any>()
            .put(ON_CHANGE_EVENT, MapBuilder.of("registrationName", ON_CHANGE_EVENT))
            .build()
    }

    override fun onAfterUpdateTransaction(view: CustomSegmentedControl) {
        super.onAfterUpdateTransaction(view)
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/ElectrumClient.kt
================================================

package com.malinwallet.app

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.OutputStream
import java.net.Socket
import java.net.SocketTimeoutException
import java.security.SecureRandom
import java.security.cert.X509Certificate
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocket
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager

class ElectrumClient {
    companion object {
        private const val TAG = "ElectrumClient"
        private const val MAX_RETRIES = 3
        private const val RETRY_DELAY_MS = 1000L // 1 second delay between retries
        
        // Default list of Electrum servers to try
        val hardcodedPeers = listOf(
            ElectrumServer("electrum1.malinwallet.io", 50001, false),
            ElectrumServer("electrum2.malinwallet.io", 50001, false),
            ElectrumServer("electrum3.malinwallet.io", 50001, false),
            ElectrumServer("electrum1.malinwallet.io", 443, true),
            ElectrumServer("electrum2.malinwallet.io", 443, true),
            ElectrumServer("electrum3.malinwallet.io", 443, true)
        )
    }

    private var socket: Socket? = null
    private var outputStream: OutputStream? = null
    private var inputReader: BufferedReader? = null
    private var context: Context? = null
    private var networkStatusListener: NetworkStatusListener? = null
    
    data class ElectrumServer(val host: String, val port: Int, val isSsl: Boolean)
    
    /**
     * Initialize ElectrumClient with application context for network checks
     */
    fun initialize(context: Context) {
        Log.i(TAG, "Initializing ElectrumClient with context")
        this.context = context
    }
    
    /**
     * Set a listener for network status changes
     */
    fun setNetworkStatusListener(listener: NetworkStatusListener) {
        Log.d(TAG, "Setting network status listener")
        this.networkStatusListener = listener
    }
    
    /**
     * Interface for listening to network status changes
     */
    interface NetworkStatusListener {
        fun onNetworkStatusChanged(isConnected: Boolean)
        fun onConnectionError(error: String)
        fun onConnectionSuccess()
    }
    
    /**
     * Check if the device has network connectivity
     */
    private fun isNetworkAvailable(): Boolean {
        val hasNetwork = context?.let { NetworkUtils.isNetworkAvailable(it) } ?: false
        Log.d(TAG, "Network available: $hasNetwork")
        return hasNetwork
    }
    
    /**
     * Connect to the next available Electrum server with network checks
     */
    suspend fun connectToNextAvailable(
        servers: List<ElectrumServer> = hardcodedPeers,
        validateCertificates: Boolean = true,
        connectTimeout: Long = 5000 // 5 seconds
    ): Boolean = withContext(Dispatchers.IO) {
        val startTime = System.currentTimeMillis()
        Log.i(TAG, "Starting connection attempt to Electrum server. Server count: ${servers.size}")
        
        // Check network availability first
        if (!isNetworkAvailable()) {
            Log.e(TAG, "No network connection available. Connection attempt aborted.")
            networkStatusListener?.onNetworkStatusChanged(false)
            return@withContext false
        }
        
        var connected = false
        var lastError: Exception? = null
        
        for (serverIndex in servers.indices) {
            val server = servers[serverIndex]
            if (connected) break
            
            Log.d(TAG, "Trying server ${serverIndex+1}/${servers.size}: ${server.host}:${server.port} (SSL: ${server.isSsl})")
            
            // Try up to MAX_RETRIES times per server
            for (attempt in 1..MAX_RETRIES) {
                try {
                    Log.d(TAG, "Connection attempt $attempt/$MAX_RETRIES to ${server.host}:${server.port} (SSL: ${server.isSsl})")
                    val attemptStartTime = System.currentTimeMillis()
                    
                    withTimeout(connectTimeout) {
                        if (connect(server, validateCertificates)) {
                            val attemptDuration = System.currentTimeMillis() - attemptStartTime
                            Log.i(TAG, "Successfully connected to ${server.host}:${server.port} in ${attemptDuration}ms")
                            networkStatusListener?.onConnectionSuccess()
                            connected = true
                        } else {
                            Log.w(TAG, "Failed to connect to ${server.host}:${server.port} - connect() returned false")
                        }
                    }
                } catch (e: TimeoutCancellationException) {
                    lastError = e
                    Log.e(TAG, "Connection to ${server.host}:${server.port} timed out after ${connectTimeout}ms (attempt $attempt)")
                    if (attempt < MAX_RETRIES) {
                        Log.d(TAG, "Retrying after ${RETRY_DELAY_MS}ms delay")
                        delay(RETRY_DELAY_MS)
                    }
                } catch (e: Exception) {
                    lastError = e
                    Log.e(TAG, "Error connecting to ${server.host}:${server.port} (attempt $attempt): ${e.message}")
                    if (attempt < MAX_RETRIES) {
                        Log.d(TAG, "Retrying after ${RETRY_DELAY_MS}ms delay")
                        delay(RETRY_DELAY_MS)
                    }
                }
            }
        }
        
        val totalDuration = System.currentTimeMillis() - startTime
        
        if (!connected) {
            Log.e(TAG, "Failed to connect to any Electrum server after ${totalDuration}ms. Last error: ${lastError?.message}")
            networkStatusListener?.onConnectionError("Failed to connect to any Electrum server: ${lastError?.message}")
        } else {
            Log.i(TAG, "Successfully connected to an Electrum server in ${totalDuration}ms")
        }
        
        connected
    }
    
    /**
     * Log the server details upon successful connection
     */
    private fun logServerDetails(server: ElectrumServer) {
        Log.i(TAG, "Connected to Electrum server: ${server.host}:${server.port} (SSL: ${server.isSsl})")
    }

    /**
     * Connect to a specific Electrum server with network check
     */
    suspend fun connect(
        server: ElectrumServer,
        validateCertificates: Boolean = true
    ): Boolean = withContext(Dispatchers.IO) {
        val startTime = System.currentTimeMillis()
        Log.d(TAG, "Attempting direct connection to ${server.host}:${server.port} (SSL: ${server.isSsl})")

        var result = false

        if (!isNetworkAvailable()) {
            Log.e(TAG, "Cannot connect to ${server.host}: No network connection available")
            networkStatusListener?.onNetworkStatusChanged(false)
            return@withContext false
        }

        try {
            close() // Close any existing connection
            Log.d(TAG, "Creating ${if (server.isSsl) "SSL " else ""}socket to ${server.host}:${server.port}")

            socket = if (server.isSsl) {
                createSslSocket(server.host, server.port, validateCertificates)
            } else {
                Socket(server.host, server.port)
            }

            Log.d(TAG, "Socket created successfully. Setting timeout and getting streams.")
            socket?.soTimeout = 10000 // 10 seconds read timeout
            outputStream = socket?.getOutputStream()
            inputReader = BufferedReader(InputStreamReader(socket?.getInputStream()))

            // Testing the connection with simple version request
            val versionRequest = "{\"id\": 0, \"method\": \"server.version\", \"params\": [\"MalinWallet\", \"1.4\"]}\n"
            Log.d(TAG, "Sending version request to verify connection")
            send(versionRequest.toByteArray())

            val response = receive()
            if (response.isNotEmpty()) {
                val responseStr = String(response)
                Log.d(TAG, "Received server version response: $responseStr")
                networkStatusListener?.onNetworkStatusChanged(true)
                logServerDetails(server) // Log server details here
                result = true
            } else {
                Log.w(TAG, "Empty response from server when verifying connection")
                networkStatusListener?.onConnectionError("Empty response from server")
                close()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error connecting to Electrum server: ${e.javaClass.simpleName} - ${e.message}")
            networkStatusListener?.onConnectionError("Error connecting: ${e.message}")
            close()
        }

        val duration = System.currentTimeMillis() - startTime
        Log.d(TAG, "Connection attempt to ${server.host}:${server.port} completed in ${duration}ms, result: $result")

        result
    }
    
    /**
     * Send data to the connected Electrum server with network check
     */
    suspend fun send(data: ByteArray): Boolean = withContext(Dispatchers.IO) {
        val message = String(data).trim()
        val messagePreview = if (message.length > 100) message.substring(0, 100) + "..." else message
        Log.d(TAG, "Sending to Electrum: $messagePreview")
        
        if (!isNetworkAvailable()) {
            Log.e(TAG, "Cannot send data: No network connection available")
            networkStatusListener?.onNetworkStatusChanged(false)
            return@withContext false
        }
        
        try {
            outputStream?.write(data)
            outputStream?.flush()
            Log.d(TAG, "Data sent successfully")
            return@withContext true
        } catch (e: Exception) {
            Log.e(TAG, "Error sending data to Electrum server: ${e.javaClass.simpleName} - ${e.message}")
            networkStatusListener?.onConnectionError("Error sending data: ${e.message}")
            return@withContext false
        }
    }
    
    /**
     * Receive data from the connected Electrum server with timeout handling
     */
    suspend fun receive(): ByteArray = withContext(Dispatchers.IO) {
        Log.d(TAG, "Waiting to receive data from Electrum server")
        val startTime = System.currentTimeMillis()
        
        try {
            val response = StringBuilder()
            var line: String? = null
            
            try {
                while (inputReader?.readLine()?.also { line = it } != null) {
                    response.append(line)
                    // Break after receiving a complete JSON object
                    if (line?.contains("}") == true) {
                        break
                    }
                }
            } catch (e: SocketTimeoutException) {
                Log.e(TAG, "Socket read timed out after ${System.currentTimeMillis() - startTime}ms")
                networkStatusListener?.onConnectionError("Socket read timed out")
            }
            
            val responseData = response.toString().toByteArray()
            val responsePreview = if (response.length > 100) response.substring(0, 100) + "..." else response.toString()
            
            if (responseData.isNotEmpty()) {
                val duration = System.currentTimeMillis() - startTime
                Log.d(TAG, "Received data (${responseData.size} bytes) in ${duration}ms: $responsePreview")
            } else {
                Log.w(TAG, "Received empty response from Electrum server")
            }
            
            return@withContext responseData
        } catch (e: Exception) {
            Log.e(TAG, "Error receiving data from Electrum server: ${e.javaClass.simpleName} - ${e.message}")
            networkStatusListener?.onConnectionError("Error receiving data: ${e.message}")
            return@withContext ByteArray(0)
        }
    }
    
    /**
     * Close the connection to the Electrum server
     */
    fun close() {
        try {
            inputReader?.close()
            outputStream?.close()
            socket?.close()
        } catch (e: Exception) {
            Log.e(TAG, "Error closing Electrum connection", e)
        } finally {
            inputReader = null
            outputStream = null
            socket = null
        }
    }
    
    /**
     * Create an SSL socket with optional certificate validation
     */
    private fun createSslSocket(host: String, port: Int, validateCertificates: Boolean): SSLSocket {
        val sslContext = SSLContext.getInstance("TLS")
        
        if (!validateCertificates) {
            val trustAllCerts = arrayOf<TrustManager>(object : X509TrustManager {
                override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
                override fun checkClientTrusted(certs: Array<X509Certificate>, authType: String) {}
                override fun checkServerTrusted(certs: Array<X509Certificate>, authType: String) {}
            })
            
            sslContext.init(null, trustAllCerts, SecureRandom())
        } else {
            sslContext.init(null, null, null)
        }
        
        val factory: SSLSocketFactory = sslContext.socketFactory
        return factory.createSocket(host, port) as SSLSocket
    }

    private fun getNextPeer(): ElectrumServer {
        val savedPeer = getSavedPeer()
        return if (savedPeer != null) {
            Log.d(TAG, "Using saved peer: ${savedPeer.host}:${savedPeer.port} (SSL: ${savedPeer.isSsl})")
            savedPeer
        } else {
            Log.d(TAG, "No saved peer found. Using default hardcoded peers.")
            hardcodedPeers.random()
        }
    }

 
    private fun getSavedPeer(): ElectrumServer? {
        // implement later
        return null
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/SettingsModule.kt
================================================

package com.malinwallet.app

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.Promise
import java.util.UUID

class SettingsModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {

    private val sharedPref: SharedPreferences = reactContext.getSharedPreferences(
        "group.com.malinwallet.app",
        Context.MODE_PRIVATE
    )
    
    companion object {
        private const val TAG = "SettingsModule"
        private const val DEVICE_UID_KEY = "deviceUID"
        private const val DEVICE_UID_COPY_KEY = "deviceUIDCopy"
        private const val CLEAR_FILES_ON_LAUNCH_KEY = "clearFilesOnLaunch"
        private const val DO_NOT_TRACK_KEY = "donottrack"
    }

    override fun getName(): String {
        return "SettingsModule"
    }

    /**
     * Initialize device UID if not exists
     * Uses the same Android ID as react-native-device-info's getUniqueId()
     */
    @ReactMethod
    fun initializeDeviceUID(promise: Promise) {
        try {
            val isDoNotTrackEnabled = sharedPref.getString(DO_NOT_TRACK_KEY, "0") == "1"
            
            if (isDoNotTrackEnabled) {
                // Set deviceUIDCopy to "Disabled" if Do Not Track is enabled
                val currentCopy = sharedPref.getString(DEVICE_UID_COPY_KEY, "")
                if (currentCopy != "Disabled") {
                    sharedPref.edit()
                        .putString(DEVICE_UID_COPY_KEY, "Disabled")
                        .apply()
                    Log.d(TAG, "Do Not Track enabled - set deviceUIDCopy to 'Disabled'")
                }
                promise.resolve("Disabled")
                return
            }
            
            // Get the Android ID (same as react-native-device-info's getUniqueId())
            val deviceUID = try {
                android.provider.Settings.Secure.getString(
                    reactApplicationContext.contentResolver,
                    android.provider.Settings.Secure.ANDROID_ID
                ) ?: "unknown"
            } catch (e: Exception) {
                Log.e(TAG, "Error getting Android ID", e)
                "unknown"
            }
            
            // Store in deviceUID for consistency
            sharedPref.edit()
                .putString(DEVICE_UID_KEY, deviceUID)
                .apply()
            
            // Copy deviceUID to deviceUIDCopy (for Settings.bundle compatibility)
            val currentCopy = sharedPref.getString(DEVICE_UID_COPY_KEY, "")
            if (deviceUID != currentCopy) {
                sharedPref.edit()
                    .putString(DEVICE_UID_COPY_KEY, deviceUID)
                    .apply()
                Log.d(TAG, "Synced deviceUID to deviceUIDCopy: $deviceUID")
            }
            
            promise.resolve(deviceUID)
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing deviceUID", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Get the device UID
     */
    @ReactMethod
    fun getDeviceUID(promise: Promise) {
        try {
            val isDoNotTrackEnabled = sharedPref.getString(DO_NOT_TRACK_KEY, "0") == "1"
            
            if (isDoNotTrackEnabled) {
                promise.resolve("Disabled")
                return
            }
            
            val deviceUID = sharedPref.getString(DEVICE_UID_KEY, null)
            promise.resolve(deviceUID)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting deviceUID", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Get the device UID copy (for Settings display)
     */
    @ReactMethod
    fun getDeviceUIDCopy(promise: Promise) {
        try {
            val deviceUIDCopy = sharedPref.getString(DEVICE_UID_COPY_KEY, "")
            promise.resolve(deviceUIDCopy)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting deviceUIDCopy", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Set the clearFilesOnLaunch preference
     */
    @ReactMethod
    fun setClearFilesOnLaunch(value: Boolean, promise: Promise) {
        try {
            sharedPref.edit()
                .putBoolean(CLEAR_FILES_ON_LAUNCH_KEY, value)
                .apply()
            Log.d(TAG, "Set clearFilesOnLaunch to: $value")
            promise.resolve(value)
        } catch (e: Exception) {
            Log.e(TAG, "Error setting clearFilesOnLaunch", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Get the clearFilesOnLaunch preference
     */
    @ReactMethod
    fun getClearFilesOnLaunch(promise: Promise) {
        try {
            val value = sharedPref.getBoolean(CLEAR_FILES_ON_LAUNCH_KEY, false)
            promise.resolve(value)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting clearFilesOnLaunch", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Set Do Not Track setting
     */
    @ReactMethod
    fun setDoNotTrack(enabled: Boolean, promise: Promise) {
        try {
            val value = if (enabled) "1" else "0"
            sharedPref.edit()
                .putString(DO_NOT_TRACK_KEY, value)
                .apply()
            
            Log.d(TAG, "Set donottrack to: $value")
            
            // Update deviceUIDCopy based on Do Not Track setting
            if (enabled) {
                sharedPref.edit()
                    .putString(DEVICE_UID_COPY_KEY, "Disabled")
                    .apply()
                Log.d(TAG, "Do Not Track enabled - set deviceUIDCopy to 'Disabled'")
            } else {
                // Re-initialize device UID
                initializeDeviceUID(promise)
                return
            }
            
            promise.resolve(enabled)
        } catch (e: Exception) {
            Log.e(TAG, "Error setting donottrack", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Get Do Not Track setting
     */
    @ReactMethod
    fun getDoNotTrack(promise: Promise) {
        try {
            val value = sharedPref.getString(DO_NOT_TRACK_KEY, "0")
            val enabled = value == "1"
            promise.resolve(enabled)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting donottrack", e)
            promise.reject("ERROR", e.message)
        }
    }

    /**
     * Open the settings activity from JavaScript
     */
    @ReactMethod
    fun openSettings(promise: Promise) {
        try {
            val intent = android.content.Intent(reactApplicationContext, SettingsActivity::class.java)
            intent.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK)
            reactApplicationContext.startActivity(intent)
            promise.resolve(true)
        } catch (e: Exception) {
            Log.e(TAG, "Error opening settings", e)
            promise.reject("ERROR", e.message)
        }
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/NetworkUtils.kt
================================================

package com.malinwallet.app

import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Build

object NetworkUtils {
    /**
     * Check if the device has an active network connection
     * @param context Application context
     * @return true if connected, false otherwise
     */
    fun isNetworkAvailable(context: Context): Boolean {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val network = connectivityManager.activeNetwork ?: return false
            val activeNetwork = connectivityManager.getNetworkCapabilities(network) ?: return false
            
            when {
                activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> true
                activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> true
                activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -> true
                else -> false
            }
        } else {
            @Suppress("DEPRECATION")
            connectivityManager.activeNetworkInfo?.isConnected ?: false
        }
    }
}


================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/BitcoinPriceWidget.kt
================================================

package com.malinwallet.app

import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.RemoteViews
import androidx.work.WorkManager

class BitcoinPriceWidget : AppWidgetProvider() {

    companion object {
        private const val TAG = "BitcoinPriceWidget"
        private const val SHARED_PREF_NAME = "group.com.malinwallet.app"
        
        fun updateNetworkStatus(context: Context, appWidgetIds: IntArray) {
            val isNetworkAvailable = NetworkUtils.isNetworkAvailable(context)
            val appWidgetManager = AppWidgetManager.getInstance(context)
            
            for (appWidgetId in appWidgetIds) {
                val views = RemoteViews(context.packageName, R.layout.widget_layout)
                views.setViewVisibility(R.id.network_status, if (isNetworkAvailable) View.GONE else View.VISIBLE)
                appWidgetManager.partiallyUpdateAppWidget(appWidgetId, views)
            }
        }

        fun refreshWidget(context: Context, appWidgetId: Int) {
            val appWidgetManager = AppWidgetManager.getInstance(context)
            
            // Create new RemoteViews to ensure it picks up current theme
            val views = RemoteViews(context.packageName, R.layout.widget_layout)
            
            // Set network status
            val isNetworkAvailable = NetworkUtils.isNetworkAvailable(context)
            views.setViewVisibility(R.id.network_status, if (isNetworkAvailable) View.GONE else View.VISIBLE)
            
            // Try to load cached data first
            val sharedPref = context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
            val cachedPrice = sharedPref.getString("previous_price", null)
            
            if (cachedPrice != null) {
                // Show cached data immediately
                val preferredCurrency = sharedPref.getString("preferredCurrency", "USD")
                val preferredCurrencyLocale = sharedPref.getString("preferredCurrencyLocale", "en-US")
                
                try {
                    val localeParts = preferredCurrencyLocale?.split("-") ?: listOf("en", "US")
                    val locale = if (localeParts.size == 2) {
                        java.util.Locale(localeParts[0], localeParts[1])
                    } else {
                        java.util.Locale.getDefault()
                    }
                    val currencyFormat = java.text.NumberFormat.getCurrencyInstance(locale)
                    val currency = java.util.Currency.getInstance(preferredCurrency ?: "USD")
                    currencyFormat.currency = currency
                    currencyFormat.maximumFractionDigits = 0
                    
                    views.setViewVisibility(R.id.loading_indicator, View.GONE)
                    views.setViewVisibility(R.id.price_value, View.VISIBLE)
                    views.setViewVisibility(R.id.last_updated_label, View.VISIBLE)
                    views.setViewVisibility(R.id.last_updated_time, View.VISIBLE)
                    views.setTextViewText(R.id.price_value, currencyFormat.format(cachedPrice.toDouble().toInt()))
                    views.setTextViewText(R.id.last_updated_time, java.text.SimpleDateFormat("hh:mm a", java.util.Locale.getDefault()).format(java.util.Date()))
                    views.setViewVisibility(R.id.price_arrow_container, View.GONE)
                } catch (e: Exception) {
                    Log.e(TAG, "Error displaying cached price", e)
                    // Show loading state if cache display fails
                    views.setViewVisibility(R.id.loading_indicator, View.VISIBLE)
                    views.setViewVisibility(R.id.price_value, View.GONE)
                    views.setViewVisibility(R.id.last_updated_label, View.GONE)
                    views.setViewVisibility(R.id.last_updated_time, View.GONE)
                    views.setViewVisibility(R.id.price_arrow_container, View.GONE)
                }
            } else {
                // No cached data, show loading state
                views.setViewVisibility(R.id.loading_indicator, View.VISIBLE)
                views.setViewVisibility(R.id.price_value, View.GONE)
                views.setViewVisibility(R.id.last_updated_label, View.GONE)
                views.setViewVisibility(R.id.last_updated_time, View.GONE)
                views.setViewVisibility(R.id.price_arrow_container, View.GONE)
            }
            
            appWidgetManager.updateAppWidget(appWidgetId, views)
            WidgetUpdateWorker.scheduleImmediateUpdate(context)
            WidgetUpdateWorker.scheduleWork(context)
        }
    }

    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)
        
        for (widgetId in appWidgetIds) {
            Log.d(TAG, "Updating widget with ID: $widgetId")
            refreshWidget(context, widgetId)
        }
    }

    override fun onEnabled(context: Context) {
        super.onEnabled(context)
        WidgetUpdateWorker.scheduleImmediateUpdate(context)
        WidgetUpdateWorker.scheduleWork(context)
    }

    override fun onDisabled(context: Context) {
        super.onDisabled(context)
        context.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE).edit().clear().apply()
        WorkManager.getInstance(context).cancelUniqueWork(WidgetUpdateWorker.WORK_NAME)
    }

    override fun onAppWidgetOptionsChanged(context: Context, appWidgetManager: AppWidgetManager, 
                                          appWidgetId: Int, newOptions: Bundle?) {
        super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions)
        refreshWidget(context, appWidgetId)
    }
}

================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MarketAPI.kt
================================================

package com.malinwallet.app

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONArray
import org.json.JSONObject
import java.text.NumberFormat
import java.util.Currency
import kotlin.math.min

object MarketAPI {

    private const val TAG = "MarketAPI"
    private val client = OkHttpClient()
    private val numberFormatter = NumberFormat.getNumberInstance()
    private val electrumClient = ElectrumClient()
    
    private var lastFetchedFee: String? = null

    // Single indicator for error/unavailable
    private const val ERROR_INDICATOR = "!"
    
    var baseUrl: String? = null
    
    data class ApiResponse(val body: String?, val code: Int)
    data class PriceResult(val rateDouble: Double, val formattedRate: String?)

    suspend fun fetchPrice(context: Context, currency: String): String? {
        Log.i(TAG, "Fetching Bitcoin price for currency: $currency")
        val startTime = System.currentTimeMillis()
        
        return try {
            val response = fetchPriceWithResponse(context, currency)
            val duration = System.currentTimeMillis() - startTime
            
            if (response.code == 200) {
                Log.i(TAG, "Successfully fetched price in ${duration}ms: ${response.body}")
                response.body
            } else {
                Log.e(TAG, "Failed to fetch price in ${duration}ms, response code: ${response.code}")
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching price for $currency", e)
            null
        }
    }
    
    suspend fun fetchPriceWithResponse(context: Context, currency: String): ApiResponse {
        val startTime = System.currentTimeMillis()
        Log.d(TAG, "Starting price fetch for currency: $currency")
        
        try {
            // Load the currency info from JSON
            val fiatUnitsJson = context.assets.open("fiatUnits.json").bufferedReader().use { it.readText() }
            val json = JSONObject(fiatUnitsJson)
            
            if (!json.has(currency)) {
                Log.e(TAG, "Currency $currency not found in fiatUnits.json")
                return ApiResponse(null, 404)
            }
            
            val currencyInfo = json.getJSONObject(currency)
            val source = currencyInfo.getString("source")
            val endPointKey = currencyInfo.getString("endPointKey")
            
            Log.d(TAG, "Using price source: $source, endpoint key: $endPointKey")

            val urlString = buildURLString(source, endPointKey)
            Log.d(TAG, "Fetching price from URL: $urlString")

            val request = Request.Builder().url(urlString).build()
            val apiStartTime = System.currentTimeMillis()
            
            val response = withContext(Dispatchers.IO) { client.newCall(request).execute() }
            val apiDuration = System.currentTimeMillis() - apiStartTime
            
            val responseCode = response.code
            Log.d(TAG, "Price API response received in ${apiDuration}ms, response code: $responseCode")
            
            if (responseCode == 429) {
                Log.e(TAG, "Rate limited by API ($source). Response code: $responseCode, Headers: ${response.headers}")
                return ApiResponse(null, responseCode)
            }

            if (!response.isSuccessful) {
                Log.e(TAG, "Failed to fetch price from $source. Response code: $responseCode")
                return ApiResponse(null, responseCode)
            }

            val jsonResponse = response.body?.string()
            Log.d(TAG, "Raw response from $source: $jsonResponse")
            
            val parsedResult = if (jsonResponse != null) {
                parseJSONBasedOnSource(jsonResponse, source, endPointKey)
            } else null
            
            val totalDuration = System.currentTimeMillis() - startTime
            if (parsedResult != null) {
                Log.i(TAG, "Successfully parsed price for $currency from $source: $parsedResult (total time: ${totalDuration}ms)")
            } else {
                Log.e(TAG, "Failed to parse price for $currency from $source (total time: ${totalDuration}ms)")
            }
            
            return ApiResponse(parsedResult, responseCode)
        } catch (e: Exception) {
            val totalDuration = System.currentTimeMillis() - startTime
            Log.e(TAG, "Error fetching price for $currency after ${totalDuration}ms: ${e.javaClass.simpleName} - ${e.message}")
            return ApiResponse(null, -1)
        }
    }

    private fun buildURLString(source: String, endPointKey: String): String {
        return if (baseUrl != null) {
            baseUrl + endPointKey
        } else {
            when (source) {
                "Yadio" -> "https://api.yadio.io/json/$endPointKey"
                "YadioConvert" -> "https://api.yadio.io/convert/1/BTC/$endPointKey"
                "Exir" -> "https://api.exir.io/v1/ticker?symbol=btc-irt"
                "coinpaprika" -> "https://api.coinpaprika.com/v1/tickers/btc-bitcoin?quotes=INR"
                "Bitstamp" -> "https://www.bitstamp.net/api/v2/ticker/btc${endPointKey.lowercase()}"
                "Coinbase" -> "https://api.coinbase.com/v2/prices/BTC-${endPointKey.uppercase()}/buy"
                "CoinGecko" -> "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=${endPointKey.lowercase()}"
                "BNR" -> "https://www.bnr.ro/nbrfxrates.xml"
                "Kraken" -> "https://api.kraken.com/0/public/Ticker?pair=XXBTZ${endPointKey.uppercase()}"
                "CoinDesk" -> "https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=${endPointKey.uppercase()}"
                else -> "https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=${endPointKey.uppercase()}"
            }
        }
    }

    private fun parseJSONBasedOnSource(jsonString: String, source: String, endPointKey: String): String? {
        return try {
            val json = JSONObject(jsonString)
            when (source) {
                "Yadio" -> json.getJSONObject(endPointKey).getString("price")
                "YadioConvert" -> json.getString("rate")
                "CoinGecko" -> json.getJSONObject("bitcoin").getString(endPointKey.lowercase())
                "Exir" -> json.getString("last")
                "Bitstamp" -> json.getString("last")
                "coinpaprika" -> json.getJSONObject("quotes").getJSONObject("INR").getString("price")
                "Coinbase" -> json.getJSONObject("data").getString("amount")
                "Kraken" -> json.getJSONObject("result").getJSONObject("XXBTZ${endPointKey.uppercase()}").getJSONArray("c").getString(0)
                "CoinDesk" -> {
                    val rate = json.optDouble(endPointKey.uppercase(), -1.0)
                    if (rate < 0) null else rate.toString()
                }
                else -> null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing price", e)
            null
        }
    }
    
    /**
     * Fetch the next block fee from Electrum servers with network awareness
     */
    suspend fun fetchNextBlockFee(context: Context): String {
        val startTime = System.currentTimeMillis()
        Log.i(TAG, "Fetching next block fee from Electrum")
        
        // Initialize ElectrumClient with context if not already done
        electrumClient.initialize(context)
        
        // Set up network status listener
        electrumClient.setNetworkStatusListener(object : ElectrumClient.NetworkStatusListener {
            override fun onNetworkStatusChanged(isConnected: Boolean) {
                Log.d(TAG, "Electrum network status changed: ${if (isConnected) "Connected" else "Disconnected"}")
            }
            
            override fun onConnectionError(error: String) {
                Log.e(TAG, "Electrum connection error: $error")
            }
            
            override fun onConnectionSuccess() {
                Log.d(TAG, "Successfully connected to Electrum server")
            }
        })
        
        try {
            // Check network connectivity first
            if (!NetworkUtils.isNetworkAvailable(context)) {
                Log.e(TAG, "No network connection available for fetching next block fee")
                return ERROR_INDICATOR
            }
            
            // For direct testing with hardcoded value
            val useTestValue = false
            if (useTestValue) {
                Log.w(TAG, "Using TEST VALUE for next block fee")
                return "25"
            }
            
            // First try connecting directly for fee histogram
            Log.d(TAG, "Attempting to connect directly to Electrum server for fee")
            var success = electrumClient.connectToNextAvailable(validateCertificates = false)

            if (success) {
                Log.i(TAG, "Connected to Electrum server: ${ElectrumClient.hardcodedPeers}")
            } else {
                Log.e(TAG, "Failed to connect to any Electrum server on first attempt. Retrying once more.")
            }
            
            if (!success) {
                Log.e(TAG, "Failed to connect to any Electrum server on first attempt. Retrying once more.")
                // Short delay before retry
                delay(1000)
                success = electrumClient.connectToNextAvailable(validateCertificates = false)
                
                if (!success) {
                    Log.e(TAG, "Failed to connect to any Electrum server after retry. Fee unavailable.")
                    return ERROR_INDICATOR
                }
            }
            
            Log.d(TAG, "Successfully connected to Electrum server. Sending fee histogram request")
            val message = "{\"id\": 1, \"method\": \"mempool.get_fee_histogram\", \"params\": []}\n"
            if (!electrumClient.send(message.toByteArray())) {
                Log.e(TAG, "Failed to send fee histogram request. Fee unavailable.")
                return ERROR_INDICATOR
            }
            
            Log.d(TAG, "Waiting for fee histogram response")
            val receivedData = electrumClient.receive()
            if (receivedData.isEmpty()) {
                Log.e(TAG, "Empty response from Electrum server when requesting fee histogram. Fee unavailable.")
                return ERROR_INDICATOR
            }
            
            val jsonString = String(receivedData)
            Log.d(TAG, "Received fee histogram: $jsonString")
            
            try {
                val json = JSONObject(jsonString)
                if (!json.has("result")) {
                    Log.e(TAG, "Invalid fee histogram response - missing 'result' field. Fee unavailable.")
                    return ERROR_INDICATOR
                }
                
                val feeHistogram = json.getJSONArray("result")
                if (feeHistogram.length() == 0) {
                    Log.e(TAG, "Empty fee histogram array. Fee unavailable.")
                    return ERROR_INDICATOR
                }
                
                Log.d(TAG, "Calculating fee from ${feeHistogram.length()} data points")
                
                val feeRate = calculateFeeFromHistogram(feeHistogram, 1)
                if (feeRate <= 0) {
                    Log.e(TAG, "Invalid fee rate calculated: $feeRate. Fee unavailable.")
                    return ERROR_INDICATOR
                }
                
                val formattedFee = feeRate.toInt().toString()
                
                Log.i(TAG, "Successfully calculated next block fee: $formattedFee sat/vB")
                return formattedFee
            } catch (e: Exception) {
                Log.e(TAG, "Error parsing fee histogram JSON: ${e.message}", e)
                return ERROR_INDICATOR
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching next block fee: ${e.message}", e)
            return ERROR_INDICATOR
        } finally {
            electrumClient.close()
        }
    }
    
    /**
     * Calculate the estimated fee from the fee histogram
     * 
     * @param feeHistogram the fee histogram from Electrum
     * @param targetBlocks the target number of blocks to confirm in
     * @return the fee rate in sat/vB that would get confirmed in the target number of blocks
     */
    private fun calculateFeeFromHistogram(feeHistogram: JSONArray, targetBlocks: Int): Double {
        try {
            Log.d(TAG, "Calculating fee from histogram with ${feeHistogram.length()} entries for $targetBlocks blocks")
            
            // Transform histogram - accumulate vsize until we reach the target block size
            val blockSize = 1000000 // 1MB block size
            var totalVsize = 0.0
            val histogramToUse = mutableListOf<Pair<Double, Double>>() // (fee, vsize)
            
            for (i in 0 until feeHistogram.length()) {
                val entry = feeHistogram.getJSONArray(i)
                val feeRate = entry.getDouble(0)
                var vsize = entry.getDouble(1)
                var timeToStop = false
                
                if (totalVsize + vsize >= blockSize * targetBlocks) {
                    // Only take what we need to fill the target block size
                    vsize = blockSize * targetBlocks - totalVsize
                    timeToStop = true
                }
                
                histogramToUse.add(Pair(feeRate, vsize))
                totalVsize += vsize
                
                Log.v(TAG, "Fee entry: rate=$feeRate, vsize=$vsize, accumulated=$totalVsize")
                
                if (timeToStop) break
            }
            
            Log.d(TAG, "Transformed histogram has ${histogramToUse.size} entries with total vsize $totalVsize")
            
            // Create a weighted flat array (similar to the JS implementation)
            val histogramFlat = mutableListOf<Double>()
            for ((fee, vsize) in histogramToUse) {
                // Divide by a factor to keep the array size manageable
                val count = (vsize / 25000.0).toInt().coerceAtLeast(1)
                repeat(count) {
                    histogramFlat.add(fee)
                }
            }
            
            if (histogramFlat.isEmpty()) {
                Log.e(TAG, "Empty flat histogram array")
                return 0.0 // Return 0 to indicate failure, will be caught and converted to ERROR_INDICATOR
            }
            
            // Sort the flat array
            histogramFlat.sort()
            
            // Calculate the median (50th percentile)
            val median = calculatePercentile(histogramFlat, 0.5)
            val result = median.coerceAtLeast(2.0) // Minimum 2 sat/vB
            
            Log.d(TAG, "Calculated median fee rate: $median, final rate: $result sat/vB")
            return result
            
        } catch (e: Exception) {
            Log.e(TAG, "Error calculating fee from histogram: ${e.message}", e)
            return 0.0 // Return 0 to indicate failure, will be caught and converted to ERROR_INDICATOR
        }
    }
    
    /**
     * Calculate the percentile of a sorted list of values
     * 
     * @param sortedValues the sorted list of values
     * @param percentile the percentile to calculate (0.0 - 1.0)
     * @return the percentile value
     */
    private fun calculatePercentile(sortedValues: List<Double>, percentile: Double): Double {
        if (sortedValues.isEmpty()) return 0.0
        
        val index = (percentile * sortedValues.size).toInt().coerceIn(0, sortedValues.size - 1)
        return sortedValues[index]
    }
    
    /**
     * Format price with currency symbol
     */
    fun formatCurrencyAmount(amount: Double, currencyCode: String): String {
        val formatter = NumberFormat.getCurrencyInstance()
        try {
            formatter.currency = Currency.getInstance(currencyCode)
            formatter.maximumFractionDigits = 0 // Ensure no fractional parts
        } catch (e: Exception) {
            Log.e(TAG, "Invalid currency code: $currencyCode", e)
        }
        return formatter.format(amount.toInt()) // Convert to integer before formatting
    }
    
    /**
     * Fetch complete market data including price and next block fee
     */
    suspend fun fetchMarketData(context: Context, currency: String): MarketData {
        val startTime = System.currentTimeMillis()
        Log.i(TAG, "Starting market data fetch for currency: $currency")
        
        val marketData = MarketData(nextBlock = "...", sats = "...", price = "...", rate = 0.0)
        
        try {
            // Check network connectivity first
            if (!NetworkUtils.isNetworkAvailable(context)) {
                Log.e(TAG, "No network connection available for fetching market data")
                return marketData.apply { 
                    nextBlock = ERROR_INDICATOR
                    sats = ERROR_INDICATOR
                    price = ERROR_INDICATOR
                }
            }
            
            // 1. Fetch price
            Log.d(TAG, "Fetching price for $currency")
            val priceStartTime = System.currentTimeMillis()
            val response = fetchPriceWithResponse(context, currency)
            val priceDuration = System.currentTimeMillis() - priceStartTime
            
            if (response.code == 429) {
                Log.e(TAG, "Rate limited by price API, aborting market data fetch")
                throw RateLimitException("Rate limited by price API")
            }
            
            val priceStr = response.body
            if (priceStr != null) {
                val rate = priceStr.toDoubleOrNull() ?: 0.0
                marketData.rate = rate
                Log.d(TAG, "Parsed price rate: $rate")
                
                if (rate > 0) {
                    // Format price with currency symbol - convert to integer
                    marketData.price = formatCurrencyAmount(rate, currency)
                    Log.d(TAG, "Formatted price: ${marketData.price}")
                    
                    // Calculate sats - convert to integer for display
                    val satsValue = ((10 / rate) * 10000000).toInt()
                    marketData.sats = numberFormatter.format(satsValue)
                    Log.d(TAG, "Calculated sats: ${marketData.sats}")
                } else {
                    Log.w(TAG, "Price rate is zero or negative: $rate")
                }
            } else {
                Log.w(TAG, "No price data received")
            }
            
            // 2. Fetch next block fee - Always run this, regardless of price fetch result
            Log.d(TAG, "Fetching next block fee")
            val feeStartTime = System.currentTimeMillis()
            val nextBlockFee = fetchNextBlockFee(context)
            val feeDuration = System.currentTimeMillis() - feeStartTime
            
            Log.d(TAG, "Next block fee fetched in ${feeDuration}ms: $nextBlockFee")
            marketData.nextBlock = nextBlockFee
            Log.i(TAG, "Set nextBlock fee in marketData: ${marketData.nextBlock}")
            
            val totalDuration = System.currentTimeMillis() - startTime
            Log.i(TAG, "Market data fetch completed in ${totalDuration}ms: $marketData")
            
        } catch (e: RateLimitException) {
            Log.e(TAG, "Rate limit exception during market data fetch: ${e.message}")
            throw e
        } catch (e: Exception) {
            val duration = System.currentTimeMillis() - startTime
            Log.e(TAG, "Error fetching market data after ${duration}ms: ${e.javaClass.simpleName} - ${e.message}", e)
        }
        
        return marketData
    }
}

================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MainApplication.kt
================================================

package com.malinwallet.app

import android.app.Application
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.util.Log
import com.bugsnag.android.Bugsnag
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.facebook.react.modules.i18nmanager.I18nUtil
import com.malinwallet.app.components.segmentedcontrol.CustomSegmentedControlPackage

class MainApplication : Application(), ReactApplication {

    private lateinit var sharedPref: SharedPreferences
    private val themeChangeReceiver = ThemeChangeReceiver()
    private val preferenceChangeListener = SharedPreferences.OnSharedPreferenceChangeListener { prefs, key ->
        if (key == "preferredCurrency") {
            prefs.edit().remove("previous_price").apply()
            
            // Update BitcoinPrice widgets
            WidgetUpdateWorker.scheduleWork(this)
            
            // Immediately refresh Market widgets
            MarketWidget.refreshAllWidgetsImmediately(this)
        } else if (key == "force_dark_mode") {
            // Theme setting changed, update all widgets
            ThemeHelper.updateAllWidgets(this)
        } else if (key == "donottrack") {
            // Handle Do Not Track changes similar to iOS
            val isEnabled = prefs.getString("donottrack", "0") == "1"
            Log.d("MainApplication", "Do Not Track changed to: $isEnabled")
            
            if (isEnabled) {
                // Set deviceUIDCopy to "Disabled"
                prefs.edit()
                    .putString("deviceUIDCopy", "Disabled")
                    .apply()
                Log.d("MainApplication", "Do Not Track enabled - set deviceUIDCopy to 'Disabled'")
            } else {
                // Re-initialize device UID
                initializeDeviceUID()
            }
        } else if (key == "deviceUID") {
            // When deviceUID changes, update deviceUIDCopy
            val isDoNotTrackEnabled = prefs.getString("donottrack", "0") == "1"
            if (!isDoNotTrackEnabled) {
                val deviceUID = prefs.getString("deviceUID", null)
                if (deviceUID != null) {
                    prefs.edit()
                        .putString("deviceUIDCopy", deviceUID)
                        .apply()
                    Log.d("MainApplication", "deviceUID changed, synced to deviceUIDCopy: $deviceUID")
                }
            }
        }
    }

    override val reactNativeHost: ReactNativeHost =
        object : DefaultReactNativeHost(this) {
            override fun getPackages(): List<ReactPackage> =
                PackageList(this).packages.apply {
                    // Packages that cannot be autolinked yet can be added manually here, for example:
                    // add(MyReactNativePackage())
                    add(CustomSegmentedControlPackage())
                    add(SettingsPackage())
                }

            override fun getJSMainModuleName(): String = "index"

            override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

            override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
            override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
        }

    override val reactHost: ReactHost
        get() = getDefaultReactHost(applicationContext, reactNativeHost)

    override fun onCreate() {
        super.onCreate()
        sharedPref = getSharedPreferences("group.com.malinwallet.app", Context.MODE_PRIVATE)
        
        // Handle clearFilesOnLaunch before registering listeners
        clearFilesIfNeeded()
        
        sharedPref.registerOnSharedPreferenceChangeListener(preferenceChangeListener)
        
        // Register the theme change receiver
        registerReceiver(themeChangeReceiver, IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED))
        
        val sharedI18nUtilInstance = I18nUtil.instance
        sharedI18nUtilInstance.allowRTL(applicationContext, true)
        SoLoader.init(this, OpenSourceMergedSoMapping)
        if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
            // If you opted-in for the New Architecture, we load the native entry point for this app.
            load()
        }

        initializeDeviceUID()
        initializeBugsnag()
    }

    override fun onTerminate() {
        super.onTerminate()
        sharedPref.unregisterOnSharedPreferenceChangeListener(preferenceChangeListener)
        
        // Unregister the theme change receiver
        try {
            unregisterReceiver(themeChangeReceiver)
        } catch (e: Exception) {
            Log.e("MainApplication", "Error unregistering theme receiver", e)
        }
    }

    private fun initializeBugsnag() {
        val isDoNotTrackEnabled = sharedPref.getString("donottrack", "0")
        if (isDoNotTrackEnabled != "1") {
            Bugsnag.start(this)
        }
    }

    /**
     * Initialize device UID similar to iOS implementation
     * Uses the same Android ID as react-native-device-info's getUniqueId()
     */
    private fun initializeDeviceUID() {
        val isDoNotTrackEnabled = sharedPref.getString("donottrack", "0") == "1"
        
        if (isDoNotTrackEnabled) {
            val currentCopy = sharedPref.getString("deviceUIDCopy", "")
            if (currentCopy != "Disabled") {
                sharedPref.edit()
                    .putString("deviceUIDCopy", "Disabled")
                    .apply()
                Log.d("MainApplication", "Do Not Track enabled - set deviceUIDCopy to 'Disabled'")
            }
            return
        }
        
        // Get the Android ID (same as react-native-device-info's getUniqueId())
        val deviceUID = try {
            android.provider.Settings.Secure.getString(
                contentResolver,
                android.provider.Settings.Secure.ANDROID_ID
            ) ?: "unknown"
        } catch (e: Exception) {
            Log.e("MainApplication", "Error getting Android ID", e)
            "unknown"
        }
        
        // Store in deviceUID for consistency
        sharedPref.edit()
            .putString("deviceUID", deviceUID)
            .apply()
        
        // Copy deviceUID to deviceUIDCopy (for Settings compatibility)
        val currentCopy = sharedPref.getString("deviceUIDCopy", "")
        if (deviceUID != currentCopy) {
            sharedPref.edit()
                .putString("deviceUIDCopy", deviceUID)
                .apply()
            Log.d("MainApplication", "Synced deviceUID to deviceUIDCopy: $deviceUID")
        }
    }

    /**
     * Clear files if clearFilesOnLaunch is enabled
     * Similar to iOS implementation
     */
    private fun clearFilesIfNeeded() {
        val shouldClear = sharedPref.getBoolean("clearFilesOnLaunch", false)
        
        if (shouldClear) {
            try {
                // Clear cache directory
                cacheDir?.let { clearDirectory(it) }
                
                // Clear files directory
                filesDir?.let { clearDirectory(it) }
                
                // Clear external cache directory
                externalCacheDir?.let { clearDirectory(it) }
                
                // Reset the flag and set a flag to show alert
                sharedPref.edit()
                    .putBoolean("clearFilesOnLaunch", false)
                    .putBoolean("shouldShowCacheClearedAlert", true)
                    .apply()
                
                Log.d("MainApplication", "Cache and files cleared on launch")
            } catch (e: Exception) {
                Log.e("MainApplication", "Error clearing files", e)
            }
        }
    }

    /**
     * Recursively clear all files in a directory
     */
    private fun clearDirectory(dir: java.io.File) {
        if (!dir.exists()) return
        
        dir.listFiles()?.forEach { file ->
            if (file.isDirectory) {
                clearDirectory(file)
            }
            try {
                file.delete()
                Log.d("MainApplication", "Deleted: ${file.absolutePath}")
            } catch (e: Exception) {
                Log.e("MainApplication", "Error deleting file: ${file.absolutePath}", e)
            }
        }
    }
}

================================================
FILE: ./android/app/src/main/java/com/malinwallet/app/MarketWidgetConfigureActivity.kt
================================================

package com.malinwallet.app

import android.appwidget.AppWidgetManager
import android.content.Intent
import android.os.Bundle
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity

/**
 * Configuration activity for the Market Widget.
 * This allows the widget to be properly configured when added to the home screen.
 */
class MarketWidgetConfigureActivity : AppCompatActivity() {

    private var appWidgetId = AppWidgetManager.INVALID_APPWIDGET_ID

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Set the result to CANCELED. This will be overridden if the user
        // configures the widget properly and clicks the Add button
        setResult(RESULT_CANCELED)

        // Find the widget id from the intent
        appWidgetId = intent.extras?.getInt(
            AppWidgetManager.EXTRA_APPWIDGET_ID,
            AppWidgetManager.INVALID_APPWIDGET_ID
        ) ?: AppWidgetManager.INVALID_APPWIDGET_ID

        // If the widget ID is invalid, just finish the activity
        if (appWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
            finish()
            return
        }

        // Currently no configuration needed, so we set result to OK right away
        val resultValue = Intent()
        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
        setResult(RESULT_OK, resultValue)

        MarketWidgetUpdateWorker.scheduleMarketUpdate(this, forceUpdate = true)

        // Finish the activity
        finish()
    }
}


================================================
FILE: ./android/app/src/androidTest/java/com/malinwallet/app/DetoxTest.java
================================================

package com.malinwallet.app;

        import com.wix.detox.Detox;
        import com.wix.detox.config.DetoxConfig;

        import org.junit.Rule;
        import org.junit.Test;
        import org.junit.runner.RunWith;

        import androidx.test.ext.junit.runners.AndroidJUnit4;
        import androidx.test.filters.LargeTest;
        import androidx.test.rule.ActivityTestRule;

@RunWith(AndroidJUnit4.class)
@LargeTest
public class DetoxTest {
    // Replace 'MainActivity' with the value of android:name entry in
    // <activity> in AndroidManifest.xml
    @Rule
    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(MainActivity.class, false, false);

    @Test
    public void runDetoxTests() {
        // This is optional - in case you've decided to integrate TestButler
        // See https://github.com/wix/Detox/blob/master/docs/Introduction.Android.md#8-test-butler-support-optional
//         TestButlerProbe.assertReadyIfInstalled();

        DetoxConfig detoxConfig = new DetoxConfig();
        detoxConfig.idlePolicyConfig.masterTimeoutSec = 90;
        detoxConfig.idlePolicyConfig.idleResourceTimeoutSec = 60;
        detoxConfig.rnContextLoadTimeoutSec = (com.malinwallet.app.BuildConfig.DEBUG ? 180 : 60);

        Detox.runTests(mActivityRule, detoxConfig);
    }
}


================================================
FILE: ./hooks/useKeyboard.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useState, useEffect } from 'react';
import { Keyboard, KeyboardEvent, Platform } from 'react-native';

interface KeyboardInfo {
  isVisible: boolean;
  height: number;
}

interface UseKeyboardProps {
  onKeyboardDidShow?: () => void;
  onKeyboardDidHide?: () => void;
}

export const useKeyboard = ({ onKeyboardDidShow, onKeyboardDidHide }: UseKeyboardProps = {}): KeyboardInfo => {
  const [keyboardInfo, setKeyboardInfo] = useState<KeyboardInfo>({
    isVisible: false,
    height: 0,
  });

  useEffect(() => {
    const handleKeyboardDidShow = (event: KeyboardEvent) => {
      setKeyboardInfo({
        isVisible: true,
        height: event.endCoordinates.height,
      });
      if (onKeyboardDidShow) {
        onKeyboardDidShow();
      }
    };

    const handleKeyboardDidHide = () => {
      setKeyboardInfo({
        isVisible: false,
        height: 0,
      });
      if (onKeyboardDidHide) {
        onKeyboardDidHide();
      }
    };

    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';
    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';

    const showSubscription = Keyboard.addListener(showEvent, handleKeyboardDidShow);
    const hideSubscription = Keyboard.addListener(hideEvent, handleKeyboardDidHide);

    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, [onKeyboardDidShow, onKeyboardDidHide]);

  return keyboardInfo;
};


================================================
FILE: ./hooks/useAsyncPromise.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useState, useEffect } from 'react';

/**
 * A custom React hook that accepts a promise and returns the resolved value and any errors that occur.
 *
 * @template T - The type of the resolved value.
 * @param {() => Promise<T>} promiseFn - A function that returns the promise to be resolved.
 * @returns {{ data: T | null, error: Error | null, loading: boolean }} - An object with the resolved data, any error, and loading state.
 */
function useAsyncPromise<T>(promiseFn: () => Promise<T>) {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    let isMounted = true;

    promiseFn()
      .then(result => {
        if (isMounted) {
          setData(result);
          setLoading(false);
        }
      })
      .catch((err: Error) => {
        if (isMounted) {
          setError(err);
          setLoading(false);
        }
      });

    return () => {
      isMounted = false;
    };
  }, [promiseFn]);

  return { data, error, loading };
}

export default useAsyncPromise;


================================================
FILE: ./hooks/context/useStorage.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useContext } from 'react';
import { StorageContext } from '../../components/Context/StorageProvider';

export const useStorage = () => useContext(StorageContext);


================================================
FILE: ./hooks/context/useSettings.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useContext } from 'react';
import { SettingsContext } from '../../components/Context/SettingsProvider';

export const useSettings = () => useContext(SettingsContext);


================================================
FILE: ./hooks/useDeviceQuickActions.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { CommonActions } from '@react-navigation/native';
import { DeviceEventEmitter, Linking, Platform } from 'react-native';
import QuickActions, { ShortcutItem } from 'react-native-quick-actions';
import DeeplinkSchemaMatch from '../class/deeplink-schema-match';
import { TWallet } from '../class/wallets/types';
import useOnAppLaunch from '../hooks/useOnAppLaunch';
import { formatBalance } from '../loc';
import * as NavigationService from '../NavigationService';
import { useSettings } from '../hooks/context/useSettings';
import { useStorage } from '../hooks/context/useStorage';

const DeviceQuickActionsStorageKey = 'DeviceQuickActionsEnabled';

export async function setEnabled(enabled: boolean = true): Promise<void> {
  await AsyncStorage.setItem(
    DeviceQuickActionsStorageKey,
    JSON.stringify(enabled)
  );
}

export async function getEnabled(): Promise<boolean> {
  try {
    const isEnabled = await AsyncStorage.getItem(DeviceQuickActionsStorageKey);
    if (isEnabled === null) {
      await setEnabled(true);
      return true;
    }
    return !!JSON.parse(isEnabled);
  } catch {
    return true;
  }
}

const useDeviceQuickActions = () => {
  const {
    wallets,
    walletsInitialized,
    isStorageEncrypted,
    addWallet,
    saveToDisk,
    setSharedCosigner
  } = useStorage();
  const { preferredFiatCurrency, isQuickActionsEnabled } = useSettings();
  const { isViewAllWalletsEnabled, getSelectedDefaultWallet } =
    useOnAppLaunch();

  useEffect(() => {
    if (walletsInitialized) {
      isStorageEncrypted()
        .then((value) => {
          if (value) {
            removeShortcuts();
          } else {
            setQuickActions();
          }
        })
        .catch(() => removeShortcuts());
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [wallets, walletsInitialized, preferredFiatCurrency, isStorageEncrypted]);

  useEffect(() => {
    if (walletsInitialized) {
      DeviceEventEmitter.addListener('quickActionShortcut', walletQuickActions);
      popInitialShortcutAction().then(popInitialAction);
      return () => DeviceEventEmitter.removeAllListeners('quickActionShortcut');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [walletsInitialized]);

  useEffect(() => {
    if (walletsInitialized) {
      if (isQuickActionsEnabled) {
        setQuickActions();
      } else {
        removeShortcuts();
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isQuickActionsEnabled, walletsInitialized]);

  const popInitialShortcutAction = async (): Promise<any> => {
    const data = await QuickActions.popInitialAction();
    return data;
  }

  const popInitialAction = async (data: any): Promise<void> => {
    if (data) {
      const wallet = wallets.find(
        (w) => w.getID() === data.userInfo.url.split('wallet/')[1]
      );
      if (wallet) {
        NavigationService.dispatch(
          CommonActions.navigate({
            name: 'WalletTransactions',
            params: {
              walletID: wallet.getID(),
              walletType: wallet.type,
            }
          }),
        )
      }
    } else {
      const url = await Linking.getInitialURL();
      if (url) {
        if (DeeplinkSchemaMatch.hasSchema(url)) {
          handleOpenURL({ url });
        }
      } else {
        if (!(await isViewAllWalletsEnabled())) {
          const selectedDefaultWalletID =
            (await getSelectedDefaultWallet()) as string;
          const selectedDefaultWallet = wallets.find(
            (w: TWallet) => w.getID() === selectedDefaultWalletID
          );
          if (selectedDefaultWallet) {
            NavigationService.dispatch(
              CommonActions.navigate({
                name: 'WalletTransactions',
                params: {
                  walletID: selectedDefaultWalletID,
                  walletType: selectedDefaultWallet.type,
                }
              }),
            )
          }
        }
      }
    }
  };

  const handleOpenURL = (event: { url: string }): void => {
    DeeplinkSchemaMatch.navigationRouteFor(
      event,
      (value: [string, any]) => NavigationService.navigate(...value),
      {
        wallets,
        addWallet,
        saveToDisk,
        setSharedCosigner,
      }
    );
  }

  const walletQuickActions = (data: any): void => {
    const wallet = wallets.find(
      (w) => w.getID() === data.userInfo.url.split('wallet/')[1]
    );
    if (wallet) {
      NavigationService.dispatch(
        CommonActions.navigate({
          name: 'WalletTransactions',
          params: {
            walletID: wallet.getID(),
            walletType: wallet.type,
          }
        }),
      )
    }
  };

  const removeShortcuts = async (): Promise<void> => {
    if (Platform.OS === 'android') {
      QuickActions.clearShortcutItems();
    } else {
      // @ts-ignore: Fix later
      QuickActions.setShortcutItems([{ type: 'EmptyWallets', title: '' }]);
    }
  };

  const setQuickActions = async (): Promise<void> => {
    if (await getEnabled()) {
      QuickActions.isSupported((error: null, _supported: any) => {
        if (error === null) {
          const shortcutItems: ShortcutItem[] = wallets
            .slice(0, 4)
            .map((wallet, index) => ({
              type: 'Wallets',
              title: wallet.getLabel(),
              subtitle:
                wallet.hideBalance || wallet.getBalance() <= 0
                  ? ''
                  : formatBalance(
                    Number(wallet.getBalance()),
                    wallet.getPreferredBalanceUnit(),
                    true,
                  ),
              userInfo: {
                url: `malinwallet://wallet/${wallet.getID()}`,
              },
              icon:
                Platform.select({
                  android: 'quickactions',
                  ios: index === 0 ? 'Favorite' : 'Bookmark',
                }) || 'quickactions',
            }));
          QuickActions.setShortcutItems(shortcutItems);
        }
      });
    } else {
      removeShortcuts();
    }
  };

  return { popInitialAction };
};

export default useDeviceQuickActions;


================================================
FILE: ./hooks/useCompanionListeners.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { CommonActions } from '@react-navigation/native';
import { useCallback, useEffect, useRef } from 'react';
import { AppState, AppStateStatus, Linking } from 'react-native';
import { getClipboardContent } from '../malin_modules/clipboard';
import { updateExchangeRate } from '../malin_modules/currency';
import triggerHapticFeedback, { HapticFeedbackTypes } from '../malin_modules/hapticFeedback';
import {
  clearStoredNotifications,
  getDeliveredNotifications,
  getStoredNotifications,
  initializeNotifications,
  removeAllDeliveredNotifications,
  setApplicationIconBadgeNumber,
} from '../malin_modules/notifications';
import { LightningCustodianWallet } from '../class';
import DeeplinkSchemaMatch from '../class/deeplink-schema-match';
import loc from '../loc';
import { Chain } from '../models/bitcoinUnits';
import { navigationRef } from '../NavigationService';
import ActionSheet from '../screen/ActionSheet';
import { useStorage } from './context/useStorage';
import RNQRGenerator from 'rn-qr-generator';
import presentAlert from '../components/Alert';
import useWidgetCommunication from './useWidgetCommunication';
import useWatchConnectivity from './useWatchConnectivity';
import useDeviceQuickActions from './useDeviceQuickActions';
import useHandoffListener from './useHandoffListener';
import useMenuElements from './useMenuElements';
import { useExtendedNavigation } from './useExtendedNavigation';

const ClipboardContentType = Object.freeze({
  BITCOIN: 'BITCOIN',
  LIGHTNING: 'LIGHTNING',
});

/**
 * Hook that initializes all companion listeners and functionality without rendering a component
 */
const useCompanionListeners = (skipIfNotInitialized = true) => {
  const {
    wallets,
    addWallet,
    saveToDisk,
    fetchAndSaveWalletTransactions,
    refreshAllWalletTransactions,
    setSharedCosigner,
    walletsInitialized,
  } = useStorage();
  const appState = useRef<AppStateStatus>(AppState.currentState);
  const clipboardContent = useRef<undefined | string>();
  const navigation = useExtendedNavigation();

  // We need to call hooks unconditionally before any conditional logic
  // We'll use this check inside the effects to conditionally run logic
  const shouldActivateListeners = !skipIfNotInitialized || walletsInitialized;

  // Initialize other hooks regardless of activation status
  // They'll handle their own conditional logic internally
  useWatchConnectivity();
  useWidgetCommunication();
  useMenuElements();
  useDeviceQuickActions();
  useHandoffListener();

  const processPushNotifications = useCallback(async () => {
    if (!shouldActivateListeners) return false;

    await new Promise(resolve => setTimeout(resolve, 200));
    try {
      const notifications2process = await getStoredNotifications();
      await clearStoredNotifications();
      setApplicationIconBadgeNumber(0);

      const deliveredNotifications = await getDeliveredNotifications();
      setTimeout(async () => {
        try {
          removeAllDeliveredNotifications();
        } catch (error) {
          console.error('Failed to remove delivered notifications:', error);
        }
      }, 5000);

      // Process notifications
      for (const payload of notifications2process) {
        const wasTapped = payload.foreground === false || (payload.foreground === true && payload.userInteraction);

        console.log('processing push notification:', payload);
        let wallet;
        switch (+payload.type) {
          case 2:
          case 3:
            wallet = wallets.find(w => w.weOwnAddress(payload.address));
            break;
          case 1:
          case 4:
            wallet = wallets.find(w => w.weOwnTransaction(payload.txid || payload.hash));
            break;
        }

        if (wallet) {
          const walletID = wallet.getID();
          fetchAndSaveWalletTransactions(walletID);
          if (wasTapped) {
            if (payload.type !== 3 || wallet.chain === Chain.OFFCHAIN) {
              navigation.navigate('WalletTransactions', {
                walletID,
                walletType: wallet.type,
              });
            } else {
              navigation.navigate('ReceiveDetails', {
                walletID,
                address: payload.address,
              });
            }

            return true;
          }
        } else {
          console.log('could not find wallet while processing push notification, NOP');
        }
      }

      if (deliveredNotifications.length > 0) {
        for (const payload of deliveredNotifications) {
          const wasTapped = payload.foreground === false || (payload.foreground === true && payload.userInteraction);

          console.log('processing push notification:', payload);
          let wallet;
          switch (+payload.type) {
            case 2:
            case 3:
              wallet = wallets.find(w => w.weOwnAddress(payload.address));
              break;
            case 1:
            case 4:
              wallet = wallets.find(w => w.weOwnTransaction(payload.txid || payload.hash));
              break;
          }

          if (wallet) {
            const walletID = wallet.getID();
            fetchAndSaveWalletTransactions(walletID);
            if (wasTapped) {
              if (payload.type !== 3 || wallet.chain === Chain.OFFCHAIN) {
                navigationRef.dispatch(
                  CommonActions.navigate({
                    name: 'WalletTransactions',
                    params: {
                      walletID,
                      walletType: wallet.type,
                    },
                  }),
                );
              } else {
                navigationRef.dispatch(
                  CommonActions.navigate({
                    name: 'ReceiveDetails',
                    params: {
                      walletID,
                      address: payload.address,
                    },
                  }),
                );
              }

              return true;
            }
          } else {
            console.log('could not find wallet while processing push notification, NOP');
          }
        }
      }

      if (deliveredNotifications.length > 0) {
        refreshAllWalletTransactions();
      }
    } catch (error) {
      console.error('Failed to process push notifications:', error);
    }
    return false;
  }, [shouldActivateListeners, wallets, fetchAndSaveWalletTransactions, navigation, refreshAllWalletTransactions]);

  useEffect(() => {
    if (!shouldActivateListeners) return;

    initializeNotifications(processPushNotifications);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [shouldActivateListeners]);

  const handleOpenURL = useCallback(
    async (event: { url: string }): Promise<void> => {
      if (!shouldActivateListeners) return;

      try {
        if (!event.url) return;
        let decodedUrl: string;
        try {
          decodedUrl = decodeURIComponent(event.url);
        } catch (e) {
          console.error('Failed to decode URL, using original', e);
          decodedUrl = event.url;
        }
        const fileName = decodedUrl.split('/').pop()?.toLowerCase() || '';
        if (/\.(jpe?g|png)$/i.test(fileName)) {
          let qrResult;
          try {
            qrResult = await RNQRGenerator.detect({ uri: decodedUrl });
          } catch (e) {
            console.error('QR detection first attempt failed:', e);
          }
          if (!qrResult || !qrResult.values || qrResult.values.length === 0) {
            const altUrl = decodedUrl.replace(/^file:\/\//, '');
            try {
              qrResult = await RNQRGenerator.detect({ uri: altUrl });
            } catch (e) {
              console.error('QR detection second attempt failed:', e);
            }
          }
          if (qrResult?.values?.length) {
            triggerHapticFeedback(HapticFeedbackTypes.NotificationSuccess);
            DeeplinkSchemaMatch.navigationRouteFor(
              { url: qrResult.values[0] },
              (value: [string, any]) => navigationRef.navigate(...value),
              {
                wallets,
                addWallet,
                saveToDisk,
                setSharedCosigner,
              },
            );
          } else {
            throw new Error(loc.send.qr_error_no_qrcode);
          }
        } else {
          DeeplinkSchemaMatch.navigationRouteFor(event, (value: [string, any]) => navigationRef.navigate(...value), {
            wallets,
            addWallet,
            saveToDisk,
            setSharedCosigner,
          });
        }
      } catch (err: any) {
        console.error('Error in handleOpenURL:', err);
        triggerHapticFeedback(HapticFeedbackTypes.NotificationError);
        presentAlert({ message: err.message || loc.send.qr_error_no_qrcode });
      }
    },
    [wallets, addWallet, saveToDisk, setSharedCosigner, shouldActivateListeners],
  );

  const showClipboardAlert = useCallback(
    ({ contentType }: { contentType: undefined | string }) => {
      if (!shouldActivateListeners) return;

      triggerHapticFeedback(HapticFeedbackTypes.ImpactLight);
      getClipboardContent().then(clipboard => {
        if (!clipboard) return;
        ActionSheet.showActionSheetWithOptions(
          {
            title: loc._.clipboard,
            message: contentType === ClipboardContentType.BITCOIN ? loc.wallets.clipboard_bitcoin : loc.wallets.clipboard_lightning,
            options: [loc._.cancel, loc._.continue],
            cancelButtonIndex: 0,
          },
          buttonIndex => {
            switch (buttonIndex) {
              case 0:
                break;
              case 1:
                handleOpenURL({ url: clipboard });
                break;
            }
          },
        );
      });
    },
    [handleOpenURL, shouldActivateListeners],
  );

  const handleAppStateChange = useCallback(
    async (nextAppState: AppStateStatus | undefined) => {
      if (!shouldActivateListeners || wallets.length === 0) return;

      if ((appState.current.match(/inactive|background/) && nextAppState === 'active') || nextAppState === undefined) {
        updateExchangeRate();
        const processed = await processPushNotifications();
        if (processed) return;
        const clipboard = await getClipboardContent();
        if (!clipboard) return;
        const isAddressFromStoredWallet = wallets.some(wallet => {
          if (wallet.chain === Chain.ONCHAIN) {
            return wallet.isAddressValid && wallet.isAddressValid(clipboard) && wallet.weOwnAddress(clipboard);
          } else {
            return (wallet as LightningCustodianWallet).isInvoiceGeneratedByWallet(clipboard) || wallet.weOwnAddress(clipboard);
          }
        });
        const isBitcoinAddress = DeeplinkSchemaMatch.isBitcoinAddress(clipboard);
        const isLightningInvoice = DeeplinkSchemaMatch.isLightningInvoice(clipboard);
        const isLNURL = DeeplinkSchemaMatch.isLnUrl(clipboard);
        const isBothBitcoinAndLightning = DeeplinkSchemaMatch.isBothBitcoinAndLightning(clipboard);
        if (
          !isAddressFromStoredWallet &&
          clipboardContent.current !== clipboard &&
          (isBitcoinAddress || isLightningInvoice || isLNURL || isBothBitcoinAndLightning)
        ) {
          let contentType;
          if (isBitcoinAddress) {
            contentType = ClipboardContentType.BITCOIN;
          } else if (isLightningInvoice || isLNURL) {
            contentType = ClipboardContentType.LIGHTNING;
          } else if (isBothBitcoinAndLightning) {
            contentType = ClipboardContentType.BITCOIN;
          }
          showClipboardAlert({ contentType });
        }
        clipboardContent.current = clipboard;
      }
      if (nextAppState) {
        appState.current = nextAppState;
      }
    },
    [processPushNotifications, showClipboardAlert, wallets, shouldActivateListeners],
  );

  const addListeners = useCallback(() => {
    if (!shouldActivateListeners) return { urlSubscription: null, appStateSubscription: null };

    const urlSubscription = Linking.addEventListener('url', handleOpenURL);
    const appStateSubscription = AppState.addEventListener('change', handleAppStateChange);

    return {
      urlSubscription,
      appStateSubscription,
    };
  }, [handleOpenURL, handleAppStateChange, shouldActivateListeners]);

  useEffect(() => {
    const subscriptions = addListeners();

    return () => {
      subscriptions.urlSubscription?.remove?.();
      subscriptions.appStateSubscription?.remove?.();
    };
  }, [addListeners]);
};

export default useCompanionListeners;


================================================
FILE: ./hooks/useBiometrics.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useState, useEffect, useCallback } from 'react';
import { Alert, Platform } from 'react-native';
import ReactNativeBiometrics, { BiometryTypes as RNBiometryTypes } from 'react-native-biometrics';
import RNSecureKeyStore, { ACCESSIBLE } from 'react-native-secure-key-store';
import loc from '../loc';
import * as NavigationService from '../NavigationService';
import presentAlert from '../components/Alert';
import { useStorage } from './context/useStorage';

const STORAGEKEY = 'Biometrics';
const rnBiometrics = new ReactNativeBiometrics({ allowDeviceCredentials: true });

const FaceID = 'Face ID';
const TouchID = 'Touch ID';
const Biometrics = 'Biometrics';

const clearKeychain = async () => {
  try {
    console.debug('Wiping keychain');
    console.debug('Wiping key: data');
    await RNSecureKeyStore.set('data', JSON.stringify({ data: { wallets: [] } }), {
      accessible: ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
    });
    console.debug('Wiped key: data');
    console.debug('Wiping key: data_encrypted');
    await RNSecureKeyStore.set('data_encrypted', '', { accessible: ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY });
    console.debug('Wiped key: data_encrypted');
    console.debug('Wiping key: STORAGEKEY');
    await RNSecureKeyStore.set(STORAGEKEY, '', { accessible: ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY });
    console.debug('Wiped key: STORAGEKEY');
    NavigationService.reset();
  } catch (error: any) {
    console.warn(error);
    presentAlert({ message: error.message });
  }
};

const unlockWithBiometrics = async () => {
  try {
    const { available } = await rnBiometrics.isSensorAvailable();
    if (!available) {
      return false;
    }

    return new Promise<boolean>(resolve => {
      rnBiometrics
        .simplePrompt({ promptMessage: loc.settings.biom_conf_identity })
        .then((result: { success: any }) => {
          if (result.success) {
            resolve(true);
          } else {
            console.debug('Biometrics authentication failed');
            resolve(false);
          }
        })
        .catch((error: Error) => {
          console.debug('Biometrics authentication error');
          presentAlert({ message: error.message });
          resolve(false);
        });
    });
  } catch (e: Error | any) {
    console.debug('Biometrics authentication error', e);
    presentAlert({ message: e.message });
    return false;
  }
};

const showKeychainWipeAlert = () => {
  if (Platform.OS === 'ios') {
    Alert.alert(
      loc.settings.encrypt_tstorage,
      loc.settings.biom_10times,
      [
        {
          text: loc._.cancel,
          onPress: () => {
            console.debug('Cancel Pressed');
          },
          style: 'cancel',
        },
        {
          text: loc._.ok,
          onPress: async () => {
            const { available } = await rnBiometrics.isSensorAvailable();
            if (!available) {
              presentAlert({ message: loc.settings.biom_no_passcode });
              return;
            }
            const isAuthenticated = await unlockWithBiometrics();
            if (isAuthenticated) {
              Alert.alert(
                loc.settings.encrypt_tstorage,
                loc.settings.biom_remove_decrypt,
                [
                  { text: loc._.cancel, style: 'cancel' },
                  {
                    text: loc._.ok,
                    style: 'destructive',
                    onPress: async () => await clearKeychain(),
                  },
                ],
                { cancelable: false },
              );
            }
          },
          style: 'default',
        },
      ],
      { cancelable: false },
    );
  }
};

const useBiometrics = () => {
  const { getItem, setItem } = useStorage();
  const [biometricEnabled, setBiometricEnabled] = useState(false);
  const [deviceBiometricType, setDeviceBiometricType] = useState<'TouchID' | 'FaceID' | 'Biometrics' | undefined>(undefined);

  useEffect(() => {
    const fetchBiometricEnabledStatus = async () => {
      const enabled = await isBiometricUseEnabled();
      setBiometricEnabled(enabled);

      const biometricType = await type();
      setDeviceBiometricType(biometricType);
    };

    fetchBiometricEnabledStatus();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const isDeviceBiometricCapable = useCallback(async () => {
    try {
      const { available } = await rnBiometrics.isSensorAvailable();
      return available;
    } catch (e) {
      console.debug('Biometrics isDeviceBiometricCapable failed');
      console.debug(e);
      setBiometricUseEnabled(false);
    }
    return false;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const type = useCallback(async () => {
    try {
      const { available, biometryType } = await rnBiometrics.isSensorAvailable();
      if (!available) {
        return undefined;
      }

      return biometryType;
    } catch (e) {
      console.debug('Biometrics biometricType failed');
      console.debug(e);
      return undefined;
    }
  }, []);

  const isBiometricUseEnabled = useCallback(async () => {
    try {
      const enabledBiometrics = await getItem(STORAGEKEY);
      return !!enabledBiometrics;
    } catch (_) {}

    return false;
  }, [getItem]);

  const isBiometricUseCapableAndEnabled = useCallback(async () => {
    const isEnabled = await isBiometricUseEnabled();
    const isCapable = await isDeviceBiometricCapable();
    return isEnabled && isCapable;
  }, [isBiometricUseEnabled, isDeviceBiometricCapable]);

  const setBiometricUseEnabled = useCallback(
    async (value: boolean) => {
      await setItem(STORAGEKEY, value === true ? '1' : '');
      setBiometricEnabled(value);
    },
    [setItem],
  );

  return {
    isDeviceBiometricCapable,
    deviceBiometricType,
    isBiometricUseEnabled,
    isBiometricUseCapableAndEnabled,
    setBiometricUseEnabled,
    clearKeychain,
    biometricEnabled,
  };
};

export { FaceID, TouchID, Biometrics, RNBiometryTypes as BiometricType, useBiometrics, showKeychainWipeAlert, unlockWithBiometrics };


================================================
FILE: ./hooks/useDebounce.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useState, useEffect, useMemo } from 'react';
import debounce from '../malin_modules/debounce';

// Overload signatures
function useDebounce<T extends (...args: any[]) => any>(callback: T, delay: number): T;
function useDebounce<T>(value: T, delay: number): T;

function useDebounce<T>(value: T, delay: number): T {
  const isFn = typeof value === 'function';

  const debouncedFunction = useMemo(() => {
    return isFn ? debounce(value as unknown as (...args: any[]) => any, delay) : null;
  }, [isFn, value, delay]);

  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    if (!isFn) {
      const handler = setTimeout(() => setDebouncedValue(value), delay);
      return () => clearTimeout(handler);
    }
  }, [isFn, value, delay]);

  return isFn ? (debouncedFunction as unknown as T) : debouncedValue;
}

export default useDebounce;


================================================
FILE: ./hooks/useSizeClass.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useSizeClass as useSizeClassOriginal, SizeClass } from '../malin_modules/sizeClass';
import type { SizeClassInfo } from '../malin_modules/sizeClass';

export { SizeClass };
export type { SizeClassInfo };

export const useSizeClass = useSizeClassOriginal;

export const useIsLargeScreen = useSizeClassOriginal;


================================================
FILE: ./hooks/useWidgetCommunication.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const useWidgetCommunication = (): void => {};

export const isBalanceDisplayAllowed = async (): Promise<boolean> => {
  return true;
};

export const setBalanceDisplayAllowed = async (_allowed: boolean): Promise<void> => {};

export default useWidgetCommunication;


================================================
FILE: ./hooks/useWatchConnectivity.ios.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useCallback, useEffect, useRef } from 'react';
import {
  transferCurrentComplicationUserInfo,
  updateApplicationContext,
  useInstalled,
  usePaired,
  useReachability,
  watchEvents,
} from 'react-native-watch-connectivity';
import { MultisigHDWallet } from '../class';
import loc from '../loc';
import { Chain } from '../models/bitcoinUnits';
import { FiatUnit } from '../models/fiatUnit';
import { useSettings } from '../hooks/context/useSettings';
import { useStorage } from '../hooks/context/useStorage';
import { isNotificationsEnabled, majorTomToGroundControl } from '../malin_modules/notifications';
import { LightningTransaction, Transaction } from '../class/wallets/types';

interface Message {
  request?: string;
  message?: string;
  walletIndex?: number;
  amount?: number;
  description?: string;
  hideBalance?: boolean;
}

interface Reply {
  (response: Record<string, any>): void;
}

interface LightningInvoiceCreateRequest {
  walletIndex: number;
  amount: number;
  description?: string;
}

export function useWatchConnectivity() {
  const { walletsInitialized, wallets, fetchWalletTransactions, saveToDisk, txMetadata } = useStorage();
  const { preferredFiatCurrency } = useSettings();
  const isReachable = useReachability();
  const isInstalled = useInstalled();
  const isPaired = usePaired();

  const messagesListenerActive = useRef(false);
  const lastPreferredCurrency = useRef(FiatUnit.USD.endPointKey);

  const createContextPayload = () => ({
    randomID: `${Date.now()}${Math.floor(Math.random() * 1000)}`,
  });

  useEffect(() => {
    if (!isInstalled || !isPaired || !walletsInitialized || !isReachable) return;

    const contextPayload = createContextPayload();
    try {
      updateApplicationContext(contextPayload);
      console.debug('Transferred user info:', contextPayload);
    } catch (error) {
      console.error('Failed to transfer user info:', error);
    }
  }, [isReachable, walletsInitialized, isInstalled, isPaired]);

  useEffect(() => {
    if (!isInstalled || !isPaired || !walletsInitialized || !isReachable || !preferredFiatCurrency) return;

    if (lastPreferredCurrency.current !== preferredFiatCurrency.endPointKey) {
      try {
        const currencyPayload = { preferredFiatCurrency: preferredFiatCurrency.endPointKey };
        transferCurrentComplicationUserInfo(currencyPayload);
        lastPreferredCurrency.current = preferredFiatCurrency.endPointKey;
        console.debug('Apple Watch: updated preferred fiat currency', currencyPayload);
      } catch (error) {
        console.error('Error updating preferredFiatCurrency on watch:', error);
      }
    } else {
      console.debug('WatchConnectivity: preferred currency has not changed');
    }
  }, [preferredFiatCurrency, walletsInitialized, isReachable, isInstalled, isPaired]);

  const handleLightningInvoiceCreateRequest = useCallback(
    async ({ walletIndex, amount, description = loc.lnd.placeholder }: LightningInvoiceCreateRequest): Promise<string | undefined> => {
      const wallet = wallets[walletIndex];
      if (wallet.allowReceive() && amount > 0) {
        try {
          if ('addInvoice' in wallet) {
            const invoiceRequest = await wallet.addInvoice(amount, description);
            if (await isNotificationsEnabled()) {
              const decoded = await wallet.decodeInvoice(invoiceRequest);
              majorTomToGroundControl([], [decoded.payment_hash], []);
              return invoiceRequest;
            }
            console.debug('Created Lightning invoice:', { invoiceRequest });
            return invoiceRequest;
          }
        } catch (invoiceError) {
          console.error('Error creating invoice:', invoiceError);
        }
      }
    },
    [wallets],
  );

  const constructWalletsToSendToWatch = useCallback(async () => {
    if (!Array.isArray(wallets) || !walletsInitialized) return;

    const walletsToProcess = await Promise.allSettled(
      wallets.map(async wallet => {
        try {
          const receiveAddress = wallet.chain === Chain.ONCHAIN ? await wallet.getAddressAsync() : wallet.getAddress();
          const transactions: Partial<Transaction>[] = wallet
            .getTransactions()
            .slice(0, 10)
            .map((transaction: Transaction & LightningTransaction) => ({
              type: determineTransactionType(transaction),
              amount: transaction.value ?? 0,
              memo:
                'hash' in (transaction as Transaction)
                  ? txMetadata[(transaction as Transaction).hash]?.memo || transaction.memo || ''
                  : transaction.memo || '',
              time: transaction.timestamp ?? transaction.time,
            }));

          const walletData = {
            label: wallet.getLabel(),
            balance: Number(wallet.getBalance()),
            type: wallet.type,
            preferredBalanceUnit: wallet.getPreferredBalanceUnit(),
            receiveAddress,
            transactions,
            chain: wallet.chain,
            hideBalance: wallet.hideBalance ? 1 : 0,
            ...(wallet.chain === Chain.ONCHAIN &&
              wallet.type !== MultisigHDWallet.type && {
                xpub: wallet.getXpub() || wallet.getSecret(),
              }),
            ...(wallet.allowBIP47() &&
              wallet.isBIP47Enabled() &&
              'getBIP47PaymentCode' in wallet && { paymentCode: wallet.getBIP47PaymentCode() }),
          };

          console.debug('Constructed wallet data for watch:', {
            label: walletData.label,
            type: walletData.type,
            preferredBalanceUnit: walletData.preferredBalanceUnit,
            transactionCount: transactions.length,
          });
          return walletData;
        } catch (error) {
          console.error('Failed to construct wallet data:', error);
          return null;
        }
      }),
    );

    const processedWallets = walletsToProcess
      .filter(result => result.status === 'fulfilled' && result.value !== null)
      .map(result => (result as PromiseFulfilledResult<any>).value);

    console.debug('Constructed wallets to process for Apple Watch:', {
      walletCount: processedWallets.length,
      walletLabels: processedWallets.map(wallet => wallet.label),
    });
    return { wallets: processedWallets, randomID: `${Date.now()}${Math.floor(Math.random() * 1000)}` };
  }, [wallets, walletsInitialized, txMetadata]);

  const determineTransactionType = (transaction: Transaction & LightningTransaction): string => {
    const confirmations = (transaction as Transaction).confirmations ?? 0;
    if (confirmations < 3) {
      return 'pending_transaction';
    }

    if (transaction.type === 'bitcoind_tx') {
      return 'onchain';
    }

    if (transaction.type === 'paid_invoice') {
      return 'offchain';
    }

    if (transaction.type === 'user_invoice' || transaction.type === 'payment_request') {
      const currentDate = new Date();
      const now = Math.floor(currentDate.getTime() / 1000);
      const timestamp = transaction.timestamp ?? 0;
      const expireTime = transaction.expire_time ?? 0;
      const invoiceExpiration = timestamp + expireTime;
      if (!transaction.ispaid && invoiceExpiration < now) {
        return 'expired_transaction';
      } else {
        return 'incoming_transaction';
      }
    }

    if ((transaction.value ?? 0) < 0) {
      return 'outgoing_transaction';
    } else {
      return 'incoming_transaction';
    }
  };

  const handleMessages = useCallback(
    async (message: Message, reply: Reply) => {
      console.debug('Received message from Apple Watch:', message);
      try {
        if (message.request === 'createInvoice' && typeof message.walletIndex === 'number' && typeof message.amount === 'number') {
          const createInvoiceRequest = await handleLightningInvoiceCreateRequest({
            walletIndex: message.walletIndex,
            amount: message.amount,
            description: message.description,
          });
          reply({ invoicePaymentRequest: createInvoiceRequest });
        } else if (message.message === 'sendApplicationContext') {
          const walletsToProcess = await constructWalletsToSendToWatch();
          if (walletsToProcess) {
            updateApplicationContext(walletsToProcess);
            console.debug('Transferred user info on request:', walletsToProcess);
          }
        } else if (message.message === 'fetchTransactions') {
          await fetchWalletTransactions();
          await saveToDisk();
          reply({});
        } else if (
          message.message === 'hideBalance' &&
          typeof message.walletIndex === 'number' &&
          typeof message.hideBalance === 'boolean' &&
          message.walletIndex >= 0 &&
          message.walletIndex < wallets.length
        ) {
          wallets[message.walletIndex].hideBalance = message.hideBalance;
          await saveToDisk();
          reply({});
        }
      } catch (error) {
        console.error('Error handling message:', error);
        reply({});
      }
    },
    [fetchWalletTransactions, saveToDisk, wallets, constructWalletsToSendToWatch, handleLightningInvoiceCreateRequest],
  );

  useEffect(() => {
    if (!isInstalled || !isPaired || !walletsInitialized) return;

    const sendWalletData = async () => {
      try {
        const walletsToProcess = await constructWalletsToSendToWatch();
        if (walletsToProcess) {
          updateApplicationContext(walletsToProcess);
          console.debug('Apple Watch: sent wallet data via transferUserInfo', walletsToProcess);
        }
      } catch (error) {
        console.error('Failed to send wallets to watch:', error);
      }
    };
    sendWalletData();
  }, [walletsInitialized, isInstalled, isPaired, constructWalletsToSendToWatch]);

  useEffect(() => {
    if (!isInstalled) return;

    const unsubscribe = watchEvents.addListener('message', (message: any) => {
      if (message.request === 'wakeUpApp') {
        console.debug('Received wake-up request from Apple Watch');
      } else {
        handleMessages(message, () => {});
      }
    });

    messagesListenerActive.current = true;
    console.debug('Message listener set up for Apple Watch');

    return () => {
      unsubscribe();
      messagesListenerActive.current = false;
      console.debug('Message listener for Apple Watch cleaned up');
    };
  }, [isInstalled, handleMessages]);
}

export default useWatchConnectivity;

================================================
FILE: ./hooks/useWalletSubscribe.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect, useMemo, useRef, useState } from 'react';
import { useStorage } from './context/useStorage';
import { TWallet } from '../class/wallets/types';

/**
 * A React hook that provides a proxied wallet instance that automatically updates when new transactions are fetched.
 */
const useWalletSubscribe = (walletID: string): TWallet => {
  const { wallets } = useStorage();

  // get wallet by ID or used cached wallet
  const previousWallet = useRef<TWallet | undefined>();
  const origWallet = wallets.find(w => w.getID() === walletID) ?? previousWallet.current;
  if (!origWallet) {
    throw new Error(`Wallet with ID ${walletID} not found`);
  }
  previousWallet.current = origWallet;

  const [lastTxFetch, setLastTxFetch] = useState(origWallet.getLastTxFetch());

  const walletProxy = useMemo(() => {
    return new Proxy(origWallet, {});
    // force update when lastTxFetch changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [lastTxFetch, origWallet]);

  // check every second for getLastTxFetch
  useEffect(() => {
    const interval = setInterval(() => {
      setLastTxFetch(origWallet.getLastTxFetch());
    }, 1000);

    return () => clearInterval(interval);
  }, [origWallet]);

  return walletProxy;
};

export default useWalletSubscribe;


================================================
FILE: ./hooks/useOnAppLaunch.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { TWallet } from '../class/wallets/types';
import { useStorage } from './context/useStorage';

const useOnAppLaunch = () => {
  const STORAGE_KEY = 'ONAPP_LAUNCH_SELECTED_DEFAULT_WALLET_KEY';
  const { wallets } = useStorage();

  const getSelectedDefaultWallet = useCallback(async (): Promise<string | undefined> => {
    let selectedWallet: TWallet | undefined;
    try {
      const selectedWalletID = await AsyncStorage.getItem(STORAGE_KEY);
      console.log('Selected wallet ID:', selectedWalletID);
      if (selectedWalletID !== null) {
        selectedWallet = wallets.find((wallet: TWallet) => wallet.getID() === selectedWalletID);
        if (!selectedWallet) {
          await AsyncStorage.removeItem(STORAGE_KEY);
          return undefined;
        }
      } else {
        return undefined;
      }
    } catch (_e) {
      return undefined;
    }
    return selectedWallet.getID();
  }, [STORAGE_KEY, wallets]);

  const setSelectedDefaultWallet = useCallback(
    async (value: string): Promise<void> => {
      await AsyncStorage.setItem(STORAGE_KEY, value);
    },
    [STORAGE_KEY],
  ); // No external dependencies

  const isViewAllWalletsEnabled = useCallback(async (): Promise<boolean> => {
    try {
      const selectedDefaultWallet = await AsyncStorage.getItem(STORAGE_KEY);
      return selectedDefaultWallet === '' || selectedDefaultWallet === null;
    } catch (_e) {
      return true;
    }
  }, [STORAGE_KEY]); // No external dependencies

  const setViewAllWalletsEnabled = useCallback(
    async (value: boolean): Promise<void> => {
      if (!value) {
        const selectedDefaultWallet = await getSelectedDefaultWallet();
        if (!selectedDefaultWallet) {
          const firstWallet = wallets[0];
          await setSelectedDefaultWallet(firstWallet.getID());
        }
      } else {
        await AsyncStorage.setItem(STORAGE_KEY, '');
      }
    },
    [STORAGE_KEY, getSelectedDefaultWallet, setSelectedDefaultWallet, wallets],
  );

  return {
    isViewAllWalletsEnabled,
    setViewAllWalletsEnabled,
    getSelectedDefaultWallet,
    setSelectedDefaultWallet,
  };
};

export default useOnAppLaunch;


================================================
FILE: ./hooks/useMenuElements.ios.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect, useCallback, useRef } from 'react';
import { NativeEventEmitter, NativeModules, Platform } from 'react-native';
import { navigationRef } from '../NavigationService';

type MenuActionHandler = () => void;

const { MenuElementsEmitter } = NativeModules;
let eventEmitter: NativeEventEmitter | null = null;
const handlerRegistry = new Map<string, MenuActionHandler>();

try {
  if (Platform.OS === 'ios' && MenuElementsEmitter) {
    eventEmitter = new NativeEventEmitter(MenuElementsEmitter);
    if (typeof MenuElementsEmitter.sharedInstance === 'function') {
      MenuElementsEmitter.sharedInstance();
    }
  }
} catch (error) {
  console.warn('Failed to initialize menu emitter:', error);
  eventEmitter = null;
}

interface MenuElementsHook {
  registerTransactionsHandler: (handler: MenuActionHandler, screenKey?: string) => boolean;
  unregisterTransactionsHandler: (screenKey: string) => void;
  isMenuElementsSupported: boolean;
}

const useMenuElements = (): MenuElementsHook => {
  const initialized = useRef(false);

  useEffect(() => {
    if (!initialized.current && eventEmitter) {
      initialized.current = true;

      eventEmitter.addListener('openSettings', () => {
        if (navigationRef.isReady()) {
          navigationRef.navigate('Settings');
        }
      });

      eventEmitter.addListener('addWalletMenuAction', () => {
        if (navigationRef.isReady()) {
          navigationRef.navigate('AddWalletRoot');
        }
      });

      eventEmitter.addListener('importWalletMenuAction', () => {
        if (navigationRef.isReady()) {
          navigationRef.navigate('AddWalletRoot', { screen: 'ImportWallet' });
        }
      });

      eventEmitter.addListener('reloadTransactionsMenuAction', () => {
        if (!navigationRef.isReady()) return;

        const currentRoute = navigationRef.getCurrentRoute();
        if (!currentRoute) return;

        const screenName = currentRoute.name;
        const params = (currentRoute.params as { walletID?: string }) || {};
        const walletID = params.walletID;
        const specificKey = walletID ? `${screenName}-${walletID}` : null;

        const handler = (specificKey ? handlerRegistry.get(specificKey) : undefined) || handlerRegistry.get(screenName);

        if (typeof handler === 'function') {
          handler();
        }
      });
    }
  }, []);

  const registerTransactionsHandler = useCallback((handler: MenuActionHandler, screenKey?: string): boolean => {
    if (typeof handler !== 'function') return false;
    const key = screenKey || navigationRef.current?.getCurrentRoute()?.name;
    if (!key) return false;
    handlerRegistry.set(key, handler);
    return true;
  }, []);

  const unregisterTransactionsHandler = useCallback((screenKey: string): void => {
    if (screenKey) handlerRegistry.delete(screenKey);
  }, []);

  return {
    registerTransactionsHandler,
    unregisterTransactionsHandler,
    isMenuElementsSupported: !!eventEmitter,
  };
};

export default useMenuElements;


================================================
FILE: ./hooks/useHandoffListener.ios.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect, useCallback } from 'react';
import { NativeEventEmitter, NativeModules } from 'react-native';
import { useStorage } from '../hooks/context/useStorage';
import { useExtendedNavigation } from '../hooks/useExtendedNavigation';
import { HandOffActivityType } from '../components/types';
import { useSettings } from './context/useSettings';

interface UserActivityData {
  activityType: HandOffActivityType;
  userInfo: {
    address?: string;
    xpub?: string;
  };
}

const EventEmitter = NativeModules.EventEmitter;
const eventEmitter = EventEmitter ? new NativeEventEmitter(EventEmitter) : null;

const useHandoffListener = () => {
  const { walletsInitialized } = useStorage();
  const { isHandOffUseEnabled } = useSettings();
  const { navigate } = useExtendedNavigation();

  const handleUserActivity = useCallback(
    (data: UserActivityData) => {
      if (!data || !data.activityType) {
        console.debug(`Invalid handoff data received: ${data ? JSON.stringify(data) : 'No data provided'}`);
        return;
      }
      const { activityType, userInfo } = data;
      const modifiedUserInfo = { ...(userInfo || {}), type: activityType };
      try {
        if (activityType === HandOffActivityType.ReceiveOnchain && modifiedUserInfo.address) {
          navigate( 'ReceiveDetails', { address: modifiedUserInfo.address, type: activityType },
          );
        } else if (activityType === HandOffActivityType.Xpub && modifiedUserInfo.xpub) {
          navigate('WalletXpub', { xpub: modifiedUserInfo.xpub, type: activityType });
        } else {
          console.debug(`Unhandled or incomplete activity type/data: ${activityType}`, modifiedUserInfo);
        }
      } catch (error) {
        console.error('Error handling user activity:', error);
      }
    },
    [navigate],
  );

  useEffect(() => {
    if (!walletsInitialized || !isHandOffUseEnabled) return;

    const activitySubscription = eventEmitter?.addListener('onUserActivityOpen', handleUserActivity);

    if (EventEmitter && EventEmitter.getMostRecentUserActivity) {
      EventEmitter.getMostRecentUserActivity()
        .then(handleUserActivity)
        .catch(() => console.debug('No valid user activity object received'));
    } else {
      console.debug('EventEmitter native module is not available.');
    }

    return () => {
      activitySubscription?.remove();
    };
  }, [walletsInitialized, isHandOffUseEnabled, handleUserActivity]);
};

export default useHandoffListener;


================================================
FILE: ./hooks/useAnimateOnChange.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect, useRef } from 'react';
import { LayoutAnimation } from 'react-native';

const useAnimateOnChange = <T>(value: T) => {
  const prevValue = useRef<T | undefined>(undefined);
  useEffect(() => {
    if (prevValue.current !== undefined && prevValue.current !== value) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }
    prevValue.current = value;
  }, [value]);
};
export default useAnimateOnChange;


================================================
FILE: ./hooks/useAppState.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useState, useEffect, useRef } from 'react';
import { AppState, AppStateStatus } from 'react-native';

const useAppState = (): { currentAppState: AppStateStatus, previousAppState: AppStateStatus | null } => {
  const [currentAppState, setCurrentAppState] = useState<AppStateStatus>(AppState.currentState);
  const previousAppState = useRef<AppStateStatus | null>(null);

  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      previousAppState.current = currentAppState;
      setCurrentAppState(nextAppState);
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);

    return () => {
      subscription.remove();
    };
  }, [currentAppState]);

  return { currentAppState, previousAppState: previousAppState.current };
};

export default useAppState;

================================================
FILE: ./hooks/useExtendedNavigation.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useNavigation, NavigationProp, ParamListBase, CommonActions } from '@react-navigation/native';
import { navigationRef } from '../NavigationService';
import { presentWalletExportReminder } from '../helpers/presentWalletExportReminder';
import { unlockWithBiometrics, useBiometrics } from './useBiometrics';
import { useStorage } from './context/useStorage';
import { requestCameraAuthorization } from '../helpers/scan-qr';
import { useCallback, useMemo } from 'react';

// List of screens that require biometrics
const requiresBiometrics = ['WalletExport', 'WalletXpub', 'ViewEditMultisigCosigners', 'ExportMultisigCoordinationSetupRoot'];

// List of screens that require wallet export to be saved
const requiresWalletExportIsSaved = ['ReceiveDetails', 'WalletAddresses'];

export const useExtendedNavigation = <T extends NavigationProp<ParamListBase>>(): T & {
  navigateToWalletsList: () => void;
} => {
  const originalNavigation = useNavigation<T>();
  const { wallets, saveToDisk } = useStorage();
  const { isBiometricUseEnabled } = useBiometrics();

  const enhancedNavigate = useCallback(
    (
      ...args:
        | [string]
        | [string, object | undefined]
        | [string, object | undefined, { merge?: boolean }]
        | [{ name: string; params?: object; path?: string; merge?: boolean }]
    ) => {
      let screenOrOptions: any;
      let params: any;
      let options: { merge?: boolean } | undefined;

      if (typeof args[0] === 'string') {
        screenOrOptions = args[0];
        params = args[1];
        options = args[2];
      } else {
        screenOrOptions = args[0];
      }
      let screenName: string;
      if (typeof screenOrOptions === 'string') {
        screenName = screenOrOptions;
      } else if (typeof screenOrOptions === 'object' && 'name' in screenOrOptions) {
        screenName = screenOrOptions.name;
        params = screenOrOptions.params; // Assign params from object if present
      } else {
        throw new Error('Invalid navigation options');
      }

      const isRequiresBiometrics = requiresBiometrics.includes(screenName);
      const isRequiresWalletExportIsSaved = requiresWalletExportIsSaved.includes(screenName);

      const proceedWithNavigation = () => {
        console.log('Proceeding with navigation to', screenName);

        // Navigation logic based on current route and target screen
        if (navigationRef.current?.isReady()) {
          // Get the current route - we need to know which navigator we're in
          const currentRoute = navigationRef.current.getCurrentRoute();
          const currentRouteName = currentRoute?.name;

          // Handle specific cases for nested navigation
          if (currentRouteName === 'DrawerRoot') {
            // If we're in DrawerRoot and trying to navigate to a screen that exists in DetailViewStackScreensStack
            originalNavigation.navigate('DrawerRoot', {
              screen: 'DetailViewStackScreensStack',
              params: {
                screen: screenName,
                params,
              },
            });
          } else {
            // Normal navigation
            if (typeof screenOrOptions === 'string') {
              originalNavigation.navigate({ name: screenOrOptions, params, merge: options?.merge });
            } else {
              originalNavigation.navigate({ ...screenOrOptions, params, merge: options?.merge });
            }
          }
        }
      };

      (async () => {
        // Skip checks for ScanQRCode screen
        const currentRouteName = navigationRef.current?.getCurrentRoute()?.name;
        if (currentRouteName === 'ScanQRCode') {
          proceedWithNavigation();
          return;
        }

        if (isRequiresBiometrics) {
          const isBiometricsEnabled = await isBiometricUseEnabled();
          if (isBiometricsEnabled) {
            const isAuthenticated = await unlockWithBiometrics();
            if (isAuthenticated) {
              proceedWithNavigation();
              return;
            } else {
              console.error('Biometric authentication failed');
              return;
            }
          }
        }
        if (isRequiresWalletExportIsSaved) {
          console.log('Checking if wallet export is saved');
          let walletID: string | undefined;
          if (params && params.walletID) {
            walletID = params.walletID;
          } else if (params && params.params && params.params.walletID) {
            walletID = params.params.walletID;
          }
          if (!walletID) {
            proceedWithNavigation();
            return;
          }
          const wallet = wallets.find(w => w.getID() === walletID);
          if (wallet && !wallet.getUserHasSavedExport()) {
            try {
              await presentWalletExportReminder();
              wallet.setUserHasSavedExport(true);
              await saveToDisk();
              proceedWithNavigation();
            } catch (error) {
              originalNavigation.navigate('WalletExport', { walletID });
            }
            return;
          }
        }

        if (screenName === 'ScanQRCode') {
          await requestCameraAuthorization();
        }
        proceedWithNavigation();
      })();
    },
    [originalNavigation, isBiometricUseEnabled, wallets, saveToDisk],
  );

  const navigateToWalletsList = useCallback(() => {
  if (navigationRef.isReady()) {
    navigationRef.dispatch(
      CommonActions.reset({
        index: 0,
        routes: [
          {
            name: 'DrawerRoot',
            state: {
              routes: [
                {
                  name: 'DetailViewStackScreensStack',
                  state: {
                    routes: [
                      {
                        name: 'WalletsList',
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      })
    );
  }
}, []);

  return useMemo(
    () => ({
      ...originalNavigation,
      navigate: enhancedNavigate,
      navigateToWalletsList,
    }),
    [originalNavigation, enhancedNavigate, navigateToWalletsList],
  ) as T & { navigateToWalletsList: () => void };
};

================================================
FILE: ./hooks/useDeviceQuickActions.windows.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved

export const DeviceQuickActionsStorageKey = 'DeviceQuickActionsEnabled';

export const setEnabled = (): void => {};

export const getEnabled = async (): Promise<boolean> => {
  return false;
};

const useDeviceQuickActions = () => {

  const popInitialAction = (): void => {};
  return { popInitialAction };
};


export default useDeviceQuickActions;


================================================
FILE: ./hooks/useMenuElements.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useCallback } from 'react';

type MenuActionHandler = () => void;

interface MenuElementsHook {
  registerTransactionsHandler: (handler: MenuActionHandler, screenKey?: string) => boolean;
  unregisterTransactionsHandler: (screenKey: string) => void;
  isMenuElementsSupported: boolean;
}

// Default implementation for platforms other than iOS
const useMenuElements = (): MenuElementsHook => {
  const registerTransactionsHandler = useCallback((_handler: MenuActionHandler, _screenKey?: string): boolean => {
    // Non-functional stub for non-iOS platforms
    return false;
  }, []);

  const unregisterTransactionsHandler = useCallback((_screenKey: string): void => {
    // No-op for non-supported platforms
  }, []);

  return {
    registerTransactionsHandler,
    unregisterTransactionsHandler,
    isMenuElementsSupported: false, // Not supported on platforms other than iOS
  };
};

export default useMenuElements;


================================================
FILE: ./hooks/useBounceAnimation.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect, useRef } from 'react';
import { Animated } from 'react-native';

const useBounceAnimation = (query: string) => {
  const bounceAnim = useRef(new Animated.Value(1.0)).current;

  useEffect(() => {
    if (query) {
      Animated.timing(bounceAnim, {
        toValue: 1.08, // Reduced from 1.2 to 1.08 for more subtle animation
        duration: 150,
        useNativeDriver: true,
      }).start(() => {
        Animated.timing(bounceAnim, {
          toValue: 1.0,
          duration: 150,
          useNativeDriver: true,
        }).start();
      });
    }
  }, [bounceAnim, query]);

  return bounceAnim;
};

export default useBounceAnimation;


================================================
FILE: ./hooks/useScreenProtect.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { CaptureProtection, useCaptureProtection } from 'react-native-capture-protection';
import { isDesktop } from '../malin_modules/environment';

export const useScreenProtect = () => {
  const { protectionStatus, status } = useCaptureProtection();

  const enableScreenProtect = () => {
    if (isDesktop) return;
    CaptureProtection.prevent();
  };

  const disableScreenProtect = async () => {
    if (isDesktop) return;
    await CaptureProtection.allow();
  };

  const isScreenBeingRecorded = async () => {
    if (isDesktop) return false;
    return await CaptureProtection.isScreenRecording();
  };

  return {
    enableScreenProtect,
    disableScreenProtect,
    isScreenBeingRecorded,
    protectionStatus,
    status,
  };
};

================================================
FILE: ./hooks/useHandoffListener.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const useHandoffListener = () => {};

export default useHandoffListener;


================================================
FILE: ./hooks/useWatchConnectivity.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
const useWatchConnectivity = () => {};
export default useWatchConnectivity;


================================================
FILE: ./hooks/useWidgetCommunication.ios.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { useEffect, useRef } from 'react';
import DefaultPreference from 'react-native-default-preference';
import { Transaction, TWallet } from '../class/wallets/types';
import { useSettings } from '../hooks/context/useSettings';
import { useStorage } from '../hooks/context/useStorage';
import { GROUP_IO_MALINWALLET } from '../malin_modules/currency';
import debounce from '../malin_modules/debounce';

enum WidgetCommunicationKeys {
  AllWalletsSatoshiBalance = 'WidgetCommunicationAllWalletsSatoshiBalance',
  AllWalletsLatestTransactionTime = 'WidgetCommunicationAllWalletsLatestTransactionTime',
  DisplayBalanceAllowed = 'WidgetCommunicationDisplayBalanceAllowed',
  LatestTransactionIsUnconfirmed = 'WidgetCommunicationLatestTransactionIsUnconfirmed',
}

const WIDGET_ENABLED = '1';
const WIDGET_DISABLED = '0';
const WIDGET_CLEARED_VALUE = '0';

const secondsToMilliseconds = (seconds: number): number => seconds * 1000;

DefaultPreference.setName(GROUP_IO_MALINWALLET);

export const isBalanceDisplayAllowed = async (): Promise<boolean> => {
  try {
    const displayBalance = await DefaultPreference.get(WidgetCommunicationKeys.DisplayBalanceAllowed);
    if (displayBalance === WIDGET_ENABLED) {
      return true;
    } else if (displayBalance === WIDGET_DISABLED) {
      return false;
    } else {
      // Preference not set, initialize to enabled by default
      await DefaultPreference.set(WidgetCommunicationKeys.DisplayBalanceAllowed, WIDGET_ENABLED);
      return true;
    }
  } catch (error) {
    console.error('Failed to get DisplayBalanceAllowed:', error);
    return true;
  }
};

export const setBalanceDisplayAllowed = async (allowed: boolean): Promise<void> => {
  try {
    if (allowed) {
      await DefaultPreference.set(WidgetCommunicationKeys.DisplayBalanceAllowed, WIDGET_ENABLED);
    } else {
      await DefaultPreference.set(WidgetCommunicationKeys.DisplayBalanceAllowed, WIDGET_DISABLED);
      // Clear widget data immediately when disabling
      await Promise.all([
        DefaultPreference.set(WidgetCommunicationKeys.AllWalletsSatoshiBalance, WIDGET_CLEARED_VALUE),
        DefaultPreference.set(WidgetCommunicationKeys.AllWalletsLatestTransactionTime, WIDGET_CLEARED_VALUE),
      ]);
    }
    console.debug('setBalanceDisplayAllowed:', allowed);
  } catch (error) {
    console.error('Failed to set DisplayBalanceAllowed:', error);
  }
};

export const calculateBalanceAndTransactionTime = async (
  wallets: TWallet[],
  walletsInitialized: boolean,
): Promise<{
  allWalletsBalance: number;
  latestTransactionTime: number | string;
}> => {
  if (!walletsInitialized || !(await isBalanceDisplayAllowed())) {
    return { allWalletsBalance: 0, latestTransactionTime: 0 };
  }

  const results = await Promise.allSettled(
    wallets.map(async wallet => {
      if (wallet.hideBalance) return { balance: 0, latestTransactionTime: 0 };

      const balance = await wallet.getBalance();
      const transactions: Transaction[] = await wallet.getTransactions();
      const confirmedTransactions = transactions.filter(t => t.confirmations > 0);
      const latestTransactionTime =
        confirmedTransactions.length > 0
          ? secondsToMilliseconds(Math.max(...confirmedTransactions.map(t => t.timestamp || t.time || 0)))
          : WidgetCommunicationKeys.LatestTransactionIsUnconfirmed;

      return { balance, latestTransactionTime };
    }),
  );

  const allWalletsBalance = results.reduce((acc, result) => acc + (result.status === 'fulfilled' ? result.value.balance : 0), 0);
  const latestTransactionTime = results.reduce(
    (max, result) =>
      result.status === 'fulfilled' && typeof result.value.latestTransactionTime === 'number' && result.value.latestTransactionTime > max
        ? result.value.latestTransactionTime
        : max,
    0,
  );

  return { allWalletsBalance, latestTransactionTime };
};

export const syncWidgetBalanceWithWallets = async (
  wallets: TWallet[],
  walletsInitialized: boolean,
  cachedBalance: { current: number },
  cachedLatestTransactionTime: { current: number | string },
): Promise<void> => {
  try {
    const { allWalletsBalance, latestTransactionTime } = await calculateBalanceAndTransactionTime(wallets, walletsInitialized);

    if (cachedBalance.current !== allWalletsBalance || cachedLatestTransactionTime.current !== latestTransactionTime) {
      await Promise.all([
        DefaultPreference.set(WidgetCommunicationKeys.AllWalletsSatoshiBalance, String(allWalletsBalance)),
        DefaultPreference.set(WidgetCommunicationKeys.AllWalletsLatestTransactionTime, String(latestTransactionTime)),
      ]);

      cachedBalance.current = allWalletsBalance;
      cachedLatestTransactionTime.current = latestTransactionTime;
    }
  } catch (error) {
    console.error('Failed to sync widget balance with wallets:', error);
  }
};

const debouncedSyncWidgetBalanceWithWallets = debounce(
  async (
    wallets: TWallet[],
    walletsInitialized: boolean,
    cachedBalance: { current: number },
    cachedLatestTransactionTime: { current: number | string },
  ) => {
    await syncWidgetBalanceWithWallets(wallets, walletsInitialized, cachedBalance, cachedLatestTransactionTime);
  },
  500,
);

const useWidgetCommunication = (): void => {
  const { wallets, walletsInitialized } = useStorage();
  const { isWidgetBalanceDisplayAllowed } = useSettings();
  const cachedBalance = useRef<number>(0);
  const cachedLatestTransactionTime = useRef<number | string>(0);

  // Handle widget data clearing when the setting is disabled
  useEffect(() => {
    const clearWidgetData = async () => {
      if (walletsInitialized && !isWidgetBalanceDisplayAllowed) {
        try {
          await Promise.all([
            DefaultPreference.set(WidgetCommunicationKeys.AllWalletsSatoshiBalance, WIDGET_CLEARED_VALUE),
            DefaultPreference.set(WidgetCommunicationKeys.AllWalletsLatestTransactionTime, WIDGET_CLEARED_VALUE),
          ]);
          cachedBalance.current = 0;
          cachedLatestTransactionTime.current = 0;
          console.debug('Widget data cleared due to setting being disabled');
        } catch (error) {
          console.error('Failed to clear widget data:', error);
        }
      }
    };

    clearWidgetData();
  }, [isWidgetBalanceDisplayAllowed, walletsInitialized]);

  // Sync widget data when wallets change or setting is enabled
  useEffect(() => {
    if (walletsInitialized) {
      debouncedSyncWidgetBalanceWithWallets(wallets, walletsInitialized, cachedBalance, cachedLatestTransactionTime);
    }
  }, [wallets, walletsInitialized, isWidgetBalanceDisplayAllowed]);

  useEffect(() => {
    return () => {
      debouncedSyncWidgetBalanceWithWallets.cancel();
    };
  }, []);
};

export default useWidgetCommunication;


================================================
FILE: ./navigation/SignVerifyStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import React from 'react';

import navigationStyle from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import { SignVerifyComponent } from './LazyLoadSignVerifyStack';

const Stack = createNativeStackNavigator();

const SignVerifyStackRoot = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator screenOptions={{ headerShadowVisible: false }}>
      <Stack.Screen
        name="SignVerify"
        component={SignVerifyComponent}
        options={navigationStyle({ headerBackVisible: false, statusBarStyle: 'light', title: loc.addresses.sign_title })(theme)}
      />
    </Stack.Navigator>
  );
};

export default SignVerifyStackRoot;


================================================
FILE: ./navigation/LazyLoadSignVerifyStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const SignVerify = lazy(() => import('../screen/wallets/signVerify'));

export const SignVerifyComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SignVerify />
  </Suspense>
);


================================================
FILE: ./navigation/DetailViewScreensStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useCallback, useMemo } from 'react';
import { View } from 'react-native';
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import HeaderRightButton from '../components/HeaderRightButton';
import navigationStyle, { CloseButtonPosition } from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import { useExtendedNavigation } from '../hooks/useExtendedNavigation';
import loc from '../loc';
import LNDViewAdditionalInvoicePreImage from '../screen/lnd/lndViewAdditionalInvoicePreImage';
import LNDViewInvoice from '../screen/lnd/lndViewInvoice';
import LnurlAuth from '../screen/lnd/lnurlAuth';
import LnurlPay from '../screen/lnd/lnurlPay';
import LnurlPaySuccess from '../screen/lnd/lnurlPaySuccess';
import Broadcast from '../screen/send/Broadcast';
import IsItMyAddress from '../screen/settings/IsItMyAddress';
import Success from '../screen/send/success';
import CPFP from '../screen/transactions/CPFP';
import TransactionDetails from '../screen/transactions/TransactionDetails';
import RBFBumpFee from '../screen/transactions/RBFBumpFee';
import RBFCancel from '../screen/transactions/RBFCancel';
import TransactionStatus from '../screen/transactions/TransactionStatus';
import WalletAddresses from '../screen/wallets/WalletAddresses';
import WalletDetails from '../screen/wallets/WalletDetails';
import GenerateWord from '../screen/wallets/generateWord';
import SelectWallet from '../screen/wallets/SelectWallet';
import WalletsList from '../screen/wallets/WalletsList';
import { DetailViewStack } from './index';
import PaymentCodesListComponent from './LazyLoadPaymentCodeStack';
import SettingsButton from '../components/icons/SettingsButton';
import { useSettings } from '../hooks/context/useSettings';
import { useStorage } from '../hooks/context/useStorage';
import WalletTransactions from '../screen/wallets/WalletTransactions';
import AddWalletButton from '../components/AddWalletButton';
import Settings from '../screen/settings/Settings';
import Currency from '../screen/settings/Currency';
import GeneralSettings from '../screen/settings/GeneralSettings';
import PlausibleDeniability from '../screen/PlausibleDeniability';
import Licensing from '../screen/settings/Licensing';
import NetworkSettings from '../screen/settings/NetworkSettings';
import SettingsBlockExplorer from '../screen/settings/SettingsBlockExplorer';
import About from '../screen/settings/About';
import DefaultView from '../screen/settings/DefaultView';
import ElectrumSettings from '../screen/settings/ElectrumSettings';
import EncryptStorage from '../screen/settings/EncryptStorage';
import Language from '../screen/settings/Language';
import LightningSettings from '../screen/settings/LightningSettings';
import NotificationSettings from '../screen/settings/NotificationSettings';
import SelfTest from '../screen/settings/SelfTest';
import ReleaseNotes from '../screen/settings/ReleaseNotes';
import ToolsScreen from '../screen/settings/tools';
import SettingsPrivacy from '../screen/settings/SettingsPrivacy';
import { useSizeClass, SizeClass } from '../malin_modules/sizeClass';
import getWalletTransactionsOptions from './helpers/getWalletTransactionsOptions';
import { isDesktop } from '../malin_modules/environment';
import ManageWallets from '../screen/wallets/ManageWallets';
import ReceiveDetails from '../screen/receive/ReceiveDetails';
import Browser from '../screen/Browser';
import Swap from '../screen/Swap';

const DetailViewStackScreensStack = () => {
  const theme = useTheme();
  const navigation = useExtendedNavigation();
  const { wallets } = useStorage();
  const { isTotalBalanceEnabled } = useSettings();
  const { sizeClass } = useSizeClass();

  const DetailButton = useMemo(() => <HeaderRightButton testID="DetailButton" disabled={true} title={loc.send.create_details} />, []);

  const navigateToAddWallet = useCallback(() => {
    navigation.navigate('AddWalletRoot');
  }, [navigation]);

  const RightBarButtons = useMemo(
    () =>
      sizeClass === SizeClass.Large ? (
        <SettingsButton />
      ) : (
        <>
          <AddWalletButton onPress={navigateToAddWallet} />
          <View style={styles.width24} />
          <SettingsButton />
        </>
      ),
    [sizeClass, navigateToAddWallet],
  );

  const useWalletListScreenOptions = useMemo<NativeStackNavigationOptions>(() => {
    const displayTitle = !isTotalBalanceEnabled || wallets.length <= 1;
    return {
      title: sizeClass === SizeClass.Large ? loc.transactions.list_title : displayTitle ? loc.wallets.wallets : '',
      navigationBarColor: theme.colors.navigationBarColor,
      headerLargeTitle: displayTitle && sizeClass === SizeClass.Compact,
      headerShadowVisible: false,
      headerStyle: {
        backgroundColor: theme.colors.customHeader,
      },
      headerRight: () => (isDesktop ? undefined : RightBarButtons),
    };
  }, [RightBarButtons, sizeClass, isTotalBalanceEnabled, theme.colors.customHeader, theme.colors.navigationBarColor, wallets]);

  const walletListScreenOptions = useWalletListScreenOptions;

  return (
    <DetailViewStack.Navigator
      initialRouteName="WalletsList"
      screenOptions={{ headerShadowVisible: false, animationTypeForReplace: 'push' }}
    >
      <DetailViewStack.Screen name="WalletsList" component={WalletsList} options={navigationStyle(walletListScreenOptions)(theme)} />
      <DetailViewStack.Screen name="WalletTransactions" component={WalletTransactions} options={getWalletTransactionsOptions} />
      <DetailViewStack.Screen
        name="WalletDetails"
        component={WalletDetails}
        options={navigationStyle({
          headerTitle: loc.wallets.details_title,
          statusBarStyle: 'auto',
        })(theme)}
      />
      <DetailViewStack.Screen
        name="TransactionDetails"
        component={TransactionDetails}
        options={navigationStyle({
          statusBarStyle: 'auto',
          headerStyle: {
            backgroundColor: theme.colors.customHeader,
          },
          headerTitle: loc.transactions.details_title,
        })(theme)}
      />
      <DetailViewStack.Screen
        name="TransactionStatus"
        component={TransactionStatus}
        initialParams={{
          hash: undefined,
          walletID: undefined,
        }}
        options={navigationStyle({
          statusBarStyle: 'auto',
          headerStyle: {
            backgroundColor: theme.colors.customHeader,
          },
          headerTitle: '',
          headerRight: () => DetailButton,
          headerBackButtonDisplayMode: 'default',
        })(theme)}
      />
      <DetailViewStack.Screen name="CPFP" component={CPFP} options={navigationStyle({ title: loc.transactions.cpfp_title })(theme)} />
      <DetailViewStack.Screen
        name="RBFBumpFee"
        component={RBFBumpFee}
        options={navigationStyle({ title: loc.transactions.rbf_title })(theme)}
      />
      <DetailViewStack.Screen
        name="RBFCancel"
        component={RBFCancel}
        options={navigationStyle({ title: loc.transactions.cancel_title })(theme)}
      />
      <DetailViewStack.Screen
        name="SelectWallet"
        component={SelectWallet}
        options={navigationStyle({ title: loc.wallets.select_wallet })(theme)}
      />
      <DetailViewStack.Screen
        name="LNDViewInvoice"
        component={LNDViewInvoice}
        options={navigationStyle({
          statusBarStyle: 'auto',
          headerTitle: loc.lndViewInvoice.lightning_invoice,
          headerStyle: {
            backgroundColor: theme.colors.customHeader,
          },
        })(theme)}
      />
      <DetailViewStack.Screen
        name="LNDViewAdditionalInvoicePreImage"
        component={LNDViewAdditionalInvoicePreImage}
        options={navigationStyle({ title: loc.lndViewInvoice.additional_info })(theme)}
      />

      <DetailViewStack.Screen
        name="Broadcast"
        component={Broadcast}
        options={navigationStyle({ title: loc.send.create_broadcast })(theme)}
      />
      <DetailViewStack.Screen
        name="IsItMyAddress"
        component={IsItMyAddress}
        initialParams={{ address: undefined }}
        options={navigationStyle({ title: loc.is_it_my_address.title })(theme)}
      />
      <DetailViewStack.Screen
        name="GenerateWord"
        component={GenerateWord}
        options={navigationStyle({ title: loc.autofill_word.title })(theme)}
      />
      <DetailViewStack.Screen
        name="LnurlPay"
        component={LnurlPay}
        options={navigationStyle({
          title: '',
          closeButtonPosition: CloseButtonPosition.Right,
        })(theme)}
      />
      <DetailViewStack.Screen
        name="PaymentCodeList"
        component={PaymentCodesListComponent}
        options={navigationStyle({ title: loc.bip47.contacts })(theme)}
      />

      <DetailViewStack.Screen
        name="LnurlPaySuccess"
        component={LnurlPaySuccess}
        options={navigationStyle({
          title: '',
          closeButtonPosition: CloseButtonPosition.Right,
          headerBackVisible: false,
          gestureEnabled: false,
        })(theme)}
      />
      <DetailViewStack.Screen name="LnurlAuth" component={LnurlAuth} options={navigationStyle({ title: '' })(theme)} />
      <DetailViewStack.Screen
        name="Success"
        component={Success}
        options={{
          headerShown: false,
          gestureEnabled: false,
        }}
      />
      <DetailViewStack.Screen
        name="WalletAddresses"
        component={WalletAddresses}
        options={navigationStyle({ title: loc.addresses.addresses_title, statusBarStyle: 'auto' })(theme)}
      />

      <DetailViewStack.Screen
        name="Settings"
        component={Settings}
        options={navigationStyle({
          title: loc.settings.header,
          headerBackButtonDisplayMode: 'default',
          headerShadowVisible: false,
          headerLargeTitle: true,
          animationTypeForReplace: 'push',
        })(theme)}
      />
      <DetailViewStack.Screen name="Currency" component={Currency} options={navigationStyle({ title: loc.settings.currency })(theme)} />
      <DetailViewStack.Screen
        name="GeneralSettings"
        component={GeneralSettings}
        options={navigationStyle({ title: loc.settings.general })(theme)}
      />
      <DetailViewStack.Screen
        name="PlausibleDeniability"
        component={PlausibleDeniability}
        options={navigationStyle({ title: loc.plausibledeniability.title })(theme)}
      />
      <DetailViewStack.Screen name="Licensing" component={Licensing} options={navigationStyle({ title: loc.settings.license })(theme)} />
      <DetailViewStack.Screen
        name="NetworkSettings"
        component={NetworkSettings}
        options={navigationStyle({ title: loc.settings.network })(theme)}
      />
      <DetailViewStack.Screen
        name="SettingsBlockExplorer"
        component={SettingsBlockExplorer}
        options={navigationStyle({ title: loc.settings.block_explorer })(theme)}
      />

      <DetailViewStack.Screen name="About" component={About} options={navigationStyle({ title: loc.settings.about })(theme)} />
      <DetailViewStack.Screen
        name="DefaultView"
        component={DefaultView}
        options={navigationStyle({ title: loc.settings.default_title })(theme)}
      />
      <DetailViewStack.Screen
        name="ElectrumSettings"
        component={ElectrumSettings}
        options={navigationStyle({ title: loc.settings.electrum_settings_server })(theme)}
        initialParams={{ server: undefined }}
      />
      <DetailViewStack.Screen
        name="EncryptStorage"
        component={EncryptStorage}
        options={navigationStyle({ title: loc.settings.encrypt_title })(theme)}
      />
      <DetailViewStack.Screen name="Language" component={Language} options={navigationStyle({ title: loc.settings.language })(theme)} />
      <DetailViewStack.Screen
        name="LightningSettings"
        component={LightningSettings}
        options={navigationStyle({ title: loc.settings.lightning_settings })(theme)}
      />
      <DetailViewStack.Screen
        name="NotificationSettings"
        component={NotificationSettings}
        options={navigationStyle({ title: loc.settings.notifications })(theme)}
      />
      <DetailViewStack.Screen name="SelfTest" component={SelfTest} options={navigationStyle({ title: loc.settings.selfTest })(theme)} />
      <DetailViewStack.Screen
        name="ReleaseNotes"
        component={ReleaseNotes}
        options={navigationStyle({ title: loc.settings.about_release_notes })(theme)}
      />
      <DetailViewStack.Screen name="ToolsScreen" component={ToolsScreen} options={navigationStyle({ title: loc.settings.tools })(theme)} />
      <DetailViewStack.Screen
        name="SettingsPrivacy"
        component={SettingsPrivacy}
        options={navigationStyle({ title: loc.settings.privacy })(theme)}
      />
      <DetailViewStack.Screen
        name="ManageWallets"
        component={ManageWallets}
        options={{
          presentation: 'fullScreenModal',
          title: loc.wallets.manage_title,
          statusBarStyle: 'auto',
          headerShown: true,
        }}
      />
      <DetailViewStack.Screen
        name="ReceiveDetails"
        component={ReceiveDetails}
        options={navigationStyle({
          title: loc.receive.header,
          closeButtonPosition: CloseButtonPosition.Left,
          statusBarStyle: 'light',
          headerShown: true,
          presentation: 'modal',
        })(theme)}
      />
      <DetailViewStack.Screen
        name="Browser"
        component={Browser}
        options={navigationStyle({ title: 'DApps Browser' })(theme)}
      />
      <DetailViewStack.Screen
        name="Swap"
        component={Swap}
        options={navigationStyle({ title: 'Swap' })(theme)}
      />
    </DetailViewStack.Navigator>
  );
};

export default DetailViewStackScreensStack;

const styles = {
  width24: {
    width: 24,
  },
  walletDetails: {
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
};


================================================
FILE: ./navigation/PaymentCodeStackParamList.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { BitcoinUnit } from '../models/bitcoinUnits';

export type PaymentCodeStackParamList = {
  PaymentCode: { paymentCode: string };
  PaymentCodesList: {
    memo: string;
    address: string;
    walletID: string;
    amount: number;
    amountSats: number;
    unit: BitcoinUnit;
    isTransactionReplaceable: boolean;
    launchedBy: string;
    isEditable: boolean;
    uri: string /* payjoin uri */;
  };
};


================================================
FILE: ./navigation/DetailViewStackParamList.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { AztecoVoucher } from '../class/azteco';
import { LightningTransaction, Transaction, TWallet } from '../class/wallets/types';
import { Chain } from '../models/bitcoinUnits';
import { ElectrumServerItem } from '../screen/settings/ElectrumSettings';
import { SendDetailsParams, TNavigationWrapper } from './SendDetailsStackParamList';

export type ScanQRCodeParamList = {
  cameraStatusGranted?: boolean;
  backdoorPressed?: boolean;
  launchedBy?: string;
  urTotal?: number;
  urHave?: number;
  backdoorText?: string;
  onBarScanned?: (data: string) => void;
  showFileImportButton?: boolean;
  backdoorVisible?: boolean;
  orientation?: 'portrait';
  animatedQRCodeData?: Record<string, any>;
};

export type DetailViewStackParamList = {
  DrawerRoot: undefined;
  UnlockWithScreen: undefined;
  WalletsList: { onBarScanned?: string };
  WalletTransactions: { isLoading?: boolean; walletID: string; walletType: string; onBarScanned?: string };
  WalletDetails: { walletID: string };
  TransactionDetails: { tx: Transaction; hash: string; walletID: string };
  TransactionStatus: { hash: string; walletID?: string };
  CPFP: {
    wallet: TWallet | null;
    txid: string;
  };
  RBFBumpFee: { txid: string; wallet: TWallet | null };
  RBFCancel: { txid: string; wallet: TWallet | null };
  SelectWallet: {
    chainType?: Chain;
    onWalletSelect?: (wallet: TWallet, navigationWrapper: TNavigationWrapper) => void;
    availableWallets?: TWallet[];
    noWalletExplanationText?: string;
    onChainRequireSend?: boolean;
    selectedWalletID?: string; // Add this parameter to scroll to a specific wallet
  };
  LNDViewInvoice: { invoice: LightningTransaction; walletID: string };
  LNDViewAdditionalInvoiceInformation: { invoiceId: string };
  LNDViewAdditionalInvoicePreImage: { invoiceId: string };
  Broadcast: object;
  IsItMyAddress: object;
  GenerateWord: undefined;
  LnurlPay: undefined;
  LnurlPaySuccess: {
    paymentHash: string;
    justPaid: boolean;
    fromWalletID: string;
  };
  LnurlAuth: undefined;
  Success: undefined;
  WalletAddresses: { walletID: string };
  AddWalletRoot: undefined;
  SendDetailsRoot: SendDetailsParams;
  LNDCreateInvoiceRoot: undefined;
  ScanLNDInvoiceRoot: {
    screen: string;
    params: {
      paymentHash: string;
      fromWalletID: string;
      justPaid: boolean;
    };
  };
  AztecoRedeemRoot: {
    screen: string;
    params: {
      aztecoVoucher: AztecoVoucher;
    };
  };
  AztecoRedeem: { aztecoVoucher: AztecoVoucher };
  WalletExport: undefined;
  ExportMultisigCoordinationSetupRoot: undefined;
  Settings: undefined;
  Currency: undefined;
  GeneralSettings: undefined;
  PlausibleDeniability: undefined;
  Licensing: undefined;
  NetworkSettings: undefined;
  About: undefined;
  DefaultView: undefined;
  ElectrumSettings: { server?: ElectrumServerItem; onBarScanned?: string };
  SettingsBlockExplorer: undefined;
  EncryptStorage: undefined;
  Language: undefined;
  LightningSettings: {
    url?: string;
    onBarScanned?: string;
  };
  NotificationSettings: undefined;
  SelfTest: undefined;
  ReleaseNotes: undefined;
  ToolsScreen: undefined;
  SettingsPrivacy: undefined;
  ViewEditMultisigCosigners: { walletID: string; cosigners: string[]; onBarScanned?: string };
  WalletXpub: { walletID: string; xpub: string };
  SignVerifyRoot: {
    screen: 'SignVerify';
    params: {
      walletID: string;
      address: string;
    };
  };
  ReceiveDetails: {
    walletID?: string;
    address: string;
  };
  ScanQRCode: ScanQRCodeParamList;
  PaymentCodeList: {
    paymentCode: string;
    walletID: string;
  };
  ManageWallets: undefined;
  Browser: undefined;
  Swap: undefined;
};


================================================
FILE: ./navigation/ReceiveDetailsStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useTheme } from '../components/themes';
import loc from '../loc';
import ReceiveDetails from '../screen/receive/ReceiveDetails';
import navigationStyle, { CloseButtonPosition } from '../components/navigationStyle';
import { ReceiveDetailsStackParamList } from './ReceiveDetailsStackParamList';

const Stack = createNativeStackNavigator<ReceiveDetailsStackParamList>();

const ReceiveDetailsStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator screenOptions={{ headerShadowVisible: false }} initialRouteName="ReceiveDetails">
      <Stack.Screen
        name="ReceiveDetails"
        component={ReceiveDetails}
        options={navigationStyle({
          title: loc.receive.header,
          closeButtonPosition: CloseButtonPosition.Left,
          statusBarStyle: 'light',
          headerShown: true,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default ReceiveDetailsStack;


================================================
FILE: ./navigation/LNDStackParamsList.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { TWallet } from '../class/wallets/types';
import { BitcoinUnit, Chain } from '../models/bitcoinUnits';
import { ScanQRCodeParamList } from './DetailViewStackParamList';
import { TNavigationWrapper } from './SendDetailsStackParamList';

export type LNDStackParamsList = {
  ScanLNDInvoice: {
    walletID: string | undefined;
    uri: string | undefined;
    invoice: string | undefined;
    onBarScanned: string | undefined;
  };
  LnurlPay: {
    lnurl: string;
    walletID: string;
  };
  LnurlPaySuccess: undefined;
  ScanQRCode: ScanQRCodeParamList;
  SelectWallet: {
    chainType?: Chain;
    onWalletSelect?: (wallet: TWallet, navigationWrapper: TNavigationWrapper) => void;
    availableWallets?: TWallet[];
    noWalletExplanationText?: string;
    onChainRequireSend?: boolean;
  };
  Success: {
    amount?: number;
    fee?: number;
    invoiceDescription?: string;
    amountUnit: BitcoinUnit;
    txid?: string;
  };
};


================================================
FILE: ./navigation/LazyLoadAddWalletStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

// Define lazy imports with more reliable loading patterns
const WalletsAdd = lazy(() => import('../screen/wallets/Add'));
const ImportCustomDerivationPath = lazy(() => import('../screen/wallets/ImportCustomDerivationPath'));
const ImportWalletDiscovery = lazy(() => import('../screen/wallets/ImportWalletDiscovery'));
const ImportSpeed = lazy(() => import('../screen/wallets/ImportSpeed'));
const ImportWallet = lazy(() => import('../screen/wallets/ImportWallet'));
const PleaseBackup = lazy(() => import('../screen/wallets/PleaseBackup'));
const PleaseBackupLNDHub = lazy(() => import('../screen/wallets/pleaseBackupLNDHub'));
const ProvideEntropy = lazy(() => import('../screen/wallets/ProvideEntropy'));
const WalletsAddMultisig = lazy(() => import('../screen/wallets/WalletsAddMultisig'));
const MultisigAdvanced = lazy(() => import('../screen/wallets/MultisigAdvanced'));
const WalletsAddMultisigStep2 = lazy(() => import('../screen/wallets/addMultisigStep2'));
const WalletsAddMultisigHelp = lazy(() => import('../screen/wallets/addMultisigHelp'));

export const AddComponent: React.FC = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <WalletsAdd />
  </Suspense>
);

export const ImportWalletDiscoveryComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ImportWalletDiscovery />
  </Suspense>
);

export const ImportCustomDerivationPathComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ImportCustomDerivationPath />
  </Suspense>
);

export const ImportWalletComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ImportWallet />
  </Suspense>
);

export const ImportSpeedComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ImportSpeed />
  </Suspense>
);

export const PleaseBackupComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PleaseBackup />
  </Suspense>
);

export const PleaseBackupLNDHubComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PleaseBackupLNDHub />
  </Suspense>
);

export const ProvideEntropyComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ProvideEntropy />
  </Suspense>
);

export const WalletsAddMultisigComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <WalletsAddMultisig />
  </Suspense>
);

export const MultisigAdvancedComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <MultisigAdvanced />
  </Suspense>
);

export const WalletsAddMultisigStep2Component = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <WalletsAddMultisigStep2 />
  </Suspense>
);

export const WalletsAddMultisigHelpComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <WalletsAddMultisigHelp />
  </Suspense>
);


================================================
FILE: ./navigation/LazyLoadScanLNDInvoiceStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

// Lazy loading components for the navigation stack
const ScanLNDInvoice = lazy(() => import('../screen/lnd/ScanLNDInvoice'));
const SelectWallet = lazy(() => import('../screen/wallets/SelectWallet'));
const Success = lazy(() => import('../screen/send/success'));
const LnurlPay = lazy(() => import('../screen/lnd/lnurlPay'));
const LnurlPaySuccess = lazy(() => import('../screen/lnd/lnurlPaySuccess'));

export const ScanLNDInvoiceComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ScanLNDInvoice />
  </Suspense>
);

export const SelectWalletComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SelectWallet />
  </Suspense>
);

export const SuccessComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <Success />
  </Suspense>
);

export const LnurlPayComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <LnurlPay />
  </Suspense>
);

export const LnurlPaySuccessComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <LnurlPaySuccess />
  </Suspense>
);


================================================
FILE: ./navigation/LazyLoadPaymentCodeStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const PaymentCodesList = lazy(() => import('../screen/wallets/PaymentCodesList'));

const PaymentCodesListComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PaymentCodesList />
  </Suspense>
);

export default PaymentCodesListComponent;


================================================
FILE: ./navigation/ExportMultisigCoordinationSetupStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import navigationStyle from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import { ExportMultisigCoordinationSetupComponent } from './LazyLoadExportMultisigCoordinationSetupStack';

export type ExportMultisigCoordinationSetupStackRootParamList = {
  ExportMultisigCoordinationSetup: {
    walletID: string;
  };
};

const Stack = createNativeStackNavigator<ExportMultisigCoordinationSetupStackRootParamList>();

const ExportMultisigCoordinationSetupStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator initialRouteName="ExportMultisigCoordinationSetup">
      <Stack.Screen
        name="ExportMultisigCoordinationSetup"
        component={ExportMultisigCoordinationSetupComponent}
        options={navigationStyle({
          headerBackVisible: false,
          statusBarStyle: 'light',
          title: loc.multisig.export_coordination_setup,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default ExportMultisigCoordinationSetupStack;


================================================
FILE: ./navigation/DrawerParamList.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { DetailViewStackParamList } from './DetailViewStackParamList';

export type DrawerParamList = {
  DetailViewStackScreensStack: {
    screen?: keyof DetailViewStackParamList;
    params?: object;
  };
};


================================================
FILE: ./navigation/DrawerRoot.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createDrawerNavigator, DrawerNavigationOptions, DrawerContentComponentProps } from '@react-navigation/drawer';
import { useLocale } from '@react-navigation/native';
import React, { useEffect, useMemo } from 'react';
import { Animated, Easing } from 'react-native';
import { useSizeClass, SizeClass } from '../malin_modules/sizeClass';
import DrawerList from '../screen/wallets/DrawerList';
import DetailViewStackScreensStack from './DetailViewScreensStack';
import { DrawerParamList } from './DrawerParamList';
import useCompanionListeners from '../hooks/useCompanionListeners';

const Drawer = createDrawerNavigator<DrawerParamList>();

const DrawerContent = (props: DrawerContentComponentProps) => {
  const { isLargeScreen } = useSizeClass();

  if (!isLargeScreen) {
    return null;
  }

  return <DrawerList {...props} />;
};

const getAnimationConfig = (isDrawerTransitionConfigured: boolean) => {
  if (!isDrawerTransitionConfigured) return {};

  return {
    config: {
      timing: Animated.timing,
      useNativeDriver: true,
      duration: 250,
      easing: Easing.inOut(Easing.cubic),
    },
  };
};

const DrawerRoot = () => {
  const { sizeClass, isLargeScreen } = useSizeClass();
  const { direction } = useLocale();
  useCompanionListeners();

  const getDrawerWidth = useMemo(() => {
    switch (sizeClass) {
      case SizeClass.Large:
        return 320;
      case SizeClass.Regular:
        return 280;
      default:
        return 0;
    }
  }, [sizeClass]);

  const drawerStyle: DrawerNavigationOptions = useMemo(
    () => ({
      drawerPosition: direction === 'rtl' ? 'right' : 'left',
      drawerStyle: {
        width: getDrawerWidth,
        height: '100%',
      },
      drawerType: isLargeScreen ? 'permanent' : 'front',
      overlayColor: 'rgba(0,0,0,0.4)',
      swipeEnabled: false,
      drawerStatusBarAnimation: 'fade',

      ...getAnimationConfig(true),
    }),
    [getDrawerWidth, isLargeScreen, direction],
  );

  useEffect(() => {
    console.debug('[DrawerRoot] Size class changed:', SizeClass[sizeClass]);
  }, [sizeClass]);

  return (
    <Drawer.Navigator screenOptions={drawerStyle} drawerContent={DrawerContent} initialRouteName="DetailViewStackScreensStack">
      <Drawer.Screen name="DetailViewStackScreensStack" component={DetailViewStackScreensStack} options={{ headerShown: false }} />
    </Drawer.Navigator>
  );
};

export default DrawerRoot;


================================================
FILE: ./navigation/index.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createNativeStackNavigator, NativeStackNavigationOptions } from '@react-navigation/native-stack';
import React, { lazy, Suspense } from 'react';
import UnlockWith from '../screen/UnlockWith';
import { LazyLoadingIndicator } from './LazyLoadingIndicator';
import { DetailViewStackParamList } from './DetailViewStackParamList';
import { useStorage } from '../hooks/context/useStorage';
import loc from '../loc';
import navigationStyle, { CloseButtonPosition } from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import WalletXpub from '../screen/wallets/xpub';
import WalletExport from '../screen/wallets/WalletExport';

// Lazy load all components except UnlockWith
const DrawerRoot = lazy(() => import('./DrawerRoot'));
const AddWalletStack = lazy(() => import('./AddWalletStack'));
const SendDetailsStack = lazy(() => import('./SendDetailsStack'));
const LNDCreateInvoiceRoot = lazy(() => import('./LNDCreateInvoiceStack'));
const ScanLNDInvoiceRoot = lazy(() => import('./ScanLNDInvoiceStack'));
const AztecoRedeemStackRoot = lazy(() => import('./AztecoRedeemStack'));
const ExportMultisigCoordinationSetupStack = lazy(() => import('./ExportMultisigCoordinationSetupStack'));
const SignVerifyStackRoot = lazy(() => import('./SignVerifyStack'));
const ScanQRCode = lazy(() => import('../screen/send/ScanQRCode'));
const ViewEditMultisigCosigners = lazy(() => import('../screen/wallets/ViewEditMultisigCosigners'));

export const NavigationDefaultOptions: NativeStackNavigationOptions = {
  headerShown: false,
  presentation: 'modal',
  headerShadowVisible: false,
};
export const NavigationFormModalOptions: NativeStackNavigationOptions = {
  headerShown: false,
  presentation: 'formSheet',
};

export const NavigationFormNoSwipeDefaultOptions: NativeStackNavigationOptions = {
  headerShown: false,
  presentation: 'modal',
  headerShadowVisible: false,
  fullScreenGestureEnabled: false,
};
export const StatusBarLightOptions: NativeStackNavigationOptions = { statusBarStyle: 'light' };

const DetailViewStack = createNativeStackNavigator<DetailViewStackParamList>();

// Lazy loading wrapper components
const LazyDrawerRoot = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <DrawerRoot />
  </Suspense>
);

const LazyAddWalletStack = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <AddWalletStack />
  </Suspense>
);

const LazySendDetailsStack = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SendDetailsStack />
  </Suspense>
);

const LazyLNDCreateInvoiceRoot = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <LNDCreateInvoiceRoot />
  </Suspense>
);

const LazyScanLNDInvoiceRoot = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ScanLNDInvoiceRoot />
  </Suspense>
);

const LazyAztecoRedeemStackRoot = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <AztecoRedeemStackRoot />
  </Suspense>
);

const LazyExportMultisigCoordinationSetupStack = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ExportMultisigCoordinationSetupStack />
  </Suspense>
);

const LazyViewEditMultisigCosigners = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ViewEditMultisigCosigners />
  </Suspense>
);

const LazySignVerifyStackRoot = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SignVerifyStackRoot />
  </Suspense>
);

const LazyScanQRCodeComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ScanQRCode />
  </Suspense>
);

const MainRoot = () => {
  const { walletsInitialized } = useStorage();
  const theme = useTheme();

  return (
    <DetailViewStack.Navigator screenOptions={{ headerShown: false }}>
      {!walletsInitialized ? (
        <DetailViewStack.Screen name="UnlockWithScreen" component={UnlockWith} />
      ) : (
        <>
          <DetailViewStack.Screen name="DrawerRoot" component={LazyDrawerRoot} />

          {/* Modal stacks */}
          <DetailViewStack.Screen name="AddWalletRoot" component={LazyAddWalletStack} options={NavigationDefaultOptions} />
          <DetailViewStack.Screen name="SendDetailsRoot" component={LazySendDetailsStack} options={NavigationFormNoSwipeDefaultOptions} />
          <DetailViewStack.Screen name="LNDCreateInvoiceRoot" component={LazyLNDCreateInvoiceRoot} options={NavigationDefaultOptions} />
          <DetailViewStack.Screen name="ScanLNDInvoiceRoot" component={LazyScanLNDInvoiceRoot} options={NavigationDefaultOptions} />
          <DetailViewStack.Screen name="AztecoRedeemRoot" component={LazyAztecoRedeemStackRoot} options={NavigationDefaultOptions} />

          <DetailViewStack.Screen
            name="WalletExport"
            component={WalletExport}
            options={navigationStyle({
              headerBackVisible: false,
              title: loc.wallets.export_title,
              presentation: 'modal',
              headerShown: true,
              closeButtonPosition: CloseButtonPosition.Right,
            })(theme)}
          />
          <DetailViewStack.Screen
            name="ExportMultisigCoordinationSetupRoot"
            component={LazyExportMultisigCoordinationSetupStack}
            options={NavigationDefaultOptions}
          />
          <DetailViewStack.Screen
            name="ViewEditMultisigCosigners"
            component={LazyViewEditMultisigCosigners}
            options={navigationStyle({
              title: loc.multisig.view_edit_cosigners,
              presentation: 'modal',
              headerShown: true,
              gestureEnabled: false,
              closeButtonPosition: CloseButtonPosition.Right,
            })(theme)}
          />
          <DetailViewStack.Screen
            name="WalletXpub"
            component={WalletXpub}
            options={navigationStyle({
              title: loc.wallets.xpub_title,
              presentation: 'modal',
              headerShown: true,
              closeButtonPosition: CloseButtonPosition.Right,
            })(theme)}
          />
          <DetailViewStack.Screen
            name="SignVerifyRoot"
            component={LazySignVerifyStackRoot}
            options={{ ...NavigationDefaultOptions, ...StatusBarLightOptions }}
          />

          <DetailViewStack.Screen
            name="ScanQRCode"
            component={LazyScanQRCodeComponent}
            options={{
              headerShown: false,
              statusBarHidden: true,
              orientation: 'portrait',
              presentation: 'fullScreenModal',
            }}
          />
        </>
      )}
    </DetailViewStack.Navigator>
  );
};

export default MainRoot;
export { DetailViewStack };


================================================
FILE: ./navigation/ScanLNDInvoiceStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import React from 'react';

import navigationStyle from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import { ScanQRCodeComponent } from './LazyLoadScanQRCodeStack';
import { LnurlPayComponent, LnurlPaySuccessComponent, ScanLNDInvoiceComponent, SuccessComponent } from './LazyLoadScanLNDInvoiceStack';
import { SelectWalletComponent } from './LazyLoadLNDCreateInvoiceStack';

const Stack = createNativeStackNavigator();

const ScanLNDInvoiceRoot = () => {
  const theme = useTheme();
  return (
    <Stack.Navigator screenOptions={{ headerShadowVisible: false }}>
      <Stack.Screen
        name="ScanLNDInvoice"
        component={ScanLNDInvoiceComponent}
        options={navigationStyle({ headerBackVisible: false, title: loc.send.header, statusBarStyle: 'light' })(theme)}
        initialParams={{ uri: undefined, walletID: undefined, invoice: undefined }}
      />
      <Stack.Screen
        name="SelectWallet"
        component={SelectWalletComponent}
        options={navigationStyle({ title: loc.wallets.select_wallet })(theme)}
      />
      <Stack.Screen
        name="Success"
        component={SuccessComponent}
        options={navigationStyle({ headerShown: false, gestureEnabled: false })(theme)}
      />
      <Stack.Screen
        name="LnurlPay"
        component={LnurlPayComponent}
        options={navigationStyle({
          title: '',
        })(theme)}
      />
      <Stack.Screen
        name="LnurlPaySuccess"
        component={LnurlPaySuccessComponent}
        options={navigationStyle({
          title: '',
          headerBackVisible: false,
          gestureEnabled: false,
        })(theme)}
      />
      <Stack.Screen
        name="ScanQRCode"
        component={ScanQRCodeComponent}
        options={navigationStyle({
          headerShown: false,
          statusBarHidden: true,
          presentation: 'fullScreenModal',
          headerShadowVisible: false,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default ScanLNDInvoiceRoot;


================================================
FILE: ./navigation/MasterView.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import DevMenu from '../components/DevMenu';
import MainRoot from './index';

const MasterView = () => {
  return (
    <>
      <MainRoot />
      {__DEV__ && <DevMenu />}
    </>
  );
};

export default MasterView;


================================================
FILE: ./navigation/LazyLoadSendDetailsStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const SendDetails = lazy(() => import('../screen/send/SendDetails'));
const Confirm = lazy(() => import('../screen/send/Confirm'));
const PsbtWithHardwareWallet = lazy(() => import('../screen/send/psbtWithHardwareWallet'));
const CreateTransaction = lazy(() => import('../screen/send/create'));
const PsbtMultisig = lazy(() => import('../screen/send/psbtMultisig'));
const PsbtMultisigQRCode = lazy(() => import('../screen/send/PsbtMultisigQRCode'));
const Success = lazy(() => import('../screen/send/success'));
const SelectWallet = lazy(() => import('../screen/wallets/SelectWallet'));
const CoinControl = lazy(() => import('../screen/send/CoinControl'));
const PaymentCodesList = lazy(() => import('../screen/wallets/PaymentCodesList'));

// Export each component with its lazy loader and optional configurations
export const SendDetailsComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SendDetails />
  </Suspense>
);
export const ConfirmComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <Confirm />
  </Suspense>
);
export const PsbtWithHardwareWalletComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PsbtWithHardwareWallet />
  </Suspense>
);
export const CreateTransactionComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <CreateTransaction />
  </Suspense>
);
export const PsbtMultisigComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PsbtMultisig />
  </Suspense>
);
export const PsbtMultisigQRCodeComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PsbtMultisigQRCode />
  </Suspense>
);
export const SuccessComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <Success />
  </Suspense>
);
export const SelectWalletComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SelectWallet />
  </Suspense>
);
export const CoinControlComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <CoinControl />
  </Suspense>
);

export const PaymentCodesListComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <PaymentCodesList />
  </Suspense>
);


================================================
FILE: ./navigation/SendDetailsStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { useMemo } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import navigationStyle, { CloseButtonPosition } from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import {
  CoinControlComponent,
  ConfirmComponent,
  CreateTransactionComponent,
  PaymentCodesListComponent,
  PsbtMultisigComponent,
  PsbtMultisigQRCodeComponent,
  PsbtWithHardwareWalletComponent,
  SelectWalletComponent,
  SendDetailsComponent,
  SuccessComponent,
} from './LazyLoadSendDetailsStack';
import { SendDetailsStackParamList } from './SendDetailsStackParamList';
import HeaderRightButton from '../components/HeaderRightButton';
import { BitcoinUnit } from '../models/bitcoinUnits';
import { ScanQRCodeComponent } from './LazyLoadScanQRCodeStack';
import SelectFeeScreen from '../screen/SelectFeeScreen';
import { Platform } from 'react-native';

const Stack = createNativeStackNavigator<SendDetailsStackParamList>();

const SendDetailsStack = () => {
  const theme = useTheme();
  const DetailsButton = useMemo(
    () => <HeaderRightButton testID="TransactionDetailsButton" disabled={true} title={loc.send.create_details} />,
    [],
  );

  return (
    <Stack.Navigator initialRouteName="SendDetails" screenOptions={{ headerShadowVisible: false, fullScreenGestureEnabled: false }}>
      <Stack.Screen
        name="SendDetails"
        component={SendDetailsComponent}
        options={navigationStyle({
          title: loc.send.header,
          statusBarStyle: 'light',
          closeButtonPosition: CloseButtonPosition.Left,
        })(theme)}
        initialParams={{ isEditable: true, feeUnit: BitcoinUnit.BTC, amountUnit: BitcoinUnit.BTC }} // Correctly typed now
      />
      <Stack.Screen
        name="SelectFee"
        component={SelectFeeScreen}
        options={navigationStyle({
          sheetAllowedDetents: Platform.OS === 'ios' ? 'fitToContents' : [0.9],
          presentation: 'formSheet',
          headerTitle: '',
          sheetGrabberVisible: true,
        })(theme)}
      />
      <Stack.Screen
        name="Confirm"
        component={ConfirmComponent}
        options={navigationStyle({ title: loc.send.confirm_header, headerRight: () => DetailsButton })(theme)}
      />
      <Stack.Screen
        name="PsbtWithHardwareWallet"
        component={PsbtWithHardwareWalletComponent}
        options={navigationStyle({ title: loc.send.header, gestureEnabled: false, fullScreenGestureEnabled: false })(theme)}
      />
      <Stack.Screen
        name="CreateTransaction"
        component={CreateTransactionComponent}
        options={navigationStyle({ title: loc.send.create_details })(theme)}
      />
      <Stack.Screen
        name="PsbtMultisig"
        component={PsbtMultisigComponent}
        options={navigationStyle({ title: loc.multisig.header })(theme)}
      />
      <Stack.Screen
        name="PsbtMultisigQRCode"
        component={PsbtMultisigQRCodeComponent}
        options={navigationStyle({ title: loc.multisig.header })(theme)}
      />
      <Stack.Screen
        name="Success"
        component={SuccessComponent}
        options={navigationStyle({ headerShown: false, gestureEnabled: false })(theme)}
      />
      <Stack.Screen
        name="SelectWallet"
        component={SelectWalletComponent}
        options={navigationStyle({ title: loc.wallets.select_wallet })(theme)}
      />
      <Stack.Screen name="CoinControl" component={CoinControlComponent} options={navigationStyle({ title: loc.cc.header })(theme)} />
      <Stack.Screen
        name="PaymentCodeList"
        component={PaymentCodesListComponent}
        options={navigationStyle({ title: loc.bip47.contacts })(theme)}
      />
      <Stack.Screen
        name="ScanQRCode"
        component={ScanQRCodeComponent}
        options={navigationStyle({
          headerShown: false,
          statusBarHidden: true,
          presentation: 'fullScreenModal',
          headerShadowVisible: false,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default SendDetailsStack;


================================================
FILE: ./navigation/LazyLoadReceiveDetailsStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const ReceiveDetails = lazy(() => import('../screen/receive/ReceiveDetails'));

export const ReceiveDetailsComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ReceiveDetails />
  </Suspense>
);


================================================
FILE: ./navigation/PaymentCodeStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import navigationStyle from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc'; // Assuming 'loc' is used for localization
import { PaymentCodeStackParamList } from './PaymentCodeStackParamList';
import PaymentCodesListComponent from './LazyLoadPaymentCodeStack';

const Stack = createNativeStackNavigator<PaymentCodeStackParamList>();
const PaymentCodeStackRoot = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator initialRouteName="PaymentCodesList" screenOptions={{ headerShadowVisible: false }}>
      <Stack.Screen
        name="PaymentCodesList"
        component={PaymentCodesListComponent}
        options={navigationStyle({ title: loc.bip47.contacts })(theme)}
      />
    </Stack.Navigator>
  );
};

export default PaymentCodeStackRoot;


================================================
FILE: ./navigation/AztecoRedeemStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import navigationStyle from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import { AztecoRedeemComponent, SelectWalletComponent } from './LazyLoadAztecoRedeemStack';

const Stack = createNativeStackNavigator();

const AztecoRedeemStackRoot = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator screenOptions={{ headerShadowVisible: false }}>
      <Stack.Screen
        name="AztecoRedeem"
        component={AztecoRedeemComponent}
        options={navigationStyle({
          title: loc.azteco.title,
          statusBarStyle: 'auto',
        })(theme)}
      />
      <Stack.Screen
        name="SelectWallet"
        component={SelectWalletComponent}
        options={navigationStyle({
          title: loc.wallets.select_wallet,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default AztecoRedeemStackRoot;


================================================
FILE: ./navigation/LazyLoadAztecoRedeemStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const AztecoRedeem = lazy(() => import('../screen/receive/AztecoRedeem'));
const SelectWallet = lazy(() => import('../screen/wallets/SelectWallet'));

export const AztecoRedeemComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <AztecoRedeem />
  </Suspense>
);

export const SelectWalletComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SelectWallet />
  </Suspense>
);


================================================
FILE: ./navigation/LazyLoadExportMultisigCoordinationSetupStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const ExportMultisigCoordinationSetup = lazy(() => import('../screen/wallets/ExportMultisigCoordinationSetup'));

export const ExportMultisigCoordinationSetupComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ExportMultisigCoordinationSetup />
  </Suspense>
);


================================================
FILE: ./navigation/LazyLoadingIndicator.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { ActivityIndicator, StyleSheet, View } from 'react-native';

export const LazyLoadingIndicator = () => (
  <View style={styles.root}>
    <ActivityIndicator size="large" />
  </View>
);

const styles = StyleSheet.create({
  root: { flex: 1, justifyContent: 'center', alignItems: 'center' },
});


================================================
FILE: ./navigation/AddWalletStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import React from 'react';

import navigationStyle, { CloseButtonPosition } from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import {
  AddComponent,
  ImportCustomDerivationPathComponent,
  ImportSpeedComponent,
  ImportWalletComponent,
  ImportWalletDiscoveryComponent,
  PleaseBackupComponent,
  PleaseBackupLNDHubComponent,
  ProvideEntropyComponent,
  WalletsAddMultisigComponent,
  MultisigAdvancedComponent,
  WalletsAddMultisigHelpComponent,
  WalletsAddMultisigStep2Component,
} from './LazyLoadAddWalletStack';
import { ScanQRCodeComponent } from './LazyLoadScanQRCodeStack';
import { ScanQRCodeParamList } from './DetailViewStackParamList';

export type AddWalletStackParamList = {
  AddWallet: {
    entropy?: string;
    words?: number;
  };
  ImportWallet?: {
    label?: string;
    triggerImport?: boolean;
    onBarScanned?: string;
  };
  ImportWalletDiscovery: {
    importText: string;
    askPassphrase: boolean;
    searchAccounts: boolean;
  };
  ImportSpeed: undefined;
  ImportCustomDerivationPath: {
    importText: string;
    password: string | undefined;
  };
  PleaseBackup: {
    walletID: string;
  };
  PleaseBackupLNDHub: {
    walletID: string;
  };
  ProvideEntropy: {
    words: number;
    entropy?: string;
  };
  WalletsAddMultisig: {
    walletLabel: string;
  };
  MultisigAdvanced: {
    m: number;
    n: number;
    format: string;
    onSave: (m: number, n: number, format: string) => void;
  };
  WalletsAddMultisigStep2: {
    m: number;
    n: number;
    walletLabel: string;
    format: string;
    onBarScanned?: string;
  };
  WalletsAddMultisigHelp: undefined;
  ScanQRCode: ScanQRCodeParamList;
};

const Stack = createNativeStackNavigator<AddWalletStackParamList>();

const AddWalletStack = () => {
  const theme = useTheme();
  return (
    <Stack.Navigator initialRouteName="AddWallet">
      <Stack.Screen
        name="AddWallet"
        component={AddComponent}
        options={navigationStyle({
          closeButtonPosition: CloseButtonPosition.Left,
          title: loc.wallets.add_title,
        })(theme)}
      />
      <Stack.Screen
        name="ImportCustomDerivationPath"
        component={ImportCustomDerivationPathComponent}
        options={navigationStyle({ statusBarStyle: 'light', title: loc.wallets.import_derivation_title })(theme)}
      />
      <Stack.Screen
        name="ImportWallet"
        component={ImportWalletComponent}
        options={navigationStyle({ title: loc.wallets.import_title })(theme)}
      />
      <Stack.Screen
        name="ImportSpeed"
        component={ImportSpeedComponent}
        options={navigationStyle({ statusBarStyle: 'light', title: loc.wallets.import_title })(theme)}
      />
      <Stack.Screen
        name="ImportWalletDiscovery"
        component={ImportWalletDiscoveryComponent}
        options={navigationStyle({
          title: loc.wallets.import_discovery_title,
        })(theme)}
      />
      <Stack.Screen
        name="PleaseBackup"
        component={PleaseBackupComponent}
        options={navigationStyle({
          gestureEnabled: false,
          headerBackVisible: false,
          title: loc.pleasebackup.title,
        })(theme)}
      />
      <Stack.Screen
        name="PleaseBackupLNDHub"
        component={PleaseBackupLNDHubComponent}
        options={navigationStyle({ gestureEnabled: false, headerBackVisible: false, title: loc.pleasebackup.title })(theme)}
      />
      <Stack.Screen
        name="ProvideEntropy"
        component={ProvideEntropyComponent}
        options={navigationStyle({ title: loc.entropy.title })(theme)}
      />
      <Stack.Screen
        name="WalletsAddMultisig"
        component={WalletsAddMultisigComponent}
        options={navigationStyle({ title: '' })(theme)}
        initialParams={{ walletLabel: loc.multisig.default_label }}
      />
      <Stack.Screen
        name="MultisigAdvanced"
        component={MultisigAdvancedComponent}
        options={navigationStyle({
          title: loc.multisig.vault_advanced_customize,
          presentation: 'formSheet',
          sheetAllowedDetents: 'fitToContents',
          sheetGrabberVisible: true,
          contentStyle: { flex: 1 },
          headerShown: true,
          headerTitle: loc.multisig.vault_advanced_customize,
        })(theme)}
      />
      <Stack.Screen
        name="WalletsAddMultisigStep2"
        component={WalletsAddMultisigStep2Component}
        options={navigationStyle({ title: '', gestureEnabled: false })(theme)}
      />
      <Stack.Screen
        name="WalletsAddMultisigHelp"
        component={WalletsAddMultisigHelpComponent}
        options={navigationStyle({
          title: '',
          gestureEnabled: false,
          headerStyle: {
            backgroundColor: '#0070FF',
          },
          headerTintColor: '#FFFFFF',
          headerBackTitle: undefined,
          statusBarStyle: 'light',
          headerShadowVisible: false,
        })(theme)}
      />
      <Stack.Screen
        name="ScanQRCode"
        component={ScanQRCodeComponent}
        options={navigationStyle({
          headerShown: false,
          statusBarHidden: true,
          presentation: 'fullScreenModal',
          headerShadowVisible: false,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default AddWalletStack;


================================================
FILE: ./navigation/LazyLoadScanQRCodeStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const ScanQRCode = lazy(() => import('../screen/send/ScanQRCode'));

export const ScanQRCodeComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <ScanQRCode />
  </Suspense>
);


================================================
FILE: ./navigation/ReceiveDetailsStackParamList.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
export type ReceiveDetailsStackParamList = {
  ReceiveDetails: {
    walletID?: string;
    address?: string;
  };
};


================================================
FILE: ./navigation/helpers/getTransactionStatusOptions.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { RouteProp } from '@react-navigation/native';
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import HeaderRightButton from '../../components/HeaderRightButton';
import loc from '../../loc';
import { DetailViewStackParamList } from '../DetailViewStackParamList';
import navigationStyle from '../../components/navigationStyle';
import { Theme } from '../../components/themes';
import React from 'react';

type TransactionStatusRouteProp = RouteProp<DetailViewStackParamList, 'TransactionStatus'>;

interface GetTransactionStatusOptionsParams {
  route: TransactionStatusRouteProp;
  navigation: any;
  theme: Theme;
}

const getTransactionStatusOptions = ({ route, navigation, theme }: GetTransactionStatusOptionsParams): NativeStackNavigationOptions => {
  const { hash, walletID } = route.params;

  const navigateToTransactionDetails = () => {
    navigation.navigate('TransactionDetails', { hash, walletID });
  };

  return {
    ...navigationStyle({
      title: '',
      headerStyle: {
        backgroundColor: theme.colors.customHeader,
      },
      headerBackTitleStyle: { fontSize: 0 },
      statusBarStyle: 'auto',
    })(theme),
    headerRight: () => (
      <HeaderRightButton
        testID="TransactionDetailsButton"
        disabled={false}
        title={loc.send.create_details}
        onPress={navigateToTransactionDetails}
      />
    ),
  };
};

export default getTransactionStatusOptions;


================================================
FILE: ./navigation/helpers/getWalletTransactionsOptions.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { TouchableOpacity, StyleSheet } from 'react-native';
import { Icon } from '@rneui/themed';
import WalletGradient from '../../class/wallet-gradient';
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import { DetailViewStackParamList } from '../DetailViewStackParamList';
import { navigationRef } from '../../NavigationService';
import { RouteProp } from '@react-navigation/native';

export type WalletTransactionsRouteProps = RouteProp<DetailViewStackParamList, 'WalletTransactions'>;

const getWalletTransactionsOptions = ({ route }: { route: WalletTransactionsRouteProps }): NativeStackNavigationOptions => {
  const { isLoading = false, walletID, walletType } = route.params;

  const onPress = () => {
    navigationRef.navigate('WalletDetails', {
      walletID,
    });
  };

  const RightButton = (
    <TouchableOpacity accessibilityRole="button" testID="WalletDetails" disabled={isLoading} style={styles.walletDetails} onPress={onPress}>
      <Icon name="more-horiz" type="material" size={22} color="#FFFFFF" />
    </TouchableOpacity>
  );

  const backgroundColor = WalletGradient.headerColorFor(walletType);

  return {
    title: '',
    headerBackTitleStyle: { fontSize: 0 },
    headerStyle: {
      backgroundColor,
    },
    headerShadowVisible: false,
    headerTintColor: '#FFFFFF',
    statusBarBackgroundColor: backgroundColor,
    headerBackTitle: undefined,
    headerRight: () => RightButton,
  };
};

const styles = StyleSheet.create({
  walletDetails: {
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
});

export default getWalletTransactionsOptions;


================================================
FILE: ./navigation/LazyLoadWalletExportStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

// Define lazy imports
const WalletExport = lazy(() => import('../screen/wallets/WalletExport'));

export const WalletExportComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <WalletExport />
  </Suspense>
);


================================================
FILE: ./navigation/LazyLoadLNDCreateInvoiceStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React, { lazy, Suspense } from 'react';

import { LazyLoadingIndicator } from './LazyLoadingIndicator';

const LNDCreateInvoice = lazy(() => import('../screen/lnd/lndCreateInvoice'));
const SelectWallet = lazy(() => import('../screen/wallets/SelectWallet'));
const LNDViewInvoice = lazy(() => import('../screen/lnd/lndViewInvoice'));
const LNDViewAdditionalInvoicePreImage = lazy(() => import('../screen/lnd/lndViewAdditionalInvoicePreImage'));

export const LNDCreateInvoiceComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <LNDCreateInvoice />
  </Suspense>
);

export const SelectWalletComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <SelectWallet />
  </Suspense>
);

export const LNDViewInvoiceComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <LNDViewInvoice />
  </Suspense>
);

export const LNDViewAdditionalInvoicePreImageComponent = () => (
  <Suspense fallback={<LazyLoadingIndicator />}>
    <LNDViewAdditionalInvoicePreImage />
  </Suspense>
);


================================================
FILE: ./navigation/LNDCreateInvoiceStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import React from 'react';
import navigationStyle, { CloseButtonPosition } from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import {
  LNDCreateInvoiceComponent,
  LNDViewAdditionalInvoicePreImageComponent,
  LNDViewInvoiceComponent,
  SelectWalletComponent,
} from './LazyLoadLNDCreateInvoiceStack';
import { ScanQRCodeComponent } from './LazyLoadScanQRCodeStack';

const Stack = createNativeStackNavigator();

const LNDCreateInvoiceRoot = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator screenOptions={{ headerShadowVisible: false }}>
      <Stack.Screen
        name="LNDCreateInvoice"
        component={LNDCreateInvoiceComponent}
        options={navigationStyle({
          title: loc.receive.header,
          closeButtonPosition: CloseButtonPosition.Right,
          headerBackVisible: false,
          statusBarStyle: 'light',
        })(theme)}
      />
      <Stack.Screen
        name="SelectWallet"
        component={SelectWalletComponent}
        options={navigationStyle({ title: loc.wallets.select_wallet })(theme)}
      />
      <Stack.Screen
        name="LNDViewInvoice"
        component={LNDViewInvoiceComponent}
        options={navigationStyle({
          statusBarStyle: 'auto',
          headerTitle: loc.lndViewInvoice.lightning_invoice,
          headerStyle: {
            backgroundColor: theme.colors.customHeader,
          },
        })(theme)}
      />
      <Stack.Screen
        name="LNDViewAdditionalInvoicePreImage"
        component={LNDViewAdditionalInvoicePreImageComponent}
        options={navigationStyle({ title: loc.lndViewInvoice.additional_info })(theme)}
      />
      <Stack.Screen
        name="ScanQRCode"
        component={ScanQRCodeComponent}
        options={navigationStyle({
          headerShown: false,
          statusBarHidden: true,
          presentation: 'fullScreenModal',
          headerShadowVisible: false,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default LNDCreateInvoiceRoot;


================================================
FILE: ./navigation/WalletExportStack.tsx
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import navigationStyle from '../components/navigationStyle';
import { useTheme } from '../components/themes';
import loc from '../loc';
import { WalletExportComponent } from './LazyLoadWalletExportStack';

export type WalletExportStackParamList = {
  WalletExport: { walletID: string };
};

const Stack = createNativeStackNavigator<WalletExportStackParamList>();

const WalletExportStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator>
      <Stack.Screen
        name="WalletExport"
        component={WalletExportComponent}
        options={navigationStyle({
          headerBackVisible: false,
          title: loc.wallets.export_title,
        })(theme)}
      />
    </Stack.Navigator>
  );
};

export default WalletExportStack;


================================================
FILE: ./navigation/SendDetailsStackParamList.ts
================================================

// Copyright (C) 2026 MalinWallet Infrastructure - All Rights Reserved
import { Psbt } from 'bitcoinjs-lib';
import { CreateTransactionTarget, CreateTransactionUtxo, TWallet } from '../class/wallets/types';
import { BitcoinUnit, Chain } from '../models/bitcoinUnits';
import { ScanQRCodeParamList } from './DetailViewStackParamList';
import { IFee } from '../screen/send/SendDetails';
import { NetworkTransactionFeeType } from '../models/networkTransactionFees';

export type SendDetailsParams = {
  transactionMemo?: string;
  isTransactionReplaceable?: boolean;
  payjoinUrl?: string;
  feeUnit?: BitcoinUnit;
  frozenBalance?: number;
  amountUnit?: BitcoinUnit;
  address?: string;
  amount?: number;
  amountSats?: number;
  onBarScanned?: string;
  unit?: BitcoinUnit;
  noRbf?: boolean;
  walletID: string;
  launchedBy?: string;
  utxos?: CreateTransactionUtxo[] | null;
  isEditable?: boolean;
  uri?: string;
  paymentCode?: string;
  selectedFeeRate?: string | undefined;
  selectedFeeType?: NetworkTransactionFeeType;
  addRecipientParams?: {
    address: string;
    amount?: number;
    memo?: string;
  };
};

export type TNavigation = {
  pop: () => void;
  navigate: () => void;
};

export type TNavigationWrapper = {
  navigation: TNavigation;
};

export type SendDetailsStackParamList = {
  SendDetails: SendDetailsParams;
  SelectFee: {
    networkTransactionFees: {
      fastestFee: number;
      mediumFee: number;
      slowFee: number;
    };
    feePrecalc: IFee;
    feeRate: string;
    feeUnit?: BitcoinUnit;
    walletID: string;
    customFee?: string | null;
  };
  Confirm: {
    fee: number;
    memo?: string;
    walletID: string;
    tx: string;
    targets?: CreateTransactionTarget[]; // needed to know if there were paymentCodes, which turned into addresses in `recipients`
    recipients: CreateTransactionTarget[];
    satoshiPerByte: number;
    payjoinUrl?: string | null;
    psbt: Psbt;
  };
  PsbtWithHardwareWallet: {
    memo?: string;
    walletID: string;
    launchedBy?: string;
    psbt?: Psbt;
    txhex?: string;
  };
  CreateTransaction: {
    memo?: string;
    psbt?: Psbt;
    txhex?: string;
    tx: string;
    fee: number;
    showAnimatedQr?: boolean;
    recipients: CreateTransactionTarget[];
    satoshiPerByte: number;
    feeSatoshi?: number;
  };
  PsbtMultisig: {
    memo?: string;
    psbtBase64: string;
    walletID: string;
    launchedBy?: string;
  };
  PsbtMultisigQRCode: {
    memo?: string;
    psbtBase64: string;
    fromWallet: string;
    launchedBy?: string;
    isShowOpenScanner?: boolean;
    onBarScanned?: string;
  };
  Success: {
    fee?: number;
    amount: number;
    amountUnit?: BitcoinUnit;
    txid?: string;
    invoiceDescription?: string;
  };
  SelectWallet: {
    chainType?: Chain;
    onWalletSelect?: (wallet: TWallet, navigationWrapper: TNavigationWrapper) => void;
    availableWallets?: TWallet[];
    noWalletExplanationText?: string;
    onChainRequireSend?: boolean;
    selectedWalletID?: string; // Add this parameter to scroll to a specific wallet
  };
  CoinControl: {
    walletID: string;
  };
  PaymentCodeList: {
    walletID: string;
    merge?: boolean;
  };
  ScanQRCode: ScanQRCodeParamList;
};
